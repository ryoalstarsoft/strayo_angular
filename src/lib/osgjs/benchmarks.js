/*!
 * OSGJS
 * Cedric Pinson <trigrou@trigrou.com> (http://cedricpinson.com)
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("bluebird"), require("zlib"), require("hammerjs"), (function webpackLoadOptionalExternalModule() { try { return require("jquery"); } catch(e) {} }()), require("leapjs"));
	else if(typeof define === 'function' && define.amd)
		define(["bluebird", "zlib", "hammer", "jquery", "leap"], factory);
	else if(typeof exports === 'object')
		exports["OSG"] = factory(require("bluebird"), require("zlib"), require("hammerjs"), (function webpackLoadOptionalExternalModule() { try { return require("jquery"); } catch(e) {} }()), require("leapjs"));
	else
		root["OSG"] = factory(root["P"], root["Zlib"], root["Hammer"], root["$"], root["Leap"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_47__, __WEBPACK_EXTERNAL_MODULE_50__, __WEBPACK_EXTERNAL_MODULE_131__, __WEBPACK_EXTERNAL_MODULE_203__, __WEBPACK_EXTERNAL_MODULE_222__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(239);
	module.exports = __webpack_require__(239);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osgNameSpace = __webpack_require__( 2 );
	var osg = __webpack_require__( 4 );
	var osgAnimation = __webpack_require__( 109 );
	var osgDB = __webpack_require__( 124 );
	var osgGA = __webpack_require__( 130 );
	var osgUtil = __webpack_require__( 154 );
	var osgViewer = __webpack_require__( 214 );
	var osgShader = __webpack_require__( 162 );
	var osgShadow = __webpack_require__( 227 );
	var osgText = __webpack_require__( 237 );
	var osgWrappers = __webpack_require__( 238 );
	
	
	var openSceneGraph = osgNameSpace;
	
	openSceneGraph.osg = osg;
	openSceneGraph.osgAnimation = osgAnimation;
	openSceneGraph.osgDB = osgDB;
	openSceneGraph.osgGA = osgGA;
	openSceneGraph.osgUtil = osgUtil;
	openSceneGraph.osgViewer = osgViewer;
	openSceneGraph.osgShader = osgShader;
	openSceneGraph.osgShadow = osgShadow;
	openSceneGraph.osgText = osgText;
	openSceneGraph.osgWrappers = osgWrappers;
	
	var namespaces = [ 'osg', 'osgAnimation', 'osgDB', 'osgGA', 'osgUtil', 'osgViewer', 'osgShader', 'osgShadow', 'osgText', 'osgWrappers' ];
	
	
	// for backward compatibility
	openSceneGraph.globalify = function () {
	    namespaces.forEach( function ( namespace ) {
	        window[ namespace ] = openSceneGraph[ namespace ];
	    } );
	};
	
	module.exports = openSceneGraph;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var pkg = __webpack_require__( 3 );
	
	module.exports = {
	    name: pkg.name,
	    version: pkg.version,
	    author: pkg.author
	};


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = {"devDependencies":{"chai":"^3.5.0","grunt-contrib-connect":"~0.9","grunt-documentation":"*","grunt-jsbeautifier":"^0.2.10","grunt-mocha":"^1.0.2","grunt-release":"^0.10.0","mocha":"^2.5.3","webpack-strip-block":"0.0.1","grunt-plato":"~0.2.1"},"peerDependencies":{"grunt":">=0.4.0"},"dependencies":{"grunt-lib-phantomjs":"^1.0.2","webpack-dev-server":"^1.7.0","webpack":"^1.7.3","raw-loader":"^0.5.1","path":"^0.11.14","leapjs":"^0.6.4","json-loader":"^0.5.4","jquery":"^2.1.3","hammerjs":"^2.0.4","grunt-webpack":"^1.0.8","grunt-shell":"*","grunt-git":"*","grunt-eslint":"^17.1.0","grunt-copy-to":"0.0.12","grunt-contrib-uglify":"*","grunt-contrib-jshint":"*","grunt-contrib-copy":"*","grunt-contrib-clean":"*","grunt":"> 1.0.0","glob":"*","extend":"*","eslint-plugin-private-variables":"^0.1.2","eslint":"^1.3.1"},"contributors":["Paul Cheyrou-Lagr√®ze <tuan.kuranes@gmail.com>","Jordi Torres <jtorresfabra@gmail.com>","Matt Fontaine <tehqin@gmail.com>","Stephane Ginier <stephane.ginier@gmail.com>"],"version":"0.2.6","author":"Cedric Pinson <trigrou@trigrou.com> (http://cedricpinson.com)","license":"MIT","description":"OpenSceneGraph implementation in javascript","repository":{"url":"git@github.com:cedricpinson/osgjs.git","type":"git"},"name":"OpenSceneGraph"}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var AutoTransform = __webpack_require__( 5 );
	var BillboardAttribute = __webpack_require__( 54 );
	var BlendColor = __webpack_require__( 55 );
	var BlendFunc = __webpack_require__( 39 );
	var BoundingBox = __webpack_require__( 14 );
	var BoundingSphere = __webpack_require__( 18 );
	var BufferArray = __webpack_require__( 40 );
	var Camera = __webpack_require__( 56 );
	var ColorMask = __webpack_require__( 58 );
	var ComputeBoundsVisitor = __webpack_require__( 30 );
	var ComputeMatrixFromNodePath = __webpack_require__( 28 );
	var CullFace = __webpack_require__( 59 );
	var CullingSet = __webpack_require__( 60 );
	var CullSettings = __webpack_require__( 57 );
	var CullStack = __webpack_require__( 62 );
	var CullVisitor = __webpack_require__( 63 );
	var Depth = __webpack_require__( 86 );
	var DrawArrayLengths = __webpack_require__( 49 );
	var DrawArrays = __webpack_require__( 42 );
	var DrawElements = __webpack_require__( 43 );
	var EllipsoidModel = __webpack_require__( 87 );
	var FrameBufferObject = __webpack_require__( 68 );
	var FrameStamp = __webpack_require__( 88 );
	var Geometry = __webpack_require__( 31 );
	var GLObject = __webpack_require__( 37 );
	var Image = __webpack_require__( 36 );
	var ImageStream = __webpack_require__( 89 );
	var KdTree = __webpack_require__( 90 );
	var KdTreeBuilder = __webpack_require__( 96 );
	var Light = __webpack_require__( 97 );
	var LightSource = __webpack_require__( 64 );
	var LineWidth = __webpack_require__( 98 );
	var Lod = __webpack_require__( 69 );
	var Map = __webpack_require__( 20 );
	var Material = __webpack_require__( 51 );
	var osgjsMath = __webpack_require__( 16 );
	var Matrix = __webpack_require__( 23 );
	var MatrixMemoryPool = __webpack_require__( 27 );
	var MatrixTransform = __webpack_require__( 44 );
	var Node = __webpack_require__( 12 );
	var NodeVisitor = __webpack_require__( 22 );
	var Notify = __webpack_require__( 10 );
	var Object = __webpack_require__( 13 );
	var PagedLOD = __webpack_require__( 71 );
	var Polytope = __webpack_require__( 61 );
	var Plane = __webpack_require__( 24 );
	var PrimitiveFunctor = __webpack_require__( 99 );
	var PrimitiveSet = __webpack_require__( 41 );
	var Program = __webpack_require__( 100 );
	var Projection = __webpack_require__( 45 );
	var Quat = __webpack_require__( 26 );
	var RenderBin = __webpack_require__( 66 );
	var RenderLeaf = __webpack_require__( 65 );
	var RenderStage = __webpack_require__( 67 );
	var Shader = __webpack_require__( 101 );
	var Shape = __webpack_require__( 102 );
	var Stack = __webpack_require__( 103 );
	var State = __webpack_require__( 104 );
	var StateAttribute = __webpack_require__( 21 );
	var StateGraph = __webpack_require__( 8 );
	var StateSet = __webpack_require__( 19 );
	var Texture = __webpack_require__( 34 );
	var TextureCubeMap = __webpack_require__( 105 );
	var Transform = __webpack_require__( 11 );
	var TriangleIndexFunctor = __webpack_require__( 91 );
	var Uniform = __webpack_require__( 35 );
	var UpdateVisitor = __webpack_require__( 106 );
	var MACROUTILS = __webpack_require__( 6 );
	var Vec2 = __webpack_require__( 70 );
	var Vec3 = __webpack_require__( 15 );
	var Vec4 = __webpack_require__( 25 );
	var Viewport = __webpack_require__( 107 );
	var osgPool = __webpack_require__( 7 );
	var TransformEnums = __webpack_require__( 29 );
	var Timer = __webpack_require__( 9 );
	var TimerGPU = __webpack_require__( 108 );
	var WebGLCaps = __webpack_require__( 32 );
	
	
	var osg = {};
	osg.AutoTransform = AutoTransform;
	osg.BillboardAttribute = BillboardAttribute;
	osg.BlendColor = BlendColor;
	osg.BlendFunc = BlendFunc;
	osg.BoundingBox = BoundingBox;
	osg.BoundingSphere = BoundingSphere;
	osg.BufferArray = BufferArray;
	osg.ColorMask = ColorMask;
	osg.Camera = Camera;
	osg.ColorMask = ColorMask;
	osg.ComputeBoundsVisitor = ComputeBoundsVisitor;
	MACROUTILS.objectMix( osg, ComputeMatrixFromNodePath );
	osg.CullFace = CullFace;
	osg.CullingSet = CullingSet;
	osg.CullSettings = CullSettings;
	osg.CullStack = CullStack;
	osg.CullVisitor = CullVisitor;
	osg.Depth = Depth;
	osg.DrawArrayLengths = DrawArrayLengths;
	osg.DrawArrays = DrawArrays;
	osg.DrawElements = DrawElements;
	osg.EllipsoidModel = EllipsoidModel;
	osg.WGS_84_RADIUS_EQUATOR = EllipsoidModel.WGS_84_RADIUS_EQUATOR;
	osg.WGS_84_RADIUS_POLAR = EllipsoidModel.WGS_84_RADIUS_POLAR;
	osg.FrameBufferObject = FrameBufferObject;
	osg.FrameStamp = FrameStamp;
	osg.Geometry = Geometry;
	osg.GLObject = GLObject;
	osg.Image = Image;
	osg.ImageStream = ImageStream;
	osg.KdTree = KdTree;
	osg.KdTreeBuilder = KdTreeBuilder;
	osg.Light = Light;
	osg.LightSource = LightSource;
	osg.LineWidth = LineWidth;
	osg.Lod = Lod;
	osg.Map = Map;
	osg.Material = Material;
	MACROUTILS.objectMix( osg, osgjsMath );
	osg.Matrix = Matrix;
	osg.MatrixTransform = MatrixTransform;
	osg.MatrixMemoryPool = MatrixMemoryPool;
	osg.Node = Node;
	osg.NodeVisitor = NodeVisitor;
	MACROUTILS.objectMix( osg, Notify );
	osg.Object = Object;
	osg.PagedLOD = PagedLOD;
	osg.Plane = Plane;
	osg.Polytope = Polytope;
	osg.PrimitiveSet = PrimitiveSet;
	osg.PrimitiveFunctor = PrimitiveFunctor;
	osg.Program = Program;
	osg.Projection = Projection;
	osg.Quat = Quat;
	osg.RenderBin = RenderBin;
	osg.RenderLeaf = RenderLeaf;
	osg.RenderStage = RenderStage;
	osg.Shader = Shader;
	MACROUTILS.objectMix( osg, Shape );
	osg.Stack = Stack;
	osg.State = State;
	osg.StateAttribute = StateAttribute;
	osg.StateGraph = StateGraph;
	osg.StateSet = StateSet;
	osg.Texture = Texture;
	osg.TextureCubeMap = TextureCubeMap;
	osg.Transform = Transform;
	osg.TriangleIndexFunctor = TriangleIndexFunctor;
	osg.Uniform = Uniform;
	osg.UpdateVisitor = UpdateVisitor;
	MACROUTILS.objectMix( osg, MACROUTILS );
	osg.Vec2 = Vec2;
	osg.Vec3 = Vec3;
	osg.Vec4 = Vec4;
	osg.Viewport = Viewport;
	
	osg.memoryPools = osgPool.memoryPools;
	
	osg.Transform.RELATIVE_RF = TransformEnums.RELATIVE_RF;
	osg.Transform.ABSOLUTE_RF = TransformEnums.ABSOLUTE_RF;
	osg.Timer = Timer;
	osg.TimerGPU = TimerGPU;
	osg.WebGLCaps = WebGLCaps;
	
	
	module.exports = osg;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var MACROUTILS = __webpack_require__( 6 );
	var Transform = __webpack_require__( 11 );
	var Vec3 = __webpack_require__( 15 );
	var Vec4 = __webpack_require__( 25 );
	var Quat = __webpack_require__( 26 );
	var Matrix = __webpack_require__( 23 );
	var NodeVisitor = __webpack_require__( 22 );
	var TransformEnums = __webpack_require__( 29 );
	var Node = __webpack_require__( 12 );
	
	/** AutoTransform is a derived form of Transform that automatically
	 * scales or rotates to keep its children aligned with screen coordinates.
	 * W.r.t. AutorotateModes only rotate to screen is supported right now.
	 * More AutorotateModes modes should be addressed in the future.
	 * @class AutoTransform
	 */
	
	var AutoTransform = function () {
	    Transform.call( this );
	    this._matrix = Matrix.create();
	    this._position = Vec3.create();
	    this._matrixDirty = true;
	    this._scale = Vec3.createAndSet( 1.0, 1.0, 1.0 );
	    this._minimumScale = 0;
	    this._maximumScale = Number.MAX_VALUE;
	    this._rotation = Quat.create();
	    this._pivotPoint = Vec3.create();
	    this._autoScaleToScreen = false;
	    this._autoRotateToScreen = false;
	    this._cachedMatrix = Matrix.create();
	    this._firstTimeToInitEyePoint = true;
	    this._autoScaleTransitionWidthRatio = 0.25;
	    this._billboardAttribute = undefined;
	    this._previousWidth = 0.0;
	    this._previousHeight = 0.0;
	    this._previousProjection = Matrix.create();
	    this._previousPosition = Vec3.create();
	};
	
	/** @lends Autotransform.prototype */
	AutoTransform.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Transform.prototype, {
	
	    getMatrix: function () {
	        return this._matrix;
	    },
	
	    setMatrix: function ( m ) {
	        this._matrix = m;
	        this.dirtyBound();
	    },
	
	    setPosition: function ( pos ) {
	        this._position = pos;
	        this._matrixDirty = true;
	        this.dirtyBound();
	    },
	    getPosition: function () {
	        return this._position;
	    },
	
	    setRotation: function ( quat ) {
	        this._rotation = quat;
	        this._matrixDirty = true;
	        this.dirtyBound();
	    },
	
	    getRotation: function () {
	        return this._rotation;
	    },
	
	    setScale: function ( scale ) {
	        this.setScaleFromVec3( Vec3.createAndSet( scale, scale, scale ) );
	    },
	
	    setScaleFromVec3: function ( scaleVec ) {
	        this._scale = scaleVec;
	        this._matrixDirty = true;
	        this.dirtyBound();
	    },
	
	    getScale: function () {
	        return this._scale;
	    },
	
	    setMinimumScale: function ( minimumScale ) {
	        this._minimumScale = minimumScale;
	    },
	
	    getMinimumScale: function () {
	        return this._minimumScale;
	    },
	
	    setMaximumScale: function ( maximumScale ) {
	        this._maximumScale = maximumScale;
	    },
	
	    getMaximumScale: function () {
	        return this._maximumScale;
	    },
	
	    setAutoScaleToScreen: function ( autoScaleToScreen ) {
	        this._autoScaleToScreen = autoScaleToScreen;
	        this._matrixDirty = true;
	    },
	
	    getAutoScaleToScreen: function () {
	        return this._autoScaleToScreen;
	    },
	
	    setAutoRotateToScreen: function ( value ) {
	        this._autoRotateToScreen = value;
	    },
	
	    getAutoRotateToScreen: function () {
	        return this._autoRotateToScreen;
	    },
	
	    setAutoScaleTransitionWidthRatio: function ( autoScaleTransitionWidthRatio ) {
	        this._autoScaleTransitionWidthRatio = autoScaleTransitionWidthRatio;
	    },
	
	    getAutoScaleTransitionWidthRatio: function () {
	        return this._autoScaleTransitionWidthRatio;
	    },
	
	    // local to "local world" (not Global World)
	    computeLocalToWorldMatrix: function ( matrix /*, nodeVisitor */ ) {
	        if ( this._matrixDirty ) this.computeMatrix();
	        if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {
	            Matrix.preMult( matrix, this._matrix );
	        } else {
	            Matrix.copy( this._matrix, matrix );
	        }
	    },
	
	    computeMatrix: ( function () {
	        var neg = Vec3.create();
	        return function () {
	            if ( !this._matrixDirty ) return;
	            Matrix.makeRotateFromQuat( this._rotation, this._matrix );
	            //_cachedMatrix.postMultTranslate(_position);
	            Matrix.postMultTranslate( this._matrix, this._position );
	            Matrix.preMultScale( this._matrix, this._scale );
	            Matrix.preMultTranslate( this._matrix, Vec3.neg( this._pivotPoint, neg ) );
	            this._matrixDirty = false;
	        };
	
	    } )(),
	
	    computeWorldToLocalMatrix: ( function () {
	        var neg = Vec3.create();
	        var rotInverse = Quat.create();
	        var scaleInverse = Vec3.create();
	        return function ( matrix /*, nodeVisitor */ ) {
	            if ( this.scale[ 0 ] === 0.0 && this.scale[ 1 ] === 0.0 && this.scale[ 2 ] === 0.0 ) {
	                return false;
	            }
	            scaleInverse[ 0 ] = 1.0 / this._scale[ 0 ];
	            scaleInverse[ 1 ] = 1.0 / this._scale[ 1 ];
	            scaleInverse[ 2 ] = 1.0 / this._scale[ 2 ];
	            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {
	                Matrix.postMultTranslate( matrix, Vec3.neg( this._position, neg ) );
	                if ( !Quat.zeroRotation( this._rotation ) ) {
	                    Matrix.postMultRotate( matrix, Quat.inverse( this._rotation, rotInverse ) );
	                }
	                Matrix.postMultScale( matrix, scaleInverse );
	                Matrix.postMultTranslate( matrix, this._pivotPoint );
	            } else { // absolute
	                Matrix.makeRotateFromQuat( Quat.inverse( this._rotation, rotInverse ), this._matrix );
	                Matrix.preMultTranslate( matrix, Vec3.neg( this._position, neg ) );
	                Matrix.postMultScale( matrix, scaleInverse );
	                Matrix.postMultTranslate( matrix, this._pivotPoint );
	            }
	            return true;
	        };
	    } )(),
	
	    computeBound: ( function () {
	        var matrix = Matrix.create();
	        return function ( bSphere ) {
	            if ( this._autoScaleToScreen && this._firstTimeToInitEyePoint )
	                return bSphere;
	            Node.prototype.computeBound.call( this, bSphere );
	            if ( !bSphere.valid() ) {
	                return bSphere;
	            }
	            Matrix.makeIdentity( matrix );
	            // local to local world (not Global World)
	            this.computeLocalToWorldMatrix( matrix );
	            Matrix.transformBoundingSphere( matrix, bSphere, bSphere );
	            return bSphere;
	        };
	    } )(),
	
	    accept: ( function () {
	
	        return function ( visitor ) {
	            if ( visitor.getVisitorType() === NodeVisitor.CULL_VISITOR ) {
	
	                var width = visitor.getViewport().width();
	                var height = visitor.getViewport().height();
	                var projMat = visitor.getCurrentProjectionMatrix();
	                var position = this._position;
	                var doUpdate = this._firstTimeToInitEyePoint;
	
	                if ( !this._firstTimeToInitEyePoint ) {
	                    if ( width !== this._previousWidth || height !== this._previousHeight ) {
	                        doUpdate = true;
	                    } else if ( !Matrix.equal( projMat, this._previousProjection ) ) {
	                        doUpdate = true;
	                    } else if ( !Vec3.equal( position, this._previousPosition ) ) {
	                        doUpdate = true;
	                    }
	                }
	                this._firstTimeToInitEyePoint = false;
	                if ( doUpdate ) {
	                    if ( this._autoScaleToScreen ) {
	                        var modelViewMat = visitor.getCurrentModelViewMatrix();
	                        var viewport = visitor.getViewport();
	                        var psvector = this.computePixelSizeVector( viewport, projMat, modelViewMat );
	                        var v = Vec4.createAndSet( this._position[ 0 ], this._position[ 1 ], this._position[ 2 ], 1.0 );
	                        var pixelSize = Vec4.dot( v, psvector );
	                        pixelSize = 0.48 / pixelSize;
	                        var size = 1.0 / pixelSize;
	                        if ( this._autoScaleTransitionWidthRatio > 0.0 ) {
	                            var c, b, a;
	                            if ( this._minimumScale > 0.0 ) {
	                                var j = this._minimumScale;
	                                var i = ( this._maximumScale < Number.MAX_VALUE ) ?
	                                    this._minimumScale + ( this._maximumScale - this._minimumScale ) * this._autoScaleTransitionWidthRatio :
	                                    this._minimumScale * ( 1.0 + this._autoScaleTransitionWidthRatio );
	                                c = 1.0 / ( 4.0 * ( i - j ) );
	                                b = 1.0 - 2.0 * c * i;
	                                a = j + b * b / ( 4.0 * c );
	                                var k = -b / ( 2.0 * c );
	                                if ( size < k ) size = this._minimumScale;
	                                else if ( size < i ) size = a + b * size + c * ( size * size );
	                            }
	                            if ( this._maximumScale < Number.MAX_VALUE ) {
	                                var n = this._maximumScale;
	                                var m = ( this._minimumScale > 0.0 ) ?
	                                    this._maximumScale + ( this._minimumScale - this._maximumScale ) * this._autoScaleTransitionWidthRatio :
	                                    this._maximumScale * ( 1.0 - this._autoScaleTransitionWidthRatio );
	                                c = 1.0 / ( 4.0 * ( m - n ) );
	                                b = 1.0 - 2.0 * c * m;
	                                a = n + b * b / ( 4.0 * c );
	                                var p = -b / ( 2.0 * c );
	
	                                if ( size > p ) size = this._maximumScale;
	                                else if ( size > m ) size = a + b * size + c * ( size * size );
	                            }
	                        }
	                        this.setScale( size );
	                    }
	                    if ( this._autoRotateToScreen ) {
	                        var rotation = Quat.create();
	                        var modelView = visitor.getCurrentModelViewMatrix();
	                        Matrix.getRotate( modelView, rotation );
	                        this.setRotation( Quat.inverse( rotation, rotation ) );
	                    }
	                    this._previousWidth = width;
	                    this._previousHeight = height;
	                    Vec3.copy( position, this._previousPosition );
	                    Matrix.copy( projMat, this._previousProjection );
	                }
	            }
	
	            Node.prototype.accept.call( this, visitor );
	        };
	    } )(),
	
	    computePixelSizeVector: ( function () {
	        var scale00 = Vec3.create();
	        var scale10 = Vec3.create();
	        return function ( W, P, M ) {
	            // Where W = viewport, P = ProjectionMatrix, M = ModelViewMatrix
	            // Comment from OSG:
	            // pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
	            // here we do it in short hand with the knowledge of how the window matrix is formed
	            // note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
	
	            // scaling for horizontal pixels
	            var P00 = P[ 0 ] * W.width() * 0.5;
	            var P20_00 = P[ 8 ] * W.width() * 0.5 + P[ 11 ] * W.width() * 0.5;
	            Vec3.set( M[ 0 ] * P00 + M[ 2 ] * P20_00,
	                M[ 4 ] * P00 + M[ 6 ] * P20_00,
	                M[ 8 ] * P00 + M[ 10 ] * P20_00, scale00 );
	
	            // scaling for vertical pixels
	            var P10 = P[ 5 ] * W.height() * 0.5;
	            var P20_10 = P[ 9 ] * W.height() * 0.5 + P[ 11 ] * W.height() * 0.5;
	            Vec3.set( M[ 1 ] * P10 + M[ 2 ] * P20_10,
	                M[ 5 ] * P10 + M[ 6 ] * P20_10,
	                M[ 9 ] * P10 + M[ 10 ] * P20_10, scale10 );
	
	            var P23 = P[ 11 ];
	            var P33 = P[ 15 ];
	            var pixelSizeVector = Vec4.createAndSet( M[ 2 ] * P23, M[ 6 ] * P23, M[ 10 ] * P23, M[ 14 ] * P23 + M[ 15 ] * P33 );
	
	            var scaleRatio = 0.7071067811 / Math.sqrt( Vec3.length2( scale00 ) + Vec3.length2( scale10 ) );
	            Vec4.mult( pixelSizeVector, scaleRatio, pixelSizeVector );
	            return pixelSizeVector;
	        };
	    } )()
	
	
	} ), 'osg', 'AutoTransform' );
	MACROUTILS.setTypeID( AutoTransform );
	
	module.exports = AutoTransform;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osgPool = __webpack_require__( 7 );
	var StateGraph = __webpack_require__( 8 );
	var Timer = __webpack_require__( 9 );
	var Notify = __webpack_require__( 10 );
	
	// make the warning about StateGraph desappear
	window.Object.keys( StateGraph );
	
	var Utils = {};
	
	Utils.init = function () {
	    var StateGraphClass = __webpack_require__( 8 );
	    osgPool.memoryPools.stateGraph = new osgPool.OsgObjectMemoryPool( StateGraphClass ).grow( 50 );
	};
	
	Utils.isArray = function ( obj ) {
	    Notify.log( 'isArray is deprecated, use instead Array.isArray' );
	    return Array.isArray( obj );
	};
	
	Utils.extend = function () {
	    // Save a reference to some core methods
	    var toString = window.Object.prototype.toString;
	    var hasOwnPropertyFunc = window.Object.prototype.hasOwnProperty;
	
	    var isFunction = function ( obj ) {
	        return toString.call( obj ) === '[object Function]';
	    };
	    var isArray = Utils.isArray;
	    var isPlainObject = function ( obj ) {
	        // Must be an Object.
	        // Because of IE, we also have to check the presence of the constructor property.
	        // Make sure that DOM nodes and window objects don't pass through, as well
	        if ( !obj || toString.call( obj ) !== '[object Object]' || obj.nodeType || obj.setInterval ) {
	            return false;
	        }
	
	        // Not own constructor property must be Object
	        if ( obj.constructor && !hasOwnPropertyFunc.call( obj, 'constructor' ) && !hasOwnPropertyFunc.call( obj.constructor.prototype, 'isPrototypeOf' ) ) {
	            return false;
	        }
	
	        // Own properties are enumerated firstly, so to speed up,
	        // if last one is own, then all properties are own.
	
	        var key;
	        for ( key in obj ) {}
	
	        return key === undefined || hasOwnPropertyFunc.call( obj, key );
	    };
	
	    // copy reference to target object
	    var target = arguments[ 0 ] || {},
	        i = 1,
	        length = arguments.length,
	        deep = false,
	        options, name, src, copy;
	
	    // Handle a deep copy situation
	    if ( typeof target === 'boolean' ) {
	        deep = target;
	        target = arguments[ 1 ] || {};
	        // skip the boolean and the target
	        i = 2;
	    }
	
	    // Handle case when target is a string or something (possible in deep copy)
	    if ( typeof target !== 'object' && !isFunction( target ) ) {
	        target = {};
	    }
	
	    // extend jQuery itself if only one argument is passed
	    if ( length === i ) {
	        target = this;
	        --i;
	    }
	
	    for ( ; i < length; i++ ) {
	        // Only deal with non-null/undefined values
	        if ( ( options = arguments[ i ] ) !== null ) {
	            // Extend the base object
	            for ( name in options ) {
	                src = target[ name ];
	                copy = options[ name ];
	
	                // Prevent never-ending loop
	                if ( target === copy ) {
	                    continue;
	                }
	
	                // Recurse if we're merging object literal values or arrays
	                if ( deep && copy && ( isPlainObject( copy ) || isArray( copy ) ) ) {
	                    var clone = src && ( isPlainObject( src ) || isArray( src ) ) ? src : isArray( copy ) ? [] : {};
	
	                    // Never move original objects, clone them
	                    target[ name ] = Utils.extend( deep, clone, copy );
	
	                    // Don't bring in undefined values
	                } else if ( copy !== undefined ) {
	                    target[ name ] = copy;
	                }
	            }
	        }
	    }
	
	    // Return the modified object
	    return target;
	};
	
	Utils.objectInherit = function ( base /*, extras*/ ) {
	    function F() {}
	    F.prototype = base;
	    var obj = new F();
	
	    // let augment object with multiple arguement
	    for ( var i = 1; i < arguments.length; i++ ) {
	        Utils.objectMix( obj, arguments[ i ], false );
	    }
	    return obj;
	};
	
	Utils.objectInehrit = function () {
	    console.warn( 'please use objectInherit instead of objectInehrit' );
	};
	
	Utils.objectMix = function ( obj, properties, test ) {
	    for ( var key in properties ) {
	        if ( !( test && obj[ key ] ) ) {
	            obj[ key ] = properties[ key ];
	        }
	    }
	    return obj;
	};
	
	Utils.objectType = {};
	Utils.objectType.type = 0;
	Utils.objectType.generate = function ( arg ) {
	    var t = Utils.objectType.type;
	    Utils.objectType[ t ] = arg;
	    Utils.objectType[ arg ] = t;
	    Utils.objectType.type += 1;
	    return t;
	};
	
	Utils.objectLibraryClass = function ( object, libName, className ) {
	    object.className = function () {
	        return className;
	    };
	    object.libraryName = function () {
	        return libName;
	    };
	    var libraryClassName = libName + '::' + className;
	    object.libraryClassName = function () {
	        return libraryClassName;
	    };
	
	    return object;
	};
	
	Utils.setTypeID = function ( classObject ) {
	    var className = classObject.prototype.libraryClassName();
	    var typeID = Utils.objectType.generate( className );
	    var getTypeID = function () {
	        return typeID;
	    };
	    classObject.typeID = classObject.prototype.typeID = typeID;
	    classObject.getTypeID = classObject.prototype.getTypeID = getTypeID;
	};
	
	Utils.createPrototypeClass = function ( Constructor, prototype, libraryName, className ) {
	
	    Constructor.prototype = prototype;
	    prototype.constructor = Constructor;
	
	    Utils.objectLibraryClass( prototype, libraryName, className );
	    Utils.setTypeID( Constructor );
	};
	
	Utils.Float32Array = typeof Float32Array !== 'undefined' ? Float32Array : null;
	Utils.Int32Array = typeof Int32Array !== 'undefined' ? Int32Array : null;
	Utils.Uint8Array = typeof Uint8Array !== 'undefined' ? Uint8Array : null;
	Utils.Uint16Array = typeof Uint16Array !== 'undefined' ? Uint16Array : null;
	Utils.Uint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : null;
	
	var times = {};
	
	// we bind the function to Notify.console once and for all to avoid costly apply function
	
	Utils.time = ( Notify.console.time || function ( name ) {
	    times[ name ] = Timer.instance().tick();
	} ).bind( Notify.console );
	
	Utils.timeEnd = ( Notify.console.timeEnd || function ( name ) {
	
	    if ( times[ name ] === undefined )
	        return;
	
	    var duration = Timer.instance().deltaM( times[ name ], Timer.instance().tick() );
	
	    Notify.debug( name + ': ' + duration + 'ms' );
	    times[ name ] = undefined;
	
	} ).bind( Notify.console );
	
	Utils.timeStamp = ( Notify.console.timeStamp || Notify.console.markTimeline || function () {} ).bind( Notify.console );
	Utils.profile = ( Notify.console.profile || function () {} ).bind( Notify.console );
	Utils.profileEnd = ( Notify.console.profileEnd || function () {} ).bind( Notify.console );
	
	module.exports = Utils;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/**
	 * Authors:
	 *  Tuan.kuranes <tuan.kuranes@gmail.com> Jerome Etienne <Jerome.etienne@gmail.com>
	 */
	
	'use strict';
	var osgPool = {};
	osgPool.memoryPools = {};
	
	/*
	 *  TODO: Add stats & reports for developper per application  finer calibration (max, min, average)
	 *  TODO: Debug Mode: check if not putting object twice, etc.
	 *  USAGE: osg.memoryPools.stateGraph = new OsgObjectMemoryPool(osg.StateGraph).grow(50);
	 */
	osgPool.OsgObjectMemoryPool = function ( ObjectClassName ) {
	    return {
	        _memPool: [],
	        reset: function () {
	            this._memPool = [];
	            return this;
	        },
	        put: function ( obj ) {
	            this._memPool.push( obj );
	        },
	        get: function () {
	            if ( this._memPool.length > 0 ) {
	                return this._memPool.pop();
	            }
	            this.grow();
	            return this.get();
	        },
	        grow: function ( sizeAddParam ) {
	            var sizeAdd;
	            if ( sizeAddParam === undefined ) {
	                sizeAdd = ( this._memPool.length > 0 ) ? this._memPool.length * 2 : 20;
	            } else {
	                sizeAdd = sizeAddParam;
	            }
	            var i = this._memPool.length;
	            while ( i++ < sizeAdd ) this._memPool.push( new ObjectClassName() );
	            return this;
	        }
	    };
	};
	
	/*
	 *  USAGE: osg.memoryPools.arrayPool = new OsgArrayMemoryPool();
	 *  mymatrix = osg.memoryPools.arrayPool.get(16);
	 *  // do use matrix, etc..
	 *  osg.memoryPools.arrayPool.put(mymatrix);
	 */
	osgPool.OsgArrayMemoryPool = function () {
	    return {
	        _mempoolofPools: [],
	        reset: function () {
	            this._memPoolofPools = {};
	            return this;
	        },
	        put: function ( obj ) {
	            if ( !this._memPoolofPools[ obj.length ] )
	                this._memPoolofPools[ obj.length ] = [];
	            this._memPoolofPools[ obj.length ].push( obj );
	        },
	        get: function ( arraySize ) {
	            if ( !this._memPoolofPools[ arraySize ] )
	                this._memPoolofPools[ arraySize ] = [];
	            else if ( this._memPoolofPools.length > 0 )
	                return this._memPool.pop();
	            this.grow( arraySize );
	            return this.get();
	        },
	        grow: function ( arraySize, sizeAdd ) {
	            if ( sizeAdd === undefined ) sizeAdd = ( this._memPool.length > 0 ) ? this._memPool.length * 2 : 5;
	            var i = this._memPool.length;
	            while ( i++ < sizeAdd ) this._memPool.push( new Array( arraySize ) );
	            return this;
	        }
	    };
	};
	/*
	 *  USAGE: osg.memoryPools.OsgObjectMemoryStack = new OsgArrayMemoryStack(ctor);
	 *         For a stack of object that you reset each frame.
	 */
	osgPool.OsgObjectMemoryStack = function ( ObjectClassName ) {
	    return {
	        _current: 0,
	        _memPool: [ new ObjectClassName() ],
	        reset: function () {
	            this._current = 0;
	            return this;
	        },
	        get: function () {
	            var obj = this._memPool[ this._current++ ];
	            if ( this._current >= this._memPool.length ) {
	                this._memPool.push( new ObjectClassName() );
	            }
	            return obj;
	        }
	    };
	};
	
	module.exports = osgPool;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osgPool = __webpack_require__( 7 );
	
	
	var StateGraph = function () {
	    this.depth = 0;
	    this.children = {};
	    this.children.keys = [];
	    this.leafs = [];
	    this.stateset = undefined;
	    this.parent = undefined;
	};
	
	StateGraph.prototype = {
	
	    clean: function () {
	
	        this.leafs.length = 0;
	        this.stateset = undefined;
	        this.parent = undefined;
	        this.depth = 0;
	        var children = this.children;
	        var child;
	        var key, keys = children.keys;
	
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	
	            key = keys[ i ];
	            child = children[ key ];
	            child.clean();
	            osgPool.memoryPools.stateGraph.put( child );
	
	        }
	
	        this.children = {};
	        keys.length = 0;
	        this.children.keys = keys;
	    },
	
	    getStateSet: function () {
	        return this.stateset;
	    },
	
	    findOrInsert: function ( stateset ) {
	
	        var sg;
	        var stateSetID = stateset.getInstanceID();
	        var children = this.children;
	
	        if ( !children[ stateSetID ] ) {
	
	            //sg = new StateGraph();
	            sg = osgPool.memoryPools.stateGraph.get();
	
	            sg.parent = this;
	            sg.depth = this.depth + 1;
	            sg.stateset = stateset;
	            children[ stateSetID ] = sg;
	            children.keys.push( stateSetID );
	
	        } else {
	
	            sg = children[ stateSetID ];
	
	        }
	        return sg;
	    }
	
	};
	
	StateGraph.moveStateGraph = function ( state, sgCurrentArg, sgNewArg ) {
	
	    var stack = [];
	    var sgNew = sgNewArg;
	    var sgCurrent = sgCurrentArg;
	    var i, l;
	    if ( sgNew === sgCurrent || sgNew === undefined ) return;
	
	    if ( sgCurrent === undefined ) {
	        // push stateset from sgNew to root, and apply
	        // stateset from root to sgNew
	        do {
	            if ( sgNew.stateset !== undefined ) {
	                stack.push( sgNew.stateset );
	            }
	            sgNew = sgNew.parent;
	        } while ( sgNew );
	
	        for ( i = stack.length - 1, l = 0; i >= l; --i ) {
	            state.pushStateSet( stack[ i ] );
	        }
	        return;
	
	    } else if ( sgCurrent.parent === sgNew.parent ) {
	        // first handle the typical case which is two state groups
	        // are neighbours.
	
	        // state has changed so need to pop old state.
	        if ( sgCurrent.stateset !== undefined ) {
	            state.popStateSet();
	        }
	        // and push new state.
	        if ( sgNew.stateset !== undefined ) {
	            state.pushStateSet( sgNew.stateset );
	        }
	        return;
	    }
	
	    // need to pop back up to the same depth as the new state group.
	    while ( sgCurrent.depth > sgNew.depth ) {
	        if ( sgCurrent.stateset !== undefined ) {
	            state.popStateSet();
	        }
	        sgCurrent = sgCurrent.parent;
	    }
	
	    // use return path to trace back steps to sgNew.
	    stack = [];
	
	    // need to pop back up to the same depth as the curr state group.
	    while ( sgNew.depth > sgCurrent.depth ) {
	        if ( sgNew.stateset !== undefined ) {
	            stack.push( sgNew.stateset );
	        }
	        sgNew = sgNew.parent;
	    }
	
	    // now pop back up both parent paths until they agree.
	
	    // DRT - 10/22/02
	    // should be this to conform with above case where two StateGraph
	    // nodes have the same parent
	    while ( sgCurrent !== sgNew ) {
	        if ( sgCurrent.stateset !== undefined ) {
	            state.popStateSet();
	        }
	        sgCurrent = sgCurrent.parent;
	
	        if ( sgNew.stateset !== undefined ) {
	            stack.push( sgNew.stateset );
	        }
	        sgNew = sgNew.parent;
	    }
	
	    for ( i = stack.length - 1, l = 0; i >= l; --i ) {
	        state.pushStateSet( stack[ i ] );
	    }
	};
	
	module.exports = StateGraph;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {// user performance if available or fallback
	
	'use strict';
	var now = ( function () {
	
	    var w = window || global;
	
	    // if no window.performance
	    if ( w.performance === undefined ) {
	        return function () {
	            return Date.now();
	        };
	    }
	
	    var fn = w.performance.now || w.performance.mozNow || w.performance.msNow || w.performance.oNow || w.performance.webkitNow ||
	        function () {
	            return Date.now();
	        };
	    return function () {
	        return fn.apply( w.performance, arguments );
	    };
	} )();
	
	
	var Timer = function () {};
	
	Timer.instance = function () {
	
	    if ( !Timer._instance )
	        Timer._instance = new Timer();
	
	    return Timer._instance;
	};
	
	Timer.prototype = {
	
	    // delta in seconds
	    deltaS: function ( t0, t1 ) {
	        return ( t1 - t0 ) / 1000.0;
	    },
	
	    // delta in milliseconds
	    deltaM: function ( t0, t1 ) {
	        return t1 - t0;
	    },
	
	    tick: function () {
	        return now();
	    }
	
	
	};
	
	
	module.exports = Timer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	'use strict';
	
	var Notify = {};
	
	Notify.DEBUG = 0;
	Notify.INFO = 1;
	Notify.NOTICE = 2;
	Notify.WARN = 3;
	Notify.ERROR = 4;
	
	Notify.console = window.console;
	
	// #FIXME getStackTrace was initially in webgl-utils (as a global function) but only used in this file
	/** Obtain a stacktrace from the current stack http://eriwen.com/javascript/js-stack-trace/
	 */
	function getStackTrace( err ) {
	    if ( Notify.console && Notify.console.trace ) {
	        if ( Notify.console.groupCollapsed ) Notify.console.groupCollapsed();
	        Notify.console.trace();
	        if ( Notify.console.groupEnd ) Notify.console.groupEnd();
	        return '';
	    }
	    var callstack = [];
	    try {
	        if ( arguments.length === 1 ) {
	            throw err;
	        } else {
	            throw new Error();
	        }
	    } catch ( error ) {
	        if ( error.stack ) { //Firefox and Chrome
	            callstack = ( error.stack + '\n' ).replace( /^\S[^\(]+?[\n$]/gm, '' ).
	            replace( /^\s+(at eval )?at\s+/gm, '' ).
	            replace( /^([^\(]+?)([\n$])/gm, '{anonymous}()@$1$2' ).
	            replace( /^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1' ).split( '\n' );
	            // Remove call to this function
	            callstack.shift();
	
	        }
	    }
	    // Remove empty entries
	    for ( var i = 0; i < callstack.length; ++i ) {
	        if ( callstack[ i ] === '' ) {
	            callstack.splice( i, 1 );
	            --i;
	        }
	    }
	
	    return callstack;
	}
	
	/** logging with readability in mind.
	 * @param { str } actual log text
	 * @param { fold  }  sometimes you want to hide looooong text
	 * @param { noTrace  } where that log came from ?
	 * @param { level  } what severity is that log (gives text color too )
	 */
	function logSub( str, level, fold, noTrace ) {
	
	    if ( Notify.console !== undefined ) {
	
	        if ( fold && Notify.console.groupCollapsed ) Notify.console.groupCollapsed();
	        if ( noTrace ) {
	            Notify.console[ level ]( str );
	        } else {
	            Notify.console[ level ]( str, getStackTrace() );
	        }
	        if ( fold && Notify.console.groupEnd ) Notify.console.groupEnd();
	
	    }
	}
	
	Notify.setNotifyLevel = function ( level ) {
	
	
	    var log = function ( str, fold, noTrace ) {
	        logSub( str, 'log', fold, noTrace );
	    };
	
	    var info = function ( str, fold, noTrace ) {
	        logSub( str, 'info', fold, noTrace );
	    };
	
	    var warn = function ( str, fold, noTrace ) {
	        logSub( str, 'warn', fold, noTrace );
	    };
	
	    var error = function ( str, fold ) {
	        logSub( str, 'error', fold, true ); // error does trace auto
	    };
	
	    var debug = function ( str, fold, noTrace ) {
	        logSub( str, 'debug', fold, noTrace );
	    };
	
	    var assert = function ( test, str ) {
	        if ( this.console !== undefined && !test ) {
	            this.console.assert( test, str );
	        }
	    };
	
	    var dummy = function () {};
	
	    Notify.assert = assert;
	    Notify.debug = dummy;
	    Notify.info = dummy;
	    Notify.log = Notify.notice = dummy;
	    Notify.warn = dummy;
	    Notify.error = dummy;
	
	    if ( level <= Notify.DEBUG ) {
	        Notify.debug = debug;
	    }
	    if ( level <= Notify.INFO ) {
	        Notify.info = info;
	    }
	    if ( level <= Notify.NOTICE ) {
	        Notify.log = Notify.notice = log;
	    }
	    if ( level <= Notify.WARN ) {
	        Notify.warn = warn;
	    }
	    if ( level <= Notify.ERROR ) {
	        Notify.error = error;
	    }
	};
	
	Notify.setNotifyLevel( Notify.NOTICE );
	
	Notify.reportWebGLError = false;
	
	Notify.setConsole = function ( replacement ) {
	    Notify.console = replacement;
	};
	
	// for debug
	Notify.printMatrix = function ( m, rowMajor ) {
	    if ( rowMajor ) {
	        console.table( [ m.slice( 0, 4 ), m.slice( 4, 8 ), m.slice( 8, 12 ), m.slice( 12, 16 ) ] );
	    } else {
	        console.table( [
	            [ m[ 0 ], m[ 4 ], m[ 8 ], m[ 12 ] ],
	            [ m[ 1 ], m[ 5 ], m[ 9 ], m[ 13 ] ],
	            [ m[ 2 ], m[ 6 ], m[ 10 ], m[ 14 ] ],
	            [ m[ 3 ], m[ 7 ], m[ 11 ], m[ 15 ] ]
	        ] );
	    }
	};
	
	module.exports = Notify;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Node = __webpack_require__( 12 );
	var Matrix = __webpack_require__( 23 );
	var TransformEnums = __webpack_require__( 29 );
	
	/**
	 * Transform - base class for Transform type node ( Camera, MatrixTransform )
	 * @class Transform
	 * @inherits Node
	 */
	var Transform = function () {
	    Node.call( this );
	    this.referenceFrame = TransformEnums.RELATIVE_RF;
	};
	
	/** @lends Transform.prototype */
	Transform.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    setReferenceFrame: function ( value ) {
	        this.referenceFrame = value;
	    },
	    getReferenceFrame: function () {
	        return this.referenceFrame;
	    },
	
	    computeBoundingSphere: ( function () {
	        var matrix = Matrix.create();
	        return function ( bSphere ) {
	            Node.prototype.computeBoundingSphere.call( this, bSphere );
	            if ( !bSphere.valid() ) {
	                return bSphere;
	            }
	
	            Matrix.makeIdentity( matrix );
	            // local to local world (not Global World)
	            this.computeLocalToWorldMatrix( matrix );
	            Matrix.transformBoundingSphere( matrix, bSphere, bSphere );
	            return bSphere;
	        };
	    } )()
	} );
	
	module.exports = Transform;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var BoundingBox = __webpack_require__( 14 );
	var BoundingSphere = __webpack_require__( 18 );
	var StateSet = __webpack_require__( 19 );
	var NodeVisitor = __webpack_require__( 22 );
	var Matrix = __webpack_require__( 23 );
	var MatrixMemoryPool = __webpack_require__( 27 );
	var ComputeMatrixFromNodePath = __webpack_require__( 28 );
	var TransformEnums = __webpack_require__( 29 );
	
	
	/**
	 *  Node that can contains child node
	 *  @class Node
	 */
	var Node = function () {
	    Object.call( this );
	
	    this.children = [];
	    this.parents = [];
	    /*jshint bitwise: false */
	    this.nodeMask = ~0;
	    /*jshint bitwise: true */
	
	    this._boundingSphere = new BoundingSphere();
	    this._boundingSphereComputed = false;
	
	    this._boundingBox = new BoundingBox();
	    this._boundingBoxComputed = false;
	
	    this._updateCallbacks = [];
	    this._cullCallback = undefined;
	    this._cullingActive = true;
	    this._numChildrenWithCullingDisabled = 0;
	
	    // it's a tmp object for internal use, do not use
	    this._tmpBox = new BoundingBox();
	};
	
	Node._reservedMatrixStack = new MatrixMemoryPool();
	var nodeGetMat = Node._reservedMatrixStack.get.bind( Node._reservedMatrixStack );
	
	/** @lends Node.prototype */
	Node.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	    /**
	      Return StateSet and create it if it does not exist yet
	      @type StateSet
	   */
	    getOrCreateStateSet: function () {
	        if ( this.stateset === undefined ) {
	            this.stateset = new StateSet();
	        }
	        return this.stateset;
	    },
	    getStateSet: function () {
	        return this.stateset;
	    },
	    accept: function ( nv ) {
	        if ( nv.validNodeMask( this ) ) {
	            nv.pushOntoNodePath( this );
	            nv.apply( this );
	            nv.popFromNodePath();
	        }
	    },
	    dirtyBound: function () {
	        if ( this._boundingSphereComputed === true || this._boundingBoxComputed === true ) {
	            this._boundingSphereComputed = false;
	            this._boundingBoxComputed = false;
	
	            for ( var i = 0, l = this.parents.length; i < l; i++ ) {
	                this.parents[ i ].dirtyBound();
	            }
	        }
	    },
	    setNodeMask: function ( mask ) {
	        this.nodeMask = mask;
	    },
	    getNodeMask: function () {
	        return this.nodeMask;
	    },
	    setStateSet: function ( s ) {
	        this.stateset = s;
	    },
	
	    /**
	     <p>
	      Set update node callback, called during update traversal.
	      The Object must have the following method
	      update(node, nodeVisitor) {}
	      note, callback is responsible for scenegraph traversal so
	      they must call traverse(node,nv) to ensure that the
	      scene graph subtree (and associated callbacks) are traversed.
	      </p>
	      <p>
	      Here a dummy UpdateCallback example
	      </p>
	      @example
	      var DummyUpdateCallback = function() {};
	      DummyUpdateCallback.prototype = {
	          update: function(node, nodeVisitor) {
	              return true;
	          }
	      };
	
	      @param Oject callback
	   */
	    setUpdateCallback: function ( cb ) {
	        if ( !this._updateCallbacks.length )
	            this.addUpdateCallback( cb );
	        else
	            this._updateCallbacks[ 0 ] = cb;
	    },
	    /** Get update node callback, called during update traversal.
	      @type Oject
	   */
	    getUpdateCallback: function () {
	        return this._updateCallbacks[ 0 ];
	    },
	
	    addUpdateCallback: function ( cb ) {
	        this._updateCallbacks.push( cb );
	    },
	    removeUpdateCallback: function ( cb ) {
	        var arrayIdx = this._updateCallbacks.indexOf( cb );
	        if ( arrayIdx !== -1 )
	            this._updateCallbacks.splice( arrayIdx, 1 );
	    },
	    getUpdateCallbackList: function () {
	        return this._updateCallbacks;
	    },
	
	
	    /**
	     <p>
	      Set cull node callback, called during cull traversal.
	      The Object must have the following method
	      cull(node, nodeVisitor) {}
	      note, callback is responsible for scenegraph traversal so
	      they must return true to traverse.
	      </p>
	      <p>
	      Here a dummy CullCallback example
	      </p>
	      @example
	      var DummyCullCallback = function() {};
	      DummyCullCallback.prototype = {
	          cull: function(node, nodeVisitor) {
	              return true;
	          }
	      };
	
	      @param Oject callback
	   */
	    setCullCallback: function ( cb ) {
	        this._cullCallback = cb;
	    },
	    getCullCallback: function () {
	        return this._cullCallback;
	    },
	
	    hasChild: function ( child ) {
	        for ( var i = 0, l = this.children.length; i < l; i++ ) {
	            if ( this.children[ i ] === child ) {
	                return true;
	            }
	        }
	        return false;
	    },
	    addChild: function ( child ) {
	        var c = this.children.push( child );
	        child.addParent( this );
	        this.dirtyBound();
	        return c;
	    },
	    getChildren: function () {
	        return this.children;
	    },
	    getNumChildren: function () {
	        return this.children.length;
	    },
	    getChild: function ( num ) {
	        return this.children[ num ];
	    },
	    getParents: function () {
	        return this.parents;
	    },
	    addParent: function ( parent ) {
	        this.parents.push( parent );
	    },
	    removeParent: function ( parent ) {
	        for ( var i = 0, l = this.parents.length, parents = this.parents; i < l; i++ ) {
	            if ( parents[ i ] === parent ) {
	                parents.splice( i, 1 );
	                return;
	            }
	        }
	    },
	    removeChildren: function () {
	        var children = this.children;
	        if ( children.length !== 0 ) {
	            for ( var i = 0, l = children.length; i < l; i++ ) {
	                children[ i ].removeParent( this );
	            }
	            children.length = 0;
	            this.dirtyBound();
	        }
	    },
	
	    // preserve order
	    removeChild: function ( child ) {
	        var children = this.children;
	        for ( var i = 0, l = children.length; i < l; i++ ) {
	            if ( children[ i ] === child ) {
	                child.removeParent( this );
	                children.splice( i, 1 );
	                i--;
	                l--;
	                this.dirtyBound();
	            }
	        }
	    },
	
	    traverse: function ( visitor ) {
	        for ( var i = 0, l = this.children.length; i < l; i++ ) {
	            var child = this.children[ i ];
	            child.accept( visitor );
	        }
	    },
	
	    ascend: function ( visitor ) {
	        for ( var i = 0, l = this.parents.length; i < l; i++ ) {
	            var parent = this.parents[ i ];
	            parent.accept( visitor );
	        }
	    },
	
	    getBoundingBox: function () {
	        if ( !this._boundingBoxComputed ) {
	            this.computeBoundingBox( this._boundingBox );
	            this._boundingBoxComputed = true;
	        }
	        return this._boundingBox;
	    },
	
	    computeBoundingBox: function ( bbox ) {
	
	        // circular dependency... not sure if the global visitor instance should be instancied here
	        var ComputeBoundsVisitor = __webpack_require__( 30 );
	        var cbv = ComputeBoundsVisitor.instance = ComputeBoundsVisitor.instance || new ComputeBoundsVisitor();
	        cbv.setNodeMaskOverride( ~0x0 ); // traverse everything to be consistent with computeBoundingSphere
	        cbv.reset();
	
	        cbv.apply( this );
	        bbox.copy( cbv.getBoundingBox() );
	        return bbox;
	    },
	
	    getBoundingSphere: function () {
	        return this.getBound();
	    },
	
	    getBound: function () {
	        if ( !this._boundingSphereComputed ) {
	            this.computeBoundingSphere( this._boundingSphere );
	            this._boundingSphereComputed = true;
	        }
	        return this._boundingSphere;
	    },
	
	    computeBoundingSphere: function ( bSphere ) {
	
	        var l = this.children.length;
	
	        bSphere.init();
	        if ( l === 0 ) return bSphere;
	
	        var cc, i;
	        var bb = this._tmpBox;
	        bb.init();
	        for ( i = 0; i < l; i++ ) {
	            cc = this.children[ i ];
	            if ( cc.referenceFrame === undefined || cc.referenceFrame === TransformEnums.RELATIVE_RF ) {
	                bb.expandByBoundingSphere( cc.getBound() );
	            }
	        }
	        if ( !bb.valid() ) return bSphere;
	
	        bSphere.set( bb.center( bSphere.center() ), 0.0 );
	        for ( i = 0; i < l; i++ ) {
	            cc = this.children[ i ];
	            if ( cc.referenceFrame === undefined || cc.referenceFrame === TransformEnums.RELATIVE_RF ) {
	                bSphere.expandRadiusBySphere( cc.getBound() );
	            }
	        }
	        return bSphere;
	    },
	
	    // matrixCreate allow user handling of garbage collection of matrices
	    getWorldMatrices: ( function () {
	        var CollectParentPaths = function () {
	            this.nodePaths = [];
	            this.halt = undefined;
	            NodeVisitor.call( this, NodeVisitor.TRAVERSE_PARENTS );
	        };
	        CollectParentPaths.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	            reset: function () {
	                this.nodePath.length = 0;
	                this.nodePaths.length = 0;
	            },
	            apply: function ( node ) {
	                if ( node.parents.length === 0 || node === this.halt || node.referenceFrame === TransformEnums.ABSOLUTE_RF ) {
	                    // copy
	                    this.nodePaths.push( this.nodePath.slice( 0 ) );
	                } else {
	                    this.traverse( node );
	                }
	            }
	        } );
	        var collected = new CollectParentPaths();
	        collected.setNodeMaskOverride( ~0x0 ); // traverse everything
	
	        return function ( halt, matrixCreate ) {
	            collected.reset();
	            collected.halt = halt;
	
	            this.accept( collected );
	            var matrixList = [];
	
	            var matrixGenerator = matrixCreate || Matrix.create;
	            for ( var i = 0, l = collected.nodePaths.length; i < l; i++ ) {
	                var np = collected.nodePaths[ i ];
	                var m = matrixGenerator();
	                if ( np.length !== 0 ) {
	                    ComputeMatrixFromNodePath.computeLocalToWorld( np, true, m );
	                }
	                matrixList.push( m );
	            }
	
	            return matrixList;
	        };
	
	    } )(),
	
	    // same as getWorldMatrices GC: Perf WIN
	    getWorldMatrix: function ( halt, matrix ) {
	
	        // pass allocator on master
	        var matrixList = this.getWorldMatrices( halt, nodeGetMat );
	
	        if ( matrixList.length === 0 ) {
	
	            Matrix.makeIdentity( matrix );
	
	        } else {
	
	            Matrix.copy( matrixList[ 0 ], matrix );
	
	        }
	
	        Node._reservedMatrixStack.reset();
	        return matrix;
	
	    },
	
	    setCullingActive: function ( value ) {
	        if ( this._cullingActive === value ) return;
	        if ( this._numChildrenWithCullingDisabled === 0 && this.parents.length > 0 ) {
	            var delta = 0;
	            if ( !this._cullingActive ) --delta;
	            if ( !value ) ++delta;
	            if ( delta !== 0 ) {
	                for ( var i = 0, k = this.parents.length; i < k; i++ ) {
	                    this.parents[ i ].setNumChildrenWithCullingDisabled( this.parents[ i ].getNumChildrenWithCullingDisabled() + delta );
	                }
	            }
	        }
	        this._cullingActive = value;
	    },
	
	    getCullingActive: function () {
	        return this._cullingActive;
	    },
	
	    isCullingActive: function () {
	        return this._numChildrenWithCullingDisabled === 0 && this._cullingActive && this.getBound().valid();
	    },
	
	    setNumChildrenWithCullingDisabled: function ( num ) {
	        if ( this._numChildrenWithCullingDisabled === num ) return;
	        if ( this._cullingActive && this.parents.length > 0 ) {
	            var delta = 0;
	            if ( this._numChildrenWithCullingDisabled > 0 ) --delta;
	            if ( num > 0 ) ++delta;
	            if ( delta !== 0 ) {
	                for ( var i = 0, k = this.parents.length; i < k; i++ ) {
	                    this.parents[ i ].setNumChildrenWithCullingDisabled( this.parents[ i ].getNumChildrenWithCullingDisabled() + delta );
	                }
	            }
	        }
	        this._numChildrenWithCullingDisabled = num;
	    },
	
	    getNumChildrenWithCullingDisabled: function () {
	        return this._numChildrenWithCullingDisabled;
	    },
	
	    releaseGLObjects: function () {
	        if ( this.stateset !== undefined ) this.stateset.releaseGLObjects();
	    }
	
	
	} ), 'osg', 'Node' );
	MACROUTILS.setTypeID( Node );
	
	
	module.exports = Node;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	
	/**
	 *  Object class
	 *  @class Object
	 */
	var Object = function () {
	    this._name = undefined;
	    this._userdata = undefined;
	    this._instanceID = Object.getInstanceID();
	};
	
	/** @lends Object.prototype */
	Object.prototype = MACROUTILS.objectLibraryClass( {
	
	    // this method works only if constructor is set correctly
	    // see issue https://github.com/cedricpinson/osgjs/issues/494
	    cloneType: function () {
	        var Constructor = this.constructor;
	        return new Constructor();
	    },
	
	    getInstanceID: function () {
	        return this._instanceID;
	    },
	
	    setName: function ( name ) {
	        this._name = name;
	    },
	
	    getName: function () {
	        return this._name;
	    },
	
	    setUserData: function ( data ) {
	        this._userdata = data;
	    },
	
	    getUserData: function () {
	        return this._userdata;
	    }
	}, 'osg', 'Object' );
	
	
	// get an instanceID for each object
	var instanceID = 0;
	Object.getInstanceID = function () {
	    instanceID += 1;
	    return instanceID;
	};
	
	module.exports = Object;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	
	
	var BoundingBox = function () {
	    this._min = Vec3.create();
	    this._max = Vec3.create();
	    this.init();
	};
	BoundingBox.prototype = MACROUTILS.objectLibraryClass( {
	
	    init: function () {
	        Vec3.copy( Vec3.infinity, this._min );
	        Vec3.copy( Vec3.negativeInfinity, this._max );
	    },
	
	    copy: function ( bbox ) {
	        var min = this._min;
	        var bmin = bbox._min;
	        min[ 0 ] = bmin[ 0 ];
	        min[ 1 ] = bmin[ 1 ];
	        min[ 2 ] = bmin[ 2 ];
	
	        var max = this._max;
	        var bmax = bbox._max;
	        max[ 0 ] = bmax[ 0 ];
	        max[ 1 ] = bmax[ 1 ];
	        max[ 2 ] = bmax[ 2 ];
	    },
	
	    valid: function () {
	        return ( this._max[ 0 ] >= this._min[ 0 ] && this._max[ 1 ] >= this._min[ 1 ] && this._max[ 2 ] >= this._min[ 2 ] );
	    },
	
	    expandByBoundingSphere: function ( bs ) {
	        if ( !bs.valid() ) {
	            return;
	        }
	        var max = this._max;
	        var min = this._min;
	        min[ 0 ] = Math.min( min[ 0 ], bs._center[ 0 ] - bs._radius );
	        min[ 1 ] = Math.min( min[ 1 ], bs._center[ 1 ] - bs._radius );
	        min[ 2 ] = Math.min( min[ 2 ], bs._center[ 2 ] - bs._radius );
	
	        max[ 0 ] = Math.max( max[ 0 ], bs._center[ 0 ] + bs._radius );
	        max[ 1 ] = Math.max( max[ 1 ], bs._center[ 1 ] + bs._radius );
	        max[ 2 ] = Math.max( max[ 2 ], bs._center[ 2 ] + bs._radius );
	    },
	
	    expandBySphere: function ( bs ) {
	        Notify.log( 'BoundingBox.expandBySphere is deprecated, use instead BoundBox.expandByBoundingSphere' );
	        return this.expandByBoundingSphere( bs );
	    },
	
	    expandByVec3: function ( v ) {
	        var min = this._min;
	        var max = this._max;
	        min[ 0 ] = Math.min( min[ 0 ], v[ 0 ] );
	        min[ 1 ] = Math.min( min[ 1 ], v[ 1 ] );
	        min[ 2 ] = Math.min( min[ 2 ], v[ 2 ] );
	
	        max[ 0 ] = Math.max( max[ 0 ], v[ 0 ] );
	        max[ 1 ] = Math.max( max[ 1 ], v[ 1 ] );
	        max[ 2 ] = Math.max( max[ 2 ], v[ 2 ] );
	    },
	
	    expandByBoundingBox: function ( bb ) {
	        if ( !bb.valid() )
	            return;
	
	        var min = this._min;
	        var max = this._max;
	        var bbmin = bb._min;
	        var bbmax = bb._max;
	
	        if ( bbmin[ 0 ] < min[ 0 ] ) min[ 0 ] = bbmin[ 0 ];
	        if ( bbmax[ 0 ] > max[ 0 ] ) max[ 0 ] = bbmax[ 0 ];
	
	        if ( bbmin[ 1 ] < min[ 1 ] ) min[ 1 ] = bbmin[ 1 ];
	        if ( bbmax[ 1 ] > max[ 1 ] ) max[ 1 ] = bbmax[ 1 ];
	
	        if ( bbmin[ 2 ] < min[ 2 ] ) min[ 2 ] = bbmin[ 2 ];
	        if ( bbmax[ 2 ] > max[ 2 ] ) max[ 2 ] = bbmax[ 2 ];
	    },
	
	    center: function ( result ) {
	        var min = this._min;
	        var max = this._max;
	        if ( result === undefined ) {
	            // TODO: deprecated warning?
	            Notify.warn( 'deprecated use center( result ) instead !' );
	            result = Vec3.create();
	        }
	        Vec3.set( ( min[ 0 ] + max[ 0 ] ) * 0.5, ( min[ 1 ] + max[ 1 ] ) * 0.5, ( min[ 2 ] + max[ 2 ] ) * 0.5, result );
	        return result;
	    },
	
	    radius: function () {
	        return Math.sqrt( this.radius2() );
	    },
	
	    radius2: function () {
	        var min = this._min;
	        var max = this._max;
	        var dx = max[ 0 ] - min[ 0 ];
	        var dy = max[ 1 ] - min[ 1 ];
	        var dz = max[ 2 ] - min[ 2 ];
	        return 0.25 * ( dx * dx + dy * dy + dz * dz );
	    },
	
	    getMin: function () {
	        return this._min;
	    },
	
	    getMax: function () {
	        return this._max;
	    },
	
	    setMin: function ( min ) {
	        Vec3.copy( min, this._min );
	        return this;
	    },
	
	    setMax: function ( max ) {
	        Vec3.copy( max, this._max );
	        return this;
	    },
	
	    xMax: function () {
	        return this._max[ 0 ];
	    },
	
	    yMax: function () {
	        return this._max[ 1 ];
	    },
	
	    zMax: function () {
	        return this._max[ 2 ];
	    },
	
	    xMin: function () {
	        return this._min[ 0 ];
	    },
	
	    yMin: function () {
	        return this._min[ 1 ];
	    },
	
	    zMin: function () {
	        return this._min[ 2 ];
	    },
	
	    corner: function ( pos, ret ) {
	        /*jshint bitwise: false */
	        if ( pos & 1 ) {
	            ret[ 0 ] = this._max[ 0 ];
	        } else {
	            ret[ 0 ] = this._min[ 0 ];
	        }
	        if ( pos & 2 ) {
	            ret[ 1 ] = this._max[ 1 ];
	        } else {
	            ret[ 1 ] = this._min[ 1 ];
	        }
	        if ( pos & 4 ) {
	            ret[ 2 ] = this._max[ 2 ];
	        } else {
	            ret[ 2 ] = this._min[ 2 ];
	        }
	        return ret;
	        /*jshint bitwise: true */
	    }
	}, 'osg', 'BoundingBox' );
	
	module.exports = BoundingBox;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osgMath = __webpack_require__( 16 );
	var config = __webpack_require__( 17 );
	
	var ArrayType = config.ArrayType;
	
	
	/** @class Vec3 Operations */
	var Vec3 = {
	
	    create: function () {
	        var out = new ArrayType( 3 );
	        out[ 0 ] = 0.0;
	        out[ 1 ] = 0.0;
	        out[ 2 ] = 0.0;
	        return out;
	    },
	
	    createAndSet: function ( x, y, z ) {
	        var out = new ArrayType( 3 );
	        out[ 0 ] = x;
	        out[ 1 ] = y;
	        out[ 2 ] = z;
	        return out;
	    },
	
	    init: function ( a ) {
	        a[ 0 ] = 0.0;
	        a[ 1 ] = 0.0;
	        a[ 2 ] = 0.0;
	        return a;
	    },
	
	    set: function ( a, b, c, r ) {
	        r[ 0 ] = a;
	        r[ 1 ] = b;
	        r[ 2 ] = c;
	        return r;
	    },
	
	    copy: function ( a, r ) {
	        r[ 0 ] = a[ 0 ];
	        r[ 1 ] = a[ 1 ];
	        r[ 2 ] = a[ 2 ];
	        return r;
	    },
	
	    cross: function ( a, b, r ) {
	        var x = a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ];
	        var y = a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ];
	        var z = a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ];
	        r[ 0 ] = x;
	        r[ 1 ] = y;
	        r[ 2 ] = z;
	        return r;
	    },
	
	    valid: function ( a ) {
	        if ( osgMath.isNaN( a[ 0 ] ) ) return false;
	        if ( osgMath.isNaN( a[ 1 ] ) ) return false;
	        if ( osgMath.isNaN( a[ 2 ] ) ) return false;
	        return true;
	    },
	
	    mult: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] * b;
	        r[ 1 ] = a[ 1 ] * b;
	        r[ 2 ] = a[ 2 ] * b;
	        return r;
	    },
	
	    length2: function ( a ) {
	        return a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ];
	    },
	
	    length: function ( a ) {
	        return Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
	    },
	
	    distance2: function ( a, b ) {
	        var x = a[ 0 ] - b[ 0 ];
	        var y = a[ 1 ] - b[ 1 ];
	        var z = a[ 2 ] - b[ 2 ];
	        return x * x + y * y + z * z;
	    },
	
	    distance: function ( a, b ) {
	        var x = a[ 0 ] - b[ 0 ];
	        var y = a[ 1 ] - b[ 1 ];
	        var z = a[ 2 ] - b[ 2 ];
	        return Math.sqrt( x * x + y * y + z * z );
	    },
	
	    normalize: function ( a, r ) {
	        var norm = this.length2( a );
	        if ( norm > 0.0 ) {
	            var inv = 1.0 / Math.sqrt( norm );
	            r[ 0 ] = a[ 0 ] * inv;
	            r[ 1 ] = a[ 1 ] * inv;
	            r[ 2 ] = a[ 2 ] * inv;
	        } else {
	            r[ 0 ] = a[ 0 ];
	            r[ 1 ] = a[ 1 ];
	            r[ 2 ] = a[ 2 ];
	        }
	        return r;
	    },
	
	    dot: function ( a, b ) {
	        return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ];
	    },
	
	    sub: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] - b[ 0 ];
	        r[ 1 ] = a[ 1 ] - b[ 1 ];
	        r[ 2 ] = a[ 2 ] - b[ 2 ];
	        return r;
	    },
	
	    add: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] + b[ 0 ];
	        r[ 1 ] = a[ 1 ] + b[ 1 ];
	        r[ 2 ] = a[ 2 ] + b[ 2 ];
	        return r;
	    },
	
	    neg: function ( a, r ) {
	        r[ 0 ] = -a[ 0 ];
	        r[ 1 ] = -a[ 1 ];
	        r[ 2 ] = -a[ 2 ];
	        return r;
	    },
	
	    lerp: function ( t, a, b, r ) {
	        r[ 0 ] = a[ 0 ] + ( b[ 0 ] - a[ 0 ] ) * t;
	        r[ 1 ] = a[ 1 ] + ( b[ 1 ] - a[ 1 ] ) * t;
	        r[ 2 ] = a[ 2 ] + ( b[ 2 ] - a[ 2 ] ) * t;
	        return r;
	    },
	    equal: function ( a, b ) {
	        return a[ 0 ] === b[ 0 ] && a[ 1 ] === b[ 1 ] && a[ 2 ] === b[ 2 ];
	    }
	};
	
	Vec3.zero = Vec3.create();
	Vec3.one = Vec3.createAndSet( 1.0, 1.0, 1.0 );
	Vec3.infinity = Vec3.createAndSet( Infinity, Infinity, Infinity );
	Vec3.negativeInfinity = Vec3.createAndSet( -Infinity, -Infinity, -Infinity );
	
	module.exports = Vec3;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';
	
	var clamp = function ( x, min, max ) {
	    // http://jsperf.com/math-clamp
	    // http://jsperf.com/clamping-methods/2
	    return Math.min( max, Math.max( min, x ) );
	};
	
	var smoothStep = function ( edge0, edge1, x ) {
	    var t = clamp( ( x - edge0 ) / ( edge1 - edge0 ), 0.0, 1.0 );
	    return t * t * ( 3.0 - 2.0 * t );
	};
	
	// native isNaN is slow (e.g: https://jsperf.com/isnan-performance/2)
	// note : native isNaN will return true for undefined but
	// this function assume that x is a number
	var fastIsNaN = function ( x ) {
	    return x !== x;
	};
	
	module.exports = {
	    clamp: clamp,
	    smoothStep: smoothStep,
	    isNaN: fastIsNaN
	};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = {
	    ArrayType: Float64Array
	};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BoundingBox = __webpack_require__( 14 );
	var Notify = __webpack_require__( 10 );
	var Vec3 = __webpack_require__( 15 );
	
	
	var BoundingSphere = function () {
	    this._center = Vec3.create();
	    this._radius = -1.0;
	};
	
	BoundingSphere.prototype = {
	    init: function () {
	        Vec3.init( this._center );
	        this._radius = -1.0;
	    },
	    valid: function () {
	        return this._radius >= 0.0;
	    },
	    set: function ( center, radius ) {
	        this._center = center;
	        this._radius = radius;
	    },
	    center: function () {
	        return this._center;
	    },
	    radius: function () {
	        return this._radius;
	    },
	    radius2: function () {
	        return this._radius * this._radius;
	    },
	
	    expandByBoundingBox: ( function () {
	        var v = Vec3.create();
	        var newbb = new BoundingBox();
	
	        return function ( bb ) {
	            if ( !bb.valid() )
	                return;
	
	            if ( this.valid() ) {
	                Vec3.copy( bb._min, newbb._min );
	                Vec3.copy( bb._max, newbb._max );
	
	                for ( var i = 0; i < 8; i++ ) {
	                    Vec3.sub( bb.corner( i, v ), this._center, v ); // get the direction vector from corner
	                    Vec3.normalize( v, v ); // normalise it.
	                    Vec3.mult( v, -this._radius, v ); // move the vector in the opposite direction distance radius.
	                    Vec3.add( v, this._center, v ); // move to absolute position.
	                    newbb.expandByVec3( v ); // add it into the new bounding box.
	                }
	
	                newbb.center( this._center );
	                this._radius = newbb.radius();
	            } else {
	                bb.center( this._center );
	                this._radius = bb.radius();
	            }
	        };
	    } )(),
	
	    expandByBox: function ( bb ) {
	        Notify.log( 'BoundingSphere.expandByBox is deprecated, use instead BoundingSphere.expandByBoundingBox' );
	        return this.expandByBoundingBox( bb );
	    },
	
	    expandByVec3: ( function () {
	        var dv = Vec3.create();
	        return function ( v ) {
	            if ( this.valid() ) {
	                Vec3.sub( v, this.center( dv ), dv );
	                var r = Vec3.length( dv );
	                if ( r > this.radius() ) {
	                    var dr = ( r - this.radius() ) * 0.5;
	                    this._center[ 0 ] += dv[ 0 ] * ( dr / r );
	                    this._center[ 1 ] += dv[ 1 ] * ( dr / r );
	                    this._center[ 2 ] += dv[ 2 ] * ( dr / r );
	                    this._radius += dr;
	                }
	            } else {
	                this._center[ 0 ] = v[ 0 ];
	                this._center[ 1 ] = v[ 1 ];
	                this._center[ 2 ] = v[ 2 ];
	                this._radius = 0.0;
	            }
	        };
	    } )(),
	
	    expandRadiusBySphere: function ( sh ) {
	        if ( sh.valid() ) {
	            if ( this.valid() ) {
	                var r = Vec3.distance( sh._center, this._center ) + sh._radius;
	                if ( r > this._radius ) {
	                    this._radius = r;
	                }
	                // else do nothing as vertex is within sphere.
	            } else {
	                Vec3.copy( sh._center, this._center );
	                this._radius = sh._radius;
	            }
	        }
	    },
	
	    expandBy: function ( bs ) {
	        Notify.log( 'BoundingSphere.expandBy is deprecated, use instead BoundingSphere.expandByBoundingSphere' );
	        this.expandByBoundingSphere( bs );
	    },
	
	    expandByBoundingSphere: function ( sh ) {
	        // ignore operation if incomming BoundingSphere is invalid.
	        if ( !sh.valid() ) {
	            return;
	        }
	
	        // This sphere is not set so use the inbound sphere
	        if ( !this.valid() ) {
	            this._center[ 0 ] = sh._center[ 0 ];
	            this._center[ 1 ] = sh._center[ 1 ];
	            this._center[ 2 ] = sh._center[ 2 ];
	            this._radius = sh.radius();
	
	            return;
	        }
	
	        // Calculate d == The distance between the sphere centers
	        var d = Vec3.distance( this.center(), sh.center() );
	
	        // New sphere is already inside this one
	        if ( d + sh.radius() <= this.radius() ) {
	            return;
	        }
	
	        //  New sphere completely contains this one
	        if ( d + this.radius() <= sh.radius() ) {
	            this._center[ 0 ] = sh._center[ 0 ];
	            this._center[ 1 ] = sh._center[ 1 ];
	            this._center[ 2 ] = sh._center[ 2 ];
	            this._radius = sh._radius;
	            return;
	        }
	
	
	        // Build a new sphere that completely contains the other two:
	        //
	        // The center point lies halfway along the line between the furthest
	        // points on the edges of the two spheres.
	        //
	        // Computing those two points is ugly - so we'll use similar triangles
	        var newRadius = ( this.radius() + d + sh.radius() ) * 0.5;
	        var ratio = ( newRadius - this.radius() ) / d;
	
	        this._center[ 0 ] += ( sh._center[ 0 ] - this._center[ 0 ] ) * ratio;
	        this._center[ 1 ] += ( sh._center[ 1 ] - this._center[ 1 ] ) * ratio;
	        this._center[ 2 ] += ( sh._center[ 2 ] - this._center[ 2 ] ) * ratio;
	
	        this._radius = newRadius;
	    },
	    contains: function ( v ) {
	        if ( !this.valid() )
	            return false;
	        return Vec3.distance2( v, this.center() ) <= this.radius2();
	    },
	    intersects: function ( bs ) {
	        if ( !this.valid() || !bs.valid() )
	            return false;
	        var r = this.radius() + bs.radius();
	        return Vec3.distance2( this.center(), bs.center() ) <= r * r;
	    }
	};
	
	module.exports = BoundingSphere;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Map = __webpack_require__( 20 );
	var Notify = __webpack_require__( 10 );
	var Object = __webpack_require__( 13 );
	var StateAttribute = __webpack_require__( 21 );
	var MACROUTILS = __webpack_require__( 6 );
	
	
	/** Stores a set of modes and attributes which represent a set of OpenGL state.
	 *  Notice that a \c StateSet contains just a subset of the whole OpenGL state.
	 * <p>In OSG, each \c Drawable and each \c Node has a reference to a
	 * \c StateSet. These <tt>StateSet</tt>s can be shared between
	 * different <tt>Drawable</tt>s and <tt>Node</tt>s (that is, several
	 * <tt>Drawable</tt>s and <tt>Node</tt>s can reference the same \c StateSet).
	 * Indeed, this practice is recommended whenever possible,
	 * as this minimizes expensive state changes in the graphics pipeline.
	 */
	var StateSet = function () {
	    Object.call( this );
	
	    this.attributeMap = new Map();
	
	    this.textureAttributeMapList = [];
	
	    this._binName = undefined;
	    this._binNumber = 0;
	
	    // put the shader generator name in an AttributePair
	    // so that we can use the mask value
	    this._shaderGeneratorPair = null;
	
	    this._updateCallbackList = [];
	
	    this.uniforms = new Map();
	
	};
	
	StateSet.AttributePair = function ( attr, value ) {
	    this._object = attr;
	    this._value = value;
	};
	
	StateSet.AttributePair.prototype = {
	    getShaderGeneratorName: function () {
	        return this._object;
	    },
	    getAttribute: function () {
	        return this._object;
	    },
	    getUniform: function () {
	        return this._object;
	    },
	    getValue: function () {
	        return this._value;
	    }
	};
	
	
	StateSet.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	    getAttributePair: function ( attribute, value ) {
	        return new StateSet.AttributePair( attribute, value );
	    },
	    addUniform: function ( uniform, mode ) {
	        if ( mode === undefined ) {
	            mode = StateAttribute.ON;
	        }
	
	        var name = uniform.getName();
	        this.uniforms[ name ] = this.getAttributePair( uniform, mode );
	        this.uniforms.dirty();
	    },
	    removeUniform: function ( uniform ) {
	        this.uniforms.remove( uniform.getName() );
	    },
	    removeUniformByName: function ( uniformName ) {
	        this.uniforms.remove( uniformName );
	    },
	    getUniform: function ( uniform ) {
	        var uniformMap = this.uniforms;
	        if ( uniformMap[ uniform ] ) return uniformMap[ uniform ].getAttribute();
	
	        return undefined;
	    },
	    getUniformList: function () {
	        return this.uniforms;
	    },
	
	    setTextureAttributeAndModes: function ( unit, attribute, mode ) {
	        if ( mode === undefined ) {
	            mode = StateAttribute.ON;
	        }
	        this._setTextureAttribute( unit, this.getAttributePair( attribute, mode ) );
	    },
	    setTextureAttributeAndMode: function ( unit, attribute, mode ) {
	        Notify.log( 'StateSet.setTextureAttributeAndMode is deprecated, insteady use setTextureAttributeAndModes' );
	        this.setTextureAttributeAndModes( unit, attribute, mode );
	    },
	
	    getNumTextureAttributeLists: function () {
	        return this.textureAttributeMapList.length;
	    },
	    getTextureAttribute: function ( unit, attribute ) {
	        if ( this.textureAttributeMapList[ unit ] === undefined ) return undefined;
	
	        var textureMap = this.textureAttributeMapList[ unit ];
	        if ( textureMap[ attribute ] === undefined ) return undefined;
	
	        return textureMap[ attribute ].getAttribute();
	    },
	
	    removeTextureAttribute: function ( unit, attributeName ) {
	        if ( this.textureAttributeMapList[ unit ] === undefined ) return;
	
	        var textureAttributeMap = this.textureAttributeMapList[ unit ];
	        if ( textureAttributeMap[ attributeName ] === undefined ) return;
	
	
	        textureAttributeMap.remove( attributeName );
	        this.textureAttributeMapList[ unit ].dirty();
	    },
	
	    getAttribute: function ( attributeType ) {
	        if ( this.attributeMap[ attributeType ] === undefined ) {
	            return undefined;
	        }
	        return this.attributeMap[ attributeType ].getAttribute();
	    },
	
	    setAttributeAndModes: function ( attribute, mode ) {
	        if ( mode === undefined ) {
	            mode = StateAttribute.ON;
	        }
	        this._setAttribute( this.getAttributePair( attribute, mode ) );
	    },
	
	    setAttributeAndMode: function ( attribute, mode ) {
	        Notify.log( 'StateSet.setAttributeAndMode is deprecated, insteady use setAttributeAndModes' );
	        this.setAttributeAndModes( attribute, mode );
	    },
	
	    setAttribute: function ( attribute, mode ) {
	        if ( mode === undefined ) {
	            mode = StateAttribute.ON;
	        }
	        this._setAttribute( this.getAttributePair( attribute, mode ) );
	    },
	
	    // TODO: check if it's an attribute type or a attribute to remove it
	    removeAttribute: function ( attributeName ) {
	
	        if ( this.attributeMap[ attributeName ] !== undefined ) {
	            delete this.attributeMap[ attributeName ];
	            this.attributeMap.dirty();
	        }
	    },
	
	    setRenderingHint: function ( hint ) {
	        if ( hint === 'OPAQUE_BIN' ) {
	            this.setRenderBinDetails( 0, 'RenderBin' );
	        } else if ( hint === 'TRANSPARENT_BIN' ) {
	            this.setRenderBinDetails( 10, 'DepthSortedBin' );
	        } else {
	            this.setRenderBinDetails( 0, '' );
	        }
	    },
	
	    getUpdateCallbackList: function () {
	        return this._updateCallbackList;
	    },
	    removeUpdateCallback: function ( cb ) {
	        var arrayIdx = this._updateCallbackList.indexOf( cb );
	        if ( arrayIdx !== -1 )
	            this._updateCallbackList.splice( arrayIdx, 1 );
	    },
	    addUpdateCallback: function ( cb ) {
	        this._updateCallbackList.push( cb );
	    },
	    hasUpdateCallback: function ( cb ) {
	        return this._updateCallbackList.indexOf( cb ) !== -1;
	    },
	
	    setRenderBinDetails: function ( num, binName ) {
	        this._binNumber = num;
	        this._binName = binName;
	    },
	    getAttributeMap: function () {
	        return this.attributeMap;
	    },
	    getBinNumber: function () {
	        return this._binNumber;
	    },
	    getBinName: function () {
	        return this._binName;
	    },
	    setBinNumber: function ( binNum ) {
	        this._binNumber = binNum;
	    },
	    setBinName: function ( binName ) {
	        this._binName = binName;
	    },
	    getAttributeList: function () {
	        var attributeMap = this.attributeMap;
	        var attributeMapKeys = attributeMap.getKeys();
	
	        var l = attributeMapKeys.length;
	        var list = [];
	        for ( var i = 0; i < l; i++ ) {
	            list.push( attributeMap[ attributeMapKeys[ i ] ] );
	        }
	        return list;
	    },
	    setShaderGeneratorName: function ( generatorName, mask ) {
	        this._shaderGeneratorPair = this.getAttributePair( generatorName, mask );
	    },
	    getShaderGeneratorPair: function () {
	        return this._shaderGeneratorPair;
	    },
	    getShaderGeneratorName: function () {
	        return this._shaderGeneratorPair ? this._shaderGeneratorPair.getShaderGeneratorName() : undefined;
	    },
	    releaseGLObjects: function () {
	        for ( var i = 0, j = this.textureAttributeMapList.length; i < j; i++ ) {
	            this.getTextureAttribute( i, 'Texture' ).releaseGLObjects();
	        }
	        var list = this.getAttributeList();
	        for ( i = 0, j = list.length; i < j; i++ ) {
	            // Remove only if we have releaseGLObject method.
	            if ( list[ i ]._object.releaseGLObjects ) {
	                list[ i ]._object.releaseGLObjects();
	            }
	        }
	    },
	    _getUniformMap: function () {
	        return this.uniforms;
	    },
	
	    // for internal use, you should not call it directly
	    _setTextureAttribute: function ( unit, attributePair ) {
	
	        if ( this.textureAttributeMapList[ unit ] === undefined ) {
	            this.textureAttributeMapList[ unit ] = new Map();
	        }
	
	        var name = attributePair.getAttribute().getTypeMember();
	        var textureUnitAttributeMap = this.textureAttributeMapList[ unit ];
	
	        textureUnitAttributeMap[ name ] = attributePair;
	        textureUnitAttributeMap.dirty();
	
	    },
	
	    // for internal use, you should not call it directly
	    _setAttribute: function ( attributePair ) {
	
	        var name = attributePair.getAttribute().getTypeMember();
	        this.attributeMap[ name ] = attributePair;
	        this.attributeMap.dirty();
	
	    }
	
	} ), 'osg', 'StateSet' );
	
	module.exports = StateSet;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	var Map = function ( obj ) {
	
	    window.Object.defineProperty( this, '_dirty', {
	        configurable: true,
	        enumerable: false,
	        writable: true,
	        value: true
	    } );
	
	    window.Object.defineProperty( this, '_keys', {
	        configurable: true,
	        enumerable: false,
	        writable: true,
	        value: undefined
	    } );
	
	    if ( obj ) this.setMap( obj );
	};
	
	Map.prototype = {
	
	    getKeys: function () {
	        if ( this._dirty ) {
	            this._keys = window.Object.keys( this );
	            this._dirty = false;
	        }
	        return this._keys;
	    },
	
	    dirty: function () {
	        this._dirty = true;
	    },
	
	    remove: function ( key ) {
	        //this[ key ] = undefined;
	        delete this[ key ];
	        this.dirty();
	        this.getKeys();
	    },
	
	    setMap: function ( map ) {
	
	        var i, l;
	        // remove all
	        var keys = window.Object.keys( this );
	        if ( keys.length > 0 ) {
	            for ( i = 0, l = keys.length; i < l; i++ )
	                delete this[ keys[ i ] ];
	        }
	
	        // add new
	        keys = window.Object.keys( map );
	        if ( keys.length > 0 ) {
	            for ( i = 0, l = keys.length; i < l; i++ ) {
	                var key = keys[ i ];
	                this[ key ] = map[ key ];
	            }
	        }
	
	        this.dirty();
	    }
	
	};
	
	module.exports = Map;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	
	
	var StateAttribute = function () {
	    Object.call( this );
	};
	
	StateAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	
	    getType: function () {
	        return this.attributeType;
	    },
	
	    // basically, if you want two StateAttribute with the same attributeType in a stateSet/State
	    // their typeMember should be different
	    getTypeMember: function () {
	        return this.attributeType;
	    },
	
	    apply: function () {},
	
	    // getHash is used by the compiler to know if a change in a StateAttribute
	    // must trigger a shader build
	    // If you create your own attribute you will have to customize this function
	    // a good rule is to that if you change uniform it should not rebuild a shader
	    // but if you change a type or representation of your StateAttribute, then it should
	    // if it impact the rendering.
	    // check other attributes for examples
	    getHash: function () {
	        return this.getTypeMember();
	    }
	
	} ), 'osg', 'StateAttribute' );
	
	StateAttribute.OFF = 0;
	StateAttribute.ON = 1;
	StateAttribute.OVERRIDE = 2;
	StateAttribute.PROTECTED = 4;
	StateAttribute.INHERIT = 8;
	
	module.exports = StateAttribute;


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	'use strict';
	
	var NodeVisitor = function ( traversalMode ) {
	    /*jshint bitwise: false */
	    this.traversalMask = ~0x0;
	    /*jshint bitwise: true */
	    this.nodeMaskOverride = 0;
	    this.traversalMode = traversalMode;
	    if ( traversalMode === undefined ) {
	        this.traversalMode = NodeVisitor.TRAVERSE_ALL_CHILDREN;
	    }
	    this.nodePath = [];
	    this.visitorType = NodeVisitor.NODE_VISITOR;
	    this._databaseRequestHandler = undefined;
	    this._frameStamp = undefined;
	};
	
	//NodeVisitor.TRAVERSE_NONE = 0;
	NodeVisitor.TRAVERSE_PARENTS = 1;
	NodeVisitor.TRAVERSE_ALL_CHILDREN = 2;
	NodeVisitor.TRAVERSE_ACTIVE_CHILDREN = 3;
	NodeVisitor.NODE_VISITOR = 0;
	NodeVisitor.UPDATE_VISITOR = 1;
	NodeVisitor.CULL_VISITOR = 2;
	
	
	NodeVisitor._traversalFunctions = {};
	NodeVisitor._traversalFunctions[ NodeVisitor.TRAVERSE_PARENTS ] = function ( node ) {
	    node.ascend( this );
	};
	NodeVisitor._traversalFunctions[ NodeVisitor.TRAVERSE_ALL_CHILDREN ] = function ( node ) {
	    node.traverse( this );
	};
	NodeVisitor._traversalFunctions[ NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ] = function ( node ) {
	    node.traverse( this );
	};
	
	
	NodeVisitor._pushOntoNodePath = {};
	NodeVisitor._pushOntoNodePath[ NodeVisitor.TRAVERSE_PARENTS ] = function ( node ) {
	    this.nodePath.unshift( node );
	};
	NodeVisitor._pushOntoNodePath[ NodeVisitor.TRAVERSE_ALL_CHILDREN ] = function ( node ) {
	    this.nodePath.push( node );
	};
	NodeVisitor._pushOntoNodePath[ NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ] = function ( node ) {
	    this.nodePath.push( node );
	};
	NodeVisitor._popFromNodePath = {};
	NodeVisitor._popFromNodePath[ NodeVisitor.TRAVERSE_PARENTS ] = function () {
	    return this.nodePath.shift();
	};
	NodeVisitor._popFromNodePath[ NodeVisitor.TRAVERSE_ALL_CHILDREN ] = function () {
	    this.nodePath.pop();
	};
	NodeVisitor._popFromNodePath[ NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ] = function () {
	    this.nodePath.pop();
	};
	
	NodeVisitor.prototype = {
	
	    reset: function () {
	        // to be used when you want to re-use a nv
	        this.nodePath.length = 0;
	    },
	
	    setFrameStamp: function ( frameStamp ) {
	        this._frameStamp = frameStamp;
	    },
	
	    getFrameStamp: function () {
	        return this._frameStamp;
	    },
	
	
	    setNodeMaskOverride: function ( m ) {
	        this.nodeMaskOverride = m;
	    },
	    getNodeMaskOverride: function () {
	        return this.nodeMaskOverride;
	    },
	
	    setTraversalMask: function ( m ) {
	        this.traversalMask = m;
	    },
	    getTraversalMask: function () {
	        return this.traversalMask;
	    },
	
	    getNodePath: function () {
	        return this.nodePath;
	    },
	
	    pushOntoNodePath: function ( node ) {
	        NodeVisitor._pushOntoNodePath[ this.traversalMode ].call( this, node );
	    },
	    popFromNodePath: function () {
	        NodeVisitor._popFromNodePath[ this.traversalMode ].call( this );
	    },
	    validNodeMask: function ( node ) {
	        var nm = node.getNodeMask();
	        /*jshint bitwise: false */
	        return ( ( this.traversalMask & ( this.nodeMaskOverride | nm ) ) !== 0 );
	        /*jshint bitwise: true */
	    },
	    apply: function ( node ) {
	        this.traverse( node );
	    },
	    traverse: function ( node ) {
	        NodeVisitor._traversalFunctions[ this.traversalMode ].call( this, node );
	    },
	    getVisitorType: function () {
	        return this.visitorType;
	    },
	    setDatabaseRequestHandler: function ( dbpager ) {
	        this._databaseRequestHandler = dbpager;
	    },
	    getDatabaseRequestHandler: function () {
	        return this._databaseRequestHandler;
	    }
	};
	
	module.exports = NodeVisitor;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var osgMath = __webpack_require__( 16 );
	var BoundingBox = __webpack_require__( 14 );
	var Plane = __webpack_require__( 24 );
	var Quat = __webpack_require__( 26 );
	var Vec3 = __webpack_require__( 15 );
	var config = __webpack_require__( 17 );
	
	var ArrayType = config.ArrayType;
	
	
	var Mabs = Math.abs;
	var NMIN_VALUE = Number.MIN_VALUE;
	
	// call by closur'd variables because Matrix object is not
	// resolved yet, a workaround would be to define Matrix such as:
	// var Matrix = {};
	// Matrix.create = function... ;
	// Matrix.func2 = function... ;
	var matrixCreate = function () {
	    var out = new ArrayType( 16 );
	    out[ 0 ] = 1.0;
	    out[ 1 ] = 0.0;
	    out[ 2 ] = 0.0;
	    out[ 3 ] = 0.0;
	    out[ 4 ] = 0.0;
	    out[ 5 ] = 1.0;
	    out[ 6 ] = 0.0;
	    out[ 7 ] = 0.0;
	    out[ 8 ] = 0.0;
	    out[ 9 ] = 0.0;
	    out[ 10 ] = 1.0;
	    out[ 11 ] = 0.0;
	    out[ 12 ] = 0.0;
	    out[ 13 ] = 0.0;
	    out[ 14 ] = 0.0;
	    out[ 15 ] = 1.0;
	    return out;
	};
	
	/** @class Matrix Operations */
	var Matrix = {
	
	    create: function () {
	        var out = new ArrayType( 16 );
	        out[ 0 ] = 1.0;
	        out[ 1 ] = 0.0;
	        out[ 2 ] = 0.0;
	        out[ 3 ] = 0.0;
	        out[ 4 ] = 0.0;
	        out[ 5 ] = 1.0;
	        out[ 6 ] = 0.0;
	        out[ 7 ] = 0.0;
	        out[ 8 ] = 0.0;
	        out[ 9 ] = 0.0;
	        out[ 10 ] = 1.0;
	        out[ 11 ] = 0.0;
	        out[ 12 ] = 0.0;
	        out[ 13 ] = 0.0;
	        out[ 14 ] = 0.0;
	        out[ 15 ] = 1.0;
	        return out;
	    },
	
	    createAndSet: function ( x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15 ) {
	        var out = new ArrayType( 16 );
	        out[ 0 ] = x0;
	        out[ 1 ] = x1;
	        out[ 2 ] = x2;
	        out[ 3 ] = x3;
	        out[ 4 ] = x4;
	        out[ 5 ] = x5;
	        out[ 6 ] = x6;
	        out[ 7 ] = x7;
	        out[ 8 ] = x8;
	        out[ 9 ] = x9;
	        out[ 10 ] = x10;
	        out[ 11 ] = x11;
	        out[ 12 ] = x12;
	        out[ 13 ] = x13;
	        out[ 14 ] = x14;
	        out[ 15 ] = x15;
	        return out;
	    },
	
	    isIdentity: function ( matrix ) {
	        for ( var i = 0; i < 16; i++ ) {
	            if ( matrix[ i ] !== Matrix.identity[ i ] ) {
	                return false;
	            }
	        }
	        return true;
	    },
	    valid: function ( matrix ) {
	        for ( var i = 0; i < 16; i++ ) {
	            if ( osgMath.isNaN( matrix[ i ] ) ) {
	                return false;
	            }
	        }
	        return true;
	    },
	    setRow: function ( matrix, row, v0, v1, v2, v3 ) {
	        var rowIndex = row * 4;
	        matrix[ rowIndex + 0 ] = v0;
	        matrix[ rowIndex + 1 ] = v1;
	        matrix[ rowIndex + 2 ] = v2;
	        matrix[ rowIndex + 3 ] = v3;
	    },
	    innerProduct: function ( a, b, r, c ) {
	        var rIndex = r * 4;
	        return ( ( a[ rIndex + 0 ] * b[ 0 + c ] ) + ( a[ rIndex + 1 ] * b[ 4 + c ] ) + ( a[ rIndex + 2 ] * b[ 8 + c ] ) + ( a[ rIndex + 3 ] * b[ 12 + c ] ) );
	    },
	
	    set: function ( matrix, row, col, value ) {
	        matrix[ row * 4 + col ] = value;
	        return value;
	    },
	
	    get: function ( matrix, row, col ) {
	        return matrix[ row * 4 + col ];
	    },
	
	
	    // explaining comment
	    //Matrix.setRow( matrix, 0, 1.0, 0.0, 0.0, 0.0 );
	    //Matrix.setRow( matrix, 1, 0.0, 1.0, 0.0, 0.0 );
	    //Matrix.setRow( matrix, 2, 0.0, 0.0, 1.0, 0.0 );
	    //Matrix.setRow( matrix, 3, 0.0, 0.0, 0.0, 1.0 );
	    makeIdentity: function ( matrix ) {
	        Matrix.copy( Matrix.identity, matrix );
	        return matrix;
	    },
	
	    equal: function ( a, b ) {
	        return a[ 0 ] === b[ 0 ] && a[ 1 ] === b[ 1 ] && a[ 2 ] === b[ 2 ] && a[ 3 ] === b[ 3 ] &&
	            a[ 4 ] === b[ 4 ] && a[ 5 ] === b[ 5 ] && a[ 6 ] === b[ 6 ] && a[ 7 ] === b[ 7 ] &&
	            a[ 8 ] === b[ 8 ] && a[ 9 ] === b[ 9 ] && a[ 10 ] === b[ 10 ] && a[ 11 ] === b[ 11 ] &&
	            a[ 12 ] === b[ 12 ] && a[ 13 ] === b[ 13 ] && a[ 14 ] === b[ 14 ] && a[ 15 ] === b[ 15 ];
	    },
	
	    /**
	     * @param {Number} x position
	     * @param {Number} y position
	     * @param {Number} z position
	     * @param {Array} matrix to write result
	     */
	    makeTranslate: function ( x, y, z, matrix ) {
	        Matrix.setRow( matrix, 0, 1.0, 0.0, 0.0, 0.0 );
	        Matrix.setRow( matrix, 1, 0.0, 1.0, 0.0, 0.0 );
	        Matrix.setRow( matrix, 2, 0.0, 0.0, 1.0, 0.0 );
	        Matrix.setRow( matrix, 3, x, y, z, 1.0 );
	        return matrix;
	    },
	
	    setTrans: function ( matrix, x, y, z ) {
	        matrix[ 12 ] = x;
	        matrix[ 13 ] = y;
	        matrix[ 14 ] = z;
	        return matrix;
	    },
	
	    getTrans: function ( matrix, result ) {
	        result[ 0 ] = matrix[ 12 ];
	        result[ 1 ] = matrix[ 13 ];
	        result[ 2 ] = matrix[ 14 ];
	        return result;
	    },
	
	    // do a * b and result in a
	    preMult: function ( a, b ) {
	        var atmp0, atmp1, atmp2, atmp3;
	
	        atmp0 = ( b[ 0 ] * a[ 0 ] ) + ( b[ 1 ] * a[ 4 ] ) + ( b[ 2 ] * a[ 8 ] ) + ( b[ 3 ] * a[ 12 ] );
	        atmp1 = ( b[ 4 ] * a[ 0 ] ) + ( b[ 5 ] * a[ 4 ] ) + ( b[ 6 ] * a[ 8 ] ) + ( b[ 7 ] * a[ 12 ] );
	        atmp2 = ( b[ 8 ] * a[ 0 ] ) + ( b[ 9 ] * a[ 4 ] ) + ( b[ 10 ] * a[ 8 ] ) + ( b[ 11 ] * a[ 12 ] );
	        atmp3 = ( b[ 12 ] * a[ 0 ] ) + ( b[ 13 ] * a[ 4 ] ) + ( b[ 14 ] * a[ 8 ] ) + ( b[ 15 ] * a[ 12 ] );
	        a[ 0 ] = atmp0;
	        a[ 4 ] = atmp1;
	        a[ 8 ] = atmp2;
	        a[ 12 ] = atmp3;
	
	        atmp0 = ( b[ 0 ] * a[ 1 ] ) + ( b[ 1 ] * a[ 5 ] ) + ( b[ 2 ] * a[ 9 ] ) + ( b[ 3 ] * a[ 13 ] );
	        atmp1 = ( b[ 4 ] * a[ 1 ] ) + ( b[ 5 ] * a[ 5 ] ) + ( b[ 6 ] * a[ 9 ] ) + ( b[ 7 ] * a[ 13 ] );
	        atmp2 = ( b[ 8 ] * a[ 1 ] ) + ( b[ 9 ] * a[ 5 ] ) + ( b[ 10 ] * a[ 9 ] ) + ( b[ 11 ] * a[ 13 ] );
	        atmp3 = ( b[ 12 ] * a[ 1 ] ) + ( b[ 13 ] * a[ 5 ] ) + ( b[ 14 ] * a[ 9 ] ) + ( b[ 15 ] * a[ 13 ] );
	        a[ 1 ] = atmp0;
	        a[ 5 ] = atmp1;
	        a[ 9 ] = atmp2;
	        a[ 13 ] = atmp3;
	
	        atmp0 = ( b[ 0 ] * a[ 2 ] ) + ( b[ 1 ] * a[ 6 ] ) + ( b[ 2 ] * a[ 10 ] ) + ( b[ 3 ] * a[ 14 ] );
	        atmp1 = ( b[ 4 ] * a[ 2 ] ) + ( b[ 5 ] * a[ 6 ] ) + ( b[ 6 ] * a[ 10 ] ) + ( b[ 7 ] * a[ 14 ] );
	        atmp2 = ( b[ 8 ] * a[ 2 ] ) + ( b[ 9 ] * a[ 6 ] ) + ( b[ 10 ] * a[ 10 ] ) + ( b[ 11 ] * a[ 14 ] );
	        atmp3 = ( b[ 12 ] * a[ 2 ] ) + ( b[ 13 ] * a[ 6 ] ) + ( b[ 14 ] * a[ 10 ] ) + ( b[ 15 ] * a[ 14 ] );
	        a[ 2 ] = atmp0;
	        a[ 6 ] = atmp1;
	        a[ 10 ] = atmp2;
	        a[ 14 ] = atmp3;
	
	        atmp0 = ( b[ 0 ] * a[ 3 ] ) + ( b[ 1 ] * a[ 7 ] ) + ( b[ 2 ] * a[ 11 ] ) + ( b[ 3 ] * a[ 15 ] );
	        atmp1 = ( b[ 4 ] * a[ 3 ] ) + ( b[ 5 ] * a[ 7 ] ) + ( b[ 6 ] * a[ 11 ] ) + ( b[ 7 ] * a[ 15 ] );
	        atmp2 = ( b[ 8 ] * a[ 3 ] ) + ( b[ 9 ] * a[ 7 ] ) + ( b[ 10 ] * a[ 11 ] ) + ( b[ 11 ] * a[ 15 ] );
	        atmp3 = ( b[ 12 ] * a[ 3 ] ) + ( b[ 13 ] * a[ 7 ] ) + ( b[ 14 ] * a[ 11 ] ) + ( b[ 15 ] * a[ 15 ] );
	        a[ 3 ] = atmp0;
	        a[ 7 ] = atmp1;
	        a[ 11 ] = atmp2;
	        a[ 15 ] = atmp3;
	
	        return a;
	    },
	
	    // do a * b and store the result in b
	    // Be aware of the change w.r.t OSG as b holds the result!
	    postMult: function ( a, b ) {
	        var btmp0, btmp1, btmp2, btmp3;
	        // post mult
	        btmp0 = ( b[ 0 ] * a[ 0 ] ) + ( b[ 1 ] * a[ 4 ] ) + ( b[ 2 ] * a[ 8 ] ) + ( b[ 3 ] * a[ 12 ] );
	        btmp1 = ( b[ 0 ] * a[ 1 ] ) + ( b[ 1 ] * a[ 5 ] ) + ( b[ 2 ] * a[ 9 ] ) + ( b[ 3 ] * a[ 13 ] );
	        btmp2 = ( b[ 0 ] * a[ 2 ] ) + ( b[ 1 ] * a[ 6 ] ) + ( b[ 2 ] * a[ 10 ] ) + ( b[ 3 ] * a[ 14 ] );
	        btmp3 = ( b[ 0 ] * a[ 3 ] ) + ( b[ 1 ] * a[ 7 ] ) + ( b[ 2 ] * a[ 11 ] ) + ( b[ 3 ] * a[ 15 ] );
	        b[ 0 ] = btmp0;
	        b[ 1 ] = btmp1;
	        b[ 2 ] = btmp2;
	        b[ 3 ] = btmp3;
	
	        btmp0 = ( b[ 4 ] * a[ 0 ] ) + ( b[ 5 ] * a[ 4 ] ) + ( b[ 6 ] * a[ 8 ] ) + ( b[ 7 ] * a[ 12 ] );
	        btmp1 = ( b[ 4 ] * a[ 1 ] ) + ( b[ 5 ] * a[ 5 ] ) + ( b[ 6 ] * a[ 9 ] ) + ( b[ 7 ] * a[ 13 ] );
	        btmp2 = ( b[ 4 ] * a[ 2 ] ) + ( b[ 5 ] * a[ 6 ] ) + ( b[ 6 ] * a[ 10 ] ) + ( b[ 7 ] * a[ 14 ] );
	        btmp3 = ( b[ 4 ] * a[ 3 ] ) + ( b[ 5 ] * a[ 7 ] ) + ( b[ 6 ] * a[ 11 ] ) + ( b[ 7 ] * a[ 15 ] );
	        b[ 4 ] = btmp0;
	        b[ 5 ] = btmp1;
	        b[ 6 ] = btmp2;
	        b[ 7 ] = btmp3;
	
	        btmp0 = ( b[ 8 ] * a[ 0 ] ) + ( b[ 9 ] * a[ 4 ] ) + ( b[ 10 ] * a[ 8 ] ) + ( b[ 11 ] * a[ 12 ] );
	        btmp1 = ( b[ 8 ] * a[ 1 ] ) + ( b[ 9 ] * a[ 5 ] ) + ( b[ 10 ] * a[ 9 ] ) + ( b[ 11 ] * a[ 13 ] );
	        btmp2 = ( b[ 8 ] * a[ 2 ] ) + ( b[ 9 ] * a[ 6 ] ) + ( b[ 10 ] * a[ 10 ] ) + ( b[ 11 ] * a[ 14 ] );
	        btmp3 = ( b[ 8 ] * a[ 3 ] ) + ( b[ 9 ] * a[ 7 ] ) + ( b[ 10 ] * a[ 11 ] ) + ( b[ 11 ] * a[ 15 ] );
	        b[ 8 ] = btmp0;
	        b[ 9 ] = btmp1;
	        b[ 10 ] = btmp2;
	        b[ 11 ] = btmp3;
	
	        btmp0 = ( b[ 12 ] * a[ 0 ] ) + ( b[ 13 ] * a[ 4 ] ) + ( b[ 14 ] * a[ 8 ] ) + ( b[ 15 ] * a[ 12 ] );
	        btmp1 = ( b[ 12 ] * a[ 1 ] ) + ( b[ 13 ] * a[ 5 ] ) + ( b[ 14 ] * a[ 9 ] ) + ( b[ 15 ] * a[ 13 ] );
	        btmp2 = ( b[ 12 ] * a[ 2 ] ) + ( b[ 13 ] * a[ 6 ] ) + ( b[ 14 ] * a[ 10 ] ) + ( b[ 15 ] * a[ 14 ] );
	        btmp3 = ( b[ 12 ] * a[ 3 ] ) + ( b[ 13 ] * a[ 7 ] ) + ( b[ 14 ] * a[ 11 ] ) + ( b[ 15 ] * a[ 15 ] );
	        b[ 12 ] = btmp0;
	        b[ 13 ] = btmp1;
	        b[ 14 ] = btmp2;
	        b[ 15 ] = btmp3;
	
	        return b;
	    },
	
	    multa: function ( a, b, r ) {
	        if ( r === a ) {
	            return Matrix.preMult( a, b );
	        } else if ( r === b ) {
	            return Matrix.postMult( a, b );
	        } else {
	            r[ 0 ] = b[ 0 ] * a[ 0 ] + b[ 1 ] * a[ 4 ] + b[ 2 ] * a[ 8 ] + b[ 3 ] * a[ 12 ];
	            r[ 1 ] = b[ 0 ] * a[ 1 ] + b[ 1 ] * a[ 5 ] + b[ 2 ] * a[ 9 ] + b[ 3 ] * a[ 13 ];
	            r[ 2 ] = b[ 0 ] * a[ 2 ] + b[ 1 ] * a[ 6 ] + b[ 2 ] * a[ 10 ] + b[ 3 ] * a[ 14 ];
	            r[ 3 ] = b[ 0 ] * a[ 3 ] + b[ 1 ] * a[ 7 ] + b[ 2 ] * a[ 11 ] + b[ 3 ] * a[ 15 ];
	
	            r[ 4 ] = b[ 4 ] * a[ 0 ] + b[ 5 ] * a[ 4 ] + b[ 6 ] * a[ 8 ] + b[ 7 ] * a[ 12 ];
	            r[ 5 ] = b[ 4 ] * a[ 1 ] + b[ 5 ] * a[ 5 ] + b[ 6 ] * a[ 9 ] + b[ 7 ] * a[ 13 ];
	            r[ 6 ] = b[ 4 ] * a[ 2 ] + b[ 5 ] * a[ 6 ] + b[ 6 ] * a[ 10 ] + b[ 7 ] * a[ 14 ];
	            r[ 7 ] = b[ 4 ] * a[ 3 ] + b[ 5 ] * a[ 7 ] + b[ 6 ] * a[ 11 ] + b[ 7 ] * a[ 15 ];
	
	            r[ 8 ] = b[ 8 ] * a[ 0 ] + b[ 9 ] * a[ 4 ] + b[ 10 ] * a[ 8 ] + b[ 11 ] * a[ 12 ];
	            r[ 9 ] = b[ 8 ] * a[ 1 ] + b[ 9 ] * a[ 5 ] + b[ 10 ] * a[ 9 ] + b[ 11 ] * a[ 13 ];
	            r[ 10 ] = b[ 8 ] * a[ 2 ] + b[ 9 ] * a[ 6 ] + b[ 10 ] * a[ 10 ] + b[ 11 ] * a[ 14 ];
	            r[ 11 ] = b[ 8 ] * a[ 3 ] + b[ 9 ] * a[ 7 ] + b[ 10 ] * a[ 11 ] + b[ 11 ] * a[ 15 ];
	
	            r[ 12 ] = b[ 12 ] * a[ 0 ] + b[ 13 ] * a[ 4 ] + b[ 14 ] * a[ 8 ] + b[ 15 ] * a[ 12 ];
	            r[ 13 ] = b[ 12 ] * a[ 1 ] + b[ 13 ] * a[ 5 ] + b[ 14 ] * a[ 9 ] + b[ 15 ] * a[ 13 ];
	            r[ 14 ] = b[ 12 ] * a[ 2 ] + b[ 13 ] * a[ 6 ] + b[ 14 ] * a[ 10 ] + b[ 15 ] * a[ 14 ];
	            r[ 15 ] = b[ 12 ] * a[ 3 ] + b[ 13 ] * a[ 7 ] + b[ 14 ] * a[ 11 ] + b[ 15 ] * a[ 15 ];
	
	            return r;
	        }
	    },
	    /* r = a * b */
	    mult: function ( a, b, r ) {
	        var s00 = b[ 0 ];
	        var s01 = b[ 1 ];
	        var s02 = b[ 2 ];
	        var s03 = b[ 3 ];
	        var s10 = b[ 4 ];
	        var s11 = b[ 5 ];
	        var s12 = b[ 6 ];
	        var s13 = b[ 7 ];
	        var s20 = b[ 8 ];
	        var s21 = b[ 9 ];
	        var s22 = b[ 10 ];
	        var s23 = b[ 11 ];
	        var s30 = b[ 12 ];
	        var s31 = b[ 13 ];
	        var s32 = b[ 14 ];
	        var s33 = b[ 15 ];
	
	        var o00 = a[ 0 ];
	        var o01 = a[ 1 ];
	        var o02 = a[ 2 ];
	        var o03 = a[ 3 ];
	        var o10 = a[ 4 ];
	        var o11 = a[ 5 ];
	        var o12 = a[ 6 ];
	        var o13 = a[ 7 ];
	        var o20 = a[ 8 ];
	        var o21 = a[ 9 ];
	        var o22 = a[ 10 ];
	        var o23 = a[ 11 ];
	        var o30 = a[ 12 ];
	        var o31 = a[ 13 ];
	        var o32 = a[ 14 ];
	        var o33 = a[ 15 ];
	
	        r[ 0 ] = s00 * o00 + s01 * o10 + s02 * o20 + s03 * o30;
	        r[ 1 ] = s00 * o01 + s01 * o11 + s02 * o21 + s03 * o31;
	        r[ 2 ] = s00 * o02 + s01 * o12 + s02 * o22 + s03 * o32;
	        r[ 3 ] = s00 * o03 + s01 * o13 + s02 * o23 + s03 * o33;
	
	        r[ 4 ] = s10 * o00 + s11 * o10 + s12 * o20 + s13 * o30;
	        r[ 5 ] = s10 * o01 + s11 * o11 + s12 * o21 + s13 * o31;
	        r[ 6 ] = s10 * o02 + s11 * o12 + s12 * o22 + s13 * o32;
	        r[ 7 ] = s10 * o03 + s11 * o13 + s12 * o23 + s13 * o33;
	
	        r[ 8 ] = s20 * o00 + s21 * o10 + s22 * o20 + s23 * o30;
	        r[ 9 ] = s20 * o01 + s21 * o11 + s22 * o21 + s23 * o31;
	        r[ 10 ] = s20 * o02 + s21 * o12 + s22 * o22 + s23 * o32;
	        r[ 11 ] = s20 * o03 + s21 * o13 + s22 * o23 + s23 * o33;
	
	        r[ 12 ] = s30 * o00 + s31 * o10 + s32 * o20 + s33 * o30;
	        r[ 13 ] = s30 * o01 + s31 * o11 + s32 * o21 + s33 * o31;
	        r[ 14 ] = s30 * o02 + s31 * o12 + s32 * o22 + s33 * o32;
	        r[ 15 ] = s30 * o03 + s31 * o13 + s32 * o23 + s33 * o33;
	
	        return r;
	    },
	    multOrig: function ( a, b, r ) {
	        var inner1 = 0.0,
	            inner2 = 0.0,
	            inner3 = 0.0,
	            inner4 = 0.0;
	        if ( r === a ) {
	            // pre mult
	            for ( var col = 0; col < 4; col++ ) {
	                inner1 = Matrix.innerProduct( b, a, 0, col );
	                inner2 = Matrix.innerProduct( b, a, 1, col );
	                inner3 = Matrix.innerProduct( b, a, 2, col );
	                inner4 = Matrix.innerProduct( b, a, 3, col );
	                a[ 0 + col ] = inner1;
	                a[ 4 + col ] = inner2;
	                a[ 8 + col ] = inner3;
	                a[ 12 + col ] = inner4;
	            }
	            return a;
	            //return Matrix.preMult(r, b);
	        } else if ( r === b ) {
	            // post mult
	            for ( var row = 0; row < 4; row++ ) {
	                inner1 = Matrix.innerProduct( b, a, row, 0 );
	                inner2 = Matrix.innerProduct( b, a, row, 1 );
	                inner3 = Matrix.innerProduct( b, a, row, 2 );
	                inner4 = Matrix.innerProduct( b, a, row, 3 );
	                Matrix.setRow( b, row, inner1, inner2, inner3, inner4 );
	            }
	            return b;
	            //return Matrix.postMult(r, a);
	        }
	
	        var s00 = b[ 0 ];
	        var s01 = b[ 1 ];
	        var s02 = b[ 2 ];
	        var s03 = b[ 3 ];
	        var s10 = b[ 4 ];
	        var s11 = b[ 5 ];
	        var s12 = b[ 6 ];
	        var s13 = b[ 7 ];
	        var s20 = b[ 8 ];
	        var s21 = b[ 9 ];
	        var s22 = b[ 10 ];
	        var s23 = b[ 11 ];
	        var s30 = b[ 12 ];
	        var s31 = b[ 13 ];
	        var s32 = b[ 14 ];
	        var s33 = b[ 15 ];
	
	        var o00 = a[ 0 ];
	        var o01 = a[ 1 ];
	        var o02 = a[ 2 ];
	        var o03 = a[ 3 ];
	        var o10 = a[ 4 ];
	        var o11 = a[ 5 ];
	        var o12 = a[ 6 ];
	        var o13 = a[ 7 ];
	        var o20 = a[ 8 ];
	        var o21 = a[ 9 ];
	        var o22 = a[ 10 ];
	        var o23 = a[ 11 ];
	        var o30 = a[ 12 ];
	        var o31 = a[ 13 ];
	        var o32 = a[ 14 ];
	        var o33 = a[ 15 ];
	
	        r[ 0 ] = s00 * o00 + s01 * o10 + s02 * o20 + s03 * o30;
	        r[ 1 ] = s00 * o01 + s01 * o11 + s02 * o21 + s03 * o31;
	        r[ 2 ] = s00 * o02 + s01 * o12 + s02 * o22 + s03 * o32;
	        r[ 3 ] = s00 * o03 + s01 * o13 + s02 * o23 + s03 * o33;
	
	        r[ 4 ] = s10 * o00 + s11 * o10 + s12 * o20 + s13 * o30;
	        r[ 5 ] = s10 * o01 + s11 * o11 + s12 * o21 + s13 * o31;
	        r[ 6 ] = s10 * o02 + s11 * o12 + s12 * o22 + s13 * o32;
	        r[ 7 ] = s10 * o03 + s11 * o13 + s12 * o23 + s13 * o33;
	
	        r[ 8 ] = s20 * o00 + s21 * o10 + s22 * o20 + s23 * o30;
	        r[ 9 ] = s20 * o01 + s21 * o11 + s22 * o21 + s23 * o31;
	        r[ 10 ] = s20 * o02 + s21 * o12 + s22 * o22 + s23 * o32;
	        r[ 11 ] = s20 * o03 + s21 * o13 + s22 * o23 + s23 * o33;
	
	        r[ 12 ] = s30 * o00 + s31 * o10 + s32 * o20 + s33 * o30;
	        r[ 13 ] = s30 * o01 + s31 * o11 + s32 * o21 + s33 * o31;
	        r[ 14 ] = s30 * o02 + s31 * o12 + s32 * o22 + s33 * o32;
	        r[ 15 ] = s30 * o03 + s31 * o13 + s32 * o23 + s33 * o33;
	
	        return r;
	    },
	
	    makeLookFromDirection: ( function () {
	        var s = Vec3.create();
	        var u = Vec3.create();
	        var neg = Vec3.create();
	
	        return function ( eye, eyeDir, up, result ) {
	            var f = eyeDir;
	            Vec3.cross( f, up, s );
	            Vec3.normalize( s, s );
	
	            Vec3.cross( s, f, u );
	            Vec3.normalize( u, u );
	
	            // s[0], u[0], -f[0], 0.0,
	            // s[1], u[1], -f[1], 0.0,
	            // s[2], u[2], -f[2], 0.0,
	            // 0,    0,    0,     1.0
	
	            result[ 0 ] = s[ 0 ];
	            result[ 1 ] = u[ 0 ];
	            result[ 2 ] = -f[ 0 ];
	            result[ 3 ] = 0.0;
	            result[ 4 ] = s[ 1 ];
	            result[ 5 ] = u[ 1 ];
	            result[ 6 ] = -f[ 1 ];
	            result[ 7 ] = 0.0;
	            result[ 8 ] = s[ 2 ];
	            result[ 9 ] = u[ 2 ];
	            result[ 10 ] = -f[ 2 ];
	            result[ 11 ] = 0.0;
	            result[ 12 ] = 0;
	            result[ 13 ] = 0;
	            result[ 14 ] = 0;
	            result[ 15 ] = 1.0;
	
	            Matrix.multTranslate( result, Vec3.neg( eye, neg ), result );
	            return result;
	        };
	    } )(),
	    makeLookAt: ( function () {
	        var f = Vec3.create();
	
	        return function ( eye, center, up, result ) {
	            Vec3.sub( center, eye, f );
	            Vec3.normalize( f, f );
	            this.makeLookFromDirection( eye, f, up, result );
	            return result;
	        };
	    } )(),
	    makeOrtho: function ( left, right, bottom, top, zNear, zFar, result ) {
	        // note transpose of Matrix_implementation wr.t OpenGL documentation, since the OSG use post multiplication rather than pre.
	        // we will change this convention later
	        var tx = -( right + left ) / ( right - left );
	        var ty = -( top + bottom ) / ( top - bottom );
	        var tz = -( zFar + zNear ) / ( zFar - zNear );
	        var row = Matrix.setRow;
	        row( result, 0, 2.0 / ( right - left ), 0.0, 0.0, 0.0 );
	        row( result, 1, 0.0, 2.0 / ( top - bottom ), 0.0, 0.0 );
	        row( result, 2, 0.0, 0.0, -2.0 / ( zFar - zNear ), 0.0 );
	        row( result, 3, tx, ty, tz, 1.0 );
	        return result;
	    },
	
	    getLookAt: ( function () {
	        var inv = matrixCreate();
	        var v1 = Vec3.create();
	        var v2 = Vec3.createAndSet( 0.0, 1.0, 0.0 );
	        var v3 = Vec3.createAndSet( 0.0, 0.0, -1.0 );
	
	        return function ( matrix, eye, center, up, distance ) {
	            if ( distance === undefined ) {
	                distance = 1.0;
	            }
	            var result = Matrix.inverse( matrix, inv );
	            if ( !result ) {
	                Matrix.makeIdentity( inv );
	            }
	            Matrix.transformVec3( inv, v1, eye );
	            Matrix.transform3x3( matrix, v2, up );
	            Matrix.transform3x3( matrix, v3, center );
	            Vec3.normalize( center, center );
	            Vec3.add( Vec3.mult( center, distance, v1 ), eye, center );
	        };
	    } )(),
	
	    //getRotate_David_Spillings_Mk1
	    getRotate: ( function () {
	        var tq = Quat.create();
	
	        return function ( mat, quatResult ) {
	            var s;
	            var i, j;
	
	            // Use tq to store the largest trace
	            var mat00 = mat[ 4 * 0 + 0 ];
	            var mat11 = mat[ 4 * 1 + 1 ];
	            var mat22 = mat[ 4 * 2 + 2 ];
	            tq[ 0 ] = 1.0 + mat00 + mat11 + mat22;
	            tq[ 1 ] = 1.0 + mat00 - mat11 - mat22;
	            tq[ 2 ] = 1.0 - mat00 + mat11 - mat22;
	            tq[ 3 ] = 1.0 - mat00 - mat11 + mat22;
	
	            // Find the maximum (could also use stacked if's later)
	            j = 0;
	            for ( i = 1; i < 4; i++ ) {
	                if ( ( tq[ i ] > tq[ j ] ) ) {
	                    j = i;
	                }
	            }
	
	            // check the diagonal
	            if ( j === 0 ) {
	                /* perform instant calculation */
	                quatResult[ 3 ] = tq[ 0 ];
	                quatResult[ 0 ] = mat[ 1 * 4 + 2 ] - mat[ 2 * 4 + 1 ];
	                quatResult[ 1 ] = mat[ 2 * 4 + 0 ] - mat[ 0 + 2 ];
	                quatResult[ 2 ] = mat[ 0 + 1 ] - mat[ 1 * 4 + 0 ];
	            } else if ( j === 1 ) {
	                quatResult[ 3 ] = mat[ 1 * 4 + 2 ] - mat[ 2 * 4 + 1 ];
	                quatResult[ 0 ] = tq[ 1 ];
	                quatResult[ 1 ] = mat[ 0 + 1 ] + mat[ 1 * 4 + 0 ];
	                quatResult[ 2 ] = mat[ 2 * 4 + 0 ] + mat[ 0 + 2 ];
	            } else if ( j === 2 ) {
	                quatResult[ 3 ] = mat[ 2 * 4 + 0 ] - mat[ 0 + 2 ];
	                quatResult[ 0 ] = mat[ 0 + 1 ] + mat[ 1 * 4 + 0 ];
	                quatResult[ 1 ] = tq[ 2 ];
	                quatResult[ 2 ] = mat[ 1 * 4 + 2 ] + mat[ 2 * 4 + 1 ];
	            } else /* if (j==3) */ {
	                quatResult[ 3 ] = mat[ 0 + 1 ] - mat[ 1 * 4 + 0 ];
	                quatResult[ 0 ] = mat[ 2 * 4 + 0 ] + mat[ 0 + 2 ];
	                quatResult[ 1 ] = mat[ 1 * 4 + 2 ] + mat[ 2 * 4 + 1 ];
	                quatResult[ 2 ] = tq[ 3 ];
	            }
	
	            s = Math.sqrt( 0.25 / tq[ j ] );
	            quatResult[ 3 ] *= s;
	            quatResult[ 0 ] *= s;
	            quatResult[ 1 ] *= s;
	            quatResult[ 2 ] *= s;
	
	            return quatResult;
	        };
	    } )(),
	
	    // Matrix M = Matrix M * Matrix Translate
	    preMultTranslate: function ( mat, translate ) {
	        var val;
	        if ( translate[ 0 ] !== 0.0 ) {
	            val = translate[ 0 ];
	            mat[ 12 ] += val * mat[ 0 ];
	            mat[ 13 ] += val * mat[ 1 ];
	            mat[ 14 ] += val * mat[ 2 ];
	            mat[ 15 ] += val * mat[ 3 ];
	        }
	
	        if ( translate[ 1 ] !== 0.0 ) {
	            val = translate[ 1 ];
	            mat[ 12 ] += val * mat[ 4 ];
	            mat[ 13 ] += val * mat[ 5 ];
	            mat[ 14 ] += val * mat[ 6 ];
	            mat[ 15 ] += val * mat[ 7 ];
	        }
	
	        if ( translate[ 2 ] !== 0.0 ) {
	            val = translate[ 2 ];
	            mat[ 12 ] += val * mat[ 8 ];
	            mat[ 13 ] += val * mat[ 9 ];
	            mat[ 14 ] += val * mat[ 10 ];
	            mat[ 15 ] += val * mat[ 11 ];
	        }
	        return mat;
	    },
	
	    postMultTranslate: function ( mat, translate ) {
	        var val;
	        if ( translate[ 0 ] !== 0.0 ) {
	            val = translate[ 0 ];
	            mat[ 0 ] += val * mat[ 3 ];
	            mat[ 4 ] += val * mat[ 7 ];
	            mat[ 8 ] += val * mat[ 11 ];
	            mat[ 12 ] += val * mat[ 15 ];
	        }
	
	        if ( translate[ 1 ] !== 0.0 ) {
	            val = translate[ 1 ];
	            mat[ 1 ] += val * mat[ 3 ];
	            mat[ 5 ] += val * mat[ 7 ];
	            mat[ 9 ] += val * mat[ 11 ];
	            mat[ 13 ] += val * mat[ 15 ];
	        }
	
	        if ( translate[ 2 ] !== 0.0 ) {
	            val = translate[ 2 ];
	            mat[ 2 ] += val * mat[ 3 ];
	            mat[ 6 ] += val * mat[ 7 ];
	            mat[ 10 ] += val * mat[ 11 ];
	            mat[ 14 ] += val * mat[ 15 ];
	        }
	        return mat;
	    },
	
	    // result = Matrix M * Matrix Translate
	    multTranslate: function ( mat, translate, result ) {
	        if ( result !== mat ) {
	            Matrix.copy( mat, result );
	        }
	
	        var val;
	        if ( translate[ 0 ] !== 0.0 ) {
	            val = translate[ 0 ];
	            result[ 12 ] += val * mat[ 0 ];
	            result[ 13 ] += val * mat[ 1 ];
	            result[ 14 ] += val * mat[ 2 ];
	            result[ 15 ] += val * mat[ 3 ];
	        }
	
	        if ( translate[ 1 ] !== 0.0 ) {
	            val = translate[ 1 ];
	            result[ 12 ] += val * mat[ 4 ];
	            result[ 13 ] += val * mat[ 5 ];
	            result[ 14 ] += val * mat[ 6 ];
	            result[ 15 ] += val * mat[ 7 ];
	        }
	
	        if ( translate[ 2 ] !== 0.0 ) {
	            val = translate[ 2 ];
	            result[ 12 ] += val * mat[ 8 ];
	            result[ 13 ] += val * mat[ 9 ];
	            result[ 14 ] += val * mat[ 10 ];
	            result[ 15 ] += val * mat[ 11 ];
	        }
	        return result;
	    },
	
	    makeRotate: ( function () {
	        var qtemp = Quat.create();
	
	        return function ( angle, x, y, z, result ) {
	            return Matrix.makeRotateFromQuat( Quat.makeRotate( angle, x, y, z, qtemp ), result );
	        };
	    } )(),
	
	    preMultRotate: ( function () {
	        var r = matrixCreate();
	        return function ( matrix, quat ) {
	            Matrix.makeRotateFromQuat( quat, r );
	            Matrix.preMult( matrix, r );
	            return matrix;
	        };
	    } )(),
	
	    postMultRotate: ( function () {
	        var r = matrixCreate();
	        return function ( matrix, quat ) {
	            Matrix.makeRotateFromQuat( quat, r );
	            Matrix.postMult( r, matrix );
	            return matrix;
	        };
	    } )(),
	
	    transform3x3: function ( m, v, result ) {
	        result[ 0 ] = m[ 0 ] * v[ 0 ] + m[ 1 ] * v[ 1 ] + m[ 2 ] * v[ 2 ];
	        result[ 1 ] = m[ 4 ] * v[ 0 ] + m[ 5 ] * v[ 1 ] + m[ 6 ] * v[ 2 ];
	        result[ 2 ] = m[ 8 ] * v[ 0 ] + m[ 9 ] * v[ 1 ] + m[ 10 ] * v[ 2 ];
	        return result;
	    },
	
	    transformVec3: function ( matrix, vector, result ) {
	        var x = vector[ 0 ];
	        var y = vector[ 1 ];
	        var z = vector[ 2 ];
	
	        var d = 1.0 / ( matrix[ 3 ] * x + matrix[ 7 ] * y + matrix[ 11 ] * z + matrix[ 15 ] );
	
	        result[ 0 ] = ( matrix[ 0 ] * x + matrix[ 4 ] * y + matrix[ 8 ] * z + matrix[ 12 ] ) * d;
	        result[ 1 ] = ( matrix[ 1 ] * x + matrix[ 5 ] * y + matrix[ 9 ] * z + matrix[ 13 ] ) * d;
	        result[ 2 ] = ( matrix[ 2 ] * x + matrix[ 6 ] * y + matrix[ 10 ] * z + matrix[ 14 ] ) * d;
	
	        return result;
	    },
	
	    transformVec4: function ( matrix, vector, result ) {
	        var x = vector[ 0 ];
	        var y = vector[ 1 ];
	        var z = vector[ 2 ];
	        var w = vector[ 3 ];
	
	        result[ 0 ] = matrix[ 0 ] * x + matrix[ 4 ] * y + matrix[ 8 ] * z + matrix[ 12 ] * w;
	        result[ 1 ] = matrix[ 1 ] * x + matrix[ 5 ] * y + matrix[ 9 ] * z + matrix[ 13 ] * w;
	        result[ 2 ] = matrix[ 2 ] * x + matrix[ 6 ] * y + matrix[ 10 ] * z + matrix[ 14 ] * w;
	        result[ 3 ] = matrix[ 3 ] * x + matrix[ 7 ] * y + matrix[ 11 ] * z + matrix[ 15 ] * w;
	
	        return result;
	    },
	
	    // http://dev.theomader.com/transform-bounding-boxes/
	    // https://github.com/erich666/GraphicsGems/blob/master/gems/TransBox.c
	    transformBoundingBox: ( function () {
	        var tempBbox = new BoundingBox();
	        return function ( m, bbIn, bbOut ) {
	            if ( bbOut === bbIn ) {
	                bbOut = tempBbox;
	            }
	            var inMin = bbIn.getMin();
	            var inMax = bbIn.getMax();
	
	            /* Take care of translation by beginning at T. */
	            var outMin = Matrix.getTrans( m, bbOut.getMin() );
	            var outMax = Vec3.copy( outMin, bbOut.getMax() );
	
	            /* Now find the extreme points by considering the product of the */
	            /* min and max with each component of M.  */
	            for ( var i = 0; i < 3; ++i ) {
	                var i4 = i * 4;
	                var mini = inMin[ i ];
	                var maxi = inMax[ i ];
	                for ( var j = 0; j < 3; ++j ) {
	                    var cm = m[ i4 + j ];
	                    var a = cm * maxi;
	                    var b = cm * mini;
	                    if ( a < b ) {
	                        outMin[ j ] += a;
	                        outMax[ j ] += b;
	                    } else {
	                        outMin[ j ] += b;
	                        outMax[ j ] += a;
	                    }
	                }
	            }
	
	            if ( bbOut === tempBbox ) {
	                bbIn.copy( tempBbox );
	            }
	        };
	    } )(),
	
	    transformBoundingSphere: ( function () {
	        var scaleVec = Vec3.create();
	        return function ( matrix, bSphere, bsOut ) {
	            if ( !bSphere.valid() ) {
	                return bsOut;
	            }
	            Vec3.copy( bSphere._center, bsOut._center );
	            bsOut._radius = bSphere._radius;
	            var sphCenter = bsOut._center;
	            var sphRadius = bsOut._radius;
	
	            Matrix.getScale2( matrix, scaleVec );
	            var scale = Math.sqrt( Math.max( Math.max( scaleVec[ 0 ], scaleVec[ 1 ] ), scaleVec[ 2 ] ) );
	            sphRadius = sphRadius * scale;
	            bsOut._radius = sphRadius;
	            Matrix.transformVec3( matrix, sphCenter, sphCenter );
	
	            return bsOut;
	        };
	    } )(),
	
	    transformVec4PostMult: function ( matrix, vector, result ) {
	        var x = vector[ 0 ];
	        var y = vector[ 1 ];
	        var z = vector[ 2 ];
	        var w = vector[ 3 ];
	
	        result[ 0 ] = matrix[ 0 ] * x + matrix[ 1 ] * y + matrix[ 2 ] * z + matrix[ 3 ] * w;
	        result[ 1 ] = matrix[ 4 ] * x + matrix[ 5 ] * y + matrix[ 6 ] * z + matrix[ 7 ] * w;
	        result[ 2 ] = matrix[ 8 ] * x + matrix[ 9 ] * y + matrix[ 10 ] * z + matrix[ 11 ] * w;
	        result[ 3 ] = matrix[ 12 ] * x + matrix[ 13 ] * y + matrix[ 14 ] * z + matrix[ 15 ] * w;
	
	        return result;
	    },
	
	    copy: function ( matrix, result ) {
	        result[ 0 ] = matrix[ 0 ];
	        result[ 1 ] = matrix[ 1 ];
	        result[ 2 ] = matrix[ 2 ];
	        result[ 3 ] = matrix[ 3 ];
	        result[ 4 ] = matrix[ 4 ];
	        result[ 5 ] = matrix[ 5 ];
	        result[ 6 ] = matrix[ 6 ];
	        result[ 7 ] = matrix[ 7 ];
	        result[ 8 ] = matrix[ 8 ];
	        result[ 9 ] = matrix[ 9 ];
	        result[ 10 ] = matrix[ 10 ];
	        result[ 11 ] = matrix[ 11 ];
	        result[ 12 ] = matrix[ 12 ];
	        result[ 13 ] = matrix[ 13 ];
	        result[ 14 ] = matrix[ 14 ];
	        result[ 15 ] = matrix[ 15 ];
	        return result;
	    },
	
	    inverse: ( function () {
	        var tmp = matrixCreate();
	
	        return function ( matrix, result ) {
	            if ( result === matrix ) {
	                Matrix.copy( matrix, tmp );
	                matrix = tmp;
	            }
	
	            if ( matrix[ 3 ] === 0.0 && matrix[ 7 ] === 0.0 && matrix[ 11 ] === 0.0 && matrix[ 15 ] === 1.0 ) {
	                return Matrix.inverse4x3( matrix, result );
	            } else {
	                return Matrix.inverse4x4( matrix, result );
	            }
	        };
	    } )(),
	
	    /**
	     *  if a result argument is given the return of the function is true or false
	     *  depending if the matrix can be inverted, else if no result argument is given
	     *  the return is identity if the matrix can not be inverted and the matrix overthise
	     */
	    inverse4x4: function ( matrix, result ) {
	        var tmp0 = matrix[ 10 ] * matrix[ 15 ];
	        var tmp1 = matrix[ 14 ] * matrix[ 11 ];
	        var tmp2 = matrix[ 6 ] * matrix[ 15 ];
	        var tmp3 = matrix[ 14 ] * matrix[ 7 ];
	        var tmp4 = matrix[ 6 ] * matrix[ 11 ];
	        var tmp5 = matrix[ 10 ] * matrix[ 7 ];
	        var tmp6 = matrix[ 2 ] * matrix[ 15 ];
	        var tmp7 = matrix[ 14 ] * matrix[ 3 ];
	        var tmp8 = matrix[ 2 ] * matrix[ 11 ];
	        var tmp9 = matrix[ 10 ] * matrix[ 3 ];
	        var tmp10 = matrix[ 2 ] * matrix[ 7 ];
	        var tmp11 = matrix[ 6 ] * matrix[ 3 ];
	        var tmp12 = matrix[ 8 ] * matrix[ 13 ];
	        var tmp13 = matrix[ 12 ] * matrix[ 9 ];
	        var tmp14 = matrix[ 4 ] * matrix[ 13 ];
	        var tmp15 = matrix[ 12 ] * matrix[ 5 ];
	        var tmp16 = matrix[ 4 ] * matrix[ 9 ];
	        var tmp17 = matrix[ 8 ] * matrix[ 5 ];
	        var tmp18 = matrix[ 0 ] * matrix[ 13 ];
	        var tmp19 = matrix[ 12 ] * matrix[ 1 ];
	        var tmp20 = matrix[ 0 ] * matrix[ 9 ];
	        var tmp21 = matrix[ 8 ] * matrix[ 1 ];
	        var tmp22 = matrix[ 0 ] * matrix[ 5 ];
	        var tmp23 = matrix[ 4 ] * matrix[ 1 ];
	
	        var t0 = ( ( tmp0 * matrix[ 5 ] + tmp3 * matrix[ 9 ] + tmp4 * matrix[ 13 ] ) -
	            ( tmp1 * matrix[ 5 ] + tmp2 * matrix[ 9 ] + tmp5 * matrix[ 13 ] ) );
	        var t1 = ( ( tmp1 * matrix[ 1 ] + tmp6 * matrix[ 9 ] + tmp9 * matrix[ 13 ] ) -
	            ( tmp0 * matrix[ 1 ] + tmp7 * matrix[ 9 ] + tmp8 * matrix[ 13 ] ) );
	        var t2 = ( ( tmp2 * matrix[ 1 ] + tmp7 * matrix[ 5 ] + tmp10 * matrix[ 13 ] ) -
	            ( tmp3 * matrix[ 1 ] + tmp6 * matrix[ 5 ] + tmp11 * matrix[ 13 ] ) );
	        var t3 = ( ( tmp5 * matrix[ 1 ] + tmp8 * matrix[ 5 ] + tmp11 * matrix[ 9 ] ) -
	            ( tmp4 * matrix[ 1 ] + tmp9 * matrix[ 5 ] + tmp10 * matrix[ 9 ] ) );
	
	        var d1 = ( matrix[ 0 ] * t0 + matrix[ 4 ] * t1 + matrix[ 8 ] * t2 + matrix[ 12 ] * t3 );
	        if ( Math.abs( d1 ) < Number.EPSILON ) {
	            Notify.info( 'Warning can\'t inverse matrix ' + matrix, false, true );
	            return false;
	        }
	        var d = 1.0 / d1;
	
	        var out00 = d * t0;
	        var out01 = d * t1;
	        var out02 = d * t2;
	        var out03 = d * t3;
	
	        var out10 = d * ( ( tmp1 * matrix[ 4 ] + tmp2 * matrix[ 8 ] + tmp5 * matrix[ 12 ] ) -
	            ( tmp0 * matrix[ 4 ] + tmp3 * matrix[ 8 ] + tmp4 * matrix[ 12 ] ) );
	        var out11 = d * ( ( tmp0 * matrix[ 0 ] + tmp7 * matrix[ 8 ] + tmp8 * matrix[ 12 ] ) -
	            ( tmp1 * matrix[ 0 ] + tmp6 * matrix[ 8 ] + tmp9 * matrix[ 12 ] ) );
	        var out12 = d * ( ( tmp3 * matrix[ 0 ] + tmp6 * matrix[ 4 ] + tmp11 * matrix[ 12 ] ) -
	            ( tmp2 * matrix[ 0 ] + tmp7 * matrix[ 4 ] + tmp10 * matrix[ 12 ] ) );
	        var out13 = d * ( ( tmp4 * matrix[ 0 ] + tmp9 * matrix[ 4 ] + tmp10 * matrix[ 8 ] ) -
	            ( tmp5 * matrix[ 0 ] + tmp8 * matrix[ 4 ] + tmp11 * matrix[ 8 ] ) );
	
	        var out20 = d * ( ( tmp12 * matrix[ 7 ] + tmp15 * matrix[ 11 ] + tmp16 * matrix[ 15 ] ) -
	            ( tmp13 * matrix[ 7 ] + tmp14 * matrix[ 11 ] + tmp17 * matrix[ 15 ] ) );
	        var out21 = d * ( ( tmp13 * matrix[ 3 ] + tmp18 * matrix[ 11 ] + tmp21 * matrix[ 15 ] ) -
	            ( tmp12 * matrix[ 3 ] + tmp19 * matrix[ 11 ] + tmp20 * matrix[ 15 ] ) );
	        var out22 = d * ( ( tmp14 * matrix[ 3 ] + tmp19 * matrix[ 7 ] + tmp22 * matrix[ 15 ] ) -
	            ( tmp15 * matrix[ 3 ] + tmp18 * matrix[ 7 ] + tmp23 * matrix[ 15 ] ) );
	        var out23 = d * ( ( tmp17 * matrix[ 3 ] + tmp20 * matrix[ 7 ] + tmp23 * matrix[ 11 ] ) -
	            ( tmp16 * matrix[ 3 ] + tmp21 * matrix[ 7 ] + tmp22 * matrix[ 11 ] ) );
	
	        var out30 = d * ( ( tmp14 * matrix[ 10 ] + tmp17 * matrix[ 14 ] + tmp13 * matrix[ 6 ] ) -
	            ( tmp16 * matrix[ 14 ] + tmp12 * matrix[ 6 ] + tmp15 * matrix[ 10 ] ) );
	        var out31 = d * ( ( tmp20 * matrix[ 14 ] + tmp12 * matrix[ 2 ] + tmp19 * matrix[ 10 ] ) -
	            ( tmp18 * matrix[ 10 ] + tmp21 * matrix[ 14 ] + tmp13 * matrix[ 2 ] ) );
	        var out32 = d * ( ( tmp18 * matrix[ 6 ] + tmp23 * matrix[ 14 ] + tmp15 * matrix[ 2 ] ) -
	            ( tmp22 * matrix[ 14 ] + tmp14 * matrix[ 2 ] + tmp19 * matrix[ 6 ] ) );
	        var out33 = d * ( ( tmp22 * matrix[ 10 ] + tmp16 * matrix[ 2 ] + tmp21 * matrix[ 6 ] ) -
	            ( tmp20 * matrix[ 6 ] + tmp23 * matrix[ 10 ] + tmp17 * matrix[ 2 ] ) );
	
	        result[ 0 ] = out00;
	        result[ 1 ] = out01;
	        result[ 2 ] = out02;
	        result[ 3 ] = out03;
	        result[ 4 ] = out10;
	        result[ 5 ] = out11;
	        result[ 6 ] = out12;
	        result[ 7 ] = out13;
	        result[ 8 ] = out20;
	        result[ 9 ] = out21;
	        result[ 10 ] = out22;
	        result[ 11 ] = out23;
	        result[ 12 ] = out30;
	        result[ 13 ] = out31;
	        result[ 14 ] = out32;
	        result[ 15 ] = out33;
	
	        return true;
	    },
	
	    // comes from OpenSceneGraph
	    /*
	    Matrix inversion technique:
	    Given a matrix mat, we want to invert it.
	    mat = [ r00 r01 r02 a
	            r10 r11 r12 b
	            r20 r21 r22 c
	            tx  ty  tz  d ]
	    We note that this matrix can be split into three matrices.
	    mat = rot * trans * corr, where rot is rotation part, trans is translation part, and corr is the correction due to perspective (if any).
	    rot = [ r00 r01 r02 0
	            r10 r11 r12 0
	            r20 r21 r22 0
	            0   0   0   1 ]
	    trans = [ 1  0  0  0
	              0  1  0  0
	              0  0  1  0
	              tx ty tz 1 ]
	    corr = [ 1 0 0 px
	             0 1 0 py
	             0 0 1 pz
	             0 0 0 s ]
	
	    where the elements of corr are obtained from linear combinations of the elements of rot, trans, and mat.
	    So the inverse is mat' = (trans * corr)' * rot', where rot' must be computed the traditional way, which is easy since it is only a 3x3 matrix.
	    This problem is simplified if [px py pz s] = [0 0 0 1], which will happen if mat was composed only of rotations, scales, and translations (which is common).  In this case, we can ignore corr entirely which saves on a lot of computations.
	  */
	
	    inverse4x3: ( function () {
	        var inv = matrixCreate();
	
	        return function ( matrix, result ) {
	
	            // Copy rotation components
	            var r00 = matrix[ 0 ];
	            var r01 = matrix[ 1 ];
	            var r02 = matrix[ 2 ];
	
	            var r10 = matrix[ 4 ];
	            var r11 = matrix[ 5 ];
	            var r12 = matrix[ 6 ];
	
	            var r20 = matrix[ 8 ];
	            var r21 = matrix[ 9 ];
	            var r22 = matrix[ 10 ];
	
	            // Partially compute inverse of rot
	            result[ 0 ] = r11 * r22 - r12 * r21;
	            result[ 1 ] = r02 * r21 - r01 * r22;
	            result[ 2 ] = r01 * r12 - r02 * r11;
	
	            // Compute determinant of rot from 3 elements just computed
	            var det = ( r00 * result[ 0 ] + r10 * result[ 1 ] + r20 * result[ 2 ] );
	            if ( Math.abs( det ) < Number.EPSILON ) {
	                Notify.info( 'Warning can\'t inverse matrix ' + matrix, false, true );
	                return false;
	            }
	
	            var oneOverDet = 1.0 / det;
	            r00 *= oneOverDet;
	            r10 *= oneOverDet;
	            r20 *= oneOverDet; // Saves on later computations
	
	            // Finish computing inverse of rot
	            result[ 0 ] *= oneOverDet;
	            result[ 1 ] *= oneOverDet;
	            result[ 2 ] *= oneOverDet;
	            result[ 3 ] = 0.0;
	            result[ 4 ] = r12 * r20 - r10 * r22; // Have already been divided by det
	            result[ 5 ] = r00 * r22 - r02 * r20; // same
	            result[ 6 ] = r02 * r10 - r00 * r12; // same
	            result[ 7 ] = 0.0;
	            result[ 8 ] = r10 * r21 - r11 * r20; // Have already been divided by det
	            result[ 9 ] = r01 * r20 - r00 * r21; // same
	            result[ 10 ] = r00 * r11 - r01 * r10; // same
	            result[ 11 ] = 0.0;
	            result[ 15 ] = 1.0;
	
	            var tx, ty, tz;
	
	            var d = matrix[ 15 ];
	            var dm = d - 1.0;
	            if ( dm * dm > 1.0e-6 ) // Involves perspective, so we must
	            { // compute the full inverse
	
	                result[ 12 ] = result[ 13 ] = result[ 14 ] = 0.0;
	
	                var a = matrix[ 3 ];
	                var b = matrix[ 7 ];
	                var c = matrix[ 11 ];
	                var px = result[ 0 ] * a + result[ 1 ] * b + result[ 2 ] * c;
	                var py = result[ 4 ] * a + result[ 5 ] * b + result[ 6 ] * c;
	                var pz = result[ 8 ] * a + result[ 9 ] * b + result[ 10 ] * c;
	
	                tx = matrix[ 12 ];
	                ty = matrix[ 13 ];
	                tz = matrix[ 14 ];
	                det = ( d - ( tx * px + ty * py + tz * pz ) );
	                if ( Math.abs( det ) < Number.EPSILON ) {
	                    Notify.info( 'Warning can\'t inverse matrix ' + matrix );
	                    return false;
	                }
	                var oneOverS = 1.0 / det;
	
	                tx *= oneOverS;
	                ty *= oneOverS;
	                tz *= oneOverS; // Reduces number of calculations later on
	
	                // Compute inverse of trans*corr
	                inv[ 0 ] = tx * px + 1.0;
	                inv[ 1 ] = ty * px;
	                inv[ 2 ] = tz * px;
	                inv[ 3 ] = -px * oneOverS;
	                inv[ 4 ] = tx * py;
	                inv[ 5 ] = ty * py + 1.0;
	                inv[ 6 ] = tz * py;
	                inv[ 7 ] = -py * oneOverS;
	                inv[ 8 ] = tx * pz;
	                inv[ 9 ] = ty * pz;
	                inv[ 10 ] = tz * pz + 1.0;
	                inv[ 11 ] = -pz * oneOverS;
	                inv[ 12 ] = -tx;
	                inv[ 13 ] = -ty;
	                inv[ 14 ] = -tz;
	                inv[ 15 ] = oneOverS;
	
	                Matrix.preMult( result, inv ); // Finish computing full inverse of mat
	            } else {
	
	                tx = matrix[ 12 ];
	                ty = matrix[ 13 ];
	                tz = matrix[ 14 ];
	
	                // Compute translation components of mat'
	                result[ 12 ] = -( tx * result[ 0 ] + ty * result[ 4 ] + tz * result[ 8 ] );
	                result[ 13 ] = -( tx * result[ 1 ] + ty * result[ 5 ] + tz * result[ 9 ] );
	                result[ 14 ] = -( tx * result[ 2 ] + ty * result[ 6 ] + tz * result[ 10 ] );
	            }
	            return true;
	        };
	    } )(),
	
	    transpose: function ( mat, dest ) {
	        // from glMatrix
	        // If we are transposing ourselves we can skip a few steps but have to cache some values
	        if ( mat === dest ) {
	            var a01 = mat[ 1 ],
	                a02 = mat[ 2 ],
	                a03 = mat[ 3 ];
	            var a12 = mat[ 6 ],
	                a13 = mat[ 7 ];
	            var a23 = mat[ 11 ];
	
	            dest[ 1 ] = mat[ 4 ];
	            dest[ 2 ] = mat[ 8 ];
	            dest[ 3 ] = mat[ 12 ];
	            dest[ 4 ] = a01;
	            dest[ 6 ] = mat[ 9 ];
	            dest[ 7 ] = mat[ 13 ];
	            dest[ 8 ] = a02;
	            dest[ 9 ] = a12;
	            dest[ 11 ] = mat[ 14 ];
	            dest[ 12 ] = a03;
	            dest[ 13 ] = a13;
	            dest[ 14 ] = a23;
	        } else {
	            dest[ 0 ] = mat[ 0 ];
	            dest[ 1 ] = mat[ 4 ];
	            dest[ 2 ] = mat[ 8 ];
	            dest[ 3 ] = mat[ 12 ];
	            dest[ 4 ] = mat[ 1 ];
	            dest[ 5 ] = mat[ 5 ];
	            dest[ 6 ] = mat[ 9 ];
	            dest[ 7 ] = mat[ 13 ];
	            dest[ 8 ] = mat[ 2 ];
	            dest[ 9 ] = mat[ 6 ];
	            dest[ 10 ] = mat[ 10 ];
	            dest[ 11 ] = mat[ 14 ];
	            dest[ 12 ] = mat[ 3 ];
	            dest[ 13 ] = mat[ 7 ];
	            dest[ 14 ] = mat[ 11 ];
	            dest[ 15 ] = mat[ 15 ];
	        }
	        return dest;
	    },
	
	    getFrustumPlanes: ( function () {
	
	        var mvp = matrixCreate();
	
	        return function ( projection, view, result, withNearFar ) {
	            Matrix.mult( projection, view, mvp );
	
	            if ( withNearFar === undefined )
	                withNearFar = false;
	            // Right clipping plane.
	            var right = result[ 0 ];
	            right[ 0 ] = mvp[ 3 ] - mvp[ 0 ];
	            right[ 1 ] = mvp[ 7 ] - mvp[ 4 ];
	            right[ 2 ] = mvp[ 11 ] - mvp[ 8 ];
	            right[ 3 ] = mvp[ 15 ] - mvp[ 12 ];
	
	            // Left clipping plane.
	            var left = result[ 1 ];
	            left[ 0 ] = mvp[ 3 ] + mvp[ 0 ];
	            left[ 1 ] = mvp[ 7 ] + mvp[ 4 ];
	            left[ 2 ] = mvp[ 11 ] + mvp[ 8 ];
	            left[ 3 ] = mvp[ 15 ] + mvp[ 12 ];
	
	            // Bottom clipping plane.
	            var bottom = result[ 2 ];
	            bottom[ 0 ] = mvp[ 3 ] + mvp[ 1 ];
	            bottom[ 1 ] = mvp[ 7 ] + mvp[ 5 ];
	            bottom[ 2 ] = mvp[ 11 ] + mvp[ 9 ];
	            bottom[ 3 ] = mvp[ 15 ] + mvp[ 13 ];
	
	            // Top clipping plane.
	            var top = result[ 3 ];
	            top[ 0 ] = mvp[ 3 ] - mvp[ 1 ];
	            top[ 1 ] = mvp[ 7 ] - mvp[ 5 ];
	            top[ 2 ] = mvp[ 11 ] - mvp[ 9 ];
	            top[ 3 ] = mvp[ 15 ] - mvp[ 13 ];
	
	            if ( withNearFar ) {
	                // Far clipping plane.
	                var far = result[ 4 ];
	                far[ 0 ] = mvp[ 3 ] - mvp[ 2 ];
	                far[ 1 ] = mvp[ 7 ] - mvp[ 6 ];
	                far[ 2 ] = mvp[ 11 ] - mvp[ 10 ];
	                far[ 3 ] = mvp[ 15 ] - mvp[ 14 ];
	
	                // Near clipping plane.
	                var near = result[ 5 ];
	                near[ 0 ] = mvp[ 3 ] + mvp[ 2 ];
	                near[ 1 ] = mvp[ 7 ] + mvp[ 6 ];
	                near[ 2 ] = mvp[ 11 ] + mvp[ 10 ];
	                near[ 3 ] = mvp[ 15 ] + mvp[ 14 ];
	            }
	
	            //Normalize the planes
	            var j = withNearFar ? 6 : 4;
	            for ( var i = 0; i < j; i++ ) {
	                Plane.normalizeEquation( result[ i ] );
	            }
	
	        };
	    } )(),
	
	    makePerspective: function ( fovy, aspect, znear, zfar, result ) {
	        var ymax = znear * Math.tan( fovy * Math.PI / 360.0 );
	        var ymin = -ymax;
	        var xmin = ymin * aspect;
	        var xmax = ymax * aspect;
	
	        return Matrix.makeFrustum( xmin, xmax, ymin, ymax, znear, zfar, result );
	    },
	
	    getFrustum: function ( matrix, result ) {
	        var right = 0.0;
	        var left = 0.0;
	        var top = 0.0;
	        var bottom = 0.0;
	        var zNear, zFar;
	
	        if ( matrix[ 0 * 4 + 3 ] !== 0.0 || matrix[ 1 * 4 + 3 ] !== 0.0 || matrix[ 2 * 4 + 3 ] !== -1.0 || matrix[ 3 * 4 + 3 ] !== 0.0 ) {
	            return false;
	        }
	
	        // note: near and far must be used inside this method instead of zNear and zFar
	        // because zNear and zFar are references and they may point to the same variable.
	        var tempNear = matrix[ 3 * 4 + 2 ] / ( matrix[ 2 * 4 + 2 ] - 1.0 );
	        var tempFar = matrix[ 3 * 4 + 2 ] / ( 1.0 + matrix[ 2 * 4 + 2 ] );
	
	        left = tempNear * ( matrix[ 2 * 4 ] - 1.0 ) / matrix[ 0 ];
	        right = tempNear * ( 1.0 + matrix[ 2 * 4 ] ) / matrix[ 0 ];
	
	        top = tempNear * ( 1.0 + matrix[ 2 * 4 + 1 ] ) / matrix[ 1 * 4 + 1 ];
	        bottom = tempNear * ( matrix[ 2 * 4 + 1 ] - 1.0 ) / matrix[ 1 * 4 + 1 ];
	
	        zNear = tempNear;
	        zFar = tempFar;
	
	        result.left = left;
	        result.right = right;
	        result.top = top;
	        result.bottom = bottom;
	        result.zNear = zNear;
	        result.zFar = zFar;
	
	        return true;
	    },
	
	    getPerspective: ( function () {
	        var c = {
	            'right': 0,
	            'left': 0,
	            'top': 0,
	            'bottom': 0,
	            'zNear': 0,
	            'zFar': 0
	        };
	        return function ( matrix, result ) {
	            // get frustum and compute results
	            var r = Matrix.getFrustum( matrix, c );
	            if ( r ) {
	                result.fovy = 180 / Math.PI * ( Math.atan( c.top / c.zNear ) - Math.atan( c.bottom / c.zNear ) );
	                result.aspectRatio = ( c.right - c.left ) / ( c.top - c.bottom );
	            }
	            result.zNear = c.zNear;
	            result.zFar = c.zFar;
	            return result;
	        };
	    } )(),
	
	    preMultScale: function ( m, scale ) {
	
	        var x = scale[ 0 ];
	        var y = scale[ 1 ];
	        var z = scale[ 2 ];
	
	        m[ 0 ] *= x;
	        m[ 4 ] *= y;
	        m[ 8 ] *= z;
	
	        m[ 1 ] *= x;
	        m[ 5 ] *= y;
	        m[ 9 ] *= z;
	
	        m[ 2 ] *= x;
	        m[ 6 ] *= y;
	        m[ 10 ] *= z;
	
	        m[ 3 ] *= x;
	        m[ 7 ] *= y;
	        m[ 11 ] *= z;
	
	        return m;
	
	    },
	
	    postMultScale: function ( m, scale ) {
	
	        var x = scale[ 0 ];
	        var y = scale[ 1 ];
	        var z = scale[ 2 ];
	
	        m[ 0 ] *= x;
	        m[ 1 ] *= y;
	        m[ 2 ] *= z;
	
	        m[ 4 ] *= x;
	        m[ 5 ] *= y;
	        m[ 6 ] *= z;
	
	        m[ 8 ] *= x;
	        m[ 9 ] *= y;
	        m[ 10 ] *= z;
	
	        m[ 12 ] *= x;
	        m[ 13 ] *= y;
	        m[ 14 ] *= z;
	
	        return m;
	    },
	
	    makeScale: function ( x, y, z, result ) {
	        Matrix.setRow( result, 0, x, 0.0, 0.0, 0.0 );
	        Matrix.setRow( result, 1, 0.0, y, 0.0, 0.0 );
	        Matrix.setRow( result, 2, 0.0, 0.0, z, 0.0 );
	        Matrix.setRow( result, 3, 0.0, 0.0, 0.0, 1.0 );
	        return result;
	    },
	
	    getScale: ( function () {
	        var sx = Vec3.create();
	        var sy = Vec3.create();
	        var sz = Vec3.create();
	        return function ( matrix, result ) {
	            sx[ 0 ] = matrix[ 0 ];
	            sx[ 1 ] = matrix[ 4 ];
	            sx[ 2 ] = matrix[ 8 ];
	            sy[ 0 ] = matrix[ 1 ];
	            sy[ 1 ] = matrix[ 5 ];
	            sy[ 2 ] = matrix[ 9 ];
	            sz[ 0 ] = matrix[ 2 ];
	            sz[ 1 ] = matrix[ 6 ];
	            sz[ 2 ] = matrix[ 10 ];
	
	            result[ 0 ] = Vec3.length( sx );
	            result[ 1 ] = Vec3.length( sy );
	            result[ 2 ] = Vec3.length( sz );
	            return result;
	        };
	    } )(),
	
	    getScale2: ( function () {
	        var sx = Vec3.create();
	        var sy = Vec3.create();
	        var sz = Vec3.create();
	        return function ( matrix, result ) {
	            sx[ 0 ] = matrix[ 0 ];
	            sx[ 1 ] = matrix[ 4 ];
	            sx[ 2 ] = matrix[ 8 ];
	            sy[ 0 ] = matrix[ 1 ];
	            sy[ 1 ] = matrix[ 5 ];
	            sy[ 2 ] = matrix[ 9 ];
	            sz[ 0 ] = matrix[ 2 ];
	            sz[ 1 ] = matrix[ 6 ];
	            sz[ 2 ] = matrix[ 10 ];
	
	            result[ 0 ] = Vec3.length2( sx );
	            result[ 1 ] = Vec3.length2( sy );
	            result[ 2 ] = Vec3.length2( sz );
	            return result;
	        };
	    } )(),
	
	    clampProjectionMatrix: function ( projection, znear, zfar, nearFarRatio, resultNearFar ) {
	        var epsilon = 1e-6;
	        if ( zfar < znear - epsilon ) {
	            Notify.log( 'clampProjectionMatrix not applied, invalid depth range, znear = ' + znear + '  zfar = ' + zfar, false, true );
	            return false;
	        }
	
	        var desiredZnear, desiredZfar;
	        if ( zfar < znear + epsilon ) {
	            // znear and zfar are too close together and could cause divide by zero problems
	            // late on in the clamping code, so move the znear and zfar apart.
	            var average = ( znear + zfar ) * 0.5;
	            znear = average - epsilon;
	            zfar = average + epsilon;
	            // OSG_INFO << '_clampProjectionMatrix widening znear and zfar to '<<znear<<' '<<zfar<<std::endl;
	        }
	
	        if ( Math.abs( projection[ 3 ] ) < epsilon &&
	            Math.abs( projection[ 7 ] ) < epsilon &&
	            Math.abs( projection[ 11 ] ) < epsilon ) {
	            // OSG_INFO << 'Orthographic matrix before clamping'<<projection<<std::endl;
	
	            var deltaSpan = ( zfar - znear ) * 0.02;
	            if ( deltaSpan < 1.0 ) {
	                deltaSpan = 1.0;
	            }
	            desiredZnear = znear - deltaSpan;
	            desiredZfar = zfar + deltaSpan;
	
	            // assign the clamped values back to the computed values.
	            znear = desiredZnear;
	            zfar = desiredZfar;
	
	            projection[ 10 ] = -2.0 / ( desiredZfar - desiredZnear );
	            projection[ 14 ] = -( desiredZfar + desiredZnear ) / ( desiredZfar - desiredZnear );
	
	            // OSG_INFO << 'Orthographic matrix after clamping '<<projection<<std::endl;
	        } else {
	
	            // OSG_INFO << 'Persepective matrix before clamping'<<projection<<std::endl;
	            //std::cout << '_computed_znear'<<_computed_znear<<std::endl;
	            //std::cout << '_computed_zfar'<<_computed_zfar<<std::endl;
	
	            var zfarPushRatio = 1.02;
	            var znearPullRatio = 0.98;
	
	            //znearPullRatio = 0.99;
	
	            desiredZnear = znear * znearPullRatio;
	            desiredZfar = zfar * zfarPushRatio;
	
	            // near plane clamping.
	            var minNearPlane = zfar * nearFarRatio;
	            if ( desiredZnear < minNearPlane ) {
	                desiredZnear = minNearPlane;
	            }
	
	            // assign the clamped values back to the computed values.
	            znear = desiredZnear;
	            zfar = desiredZfar;
	
	            var m22 = projection[ 10 ];
	            var m32 = projection[ 14 ];
	            var m23 = projection[ 11 ];
	            var m33 = projection[ 15 ];
	            var transNearPlane = ( -desiredZnear * m22 + m32 ) / ( -desiredZnear * m23 + m33 );
	            var transFarPlane = ( -desiredZfar * m22 + m32 ) / ( -desiredZfar * m23 + m33 );
	
	            var ratio = Math.abs( 2.0 / ( transNearPlane - transFarPlane ) );
	            var center = -( transNearPlane + transFarPlane ) / 2.0;
	
	            var centerRatio = center * ratio;
	            projection[ 2 ] = projection[ 2 ] * ratio + projection[ 3 ] * centerRatio;
	            projection[ 6 ] = projection[ 6 ] * ratio + projection[ 7 ] * centerRatio;
	            projection[ 10 ] = m22 * ratio + m23 * centerRatio;
	            projection[ 14 ] = m32 * ratio + m33 * centerRatio;
	            // same as
	            // var matrix = [ 1.0, 0.0, 0.0, 0.0,
	            //     0.0, 1.0, 0.0, 0.0,
	            //     0.0, 0.0, ratio, 0.0,
	            //     0.0, 0.0, center * ratio, 1.0
	            // ];
	            // Matrix.postMult( matrix, projection );
	
	            // OSG_INFO << 'Persepective matrix after clamping'<<projection<<std::endl;
	        }
	        if ( resultNearFar !== undefined ) {
	            resultNearFar[ 0 ] = znear;
	            resultNearFar[ 1 ] = zfar;
	        }
	        return true;
	    },
	
	    // compute the 4 corners vector of the frustum
	    computeFrustumCornersVectors: function ( projectionMatrix, vectorsArray ) {
	        //var znear = projectionMatrix[ 12 + 2 ] / ( projectionMatrix[ 8 + 2 ] - 1.0 );
	        //var zfar = projectionMatrix[ 12 + 2 ] / ( projectionMatrix[ 8 + 2 ] + 1.0 );
	        var x = 1.0 / projectionMatrix[ 0 ];
	        var y = 1.0 / projectionMatrix[ 1 * 4 + 1 ];
	
	        vectorsArray[ 0 ] = Vec3.createAndSet( -x, y, 1.0 );
	        vectorsArray[ 1 ] = Vec3.createAndSet( -x, -y, 1.0 );
	        vectorsArray[ 2 ] = Vec3.createAndSet( x, -y, 1.0 );
	        vectorsArray[ 3 ] = Vec3.createAndSet( x, y, 1.0 );
	        return vectorsArray;
	    },
	
	    // better precison
	    // no far clipping artifacts.
	    // no reason not to use.
	    // Tightening the Precision of Perspective Rendering
	    //http://www.geometry.caltech.edu/pubs/UD12.pdf
	    // drop-in, just remove the one below, and rename this one
	    makeFrustumInfinite: function ( left, right, bottom, top, znear, zfar, result ) {
	        var X = 2.0 * znear / ( right - left );
	        var Y = 2.0 * znear / ( top - bottom );
	        var A = ( right + left ) / ( right - left );
	        var B = ( top + bottom ) / ( top - bottom );
	        var C = -1.0;
	        Matrix.setRow( result, 0, X, 0.0, 0.0, 0.0 );
	        Matrix.setRow( result, 1, 0.0, Y, 0.0, 0.0 );
	        Matrix.setRow( result, 2, A, B, C, -1.0 );
	        Matrix.setRow( result, 3, 0.0, 0.0, -2.0 * znear, 0.0 );
	        return result;
	    },
	
	    makeFrustum: function ( left, right, bottom, top, znear, zfar, result ) {
	        var X = 2.0 * znear / ( right - left );
	        var Y = 2.0 * znear / ( top - bottom );
	        var A = ( right + left ) / ( right - left );
	        var B = ( top + bottom ) / ( top - bottom );
	        var C = -( zfar + znear ) / ( zfar - znear );
	        var D = -2.0 * zfar * znear / ( zfar - znear );
	        Matrix.setRow( result, 0, X, 0.0, 0.0, 0.0 );
	        Matrix.setRow( result, 1, 0.0, Y, 0.0, 0.0 );
	        Matrix.setRow( result, 2, A, B, C, -1.0 );
	        Matrix.setRow( result, 3, 0.0, 0.0, D, 0.0 );
	        return result;
	    },
	
	    makeRotateFromQuat: function ( quat, result ) {
	        Matrix.makeIdentity( result );
	        return Matrix.setRotateFromQuat( result, quat );
	    },
	
	    setRotateFromQuat: function ( matrix, quat ) {
	        var length2 = Quat.length2( quat );
	        if ( Mabs( length2 ) <= NMIN_VALUE ) {
	            matrix[ 0 ] = 0.0;
	            matrix[ 1 ] = 0.0;
	            matrix[ 2 ] = 0.0;
	
	            matrix[ 4 ] = 0.0;
	            matrix[ 5 ] = 0.0;
	            matrix[ 6 ] = 0.0;
	
	            matrix[ 8 ] = 0.0;
	            matrix[ 9 ] = 0.0;
	            matrix[ 10 ] = 0.0;
	        } else {
	            var rlength2;
	            // normalize quat if required.
	            // We can avoid the expensive sqrt in this case since all 'coefficients' below are products of two q components.
	            // That is a square of a square root, so it is possible to avoid that
	            if ( length2 !== 1.0 ) {
	                rlength2 = 2.0 / length2;
	            } else {
	                rlength2 = 2.0;
	            }
	
	            // Source: Gamasutra, Rotating Objects Using Quaternions
	            //
	            //http://www.gamasutra.com/features/19980703/quaternions_01.htm
	
	            var wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;
	
	            // calculate coefficients
	            x2 = rlength2 * quat[ 0 ];
	            y2 = rlength2 * quat[ 1 ];
	            z2 = rlength2 * quat[ 2 ];
	
	            xx = quat[ 0 ] * x2;
	            xy = quat[ 0 ] * y2;
	            xz = quat[ 0 ] * z2;
	
	            yy = quat[ 1 ] * y2;
	            yz = quat[ 1 ] * z2;
	            zz = quat[ 2 ] * z2;
	
	            wx = quat[ 3 ] * x2;
	            wy = quat[ 3 ] * y2;
	            wz = quat[ 3 ] * z2;
	
	            // Note.  Gamasutra gets the matrix assignments inverted, resulting
	            // in left-handed rotations, which is contrary to OpenGL and OSG's
	            // methodology.  The matrix assignment has been altered in the next
	            // few lines of code to do the right thing.
	            // Don Burns - Oct 13, 2001
	            matrix[ 0 ] = 1.0 - ( yy + zz );
	            matrix[ 4 ] = xy - wz;
	            matrix[ 8 ] = xz + wy;
	
	
	            matrix[ 0 + 1 ] = xy + wz;
	            matrix[ 4 + 1 ] = 1.0 - ( xx + zz );
	            matrix[ 8 + 1 ] = yz - wx;
	
	            matrix[ 0 + 2 ] = xz - wy;
	            matrix[ 4 + 2 ] = yz + wx;
	            matrix[ 8 + 2 ] = 1.0 - ( xx + yy );
	        }
	        return matrix;
	    }
	};
	
	Matrix.identity = Matrix.create();
	
	module.exports = Matrix;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Matrix = __webpack_require__( 23 );
	var MACROUTILS = __webpack_require__( 6 );
	var Vec4 = __webpack_require__( 25 );
	var Vec3 = __webpack_require__( 15 );
	
	
	/** @class Plane Operations */
	var Plane = MACROUTILS.objectInherit( Vec4, {
	    // Many case (frustum, convexity)
	    // needs to know where from a plane it stands,
	    // not just boolean intersection
	    INSIDE: 1,
	    INTERSECT: 2,
	    OUTSIDE: 3,
	    /* Transform the plane */
	    transformProvidingInverse: function () {
	        var iplane = Plane.create();
	        return function ( plane, matrix ) {
	            Matrix.transformVec4PostMult( matrix, plane, iplane );
	            Plane.normalizeEquation( iplane );
	            Plane.copy( iplane, plane );
	            return plane;
	        };
	    },
	
	    normalizeEquation: function ( plane ) {
	        // multiply the coefficients of the plane equation with a constant factor so that the equation a^2+b^2+c^2 = 1 holds.
	        var inv = 1.0 / Math.sqrt( plane[ 0 ] * plane[ 0 ] + plane[ 1 ] * plane[ 1 ] + plane[ 2 ] * plane[ 2 ] );
	        plane[ 0 ] *= inv;
	        plane[ 1 ] *= inv;
	        plane[ 2 ] *= inv;
	        plane[ 3 ] *= inv;
	    },
	    /*only the normal Component*/
	    getNormal: function ( plane, result ) {
	        result[ 0 ] = plane[ 0 ];
	        result[ 1 ] = plane[ 1 ];
	        result[ 2 ] = plane[ 2 ];
	        return result;
	    },
	    setNormal: function ( plane, normal ) {
	        plane[ 0 ] = normal[ 0 ];
	        plane[ 1 ] = normal[ 1 ];
	        plane[ 2 ] = normal[ 2 ];
	    },
	    /* only the distance getter*/
	    getDistance: function ( plane ) {
	        return plane[ 3 ];
	    },
	    setDistance: function ( plane, distance ) {
	        plane[ 3 ] = distance;
	    },
	
	    /* using the plane equation, compute distance to plane of a point*/
	    distanceToPlane: function ( plane, position ) {
	        return plane[ 0 ] * position[ 0 ] + plane[ 1 ] * position[ 1 ] + plane[ 2 ] * position[ 2 ] + plane[ 3 ];
	    },
	
	
	    intersectsOrContainsBoundingSphere: function ( plane, bSphere ) {
	        if ( !bSphere.valid() ) return Plane.OUTSIDE;
	        var position = bSphere.center();
	        var radius = bSphere.radius();
	        var d = this.distanceToPlane( plane, position );
	        if ( d < -radius ) {
	            return Plane.OUTSIDE;
	        } else if ( d <= radius ) {
	            return Plane.INTERSECT;
	        }
	        return Plane.INSIDE;
	    },
	
	    instersectsBoundingSphere: function ( plane, bSphere ) {
	        return this.intersectsOrContainsBoundingSphere( plane, bSphere ) === Plane.INTERSECT;
	    },
	
	    // absPlane optional paramter is an optimisation for the
	    // DOD case: on plane, many bounding boxes
	    intersectsOrContainsBoundingBox: function () {
	        var center = Vec3.create();
	        var extent = Vec3.create();
	        var absTemp = Vec3.create();
	        return function ( plane, bbox, absPlane ) {
	            Vec3.add( bbox.getMax(), bbox.getMin(), center );
	            Vec3.mult( center, 0.5, center );
	
	            Vec3.sub( bbox.getMax(), bbox.getMin(), center );
	            Vec3.mult( extent, 0.5, extent );
	
	            var d = Vec3.dot( center, plane );
	            if ( !absPlane ) {
	                absPlane = absTemp;
	                absPlane[ 0 ] = Math.abs( plane[ 0 ] );
	                absPlane[ 1 ] = Math.abs( plane[ 1 ] );
	                absPlane[ 2 ] = Math.abs( plane[ 2 ] );
	            }
	            var r = Vec3.dot( extent, absPlane );
	            if ( d + r > 0 ) return Plane.INTERSECT; // partially inside
	            if ( d - r >= 0 ) return Plane.INSIDE; // fully inside
	            return Plane.OUTSIDE;
	        };
	    },
	
	    intersectsBoundingBox: function ( plane, bbox, absPlane ) {
	        return this.intersectsOrContainsBoundingBox( plane, bbox, absPlane ) === Plane.INTERSECT;
	    },
	
	    intersectOrContainsVertices: function ( plane, vertices ) {
	        var side = -1;
	        // all points must be on one side only
	        for ( var i = 0; i < vertices.length; i++ ) {
	            var d = this.distanceToPlane( plane, vertices[ i ] );
	            if ( d < 0.0 ) {
	                if ( side === 1 ) return Plane.INTERSECT;
	                side = 2;
	            } else if ( d > 0.0 ) {
	                if ( side === 2 ) return Plane.INTERSECT;
	                side = 1;
	            } else { //if ( d === 0.0 )
	                return Plane.INTERSECT;
	            }
	        }
	        return ( side > 0 ) ? Plane.INSIDE : Plane.OUTSIDE;
	
	    },
	    intersectVertices: function ( plane, vertices ) {
	        return this.intersectOrContainsVertices( plane, vertices ) === Plane.INTERSECT;
	    }
	
	
	} );
	
	module.exports = Plane;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var config = __webpack_require__( 17 );
	
	var ArrayType = config.ArrayType;
	
	/** @class Vec4 Operations */
	var Vec4 = {
	
	    create: function () {
	        var out = new ArrayType( 4 );
	        out[ 0 ] = 0.0;
	        out[ 1 ] = 0.0;
	        out[ 2 ] = 0.0;
	        out[ 3 ] = 0.0;
	        return out;
	    },
	
	    createAndSet: function ( x, y, z, w ) {
	        var out = new ArrayType( 4 );
	        out[ 0 ] = x;
	        out[ 1 ] = y;
	        out[ 2 ] = z;
	        out[ 3 ] = w;
	        return out;
	    },
	
	    init: function ( a ) {
	        a[ 0 ] = 0.0;
	        a[ 1 ] = 0.0;
	        a[ 2 ] = 0.0;
	        a[ 3 ] = 0.0;
	        return a;
	    },
	
	    set: function ( a, b, c, d, r ) {
	        r[ 0 ] = a;
	        r[ 1 ] = b;
	        r[ 2 ] = c;
	        r[ 3 ] = d;
	        return r;
	    },
	
	    dot: function ( a, b ) {
	        return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ] + a[ 3 ] * b[ 3 ];
	    },
	
	    copy: function ( a, r ) {
	        r[ 0 ] = a[ 0 ];
	        r[ 1 ] = a[ 1 ];
	        r[ 2 ] = a[ 2 ];
	        r[ 3 ] = a[ 3 ];
	        return r;
	    },
	
	    sub: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] - b[ 0 ];
	        r[ 1 ] = a[ 1 ] - b[ 1 ];
	        r[ 2 ] = a[ 2 ] - b[ 2 ];
	        r[ 3 ] = a[ 3 ] - b[ 3 ];
	        return r;
	    },
	
	    mult: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] * b;
	        r[ 1 ] = a[ 1 ] * b;
	        r[ 2 ] = a[ 2 ] * b;
	        r[ 3 ] = a[ 3 ] * b;
	        return r;
	    },
	
	    add: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] + b[ 0 ];
	        r[ 1 ] = a[ 1 ] + b[ 1 ];
	        r[ 2 ] = a[ 2 ] + b[ 2 ];
	        r[ 3 ] = a[ 3 ] + b[ 3 ];
	        return r;
	    },
	
	    neg: function ( a, r ) {
	        r[ 0 ] = -a[ 0 ];
	        r[ 1 ] = -a[ 1 ];
	        r[ 2 ] = -a[ 2 ];
	        r[ 3 ] = -a[ 3 ];
	        return r;
	    },
	
	    lerp: function ( t, a, b, r ) {
	        var tmp = 1.0 - t;
	        r[ 0 ] = a[ 0 ] * tmp + t * b[ 0 ];
	        r[ 1 ] = a[ 1 ] * tmp + t * b[ 1 ];
	        r[ 2 ] = a[ 2 ] * tmp + t * b[ 2 ];
	        r[ 3 ] = a[ 3 ] * tmp + t * b[ 3 ];
	        return r;
	    }
	};
	
	module.exports = Vec4;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var Vec4 = __webpack_require__( 25 );
	var config = __webpack_require__( 17 );
	
	var ArrayType = config.ArrayType;
	
	
	var Msqrt = Math.sqrt;
	var Mcos = Math.cos;
	var Msin = Math.sin;
	
	var Quat = {
	
	    create: function () {
	        var out = new ArrayType( 4 );
	        out[ 0 ] = 0.0;
	        out[ 1 ] = 0.0;
	        out[ 2 ] = 0.0;
	        out[ 3 ] = 1.0;
	        return out;
	    },
	
	    createAndSet: Vec4.createAndSet,
	
	    makeIdentity: function ( element ) {
	        return Quat.init( element );
	    },
	
	    init: function ( element ) {
	        element[ 0 ] = 0.0;
	        element[ 1 ] = 0.0;
	        element[ 2 ] = 0.0;
	        element[ 3 ] = 1.0;
	        return element;
	    },
	
	    // reuse Vec4 methods
	    copy: Vec4.copy,
	    set: Vec4.set,
	    sub: Vec4.sub,
	    add: Vec4.add,
	    dot: Vec4.dot,
	    neg: Vec4.neg,
	    lerp: Vec4.lerp,
	
	    length2: function ( a ) {
	        return a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] + a[ 3 ] * a[ 3 ];
	    },
	
	    zeroRotation: function ( q ) {
	        return q[ 0 ] === 0.0 && q[ 1 ] === 0.0 && q[ 2 ] === 0.0 && q[ 3 ] === 1.0;
	    },
	
	    length: function ( a ) {
	        return Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] + a[ 3 ] * a[ 3 ] );
	    },
	
	    makeRotate: function ( angle, x, y, z, result ) {
	        var epsilon = 0.0000001;
	        var length = Msqrt( x * x + y * y + z * z );
	        if ( length < epsilon ) {
	            return this.init( result );
	        }
	
	        var inversenorm = 1.0 / length;
	        var coshalfangle = Mcos( 0.5 * angle );
	        var sinhalfangle = Msin( 0.5 * angle );
	
	        result[ 0 ] = x * sinhalfangle * inversenorm;
	        result[ 1 ] = y * sinhalfangle * inversenorm;
	        result[ 2 ] = z * sinhalfangle * inversenorm;
	        result[ 3 ] = coshalfangle;
	        return result;
	    },
	
	    // http://physicsforgames.blogspot.fr/2010/02/quaternions.html
	    // called quatBlend
	    //
	    // NLERP is supposed to be
	    // - Commutative,
	    // - NOT Constant velocity
	    // - Torque minimal
	    //
	    // a and be must be normalized
	    // (otherwise they're not rotation...)
	    // t must be between 0 and 1
	    nlerp: function ( t, a, b, r ) {
	        var dot = this.dot( a, b );
	        var at = 1.0 - t;
	
	        // shortest path
	        if ( dot < 0.0 ) {
	
	            // negates directly b in the 4 equation
	            // this.neg( b, r );
	            r[ 0 ] = a[ 0 ] * at - b[ 0 ] * t;
	            r[ 1 ] = a[ 1 ] * at - b[ 1 ] * t;
	            r[ 2 ] = a[ 2 ] * at - b[ 2 ] * t;
	            r[ 3 ] = a[ 3 ] * at - b[ 3 ] * t;
	
	        } else {
	            r[ 0 ] = a[ 0 ] * at + b[ 0 ] * t;
	            r[ 1 ] = a[ 1 ] * at + b[ 1 ] * t;
	            r[ 2 ] = a[ 2 ] * at + b[ 2 ] * t;
	            r[ 3 ] = a[ 3 ] * at + b[ 3 ] * t;
	        }
	
	        return this.normalize( r, r );
	    },
	
	    //
	    // MUST READ on SLERP, NLERP, LOG-LERP
	    // http://number-none.com/product/Understanding%20Slerp,%20Then%20Not%20Using%20It/
	    // with a slerp implementation (robust)
	    //
	    // MUST READ Howto enhance lerp, slerp and q normalize
	    // http://number-none.com/product/Hacking%20Quaternions/
	    //
	    // MUST READ The book:
	    // Essential Mathematics for Games and Interactive Applications page
	    // ( from 10.6.1 Linear Interpolation to 10.6.3 Performance Improvements )
	    //
	    //  SLERP is:
	    // - NOT commutative
	    // - constant velocity
	    // - torque minimal
	    //
	    // so not to be used when blending multiple non ordered rotations
	    // (as in multiple animation)
	    //
	    slerp: ( function () {
	
	        var epsilon = 0.00001;
	        // a and be must be normalized
	        // (otherwise they're not rotation...)
	        // t must be between 0 and 1
	        return function ( t, a, b, r ) {
	
	            var cos = this.dot( a, b );
	            var invTB = 1.0;
	
	            // shortest path
	            if ( cos < 0.0 ) {
	                invTB = -1.0;
	                cos = -cos;
	            }
	
	            var ta, tb;
	            if ( cos > 1.0 - epsilon ) {
	                // negligible rotation: optimize by just a lerp
	                // a line rather than a rotation.
	                ta = 1.0 - t;
	                tb = t;
	
	            } else {
	
	                var sin = Math.sqrt( 1.0 - cos * cos );
	
	                // which one is better ?
	
	                // Atan2:
	                //  sin != 0 && cos !f= 0
	                //  Atan2 returns the angle between -œÄ and œÄ radians (equivalent to -180 and 180 degrees)
	                var angle = Math.atan2( sin, cos );
	                // Acos:
	                // need clamp(-1,1) on input Cos to avoid NaN but we make it lerp anyway
	                // acos returns the angle between 0 and œÄ radians (equivalent to 0 and 180 degrees)
	                //var angle = Math.acos( cos ); / / 0 <= omega <= Pi( see man acos )
	
	                var oneOverSin = 1.0 / sin;
	                ta = Math.sin( ( 1.0 - t ) * angle ) * oneOverSin;
	                tb = Math.sin( t * angle ) * oneOverSin;
	            }
	
	            tb *= invTB;
	
	            r[ 0 ] = a[ 0 ] * ta + b[ 0 ] * tb;
	            r[ 1 ] = a[ 1 ] * ta + b[ 1 ] * tb;
	            r[ 2 ] = a[ 2 ] * ta + b[ 2 ] * tb;
	            r[ 3 ] = a[ 3 ] * ta + b[ 3 ] * tb;
	            return r;
	        };
	
	    } )(),
	
	    transformVec3: function ( q, a, result ) {
	        var x = a[ 0 ];
	        var y = a[ 1 ];
	        var z = a[ 2 ];
	        var qx = q[ 0 ];
	        var qy = q[ 1 ];
	        var qz = q[ 2 ];
	        var qw = q[ 3 ];
	        // calculate quat * vec
	        var ix = qw * x + qy * z - qz * y;
	        var iy = qw * y + qz * x - qx * z;
	        var iz = qw * z + qx * y - qy * x;
	        var iw = -qx * x - qy * y - qz * z;
	
	        // calculate result * inverse quat
	        result[ 0 ] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        result[ 1 ] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        result[ 2 ] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	        return result;
	    },
	
	    normalize: function ( q, qr ) {
	        var div = 1.0 / this.length( q );
	        qr[ 0 ] = q[ 0 ] * div;
	        qr[ 1 ] = q[ 1 ] * div;
	        qr[ 2 ] = q[ 2 ] * div;
	        qr[ 3 ] = q[ 3 ] * div;
	        return qr;
	    },
	
	    // conjugate
	    // we suppose to have unit quaternion
	    conj: function ( a, result ) {
	        result[ 0 ] = -a[ 0 ];
	        result[ 1 ] = -a[ 1 ];
	        result[ 2 ] = -a[ 2 ];
	        result[ 3 ] = a[ 3 ];
	        return result;
	    },
	
	    // only if you don't have unit quaternion
	    // otherwise use conjugate
	    inverse: function ( a, result ) {
	        var div = 1.0 / this.length2( a );
	        this.conj( a, result );
	        result[ 0 ] *= div;
	        result[ 1 ] *= div;
	        result[ 2 ] *= div;
	        result[ 3 ] *= div;
	        return result;
	    },
	
	    // we suppose to have unit quaternion
	    // multiply 2 quaternions
	    mult: function ( a, b, result ) {
	        var ax = a[ 0 ];
	        var ay = a[ 1 ];
	        var az = a[ 2 ];
	        var aw = a[ 3 ];
	
	        var bx = b[ 0 ];
	        var by = b[ 1 ];
	        var bz = b[ 2 ];
	        var bw = b[ 3 ];
	
	        result[ 0 ] = ax * bw + ay * bz - az * by + aw * bx;
	        result[ 1 ] = -ax * bz + ay * bw + az * bx + aw * by;
	        result[ 2 ] = ax * by - ay * bx + az * bw + aw * bz;
	        result[ 3 ] = -ax * bx - ay * by - az * bz + aw * bw;
	        return result;
	    },
	
	    div: function ( a, b, result ) {
	        var d = 1.0 / b;
	        result[ 0 ] = a[ 0 ] * d;
	        result[ 1 ] = a[ 1 ] * d;
	        result[ 2 ] = a[ 2 ] * d;
	        result[ 3 ] = a[ 3 ] * d;
	        return result;
	    },
	
	    exp: function ( a, res ) {
	        var r = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
	        var et = Math.exp( a[ 3 ] );
	        var s = 0;
	        if ( r > 0.00001 ) {
	            s = et * Math.sin( r ) / r;
	        }
	
	        res[ 0 ] = s * a[ 0 ];
	        res[ 1 ] = s * a[ 1 ];
	        res[ 2 ] = s * a[ 2 ];
	        res[ 3 ] = et * Math.cos( r );
	        return res;
	    },
	
	    ln: function ( a, res ) {
	        var n = a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ];
	        var r = Math.sqrt( n );
	        var t = 0;
	        if ( r > 0.00001 ) {
	            t = Math.atan2( r, a[ 3 ] ) / r;
	        }
	
	        n += a[ 3 ] * a[ 3 ];
	        res[ 0 ] = t * a[ 0 ];
	        res[ 1 ] = t * a[ 1 ];
	        res[ 2 ] = t * a[ 2 ];
	        res[ 3 ] = 0.5 * Math.log( n );
	        return res;
	    },
	
	
	    //http://theory.org/software/qfa/writeup/node12.html
	    //http://www.ece.uwaterloo.ca/~dwharder/C++/CQOST/src/
	    //http://willperone.net/Code/quaternion.php
	
	    // a is computeTangent(q1-1,q1,q2)
	    // b is computeTangent(q2-1,q2,q2+1)
	    squad: function ( t, q1, a, b, q2, r ) {
	        var r1 = this.slerp( t, q1, q2 );
	        var r2 = this.slerp( t, a, b );
	        return this.slerp( 2.0 * t * ( 1.0 - t ), r1, r2, r );
	    },
	
	    // qcur is current
	    // q0 is qcur-1
	    // q2 is qcur+1
	    // compute tangent in of q1
	    computeTangent: function ( q0, qcur, q2, r ) {
	
	        // first step
	        var invq = this.inv( qcur );
	        var qa = this.create();
	        var qb = this.create();
	
	        this.mult( q2, invq, qa );
	        this.ln( qa, qa );
	
	        this.mult( q0, invq, qb );
	        this.ln( qb, qb );
	
	        this.add( qa, qb, qa );
	        this.div( qa, -4.0, qa );
	        this.exp( qa, qb );
	        return this.mult( qb, qcur, r );
	    },
	
	    makeRotateFromTo: function ( from, to, out ) {
	        // Now let's get into the real stuff
	        // Use "dot product plus one" as test as it can be re-used later on
	        var dotProdPlus1 = 1.0 + Vec3.dot( from, to );
	
	        // Check for degenerate case of full u-turn. Use epsilon for detection
	        if ( dotProdPlus1 < 1e-7 ) {
	
	            // Get an orthogonal vector of the given vector
	            // in a plane with maximum vector coordinates.
	            // Then use it as quaternion axis with pi angle
	            // Trick is to realize one value at least is >0.6 for a normalized vector.
	            var x = from[ 0 ];
	            var y = from[ 1 ];
	            var z = from[ 2 ];
	            var norm;
	            if ( Math.abs( x ) < 0.6 ) {
	                norm = Math.sqrt( 1.0 - x * x );
	                out[ 1 ] = z / norm;
	                out[ 2 ] = -y / norm;
	                out[ 0 ] = out[ 3 ] = 0.0;
	            } else if ( Math.abs( y ) < 0.6 ) {
	                norm = Math.sqrt( 1.0 - y * y );
	                out[ 0 ] = -z / norm;
	                out[ 2 ] = x / norm;
	                out[ 1 ] = out[ 3 ] = 0.0;
	            } else {
	                norm = Math.sqrt( 1.0 - z * z );
	                out[ 0 ] = y / norm;
	                out[ 1 ] = -x / norm;
	                out[ 2 ] = out[ 3 ] = 0.0;
	            }
	        } else {
	            // Find the shortest angle quaternion that transforms normalized vectors
	            // into one other. Formula is still valid when vectors are colinear
	
	            var s = Math.sqrt( 0.5 * dotProdPlus1 );
	            Vec3.cross( from, to, out );
	            var f = 0.5 / s;
	            out[ 0 ] *= f;
	            out[ 1 ] *= f;
	            out[ 2 ] *= f;
	            out[ 3 ] = s;
	        }
	        return out;
	    }
	};
	
	Quat.identity = Quat.create();
	
	module.exports = Quat;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Matrix = __webpack_require__( 23 );
	
	
	/**
	 *  Prevents Memory fragmentation, GC heavy usage
	 *    using pre-allocated memory segment
	 *    allowing reuse of memory
	 *  @class MatrixMemoryPool
	 */
	var MatrixMemoryPool = function () {
	
	    this._stack = [ Matrix.create() ];
	    this._current = 0;
	
	};
	
	
	/** @lends MatrixMemoryPool.prototype */
	MatrixMemoryPool.prototype = {
	
	    // start reuse the stack
	    reset: function () {
	
	        // ensure next stack.get gives
	        // same result as a Matrix.create()
	        // (ensure no side effect)
	        // Beware: _stack start at 1 !
	        for ( var i = 0, l = this._current; i <= l; i++ ) {
	            Matrix.makeIdentity( this._stack[ i ] );
	        }
	        this._current = 0;
	
	    },
	
	    get: function () {
	
	        var m = this._stack[ this._current++ ];
	
	        if ( this._current === this._stack.length ) {
	
	            this._stack.push( Matrix.create() );
	
	        }
	
	        return m;
	
	    }
	
	};
	
	module.exports = MatrixMemoryPool;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Matrix = __webpack_require__( 23 );
	var TransformEnums = __webpack_require__( 29 );
	
	
	// TODO: GC PERF: add a result Matrix Parameter.
	var computeLocalToWorld = function ( nodePath, ignoreCameras, userMatrix ) {
	
	    var ignoreCamera = ignoreCameras;
	
	    if ( ignoreCamera === undefined ) ignoreCamera = true;
	
	    var matrix = userMatrix || Matrix.create();
	
	    var j = 0;
	
	    if ( ignoreCamera ) {
	
	        for ( j = nodePath.length - 1; j >= 0; j-- ) {
	
	            var camera = nodePath[ j ];
	
	            if ( camera.className() === 'Camera' &&
	                ( camera.getReferenceFrame() !== TransformEnums.RELATIVE_RF || camera.getParents().length === 0 ) ) {
	                break;
	            }
	
	        }
	
	        // because when we break it's to an index - 1
	        // it works because if nothing camera found j == -1 at the end of the loop
	        // and if we found a camera we want to start at the camera index + 1
	        j += 1;
	
	    }
	
	    for ( var i = j, l = nodePath.length; i < l; i++ ) {
	
	        var node = nodePath[ i ];
	
	        if ( node.computeLocalToWorldMatrix ) {
	            node.computeLocalToWorldMatrix( matrix );
	        }
	
	    }
	
	    return matrix;
	
	};
	
	module.exports = {
	    computeLocalToWorld: computeLocalToWorld
	};


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	'use strict';
	module.exports = {
	    RELATIVE_RF: 0,
	    ABSOLUTE_RF: 1
	};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BoundingBox = __webpack_require__( 14 );
	var Geometry = __webpack_require__( 31 );
	var Matrix = __webpack_require__( 23 );
	var MatrixMemoryPool = __webpack_require__( 27 );
	var Transform = __webpack_require__( 11 );
	var NodeVisitor = __webpack_require__( 22 );
	var MACROUTILS = __webpack_require__( 6 );
	
	
	var ComputeBoundsVisitor = function ( traversalMode ) {
	    NodeVisitor.call( this, traversalMode );
	
	    // keep a matrix in memory to avoid to create matrix
	    this._reservedMatrixStack = new MatrixMemoryPool();
	
	    // Matrix stack along path traversal
	    this._matrixStack = [];
	    this._bb = new BoundingBox();
	};
	
	ComputeBoundsVisitor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( NodeVisitor.prototype, {
	
	    reset: function () {
	        this._reservedMatrixStack.reset();
	        this._matrixStack.length = 0;
	        this._bb.init();
	    },
	
	    getBoundingBox: function () {
	        return this._bb;
	    },
	
	    // not implemented
	    //void getPolytope(osg::Polytope& polytope, float margin=0.1) const;
	    //void getBase(osg::Polytope& polytope, float margin=0.1) const;
	
	    //applyDrawable: function ( drawable ) {},
	
	    applyTransform: function ( transform ) {
	
	        var matrix = this._reservedMatrixStack.get();
	        var stackLength = this._matrixStack.length;
	
	        if ( stackLength )
	            Matrix.copy( this._matrixStack[ stackLength - 1 ], matrix );
	
	        transform.computeLocalToWorldMatrix( matrix, this );
	
	        this.pushMatrix( matrix );
	
	        this.traverse( transform );
	
	        this.popMatrix();
	    },
	
	    apply: function ( node ) {
	
	        if ( node instanceof Transform ) {
	            this.applyTransform( node );
	            return;
	
	        } else if ( node instanceof Geometry ) {
	            this.applyBoundingBox( node.getBoundingBox() );
	            return;
	        }
	
	        this.traverse( node );
	
	    },
	
	    pushMatrix: function ( matrix ) {
	        this._matrixStack.push( matrix );
	    },
	
	    popMatrix: function () {
	        this._matrixStack.pop();
	    },
	
	
	    applyBoundingBox: ( function () {
	        var bbOut = new BoundingBox();
	
	        return function ( bbox ) {
	
	            var stackLength = this._matrixStack.length;
	
	            if ( !stackLength )
	                this._bb.expandByBoundingBox( bbox );
	            else if ( bbox.valid() ) {
	                var matrix = this._matrixStack[ stackLength - 1 ];
	                Matrix.transformBoundingBox( matrix, bbox, bbOut );
	                this._bb.expandByBoundingBox( bbOut );
	            }
	
	        };
	    } )(),
	
	    getMatrixStack: function () {
	        return this._matrixStack;
	    }
	
	
	} ), 'osg', 'ComputeBoundsVisitor' );
	
	module.exports = ComputeBoundsVisitor;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Node = __webpack_require__( 12 );
	var Notify = __webpack_require__( 10 );
	var WebGLCaps = __webpack_require__( 32 );
	var DrawElements = __webpack_require__( 43 );
	var BufferArrayProxy = __webpack_require__( 53 );
	
	/**
	 * Geometry manage array and primitives to draw a geometry.
	 * @class Geometry
	 */
	
	var Geometry = function () {
	
	    Node.call( this );
	
	    // Use proxy to detect change in vertex attributes
	    // you should use setVertexAttribute but if you dont
	    if ( window.Proxy ) {
	
	        var self = this;
	
	        this._attributes = {};
	        this._primitives = [];
	        this.attributes = new Proxy( this._attributes, {
	            set: function ( obj, prop, value ) {
	                var old = obj[ prop ];
	                if ( old !== value ) {
	                    obj[ prop ] = value;
	                    self.dirty();
	                }
	                return true;
	            }
	        } );
	
	        var push = function () {
	            this.push.apply( this, arguments );
	            self.dirty();
	
	        }.bind( this._primitives );
	
	        var pop = function () {
	            this.pop();
	            self.dirty();
	
	        }.bind( this._primitives );
	
	        this.primitives = new Proxy( this._primitives, {
	            get: function ( obj, key ) {
	                if ( key === 'push' ) return push;
	                if ( key === 'pop' ) return pop;
	                return obj[ key ];
	            }
	        } );
	
	    } else {
	
	        this.attributes = {};
	        this.primitives = [];
	        this._primitives = this.primitives;
	        this._attributes = this.attributes;
	
	    }
	
	    // function is generated for each Shader Program ID
	    // which generates a a special "draw"
	    // TODO: could be upon hash of combination of attributes
	    // (as multiple shader Programs can use same combination of attributes)
	    this._cacheDrawCall = {};
	
	    // VAO cached data, per combination of vertex buffer
	    // program id also the cache key
	    this._extVAO = undefined;
	    this._vao = {};
	    this._cacheVertexAttributeBufferList = {};
	
	    // null means the kdTree builder will skip the kdTree creation
	    this._shape = undefined;
	
	};
	
	/**
	 * enableVAO flag
	 * We rely on Proxy to detect changes in vertextes attributes list or in primitives
	 * list. If you dont have Proxy and you still want to use the VAO code path, replace
	 * OSG.osg.Geometry.enableVAO = true at the begining of your application, but be sure to
	 * not change vertexes attributes without calling dirty after.
	 */
	Geometry.enableVAO = Boolean( window.Proxy );
	if ( Geometry.enableVAO ) Notify.log( 'enable VAO' );
	
	
	/** @lends Geometry.prototype */
	Geometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {
	
	    releaseGLObjects: function () {
	
	        if ( this.stateset !== undefined ) this.stateset.releaseGLObjects();
	
	        var keys = window.Object.keys( this._attributes );
	        var value;
	        var i, l;
	
	        for ( i = 0, l = keys.length; i < l; i++ ) {
	            value = this._attributes[ keys[ i ] ];
	            value.releaseGLObjects();
	        }
	
	        for ( var j = 0, h = this._primitives.length; j < h; j++ ) {
	            var prim = this._primitives[ j ];
	            if ( prim.getIndices !== undefined ) {
	                if ( prim.getIndices() !== undefined && prim.getIndices() !== null ) {
	                    prim.indices.releaseGLObjects();
	                }
	            }
	        }
	
	        this.releaseVAO();
	
	    },
	
	    releaseVAO: function () {
	
	        if ( !this._extVAO ) return;
	
	        var keys = window.Object.keys( this._vao );
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	            var prgID = keys[ i ];
	            if ( this._vao[ prgID ] ) {
	                var vao = this._vao[ prgID ];
	                this._extVAO.deleteVertexArrayOES( vao );
	                this._vao[ prgID ] = undefined;
	            }
	        }
	    },
	
	    dirty: function () {
	        this._cacheDrawCall = {};
	        this.releaseVAO();
	    },
	
	    getPrimitives: function () {
	        // Notify.warn( 'deprecated use instead getPrimitiveSetList' );
	        return this.getPrimitiveSetList();
	    },
	
	    getAttributes: function () {
	        // Notify.warn( 'deprecated use instead getVertexAttributeList' );
	        return this.getVertexAttributeList();
	    },
	
	    getShape: function () {
	        return this._shape;
	    },
	
	    setShape: function ( shape ) {
	        this._shape = shape;
	    },
	
	    getVertexAttributeList: function () {
	        return this.attributes;
	    },
	
	    /**
	     * Return the primitiveset list
	     * If you modify something inside this array
	     * you must call dirty() on the Geometry
	     */
	    getPrimitiveSetList: function () {
	        return this.primitives;
	    },
	
	    /**
	     * Set the buffer array on the attribute name key
	     * key is often something like Vertex, Normal, Color, ...
	     * for classic geometry
	     *
	     * if you change a buffer a dirty will be automatically
	     * called to rebuild the VAO if needed.
	     */
	    setVertexAttribArray: function ( key, array ) {
	        if ( this._attributes[ key ] !== array ) {
	            this._attributes[ key ] = array;
	            this.dirty();
	        }
	    },
	
	    _generateVertexSetup: function ( validAttributeKeyList, validAttributeIndexList, includeFirstIndexBuffer ) {
	
	        // generate setup for vertex attribute
	        // will be used as setup for vao or as is without vao
	        var vertexAttributeSetup = [ '//generated by Geometry::implementation',
	            'state.lazyDisablingOfVertexAttributes();',
	            'var attr;'
	        ];
	
	        for ( var i = 0, l = validAttributeKeyList.length; i < l; i++ ) {
	
	            vertexAttributeSetup.push( 'attr = this._attributes[\'' + validAttributeKeyList[ i ] + '\'];' );
	            vertexAttributeSetup.push( 'if ( attr.BufferArrayProxy ) attr = attr.getBufferArray();' );
	            vertexAttributeSetup.push( 'if ( !attr.isValid() ) return;' );
	            vertexAttributeSetup.push( 'state.setVertexAttribArray(' + validAttributeIndexList[ i ] + ', attr, attr.getNormalize() );' );
	
	        }
	
	        vertexAttributeSetup.push( 'state.applyDisablingOfVertexAttributes();' );
	
	        if ( includeFirstIndexBuffer )
	            vertexAttributeSetup.push( 'state.setIndexArray( this._primitives[ 0 ].getIndices() );' );
	
	        return vertexAttributeSetup;
	    },
	
	    _generatePrimitive: function ( primitives, hasVertexColor, optimizeVAO ) {
	
	        var primitiveSetup = [
	            hasVertexColor ? 'state.enableVertexColor();' : 'state.disableVertexColor();'
	        ];
	
	        if ( optimizeVAO ) {
	            return primitiveSetup.concat( [
	                'var primitive = this._primitives[ 0 ];',
	                'var indexes = primitive.getIndices();',
	                'if ( indexes.isDirty() ) {;',
	                '  indexes.bind( gl );',
	                '  indexes.compile( gl );',
	                '};',
	                'primitive.drawElements( state );'
	            ] );
	        }
	
	
	        primitiveSetup.push( 'var primitives = this._primitives;' );
	        for ( var j = 0, m = primitives.length; j < m; j++ )
	            primitiveSetup.push( 'primitives[' + j + '].draw(state);' );
	
	        return primitiveSetup;
	    },
	
	    /**
	     *  Generate a function specific to the Geometry/Program
	     *  two version one using VAO and a regular one
	     */
	    generateDrawCommand: ( function () {
	
	        var validAttributeList = [];
	        var validAttributeKeyList = [];
	
	        return function ( state, program, prgID ) {
	
	            var attributesCacheKeys = program._attributesCache.getKeys();
	            var attributesCacheMap = program._attributesCache;
	            var geometryVertexAttributes = this.getVertexAttributeList();
	
	            validAttributeKeyList.length = 0;
	            validAttributeList.length = 0;
	
	            // 1 - register valid vertex attributes and color flag
	
	            var attribute, i, l, j, m, key, attr;
	
	            var extVAO = this._extVAO;
	            var listVABuff = extVAO ? [] : undefined;
	
	            var hasVertexColor = false;
	
	            for ( i = 0, l = attributesCacheKeys.length; i < l; i++ ) {
	
	                key = attributesCacheKeys[ i ];
	                attribute = attributesCacheMap[ key ];
	                attr = geometryVertexAttributes[ key ];
	
	                if ( attr === undefined ) continue;
	
	                var attributeBuffer = this._attributes[ key ];
	
	                // dont use VAO if we have BufferArrayProxy
	                // typically used for morphing
	                if ( attributeBuffer instanceof BufferArrayProxy ) {
	                    attributeBuffer = attributeBuffer.getBufferArray();
	                    extVAO = false;
	                }
	
	                if ( !attributeBuffer.isValid() ) return undefined;
	
	                // store for later usage at draw time/update
	                if ( extVAO ) listVABuff.push( attributeBuffer );
	
	                if ( !hasVertexColor && key === 'Color' )
	                    hasVertexColor = true;
	
	                validAttributeKeyList.push( key );
	                validAttributeList.push( attribute );
	            }
	
	
	            var autogeneratedFunction;
	            var functionName;
	
	            // generate specific function using VAO or standard
	            if ( extVAO ) {
	
	                this._cacheVertexAttributeBufferList[ prgID ] = listVABuff;
	
	                // if there is only one drawElement we can put the index buffer
	                // in the vao
	                var optimizeIndexBufferVAO = ( this._primitives.length === 1 && this._primitives[ 0 ] instanceof DrawElements );
	
	                var vertexAttributeSetup = this._generateVertexSetup( validAttributeKeyList, validAttributeList, optimizeIndexBufferVAO );
	
	                state.clearVertexAttribCache();
	                var vao = this._extVAO.createVertexArrayOES();
	                state.setVertexArrayObject( vao );
	                this._vao[ prgID ] = vao;
	
	                // evaluate the vertexAttribute setup to register into the vao
	                /*jshint evil: true */
	                var vertexSetupCommand = new Function( 'state', vertexAttributeSetup.join( '\n' ) );
	                /*jshint evil: false */
	                vertexSetupCommand.call( this, state );
	
	                // setup the program
	                var vaoSetup = [
	                    'var gl = state.getGraphicContext();',
	                    'var vao = this._vao[ ' + prgID + ' ] ',
	                    'var hasChanged = state.setVertexArrayObject( vao );',
	                    'if ( hasChanged ) {',
	                    '  var vaList = this._cacheVertexAttributeBufferList[ ' + prgID + ' ];',
	                    '  var va;'
	                ];
	                for ( j = 0, m = listVABuff.length; j < m; j++ ) {
	                    vaoSetup.push( '  va = vaList[ ' + j + '];' );
	                    vaoSetup.push( '  if ( va.isDirty() ) {;' );
	                    vaoSetup.push( '    va.bind( gl );' );
	                    vaoSetup.push( '    va.compile( gl );' );
	                    vaoSetup.push( '  };' );
	                }
	                vaoSetup.push( '}' );
	
	                autogeneratedFunction = vaoSetup.concat( this._generatePrimitive( this._primitives, hasVertexColor, optimizeIndexBufferVAO ) ).join( '\n' );
	                functionName = 'GeometryDrawImplementationCacheVAO';
	
	            } else {
	
	                autogeneratedFunction = this._generateVertexSetup( validAttributeKeyList, validAttributeList, false ).concat( this._generatePrimitive( this._primitives, hasVertexColor, false ) ).join( '\n' );
	                functionName = 'GeometryDrawImplementationCache';
	
	            }
	
	            /*jshint evil: true */
	            // name the function
	            // http://stackoverflow.com/questions/5905492/dynamic-function-name-in-javascript
	            var drawCommand = ( new Function( 'state', 'return function ' + functionName + '( state ) { ' + autogeneratedFunction + '}' ) )();
	            /*jshint evil: false */
	
	            this._cacheDrawCall[ prgID ] = drawCommand;
	            return drawCommand;
	        };
	
	    } )(),
	
	    drawImplementation: function ( state ) {
	
	        var program = state.getLastProgramApplied();
	        var prgID = program.getInstanceID();
	
	        var cachedDraw = this._cacheDrawCall[ prgID ];
	
	        // most of the time we should use vao
	        if ( this._extVAO && !this._vao[ prgID ] ) state.setVertexArrayObject( null );
	
	        if ( cachedDraw === undefined ) {
	
	            if ( !this._primitives.length ) return;
	
	            // no cache for this combination of vertex attributes
	            // compute new Draw Call
	
	            if ( this._extVAO === undefined && Geometry.enableVAO ) { // will be null if not supported
	                var extVAO = WebGLCaps.instance( state.getGraphicContext() ).getWebGLExtension( 'OES_vertex_array_object' );
	                this._extVAO = extVAO;
	            }
	
	            cachedDraw = this.generateDrawCommand( state, program, prgID );
	        }
	
	        cachedDraw.call( this, state );
	
	    },
	
	    setBound: function ( bb ) {
	        this._boundingBox = bb;
	        this._boundingBoxComputed = true;
	    },
	
	    computeBoundingBox: function ( boundingBox ) {
	
	        boundingBox.init();
	
	        var vertexArray = this.getVertexAttributeList().Vertex;
	        if ( vertexArray && vertexArray.getElements() && vertexArray.getItemSize() > 2 ) {
	            var vertexes = vertexArray.getElements();
	            var itemSize = vertexArray.getItemSize();
	
	            var min = boundingBox.getMin();
	            var max = boundingBox.getMax();
	
	            var minx = min[ 0 ];
	            var miny = min[ 1 ];
	            var minz = min[ 2 ];
	            var maxx = max[ 0 ];
	            var maxy = max[ 1 ];
	            var maxz = max[ 2 ];
	
	            // if the box is un-initialized min=Inf and max=-Inf
	            // we can't simply write if(x > min) [...] else (x < max) [...]
	            // most of the time the else condition is run so it's a kinda useless
	            // optimization anyway
	            for ( var idx = 0, l = vertexes.length; idx < l; idx += itemSize ) {
	                var v1 = vertexes[ idx ];
	                var v2 = vertexes[ idx + 1 ];
	                var v3 = vertexes[ idx + 2 ];
	                if ( v1 < minx ) minx = v1;
	                if ( v1 > maxx ) maxx = v1;
	                if ( v2 < miny ) miny = v2;
	                if ( v2 > maxy ) maxy = v2;
	                if ( v3 < minz ) minz = v3;
	                if ( v3 > maxz ) maxz = v3;
	            }
	
	            min[ 0 ] = minx;
	            min[ 1 ] = miny;
	            min[ 2 ] = minz;
	            max[ 0 ] = maxx;
	            max[ 1 ] = maxy;
	            max[ 2 ] = maxz;
	        }
	
	        return boundingBox;
	    },
	
	    computeBoundingSphere: function ( boundingSphere ) {
	        boundingSphere.init();
	        var bb = this.getBoundingBox();
	        boundingSphere.expandByBoundingBox( bb );
	        return boundingSphere;
	    }
	
	
	} ), 'osg', 'Geometry' );
	
	Geometry.appendVertexAttributeToList = function ( from, to, postfix ) {
	
	    var keys = window.Object.keys( from );
	    var key, keyPostFix;
	
	    for ( var i = 0, l = keys.length; i < l; i++ ) {
	
	        key = keys[ i ];
	        keyPostFix = key;
	        if ( postfix !== undefined )
	            keyPostFix += '_' + postfix;
	
	        to[ keyPostFix ] = from[ key ];
	
	    }
	
	};
	
	
	MACROUTILS.setTypeID( Geometry );
	
	module.exports = Geometry;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var WebGLUtils = __webpack_require__( 33 );
	var Texture;
	
	var WebGLCaps = function () {
	
	    // circular deps with texture
	    if ( !Texture ) Texture = __webpack_require__( 34 );
	
	    this._checkRTT = {};
	    this._webGLExtensions = {};
	    this._webGLParameters = {};
	    this._webGLShaderMaxInt = 'NONE';
	    this._webGLShaderMaxFloat = 'NONE';
	
	    this._bugsDB = {};
	    this._webGLPlatforms = {};
	
	    // webgl minimum requirements as per webgl specs
	    // useful for nodejs env
	    this._webGLParameters[ 'MAX_COMBINED_TEXTURE_IMAGE_UNITS' ] = 8;
	    this._webGLParameters[ 'MAX_CUBE_MAP_TEXTURE_SIZE' ] = 16;
	    this._webGLParameters[ 'MAX_FRAGMENT_UNIFORM_VECTORS' ] = 16;
	    this._webGLParameters[ 'MAX_RENDERBUFFER_SIZE' ] = 1;
	    this._webGLParameters[ 'MAX_TEXTURE_IMAGE_UNITS' ] = 8;
	    this._webGLParameters[ 'MAX_TEXTURE_SIZE' ] = 64;
	    this._webGLParameters[ 'MAX_VARYING_VECTORS' ] = 8;
	    this._webGLParameters[ 'MAX_VERTEX_ATTRIBS' ] = 8;
	    this._webGLParameters[ 'MAX_VERTEX_TEXTURE_IMAGE_UNITS' ] = 0;
	    this._webGLParameters[ 'MAX_VERTEX_UNIFORM_VECTORS' ] = 128;
	    this._webGLParameters[ 'MAX_VIEWPORT_DIMS' ] = [ 1, 1 ];
	    this._webGLParameters[ 'NUM_COMPRESSED_TEXTURE_FORMATS' ] = 0;
	    this._webGLParameters[ 'MAX_SHADER_PRECISION_FLOAT' ] = 'none';
	    this._webGLParameters[ 'MAX_SHADER_PRECISION_INT' ] = 'none';
	
	    // for multiple context
	    // allow checking we're on the good one
	    this._gl = undefined;
	
	};
	
	WebGLCaps.instance = function ( glParam ) {
	
	
	    if ( !WebGLCaps._instance ) {
	
	        var oldWebGLInspector;
	        var gl = glParam;
	
	        if ( !gl ) {
	
	            // make sure we don't break webglinspector
	            // with our webglcaps canvas
	            var webglInspector = typeof window !== 'undefined' && window.gli;
	
	            if ( webglInspector ) {
	
	                oldWebGLInspector = window.gli.host.inspectContext;
	                window.gli.host.inspectContext = false;
	
	            }
	
	            var c = document.createElement( 'canvas' );
	            c.width = 32;
	            c.height = 32;
	            // not necessary, but for some reasons it crashed on chromium vr build
	            var opt = {
	                antialias: false
	            };
	
	            gl = WebGLUtils.setupWebGL( c, opt, function () {} );
	
	        }
	
	        WebGLCaps._instance = new WebGLCaps();
	        if ( gl ) {
	
	            WebGLCaps._instance.init( gl );
	
	        } else {
	
	            // gracefully handle non webgl
	            // like nodejs, phantomjs
	            // warns but no error so that nodejs/phantomjs
	            // can still has some webglcaps object
	            Notify.warn( 'no support for webgl context detected.' );
	
	        }
	
	        if ( oldWebGLInspector ) {
	
	            window.gli.host.inspectContext = oldWebGLInspector;
	
	        }
	
	        //delete c;
	    }
	
	    if ( glParam && glParam !== WebGLCaps._instance.getContext() ) {
	
	        // webgl caps called with a different context
	        // than the one we draw in, will result on hard crash
	        // when using extension from another context
	        WebGLCaps._instance.initContextDependant( glParam );
	
	    }
	
	    return WebGLCaps._instance;
	};
	
	WebGLCaps.prototype = {
	
	    getContext: function () {
	        return this._gl;
	    },
	
	    initContextDependant: function ( gl ) {
	
	        // store context in case of multiple context
	        this._gl = gl;
	
	        // Takes care of circular dependencies on Texture
	        // Texture should be resolved at this point
	        // Texture = require( 'osg/Texture' );
	
	        // get extensions
	        this.initWebGLExtensions( gl );
	
	        // get float support
	        this.hasLinearHalfFloatRTT( gl );
	        this.hasLinearFloatRTT( gl );
	        this.hasHalfFloatRTT( gl );
	        this.hasFloatRTT( gl );
	
	    },
	
	    init: function ( gl ) {
	
	        // get capabilites
	        this.initWebGLParameters( gl );
	
	        // order is important
	        // to allow webgl extensions filtering
	        this.initPlatformSupport();
	        this.initBugDB();
	
	        this.initContextDependant( gl );
	
	        this._isGL2 = typeof window.WebGL2RenderingContext !== 'undefined' && gl instanceof window.WebGL2RenderingContext;
	
	        if ( this._isGL2 ) {
	
	
	            // osgjs code is webgl1, so we fake webgl2 capabilities
	            // and calls for retrocompatibility with webgl1
	            this._checkRTT[ Texture.FLOAT + ',' + Texture.NEAREST ] = true;
	            this._checkRTT[ Texture.HALF_FLOAT + ',' + Texture.NEAREST ] = true;
	            this._checkRTT[ Texture.FLOAT + ',' + Texture.LINEAR ] = true;
	            this._checkRTT[ Texture.HALF_FLOAT + ',' + Texture.LINEAR ] = true;
	
	            var nativeExtension = [
	                'OES_element_index_uint',
	                'EXT_sRGB',
	                'EXT_blend_minmax',
	                'EXT_frag_depth',
	                'WEBGL_depth_texture',
	                'EXT_shader_texture_lod',
	                'OES_standard_derivatives',
	                'OES_texture_float',
	                'OES_texture_half_float',
	                'OES_vertex_array_object',
	                'WEBGL_draw_buffers',
	                'OES_fbo_render_mipmap',
	                'ANGLE_instanced_arrays'
	            ];
	
	            var ext = WebGLCaps._instance.getWebGLExtensions();
	            var dummyFunc = function () {};
	            for ( var i = 0, l = nativeExtension.length; i < l; i++ ) {
	                ext[ nativeExtension[ i ] ] = dummyFunc;
	            }
	        }
	
	    },
	
	    isWebGL2: function () {
	        return this._isGL2;
	    },
	    // inevitable bugs per platform (browser/OS/GPU)
	    initBugDB: function () {
	
	        var p = this._webGLPlatforms;
	        var ext = this._webGLParameters;
	
	        // derivatives gives strange results on Shadow Shaders
	        if ( p.Apple ) {
	
	            if ( !ext.UNMASKED_VENDOR_WEBGL || ext.UNMASKED_VENDOR_WEBGL.indexOf( 'Intel' ) !== -1 ) {
	                // bug is on INTEL GPU on APPLE
	                // we disable the ext on Apple if we cannot get GPU info
	                this._bugsDB[ 'OES_standard_derivatives' ] = true;
	
	            }
	
	        }
	
	    },
	    initPlatformSupport: function () {
	
	        var p = this._webGLPlatforms;
	
	        p.Apple = navigator.vendor.indexOf( 'Apple' ) !== -1 || navigator.vendor.indexOf( 'OS X' ) !== -1;
	
	        // degrades complexity on handhelds.
	        p.Mobile = /Mobi/.test( navigator.userAgent ) || /ablet/.test( navigator.userAgent );
	
	    },
	    getWebGLPlatform: function ( str ) {
	        return this._webGLPlatforms[ str ];
	    },
	    getWebGLPlatforms: function () {
	        return this._webGLPlatforms;
	    },
	
	    getWebGLParameter: function ( str ) {
	        return this._webGLParameters[ str ];
	    },
	    getWebGLParameters: function () {
	        return this._webGLParameters;
	    },
	    getShaderMaxPrecisionFloat: function () {
	        return this._webGLParameters.MAX_SHADER_PRECISION_FLOAT;
	    },
	    getShaderMaxPrecisionInt: function () {
	        return this._webGLParameters.MAX_SHADER_PRECISION_INT;
	    },
	    checkSupportRTT: function ( gl, typeFloat, typeTexture ) {
	
	        var key = typeFloat + ',' + typeTexture;
	
	        // check once only
	        if ( this._checkRTT[ key ] !== undefined )
	            return this._checkRTT[ key ];
	
	        // no cached results, need gl context
	        if ( !gl ) return false;
	
	        // from http://codeflow.org/entries/2013/feb/22/how-to-write-portable-webgl/#how-can-i-detect-if-i-can-render-to-floating-point-textures
	
	        // setup the texture
	        var texture = gl.createTexture();
	        gl.bindTexture( gl.TEXTURE_2D, texture );
	        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, typeFloat, null );
	        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, typeTexture );
	        gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, typeTexture );
	
	        // setup the framebuffer
	        var framebuffer = gl.createFramebuffer();
	        gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
	        gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0 );
	
	        // check the framebuffer
	        var status = this._checkRTT[ key ] = gl.checkFramebufferStatus( gl.FRAMEBUFFER ) === gl.FRAMEBUFFER_COMPLETE;
	
	        // cleanup
	        gl.deleteTexture( texture );
	        gl.deleteFramebuffer( framebuffer );
	        gl.bindTexture( gl.TEXTURE_2D, null );
	        gl.bindFramebuffer( gl.FRAMEBUFFER, null );
	
	        return status;
	    },
	    hasLinearHalfFloatRTT: function ( gl ) {
	        return this._webGLExtensions[ 'OES_texture_half_float_linear' ] && this.checkSupportRTT( gl, Texture.HALF_FLOAT, Texture.LINEAR );
	    },
	    hasLinearFloatRTT: function ( gl ) {
	        return this._webGLExtensions[ 'OES_texture_float_linear' ] && this.checkSupportRTT( gl, Texture.FLOAT, Texture.LINEAR );
	    },
	    hasHalfFloatRTT: function ( gl ) {
	        return this._webGLExtensions[ 'OES_texture_half_float' ] && this.checkSupportRTT( gl, Texture.HALF_FLOAT, Texture.NEAREST );
	    },
	    hasFloatRTT: function ( gl ) {
	        return this._webGLExtensions[ 'OES_texture_float' ] && this.checkSupportRTT( gl, Texture.FLOAT, Texture.NEAREST );
	    },
	    queryPrecision: function ( gl, shaderType, precision ) {
	        var answer = gl.getShaderPrecisionFormat( shaderType, precision );
	        if ( !answer ) return false;
	        return answer.precision !== 0;
	    },
	    initWebGLParameters: function ( gl ) {
	        if ( !gl ) return;
	        var limits = [
	            'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
	            'MAX_CUBE_MAP_TEXTURE_SIZE',
	            'MAX_FRAGMENT_UNIFORM_VECTORS',
	            'MAX_RENDERBUFFER_SIZE',
	            'MAX_TEXTURE_IMAGE_UNITS',
	            'MAX_TEXTURE_SIZE',
	            'MAX_VARYING_VECTORS',
	            'MAX_VERTEX_ATTRIBS',
	            'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
	            'MAX_VERTEX_UNIFORM_VECTORS',
	            'MAX_VIEWPORT_DIMS',
	            'SHADING_LANGUAGE_VERSION',
	            'VERSION',
	            'VENDOR',
	            'RENDERER',
	            'ALIASED_LINE_WIDTH_RANGE',
	            'ALIASED_POINT_SIZE_RANGE',
	            'RED_BITS',
	            'GREEN_BITS',
	            'BLUE_BITS',
	            'ALPHA_BITS',
	            'DEPTH_BITS',
	            'STENCIL_BITS'
	        ];
	        var params = this._webGLParameters;
	        for ( var i = 0, len = limits.length; i < len; ++i ) {
	            var par = limits[ i ];
	            params[ par ] = gl.getParameter( gl[ par ] );
	        }
	
	        //shader precisions for float
	        if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ) ) {
	            params.MAX_SHADER_PRECISION_FLOAT = 'high';
	        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ) ) {
	            params.MAX_SHADER_PRECISION_FLOAT = 'medium';
	        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.LOW_FLOAT ) ) {
	            params.MAX_SHADER_PRECISION_FLOAT = 'low';
	        }
	
	        //shader precisions for float
	        if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.HIGH_INT ) ) {
	            params.MAX_SHADER_PRECISION_INT = 'high';
	        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.MEDIUM_INT ) ) {
	            params.MAX_SHADER_PRECISION_INT = 'medium';
	        } else if ( this.queryPrecision( gl, gl.FRAGMENT_SHADER, gl.LOW_INT ) ) {
	            params.MAX_SHADER_PRECISION_INT = 'low';
	        }
	
	        // get GPU, Angle or not, Opengl/directx, etc.
	        //  ffx && chrome only
	        var debugInfo = gl.getExtension( 'WEBGL_debug_renderer_info' );
	        if ( debugInfo ) {
	            params.UNMASKED_RENDERER_WEBGL = gl.getParameter( debugInfo.UNMASKED_VENDOR_WEBGL );
	            params.UNMASKED_VENDOR_WEBGL = gl.getParameter( debugInfo.UNMASKED_RENDERER_WEBGL );
	
	        }
	        // TODO ?
	        // try to compile a small shader to test the spec is respected
	    },
	    getWebGLExtension: function ( str ) {
	        return this._webGLExtensions[ str ];
	    },
	    getWebGLExtensions: function () {
	        return this._webGLExtensions;
	    },
	    initWebGLExtensions: function ( gl, filterBugs ) {
	
	        // nodejs, phantomjs
	        if ( !gl ) return;
	
	        var doFilter = filterBugs;
	        if ( doFilter === undefined )
	            doFilter = true;
	
	        var supported = gl.getSupportedExtensions();
	        var ext = this._webGLExtensions;
	        // we load all the extensions
	        for ( var i = 0, len = supported.length; i < len; ++i ) {
	            var sup = supported[ i ];
	
	            if ( doFilter && this._bugsDB[ sup ] ) {
	                // bugs on that configuration, do not enable
	                continue;
	            }
	
	            ext[ sup ] = gl.getExtension( sup );
	        }
	
	        var anisoExt = this.getWebGLExtension( 'EXT_texture_filter_anisotropic' );
	        if ( anisoExt ) {
	            Texture.ANISOTROPIC_SUPPORT_EXT = true;
	            Texture.ANISOTROPIC_SUPPORT_MAX = gl.getParameter( anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	        }
	
	    }
	};
	
	module.exports = WebGLCaps;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

	// jshint ignore: start
	
	/*
	 * Copyright 2010, Google Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *     * Redistributions of source code must retain the above copyright
	 * notice, this list of conditions and the following disclaimer.
	 *     * Redistributions in binary form must reproduce the above
	 * copyright notice, this list of conditions and the following disclaimer
	 * in the documentation and/or other materials provided with the
	 * distribution.
	 *     * Neither the name of Google Inc. nor the names of its
	 * contributors may be used to endorse or promote products derived from
	 * this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	
	/**
	 * @fileoverview This file contains functions every webgl program will need
	 * a version of one way or another.
	 *
	 * Instead of setting up a context manually it is recommended to
	 * use. This will check for success or failure. On failure it
	 * will attempt to present an approriate message to the user.
	 *
	 *       gl = WebGLUtils.setupWebGL(canvas);
	 *
	 * For animated WebGL apps use of setTimeout or setInterval are
	 * discouraged. It is recommended you structure your rendering
	 * loop like this.
	 *
	 *       function render() {
	 *         window.requestAnimationFrame(render, canvas);
	 *
	 *         // do rendering
	 *         ...
	 *       }
	 *       render();
	 *
	 * This will call your rendering function up to the refresh rate
	 * of your display but will stop rendering if your app is not
	 * visible.
	 */
	
	'use strict';
	var WebGLUtils = function () {
	
	    /**
	     * Creates the HTLM for a failure message
	     * @param {string} canvasContainerId id of container of th
	     *        canvas.
	     * @return {string} The html.
	     */
	    var makeFailHTML = function ( msg ) {
	        return '' +
	            '<div style="margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;">' + msg + '</div>';
	        // return '' +
	        //   '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
	        //   '<td align="center">' +
	        //   '<div style="display: table-cell; vertical-align: middle;">' +
	        //   '<div style="">' + msg + '</div>' +
	        //   '</div>' +
	        //   '</td></tr></table>';
	    };
	
	    /**
	     * Mesasge for getting a webgl browser
	     * @type {string}
	     */
	    var GET_A_WEBGL_BROWSER = '' +
	        'This page requires a browser that supports WebGL.<br/>' +
	        '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';
	
	    /**
	     * Mesasge for need better hardware
	     * @type {string}
	     */
	    var OTHER_PROBLEM = '' +
	        "It doesn't appear your computer can support WebGL.<br/>" +
	        '<a href="http://get.webgl.org">Click here for more information.</a>';
	
	    /**
	     * Creates a webgl context. If creation fails it will
	     * change the contents of the container of the <canvas>
	     * tag to an error message with the correct links for WebGL.
	     * @return {WebGLRenderingContext} The created context.
	     */
	    var setupWebGL = function (
	        /** Element */
	        canvas,
	        /** WebGLContextCreationAttirbutes */
	        opt_attribs,
	        /** function:(msg) */
	        opt_onError ) {
	        function handleCreationError( msg ) {
	            if ( msg.indexOf( 'WebGL2' ) !== -1 ) return;
	            var container = document.getElementsByTagName( "body" )[ 0 ];
	            //var container = canvas.parentNode;
	            if ( container ) {
	                var str = window.WebGLRenderingContext ?
	                    OTHER_PROBLEM :
	                    GET_A_WEBGL_BROWSER;
	                if ( msg ) {
	                    str += "<br/><br/>Status: " + msg;
	                }
	                container.innerHTML = makeFailHTML( str );
	            }
	        }
	
	        opt_onError = opt_onError || handleCreationError;
	
	        if ( canvas.addEventListener ) {
	            canvas.addEventListener( "webglcontextcreationerror", function ( event ) {
	                opt_onError( event.statusMessage );
	            }, false );
	        }
	        var context = create3DContext( canvas, opt_attribs );
	        if ( !context ) {
	            //if ( !window.WebGLRenderingContext )
	            opt_onError( "" );
	        }
	
	        return context;
	    };
	
	    /**
	     * Creates a webgl context.
	     * @param {!Canvas} canvas The canvas tag to get context
	     *     from. If one is not passed in one will be created.
	     * @return {!WebGLContext} The created context.
	     */
	    var create3DContext = function ( canvas, opt_attribs ) {
	
	        // only try to enable if URl options ?webgl2=1
	        var names = [];
	        if ( opt_attribs && opt_attribs.webgl2 ) {
	            names = names.concat( [ "webgl2", "experimental-webgl2" ] );
	        }
	        names = names.concat( [ "webgl", "experimental-webgl", "webkit-3d", "moz-webgl" ] );
	
	        var context = null;
	        for ( var ii = 0; ii < names.length; ++ii ) {
	            try {
	                context = canvas.getContext( names[ ii ], opt_attribs );
	            } catch ( e ) {}
	            if ( context ) {
	                break;
	            }
	        }
	        return context;
	    };
	
	    return {
	        create3DContext: create3DContext,
	        setupWebGL: setupWebGL
	    };
	}();
	
	/**
	 * Provides requestAnimationFrame in a cross browser
	 * way.
	 */
	if ( !window.requestAnimationFrame ) {
	    window.requestAnimationFrame = ( function () {
	        return window.requestAnimationFrame ||
	            window.webkitRequestAnimationFrame ||
	            window.mozRequestAnimationFrame ||
	            window.oRequestAnimationFrame ||
	            window.msRequestAnimationFrame ||
	            function ( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
	                window.setTimeout( callback, 1000 / 60 );
	            };
	    } )();
	}
	
	if ( !window.cancelRequestAnimFrame ) {
	    window.cancelRequestAnimFrame = ( function () {
	        return window.cancelAnimationFrame ||
	            window.webkitCancelRequestAnimationFrame ||
	            window.mozCancelRequestAnimationFrame ||
	            window.oCancelRequestAnimationFrame ||
	            window.msCancelRequestAnimationFrame ||
	            clearTimeout;
	    } )();
	}
	
	if ( !Date.now ) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	
	module.exports = WebGLUtils;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	var Uniform = __webpack_require__( 35 );
	var Image = __webpack_require__( 36 );
	var GLObject = __webpack_require__( 37 );
	var ReaderParser = __webpack_require__( 38 );
	var CustomMap = __webpack_require__( 20 );
	var TextureManager = __webpack_require__( 52 );
	var WebglCaps = __webpack_require__( 32 );
	
	
	// helper
	var isPowerOf2 = function ( x ) {
	    /*jshint bitwise: false */
	    return ( ( x !== 0 ) && ( ( x & ( ~x + 1 ) ) === x ) );
	    /*jshint bitwise: true */
	};
	
	/**
	 * Texture encapsulate webgl texture object
	 * @class Texture
	 * Not that dirty here is mainly for texture binding
	 * any dirty will cause re-bind
	 * hint: don't dirty a texture attached to a camera/framebuffer
	 * it will end blank
	 * @inherits StateAttribute
	 */
	var Texture = function () {
	
	    StateAttribute.call( this );
	    GLObject.call( this );
	    this.setDefaultParameters();
	    this._dirty = true;
	    this._dirtyMipmap = true;
	    this._applyTexImage2DCallbacks = [];
	    this._textureObject = undefined;
	
	    this._textureNull = true;
	};
	
	var checkAndFixEnum = function ( mode, fallback ) {
	
	    var value = Texture[ mode ];
	
	    if ( value === undefined ) {
	        Notify.warn( 'bad Texture enum argument ' + mode + '\n' + 'fallback to ' + fallback );
	        return fallback;
	    }
	
	    return value;
	};
	
	Texture.UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
	Texture.UNPACK_FLIP_Y_WEBGL = 0x9240;
	Texture.BROWSER_DEFAULT_WEBGL = 0x9244;
	Texture.NONE = 0x0;
	
	Texture.DEPTH_COMPONENT = 0x1902;
	Texture.ALPHA = 0x1906;
	Texture.RGB = 0x1907;
	Texture.RGBA = 0x1908;
	Texture.LUMINANCE = 0x1909;
	Texture.LUMINANCE_ALPHA = 0x190A;
	
	// DXT formats, from:
	// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
	Texture.COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
	Texture.COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;
	Texture.COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
	Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;
	
	// ATC formats, from:
	// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/
	Texture.COMPRESSED_RGB_ATC_WEBGL = 0x8C92;
	Texture.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;
	Texture.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;
	
	// PVR formats, from:
	// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
	Texture.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
	Texture.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
	Texture.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
	Texture.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;
	
	// ETC1 format, from:
	// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/
	Texture.COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;
	
	// filter mode
	Texture.LINEAR = 0x2601;
	Texture.NEAREST = 0x2600;
	Texture.NEAREST_MIPMAP_NEAREST = 0x2700;
	Texture.LINEAR_MIPMAP_NEAREST = 0x2701;
	Texture.NEAREST_MIPMAP_LINEAR = 0x2702;
	Texture.LINEAR_MIPMAP_LINEAR = 0x2703;
	// filter anisotropy
	Texture.TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;
	Texture.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;
	
	// wrap mode
	Texture.CLAMP_TO_EDGE = 0x812F;
	Texture.REPEAT = 0x2901;
	Texture.MIRRORED_REPEAT = 0x8370;
	
	// target
	Texture.TEXTURE_2D = 0x0DE1;
	Texture.TEXTURE_CUBE_MAP = 0x8513;
	Texture.TEXTURE_BINDING_CUBE_MAP = 0x8514;
	Texture.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
	Texture.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
	Texture.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
	Texture.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
	Texture.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
	Texture.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
	Texture.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
	
	Texture.UNSIGNED_BYTE = 0x1401;
	Texture.UNSIGNED_SHORT = 0x1403;
	Texture.UNSIGNED_SHORT_4_4_4_4 = 0x8033;
	Texture.UNSIGNED_SHORT_5_5_5_1 = 0x8034;
	Texture.UNSIGNED_SHORT_5_6_5 = 0x8363;
	Texture.FLOAT = 0x1406;
	Texture.HALF_FLOAT_OES = Texture.HALF_FLOAT = 0x8D61;
	
	Texture._sTextureManager = new window.Map();
	
	// Getter for textureManager
	Texture.getTextureManager = function ( gl ) {
	
	    if ( !Texture._sTextureManager.has( gl ) )
	        Texture._sTextureManager.set( gl, new TextureManager() );
	
	    return Texture._sTextureManager.get( gl );
	};
	
	Texture.getEnumFromString = function ( v ) {
	
	    var value = v;
	
	    if ( typeof ( value ) === 'string' )
	        value = checkAndFixEnum( value, v );
	
	    return value;
	};
	
	Texture.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( GLObject.prototype, MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Texture',
	
	    cloneType: function () {
	        return new Texture();
	    },
	
	    dirty: function () {
	        this._dirty = true;
	    },
	
	    isDirty: function () {
	        return this._dirty;
	    },
	
	    isTextureNull: function () {
	        return this._textureNull;
	    },
	
	    getOrCreateUniforms: function ( unit ) {
	
	        if ( Texture.uniforms === undefined ) {
	            Texture.uniforms = [];
	        }
	        if ( Texture.uniforms[ unit ] === undefined ) {
	            var name = this.getType() + unit;
	            var uniformMap = new CustomMap();
	            var uniform = Uniform.createInt1( unit, name );
	            uniformMap.setMap( {
	                texture: uniform
	            } );
	
	            Texture.uniforms[ unit ] = uniformMap;
	        }
	
	        // uniform for an texture attribute should directly in Texture.uniforms[unit]
	        // and not in Texture.uniforms[unit][Texture0]
	
	        // Why it's in Texture.uniforms[unit]['texture'] :
	        // a 'texture' is a texture attribute but you also have old texenv
	        //  that are texture attribute because  they are applied on a texture unit.
	        // I admit that currently we dont have this or we used to but we dont have it anymore.
	        // It's the same design than osg.
	        // We could imagine for example a TextureGreyScale texture attributes,
	        // that would transform the input texture
	        // on unit X into greyscale used in the shader.
	
	        return Texture.uniforms[ unit ];
	    },
	
	    setDefaultParameters: function () {
	        this._image = undefined;
	        this._magFilter = Texture.LINEAR;
	        this._minFilter = Texture.LINEAR;
	        this._maxAnisotropy = 1.0;
	        this._wrapS = Texture.CLAMP_TO_EDGE;
	        this._wrapT = Texture.CLAMP_TO_EDGE;
	        this._textureWidth = 0;
	        this._textureHeight = 0;
	        this._unrefImageDataAfterApply = false;
	        this._internalFormat = undefined;
	        this._dirtyMipmap = true;
	        this._textureTarget = Texture.TEXTURE_2D;
	        this._type = Texture.UNSIGNED_BYTE;
	        this._isCompressed = false;
	
	        this._flipY = true;
	        this._colorSpaceConversion = Texture.NONE; //Texture.BROWSER_DEFAULT_WEBGL;
	    },
	
	    // check https://www.khronos.org/registry/webgl/specs/latest/1.0/#PIXEL_STORAGE_PARAMETERS
	    setColorSpaceConversion: function ( enumValue ) {
	        this._colorSpaceConversion = enumValue;
	    },
	
	    setFlipY: function ( bool ) {
	        this._flipY = bool;
	    },
	
	
	    getTextureTarget: function () {
	        return this._textureTarget;
	    },
	
	    getTextureObject: function () {
	        return this._textureObject;
	    },
	
	    setTextureSize: function ( w, h ) {
	
	        var maxSize = WebglCaps.instance().getWebGLParameter( 'MAX_TEXTURE_SIZE' );
	
	        if ( w !== this._textureWidth || h !== this._textureHeight )
	            this.dirty();
	
	        if ( w !== undefined ) {
	            if ( w > maxSize ) {
	                Notify.error( 'width (' + w + ') too big for GPU. Max Texture Size is "' + maxSize + '"' );
	                this._textureWidth = maxSize;
	            } else {
	                this._textureWidth = w;
	            }
	        }
	
	        if ( h !== undefined ) {
	            if ( h > maxSize ) {
	                Notify.error( 'height (' + h + ') too big for GPU. Max Texture Size is "' + maxSize + '"' );
	                this._textureHeight = maxSize;
	            } else {
	                this._textureHeight = h;
	            }
	        }
	
	        this._textureNull = false;
	    },
	
	    init: function ( state ) {
	
	        if ( !this._gl ) this.setGraphicContext( state.getGraphicContext() );
	
	        if ( !this._textureObject ) {
	            this._textureObject = Texture.getTextureManager( this._gl ).generateTextureObject( this._gl,
	                this,
	                this._textureTarget,
	                this._internalFormat,
	                this._textureWidth,
	                this._textureHeight );
	
	            this.dirty();
	            this._dirtyTextureObject = false;
	            this._textureNull = false;
	        }
	    },
	
	    addApplyTexImage2DCallback: function ( callback ) {
	
	        var index = this._applyTexImage2DCallbacks.indexOf( callback );
	        if ( index < 0 ) {
	            this._applyTexImage2DCallbacks.push( callback );
	        }
	    },
	
	    removeApplyTexImage2DCallback: function ( callback ) {
	
	        var index = this._applyTexImage2DCallbacks.indexOf( callback );
	        if ( index >= 0 ) {
	            this._applyTexImage2DCallbacks.splice( index, 1 );
	        }
	    },
	
	    getWidth: function () {
	        return this._textureWidth;
	    },
	
	    getHeight: function () {
	        return this._textureHeight;
	    },
	
	    releaseGLObjects: function () {
	
	        if ( this._textureObject !== undefined && this._textureObject !== null && this._gl !== undefined ) {
	            Texture.getTextureManager( this._gl ).releaseTextureObject( this._textureObject );
	        }
	        this._textureObject = undefined;
	    },
	
	    getWrapT: function () {
	        return this._wrapT;
	    },
	
	    getWrapS: function () {
	        return this._wrapS;
	    },
	
	    setWrapS: function ( value ) {
	
	        if ( typeof value === 'string' ) {
	            this._wrapS = checkAndFixEnum( value, Texture.CLAMP_TO_EDGE );
	        } else {
	            this._wrapS = value;
	        }
	
	        this.dirtyTextureParameters();
	
	    },
	
	    setWrapT: function ( value ) {
	
	        if ( typeof value === 'string' ) {
	            this._wrapT = checkAndFixEnum( value, Texture.CLAMP_TO_EDGE );
	        } else {
	            this._wrapT = value;
	        }
	
	        this.dirtyTextureParameters();
	    },
	
	    // TODO CP:
	    // we should split dirty texture object of parameters
	    // dirty parameters only regenarate parameter
	    // dirty texture object needs to release a texture and
	    // re allocate one
	    dirtyTextureParameters: function () {
	        this.dirty(); // make everything dirty for now
	        this.dirtyMipmap();
	        this.dirtyTextureObject();
	    },
	
	    dirtyTextureObject: function () {
	        this._dirtyTextureObject = true;
	        this.dirtyMipmap();
	        this.dirty(); // make everything dirty for now
	    },
	
	
	    getMinFilter: function () {
	        return this._minFilter;
	    },
	
	    getMagFilter: function () {
	        return this._magFilter;
	    },
	
	    // https://www.opengl.org/registry/specs/EXT/texture_filter_anisotropic.txt
	    setMaxAnisotropy: function ( multiplier ) {
	        this._maxAnisotropy = multiplier;
	        this.dirtyTextureParameters();
	    },
	
	    getMaxAnisotropy: function () {
	        return this._maxAnisotropy;
	    },
	
	    // some value enable mipmapping
	    setMinFilter: function ( value ) {
	
	        if ( typeof ( value ) === 'string' ) {
	            this._minFilter = checkAndFixEnum( value, Texture.LINEAR );
	        } else {
	            this._minFilter = value;
	        }
	
	        this.dirtyTextureParameters();
	    },
	
	    // Either Linear or nearest.
	    setMagFilter: function ( value ) {
	
	        if ( typeof ( value ) === 'string' ) {
	            this._magFilter = checkAndFixEnum( value, Texture.LINEAR );
	        } else {
	            this._magFilter = value;
	        }
	
	        this.dirtyTextureParameters();
	    },
	
	    setImage: function ( img, imageFormat ) {
	
	        var image = img;
	        if ( img instanceof window.Image ||
	            img instanceof HTMLCanvasElement ||
	            img instanceof Uint8Array ) {
	            image = new Image( img );
	        }
	
	        this._image = image;
	        this.setImageFormat( imageFormat );
	        if ( image ) {
	            if ( image.getWidth && image.getHeight ) {
	                this.setTextureSize( image.getWidth(), image.getHeight() );
	            } else if ( image.width && image.height ) {
	                this.setTextureSize( image.width, image.height );
	            }
	        }
	        this._textureNull = false;
	        this.dirty();
	    },
	
	    getImage: function () {
	        return this._image;
	    },
	
	    setImageFormat: function ( format ) {
	
	        var imageFormat = format;
	        if ( imageFormat ) {
	
	            if ( typeof imageFormat === 'string' )
	                imageFormat = Texture[ imageFormat ];
	
	            this._imageFormat = imageFormat;
	        } else {
	            this._imageFormat = Texture.RGBA;
	        }
	    },
	
	    setType: function ( value ) {
	        Notify.log( 'Texture.setType is deprecated, use instead Texture.setInternalFormatType' );
	        this.setInternalFormatType( value );
	    },
	
	    setInternalFormatType: function ( value ) {
	
	        if ( typeof value === 'string' ) {
	            this._type = Texture[ value ];
	        } else {
	            this._type = value;
	        }
	    },
	
	    getInternalFormatType: function () {
	        return this._type;
	    },
	
	    setUnrefImageDataAfterApply: function ( bool ) {
	        this._unrefImageDataAfterApply = bool;
	    },
	
	    checkIsCompressed: function ( format ) {
	
	        var fo = format || this._internalFormat;
	        switch ( fo ) {
	        case Texture.COMPRESSED_RGB_S3TC_DXT1_EXT:
	        case Texture.COMPRESSED_RGBA_S3TC_DXT1_EXT:
	        case Texture.COMPRESSED_RGBA_S3TC_DXT3_EXT:
	        case Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT:
	        case Texture.COMPRESSED_RGB_ATC_WEBGL:
	        case Texture.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:
	        case Texture.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:
	        case Texture.COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
	        case Texture.COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
	        case Texture.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
	        case Texture.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
	        case Texture.COMPRESSED_RGB_ETC1_WEBGL:
	            return true;
	        default:
	            return false;
	        }
	    },
	
	    setInternalFormat: function ( formatSource ) {
	
	        var format = formatSource;
	        if ( format ) {
	
	            if ( typeof format === 'string' )
	                format = Texture[ format ];
	
	            this._isCompressed = this.checkIsCompressed( format );
	
	        } else {
	            this._isCompressed = false;
	            format = Texture.RGBA;
	        }
	
	        this._internalFormat = format;
	    },
	
	    getInternalFormat: function () {
	        return this._internalFormat;
	    },
	
	    isDirtyMipmap: function () {
	        return this._dirtyMipmap;
	    },
	
	    // Will cause the mipmaps to be regenerated on the next bind of the texture
	    // Nothing will be done if the minFilter is not of the form XXX_MIPMAP_XXX
	    // TODO : not to be used if the texture is compressed !
	    dirtyMipmap: function () {
	        this._dirtyMipmap = true;
	    },
	
	    applyFilterParameter: function ( gl, target ) {
	
	        var powerOfTwo = isPowerOf2( this._textureWidth ) && isPowerOf2( this._textureHeight );
	        if ( !powerOfTwo ) {
	            // NPOT non support in webGL explained here
	            // https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
	            // so disabling mipmap...
	            this._wrapT = Texture.CLAMP_TO_EDGE;
	            this._wrapS = Texture.CLAMP_TO_EDGE;
	
	            if ( this._minFilter === Texture.LINEAR_MIPMAP_LINEAR ||
	                this._minFilter === Texture.LINEAR_MIPMAP_NEAREST ) {
	                this._minFilter = Texture.LINEAR;
	            }
	        }
	        gl.texParameteri( target, gl.TEXTURE_MAG_FILTER, this._magFilter );
	        gl.texParameteri( target, gl.TEXTURE_MIN_FILTER, this._minFilter );
	
	
	        // handle extension EXT_texture_filter_anisotropic
	        if ( this._maxAnisotropy > 1.0 && Texture.ANISOTROPIC_SUPPORT_EXT ) {
	            var multiplier = this._maxAnisotropy < Texture.ANISOTROPIC_SUPPORT_MAX ? this._maxAnisotropy : Texture.ANISOTROPIC_SUPPORT_MAX;
	            gl.texParameterf( target, Texture.TEXTURE_MAX_ANISOTROPY_EXT, multiplier );
	        }
	
	        gl.texParameteri( target, gl.TEXTURE_WRAP_S, this._wrapS );
	        gl.texParameteri( target, gl.TEXTURE_WRAP_T, this._wrapT );
	
	    },
	
	    generateMipmap: function ( gl, target ) {
	
	        this._dirtyMipmap = false;
	        if ( !this.hasMipmapFilter() ) return;
	
	        // manual mipmap provided
	        var img = this._image;
	        if ( img && img.hasMipmap() ) {
	
	            var internalFormat = this._internalFormat;
	            var mips = img.getMipmap();
	            for ( var level = 1, nbLevel = mips.length; level < nbLevel; level++ ) {
	                var imi = mips[ level ];
	                if ( this._isCompressed )
	                    this.applyTexImage2D( gl, this._textureTarget, level, this._internalFormat, imi.getWidth(), imi.getHeight(), 0, imi.getImage() );
	                else
	                    this.applyTexImage2D( gl, this._textureTarget, level, internalFormat, imi.getWidth(), imi.getHeight(), 0, internalFormat, this._type, imi.getImage() );
	            }
	
	        } else {
	            // automatic mipmap
	            gl.generateMipmap( target );
	        }
	    },
	
	    // return true if contains a mipmap filter
	    hasMipmapFilter: function () {
	
	        return this._minFilter === Texture.NEAREST_MIPMAP_NEAREST ||
	            this._minFilter === Texture.LINEAR_MIPMAP_NEAREST ||
	            this._minFilter === Texture.NEAREST_MIPMAP_LINEAR ||
	            this._minFilter === Texture.LINEAR_MIPMAP_LINEAR;
	    },
	
	    applyTexImage2D: function ( gl ) {
	
	        var args = Array.prototype.slice.call( arguments, 1 );
	        MACROUTILS.timeStamp( 'osgjs.metrics:Texture.texImage2d' );
	
	        // use parameters of pixel store
	        gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, this._flipY );
	        gl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._colorSpaceConversion );
	
	        if ( this._isCompressed ) gl.compressedTexImage2D.apply( gl, args );
	        else gl.texImage2D.apply( gl, args );
	
	        // call a callback when upload is done if there is one
	        var numCallback = this._applyTexImage2DCallbacks.length;
	        if ( numCallback > 0 ) {
	            for ( var i = 0, l = numCallback; i < l; i++ ) {
	                this._applyTexImage2DCallbacks[ i ].call( this );
	            }
	        }
	    },
	
	    computeTextureFormat: function () {
	
	        if ( !this._internalFormat ) {
	            this._internalFormat = this._imageFormat || Texture.RGBA;
	            this._imageFormat = this._internalFormat;
	        } else {
	            this._imageFormat = this._internalFormat;
	        }
	
	    },
	
	    applyImage: function ( gl, image ) {
	
	        if ( this._isCompressed ) {
	            this.applyTexImage2D( gl, this._textureTarget, 0, this._internalFormat, this._textureWidth, this._textureHeight, 0, image.getImage() );
	        } else if ( image.isTypedArray() ) {
	            this.applyTexImage2D( gl,
	                this._textureTarget,
	                0,
	                this._internalFormat,
	                this._textureWidth,
	                this._textureHeight,
	                0,
	                this._internalFormat,
	                this._type,
	                this._image.getImage() );
	        } else {
	            this.applyTexImage2D( gl,
	                this._textureTarget,
	                0,
	                this._internalFormat,
	                this._internalFormat,
	                this._type,
	                image.getImage() );
	        }
	        image.setDirty( false );
	
	    },
	
	    apply: function ( state ) {
	
	        var gl = state.getGraphicContext();
	        // if need to release the texture
	        if ( this._dirtyTextureObject ) {
	            this.releaseGLObjects();
	            this._dirtyTextureObject = false;
	        }
	
	        if ( this._textureObject !== undefined && !this.isDirty() ) {
	            this._textureObject.bind( gl );
	            // If we have modified the texture via Rtt or texSubImage2D and _need_ updated mipmaps,
	            // then we must regenerate the mipmaps explicitely.
	            // In all other cases, don't set this flag because it can be costly
	            if ( this.isDirtyMipmap() ) {
	                this.generateMipmap( gl, this._textureTarget );
	            }
	
	            // image update like video
	            if ( this._image !== undefined && this._image.isDirty() ) {
	                this.applyImage( gl, this._image );
	            }
	
	        } else if ( this._textureNull ) {
	
	            gl.bindTexture( this._textureTarget, null );
	
	        } else {
	
	            var image = this._image;
	            if ( image !== undefined ) {
	
	                // when data is ready we will upload it to the gpu
	                if ( image.isReady() ) {
	
	                    // must be called before init
	                    this.computeTextureFormat();
	
	                    var imgWidth = image.getWidth() || this._textureWidth;
	                    var imgHeight = image.getHeight() || this._textureHeight;
	
	                    this.setTextureSize( imgWidth, imgHeight );
	
	                    if ( !this._textureObject ) {
	                        this.init( state );
	                    }
	
	                    this._textureObject.bind( gl );
	
	                    this.applyImage( gl, this._image );
	                    this.applyFilterParameter( gl, this._textureTarget );
	                    this.generateMipmap( gl, this._textureTarget );
	
	                    if ( this._unrefImageDataAfterApply ) {
	                        this._image = undefined;
	                    }
	
	                    this._dirty = false;
	
	                } else {
	                    gl.bindTexture( this._textureTarget, null );
	                }
	
	            } else if ( this._textureHeight !== 0 && this._textureWidth !== 0 ) {
	
	                // must be called before init
	                this.computeTextureFormat();
	
	                if ( !this._textureObject ) {
	                    this.init( state );
	                }
	                this._textureObject.bind( gl );
	                this.applyTexImage2D( gl, this._textureTarget, 0, this._internalFormat, this._textureWidth, this._textureHeight, 0, this._internalFormat, this._type, null );
	
	                this.applyFilterParameter( gl, this._textureTarget );
	                this.generateMipmap( gl, this._textureTarget );
	                this._dirty = false;
	            }
	        }
	    }
	
	} ) ), 'osg', 'Texture' );
	
	MACROUTILS.setTypeID( Texture );
	
	Texture.textureNull = new Texture();
	
	Texture.createFromImage = function ( image, format ) {
	    var a = new Texture();
	    a.setImage( image, format );
	    return a;
	};
	
	Texture.createFromCanvas = function ( canvas, format ) {
	    return Texture.createFromImage( canvas, format );
	};
	
	Texture.create = function ( url ) {
	    Notify.log( 'Texture.create is deprecated, use Texture.createFromURL instead' );
	    return Texture.createFromURL( url );
	};
	
	Texture.createFromURL = function ( imageSource, format ) {
	    Notify.log( 'Texture.createFromURL is deprecated, use instead osgDB.readImageURL' );
	    var texture = new Texture();
	    ReaderParser.readImage( imageSource ).then( function ( img ) {
	        texture.setImage( img, format );
	    } );
	    return texture;
	};
	
	
	module.exports = Texture;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	
	
	/**
	 * Uniform manage variable used in glsl shader.
	 * @class Uniform
	 */
	var Uniform = function ( name ) {
	    this._data = undefined;
	    this._transpose = false;
	    this._glCall = '';
	    this._cache = undefined;
	    this._name = name;
	    this._type = undefined;
	    this._isMatrix = false;
	};
	
	Uniform.isUniform = function ( obj ) {
	    if ( typeof obj === 'object' && window.Object.getPrototypeOf( obj ) === Uniform.prototype ) {
	        return true;
	    }
	    return false;
	};
	
	/** @lends Uniform.prototype */
	Uniform.prototype = {
	
	    getName: function () {
	        return this._name;
	    },
	
	    dirty: function () {
	        Notify.log( 'deprecated dont use Uniform.dirty anymore' );
	    },
	
	    getType: function () {
	        return this._type;
	    },
	
	    get: function () {
	        Notify.log( 'deprecated use getInternalArray instead' );
	        return this._data;
	    },
	
	    set: function ( array ) {
	        Notify.log( 'deprecated use setFloat/setInt instead' );
	        var value = array;
	        if ( !Array.isArray( value ) && value.byteLength === undefined )
	            this._data[ 0 ] = value;
	        else
	            this._data = array;
	    },
	
	    apply: function UniformApply( gl, location ) {
	
	        if ( !this._cache )
	            this._cache = gl[ this._glCall ];
	
	        if ( this._isMatrix )
	            this._cache.call( gl, location, this._transpose, this._data );
	        else
	            this._cache.call( gl, location, this._data );
	    },
	
	    // no type checking, so array should be valid
	    setInternalArray: function ( array ) {
	        this._data = array;
	    },
	
	    getInternalArray: function () {
	        return this._data;
	    },
	
	    setFloat: function ( f ) {
	        this._data[ 0 ] = f;
	    },
	
	    setFloat1: function ( f ) {
	        this._data[ 0 ] = f[ 0 ];
	    },
	
	    setFloat2: function ( f ) {
	        this._data[ 0 ] = f[ 0 ];
	        this._data[ 1 ] = f[ 1 ];
	    },
	
	    setFloat3: function ( f ) {
	        this._data[ 0 ] = f[ 0 ];
	        this._data[ 1 ] = f[ 1 ];
	        this._data[ 2 ] = f[ 2 ];
	    },
	
	    setFloat4: function ( f ) {
	        this._data[ 0 ] = f[ 0 ];
	        this._data[ 1 ] = f[ 1 ];
	        this._data[ 2 ] = f[ 2 ];
	        this._data[ 3 ] = f[ 3 ];
	    },
	
	    setFloat9: function ( f ) {
	        this._data[ 0 ] = f[ 0 ];
	        this._data[ 1 ] = f[ 1 ];
	        this._data[ 2 ] = f[ 2 ];
	        this._data[ 3 ] = f[ 3 ];
	        this._data[ 4 ] = f[ 4 ];
	        this._data[ 5 ] = f[ 5 ];
	        this._data[ 6 ] = f[ 6 ];
	        this._data[ 7 ] = f[ 7 ];
	        this._data[ 8 ] = f[ 8 ];
	    },
	
	    setFloat16: function ( f ) {
	        this._data[ 0 ] = f[ 0 ];
	        this._data[ 1 ] = f[ 1 ];
	        this._data[ 2 ] = f[ 2 ];
	        this._data[ 3 ] = f[ 3 ];
	        this._data[ 4 ] = f[ 4 ];
	        this._data[ 5 ] = f[ 5 ];
	        this._data[ 6 ] = f[ 6 ];
	        this._data[ 7 ] = f[ 7 ];
	        this._data[ 8 ] = f[ 8 ];
	        this._data[ 9 ] = f[ 9 ];
	        this._data[ 10 ] = f[ 10 ];
	        this._data[ 11 ] = f[ 11 ];
	        this._data[ 12 ] = f[ 12 ];
	        this._data[ 13 ] = f[ 13 ];
	        this._data[ 14 ] = f[ 14 ];
	        this._data[ 15 ] = f[ 15 ];
	    }
	};
	Uniform.prototype.setVec2 = Uniform.prototype.setFloat2;
	Uniform.prototype.setVec3 = Uniform.prototype.setFloat3;
	Uniform.prototype.setVec4 = Uniform.prototype.setFloat4;
	Uniform.prototype.setMatrix4 = Uniform.prototype.setFloat16;
	Uniform.prototype.setMatrix3 = Uniform.prototype.setFloat9;
	Uniform.prototype.setInt = Uniform.prototype.setFloat;
	Uniform.prototype.setInt1 = Uniform.prototype.setFloat1;
	Uniform.prototype.setInt2 = Uniform.prototype.setFloat2;
	Uniform.prototype.setInt3 = Uniform.prototype.setFloat3;
	Uniform.prototype.setInt4 = Uniform.prototype.setFloat4;
	
	
	var createUniformX = function ( dataOrName, uniformName, defaultConstructor, glSignature, type, isMatrix ) {
	    var data = uniformName === undefined ? undefined : dataOrName;
	    var uniform = new Uniform( uniformName === undefined ? dataOrName : uniformName );
	
	    uniform._data = defaultConstructor();
	
	    if ( data !== undefined ) {
	        if ( data.length ) {
	            for ( var i = 0, nbElts = data.length; i < nbElts; ++i )
	                uniform._data[ i ] = data[ i ];
	        } else {
	            uniform._data[ 0 ] = data;
	        }
	    }
	
	    uniform._glCall = glSignature;
	    uniform._type = type;
	    uniform._isMatrix = !!isMatrix;
	    return uniform;
	};
	
	var constructorFloat = function () {
	    return new Float32Array( 1 );
	};
	
	var constructorFloat2 = function () {
	    return new Float32Array( 2 );
	};
	
	var constructorFloat3 = function () {
	    return new Float32Array( 3 );
	};
	
	var constructorFloat4 = function () {
	    return new Float32Array( 4 );
	};
	
	var constructorInt = function () {
	    return new Int32Array( 1 );
	};
	
	var constructorInt2 = function () {
	    return new Int32Array( 2 );
	};
	
	var constructorInt3 = function () {
	    return new Int32Array( 3 );
	};
	
	var constructorInt4 = function () {
	    return new Int32Array( 4 );
	};
	
	var constructorMat2 = function () {
	    var out = new Float32Array( 4 );
	    out[ 0 ] = out[ 3 ] = 1.0;
	    return out;
	};
	
	var constructorMat3 = function () {
	    var out = new Float32Array( 9 );
	    out[ 0 ] = out[ 4 ] = out[ 8 ] = 1.0;
	    return out;
	};
	
	var constructorMat4 = function () {
	    var out = new Float32Array( 16 );
	    out[ 0 ] = out[ 5 ] = out[ 10 ] = out[ 15 ] = 1.0;
	    return out;
	};
	
	// works also for float array but data must be given
	Uniform.createFloat1 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorFloat, 'uniform1fv', 'float' );
	};
	
	Uniform.createInt1 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorInt, 'uniform1iv', 'int' );
	};
	
	Uniform.createFloat2 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorFloat2, 'uniform2fv', 'vec2' );
	};
	
	Uniform.createInt2 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorInt2, 'uniform2iv', 'vec2i' );
	};
	
	Uniform.createFloat3 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorFloat3, 'uniform3fv', 'vec3' );
	};
	
	Uniform.createInt3 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorInt3, 'uniform3iv', 'vec3i' );
	};
	
	Uniform.createFloat4 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorFloat4, 'uniform4fv', 'vec4' );
	};
	
	Uniform.createInt4 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorInt4, 'uniform4iv', 'vec4i' );
	};
	
	Uniform.createMatrix2 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorMat2, 'uniformMatrix2fv', 'mat2', true );
	};
	
	Uniform.createMatrix3 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorMat3, 'uniformMatrix3fv', 'mat3', true );
	};
	
	Uniform.createMatrix4 = function ( data, uniformName ) {
	    return createUniformX( data, uniformName, constructorMat4, 'uniformMatrix4fv', 'mat4', true );
	};
	
	// alias
	Uniform.float = Uniform.createFloatArray = Uniform.createFloat = Uniform.createFloat1;
	Uniform.int = Uniform.createIntArray = Uniform.createInt = Uniform.createInt1;
	
	Uniform.vec2 = Uniform.createFloat2Array = Uniform.createFloat2;
	Uniform.vec2i = Uniform.createInt2Array = Uniform.createInt2;
	
	Uniform.vec3 = Uniform.createFloat3Array = Uniform.createFloat3;
	Uniform.vec3i = Uniform.createInt3Array = Uniform.createInt3;
	
	Uniform.vec4 = Uniform.createFloat4Array = Uniform.createFloat4;
	Uniform.vec4i = Uniform.createInt4Array = Uniform.createInt4;
	
	Uniform.mat2 = Uniform.createMat2 = Uniform.createMatrix2;
	Uniform.mat3 = Uniform.createMat3 = Uniform.createMatrix3;
	Uniform.mat4 = Uniform.createMat4 = Uniform.createMatrix4;
	
	module.exports = Uniform;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	
	
	var ImageObject = function ( image ) {
	    Object.call( this );
	
	    this._imageObject = undefined;
	    this._url = undefined;
	    this._width = undefined;
	    this._height = undefined;
	    this._dirty = true;
	    this._mipmap = [];
	
	    if ( image ) {
	        this.setImage( image );
	    }
	
	    this._isGreyscale = undefined;
	};
	
	ImageObject.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	
	    dirty: function () {
	        this._isGreyscale = undefined;
	        this._dirty = true;
	    },
	
	    isDirty: function () {
	        return this._dirty;
	    },
	
	    setDirty: function ( bool ) {
	        this._dirty = bool;
	    },
	
	    getImage: function () {
	        return ( this._imageObject instanceof ImageObject ) ? this._imageObject.getImage() : this._imageObject;
	    },
	
	    getURL: function () {
	        return this._url;
	    },
	
	    setURL: function ( url ) {
	        this._url = url;
	    },
	
	    useOrCreateImage: function ( img ) {
	        return ( img instanceof( ImageObject ) === false ) ? new ImageObject( img ) : img;
	    },
	
	    setImage: function ( img ) {
	        if ( !this._url && img && ( img.src || img.currentSrc ) ) {
	            // TODO what is currentSrc ?
	            this._url = img.src || img.currentSrc;
	        }
	
	        this._mipmap.length = 0;
	
	        // img can be an image or an array of image if specify the
	        // all mipmap levels
	        if ( Array.isArray( img ) ) {
	            for ( var i = 0, nbImg = img.length; i < nbImg; i++ ) {
	                this._mipmap.push( this.useOrCreateImage( img[ i ] ) );
	            }
	            this.setWidth( this._mipmap[ 0 ].getWidth() );
	            this.setHeight( this._mipmap[ 0 ].getHeight() );
	        } else {
	            this._mipmap.push( img );
	        }
	
	        this._imageObject = this._mipmap[ 0 ];
	        this.dirty();
	    },
	
	    isCanvas: function () {
	        return this.getImage() instanceof window.HTMLCanvasElement;
	    },
	
	    isVideo: function () {
	        return this.getImage() instanceof window.HTMLVideoElement;
	    },
	
	    isImage: function () {
	        return this.getImage() instanceof window.Image;
	    },
	
	    isTypedArray: function () {
	        var img = this.getImage();
	        return img instanceof Uint8Array || img instanceof Float32Array || img instanceof Uint16Array;
	    },
	
	    setWidth: function ( w ) {
	        this._width = w;
	    },
	
	    setHeight: function ( h ) {
	        this._height = h;
	    },
	
	    getWidth: function () {
	        var img = this.getImage();
	        if ( this.isImage() ) {
	            return img.naturalWidth;
	        } else if ( this.isVideo() ) {
	            return img.videoWidth;
	        } else if ( this.isCanvas() ) {
	            return img.width;
	        }
	        return this._width;
	    },
	
	    getHeight: function () {
	        var img = this.getImage();
	        if ( this.isImage() ) {
	            return img.naturalHeight;
	        } else if ( this.isVideo() ) {
	            return img.videoHeight;
	        } else if ( this.isCanvas() ) {
	            return img.height;
	        }
	        return this._height;
	    },
	
	    isGreyscale: function ( nbSamples ) {
	        if ( this._isGreyscale !== undefined )
	            return this._isGreyscale;
	
	        if ( this._imageObject !== undefined && this.isReady() && this._isGreyscale === undefined ) {
	
	            var canvas = this._imageObject;
	            if ( !this.isCanvas() ) {
	                canvas = document.createElement( 'canvas' );
	            }
	            var ctx = canvas.getContext( '2d' );
	            canvas.width = this._imageObject.width;
	            canvas.height = this._imageObject.height;
	            ctx.drawImage( this._imageObject, 0, 0 );
	
	            var sampleX, sampleY;
	            // cap sample if needed
	            if ( !nbSamples ) {
	                sampleX = canvas.width;
	                sampleY = canvas.height;
	            }
	            if ( nbSamples > 0 ) {
	                nbSamples = Math.min( Math.min( canvas.width, canvas.height ), nbSamples );
	                sampleX = sampleY = nbSamples;
	            }
	
	            var isGreyscale = true;
	            var xFactor = canvas.width / ( sampleX );
	            var yFactor = canvas.height / ( sampleY );
	            for ( var i = 0; i < sampleX; i++ ) {
	                for ( var j = 0; j < sampleY; j++ ) {
	                    var x = Math.floor( xFactor * ( i + 0.5 ) ),
	                        y = Math.floor( yFactor * ( j + 0.5 ) );
	                    var data = ctx.getImageData( x, y, 1, 1 ).data;
	                    if ( !( data[ 0 ] === data[ 1 ] && data[ 0 ] === data[ 2 ] ) ) {
	                        isGreyscale = false;
	                        break;
	                    }
	                }
	            }
	            this._isGreyscale = isGreyscale;
	        }
	
	        return this._isGreyscale;
	    },
	
	    isReady: function () {
	
	        // image is a osgImage
	        if ( this._imageObject && this._imageObject instanceof ImageObject ) {
	            return this._imageObject.isReady();
	        }
	
	
	        // image are ready for static data
	        if ( this.isCanvas() ||
	            this.isTypedArray() ) {
	            return true;
	        }
	
	        if ( this.isImage() ) {
	            var image = this.getImage();
	            if ( image.complete ) {
	                if ( image.naturalWidth !== undefined && image.naturalWidth === 0 ) {
	                    return false;
	                }
	
	                return true;
	            }
	        }
	
	        if ( this.isVideo() ) {
	            if ( this.getWidth() !== 0 ) return true;
	        }
	
	        // here means we have something but we don't know what
	        // Check if the object is not a image
	        // by "feature" detect it
	        var imageTry = this.getImage();
	        if ( imageTry.complete ) {
	            if ( imageTry.naturalWidth !== undefined && imageTry.naturalWidth === 0 ) {
	                return false;
	            }
	            return true;
	        }
	
	        // It's not something we recognise
	        return false;
	    },
	
	    getMipmap: function () {
	        return this._mipmap;
	    },
	
	    hasMipmap: function () {
	        return this._mipmap.length > 1;
	    },
	
	    release: function () {
	        this._mipmap.length = 0;
	        this._imageObject = undefined;
	    }
	} ), 'osg', 'Image' );
	
	MACROUTILS.setTypeID( ImageObject );
	
	module.exports = ImageObject;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';
	
	// Base class for GLResources: Textures, Buffers, Programs, Shaders, FrameBuffers and RenderBuffers
	// It holds a reference to the graphic context that is needed for resource deletion
	
	var GLObject = function () {
	    this._gl = undefined;
	};
	
	GLObject.prototype = {
	    setGraphicContext: function ( gl ) {
	        this._gl = gl;
	    },
	    getGraphicContext: function () {
	        return this._gl;
	    }
	};
	
	module.exports = GLObject;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Uniform = __webpack_require__( 35 );
	var BlendFunc = __webpack_require__( 39 );
	var Geometry = __webpack_require__( 31 );
	var BufferArray = __webpack_require__( 40 );
	var PrimitiveSet = __webpack_require__( 41 );
	var DrawArrays = __webpack_require__( 42 );
	var DrawElements = __webpack_require__( 43 );
	var StateSet = __webpack_require__( 19 );
	var Node = __webpack_require__( 12 );
	var Matrix = __webpack_require__( 23 );
	var MatrixTransform = __webpack_require__( 44 );
	var Projection = __webpack_require__( 45 );
	
	
	var ReaderParser = {};
	
	ReaderParser.ObjectWrapper = {};
	ReaderParser.ObjectWrapper.serializers = {};
	
	ReaderParser.readImage = function ( url, options ) {
	    return ReaderParser.registry().readImageURL( url, options );
	};
	ReaderParser.readImageURL = ReaderParser.readImage; // alias
	
	ReaderParser.readBinaryArrayURL = function ( url, options ) {
	    return ReaderParser.registry().readBinaryArrayURL( url, options );
	};
	
	ReaderParser.readNodeURL = function ( url, options ) {
	    return ReaderParser.registry().readNodeURL( url, options );
	};
	
	ReaderParser.registry = function () {
	    var Input = __webpack_require__( 46 );
	    if ( ReaderParser.registry._input === undefined ) {
	        ReaderParser.registry._input = new Input();
	    }
	    return ReaderParser.registry._input;
	};
	
	ReaderParser.parseSceneGraph = function ( node, options ) {
	    if ( node.Version !== undefined && node.Version > 0 ) {
	        MACROUTILS.time( 'osgjs.metric:ReaderParser.parseSceneGraph' );
	
	        var getPropertyValue = function ( o ) {
	            var props = window.Object.keys( o );
	            for ( var i = 0, l = props.length; i < l; i++ ) {
	                if ( props[ i ] !== 'Generator' && props[ i ] !== 'Version' ) {
	                    return props[ i ];
	                }
	            }
	            return undefined;
	        };
	
	        var key = getPropertyValue( node );
	        if ( key ) {
	            var obj = {};
	            obj[ key ] = node[ key ];
	            var input = ReaderParser.registry().clone();
	            input.setJSON( obj );
	
	            // copy global options and override with user options
	            var opt = MACROUTILS.objectMix( MACROUTILS.objectMix( {}, ReaderParser.registry().getOptions() ), options || {} );
	            input.setOptions( opt );
	            var object = input.readObject();
	            MACROUTILS.timeEnd( 'osgjs.metric:ReaderParser.parseSceneGraph' );
	            return object;
	        } else {
	            Notify.log( 'can\'t parse scenegraph ' + node );
	        }
	    } else {
	        MACROUTILS.time( 'osgjs.metric:ReaderParser.parseSceneGraphDeprecated' );
	        var nodeOld = ReaderParser.parseSceneGraphDeprecated( node );
	        MACROUTILS.timeEnd( 'osgjs.metric:ReaderParser.parseSceneGraphDeprecated' );
	        return nodeOld;
	    }
	    return undefined;
	};
	
	ReaderParser.parseSceneGraphDeprecated = function ( node ) {
	    var getFieldBackwardCompatible = function ( field, json ) {
	        var value = json[ field ];
	        if ( value === undefined ) {
	            value = json[ field.toLowerCase() ];
	        }
	        return value;
	    };
	    var setName = function ( osgjs, json ) {
	        var name = getFieldBackwardCompatible( 'Name', json );
	        if ( name && osgjs.setName !== undefined ) {
	            osgjs.setName( name );
	        }
	    };
	
	    var setMaterial = function ( osgjs, json ) {
	        setName( osgjs, json );
	        osgjs.setAmbient( getFieldBackwardCompatible( 'Ambient', json ) );
	        osgjs.setDiffuse( getFieldBackwardCompatible( 'Diffuse', json ) );
	        osgjs.setEmission( getFieldBackwardCompatible( 'Emission', json ) );
	        osgjs.setSpecular( getFieldBackwardCompatible( 'Specular', json ) );
	        osgjs.setShininess( getFieldBackwardCompatible( 'Shininess', json ) );
	    };
	
	    var setBlendFunc = function ( osgjs, json ) {
	        setName( osgjs, json );
	        osgjs.setSourceRGB( json.SourceRGB );
	        osgjs.setSourceAlpha( json.SourceAlpha );
	        osgjs.setDestinationRGB( json.DestinationRGB );
	        osgjs.setDestinationAlpha( json.DestinationAlpha );
	    };
	
	    var setTexture = function ( osgjs, json ) {
	        var magFilter = json.MagFilter || json[ 'mag_filter' ] || undefined;
	        if ( magFilter ) {
	            osgjs.setMagFilter( magFilter );
	        }
	        var minFilter = json.MinFilter || json[ 'min_filter' ] || undefined;
	        if ( minFilter ) {
	            osgjs.setMinFilter( minFilter );
	        }
	        var wrapT = json.WrapT || json[ 'wrap_t' ] || undefined;
	        if ( wrapT ) {
	            osgjs.setWrapT( wrapT );
	        }
	        var wrapS = json.WrapS || json[ 'wrap_s' ] || undefined;
	        if ( wrapS ) {
	            osgjs.setWrapS( wrapS );
	        }
	        var file = getFieldBackwardCompatible( 'File', json );
	        ReaderParser.readImage( file ).then( function ( img ) {
	            osgjs.setImage( img );
	        } ).catch( function () {
	            Notify.log( 'Can\'t read image' );
	        } );
	    };
	
	    var setStateSet = function ( osgjs, json ) {
	        setName( osgjs, json );
	        var textures = getFieldBackwardCompatible( 'Textures', json ) || getFieldBackwardCompatible( 'TextureAttributeList', json ) || undefined;
	        if ( textures ) {
	            for ( var t = 0, tl = textures.length; t < tl; t++ ) {
	                var file = getFieldBackwardCompatible( 'File', textures[ t ] );
	                if ( !file ) {
	                    Notify.log( 'no texture on unit ' + t + ' skip it' );
	                    continue;
	                }
	                var Texture = __webpack_require__( 34 );
	                var tex = new Texture();
	                setTexture( tex, textures[ t ] );
	
	                osgjs.setTextureAttributeAndModes( t, tex );
	                osgjs.addUniform( Uniform.createInt1( t, 'Texture' + t ) );
	            }
	        }
	
	        var blendfunc = getFieldBackwardCompatible( 'BlendFunc', json );
	        if ( blendfunc ) {
	            var newblendfunc = new BlendFunc();
	            setBlendFunc( newblendfunc, blendfunc );
	            osgjs.setAttributeAndModes( newblendfunc );
	        }
	
	        var material = getFieldBackwardCompatible( 'Material', json );
	        if ( material ) {
	            var Material = __webpack_require__( 51 );
	            var newmaterial = new Material();
	            setMaterial( newmaterial, material );
	            osgjs.setAttributeAndModes( newmaterial );
	        }
	    };
	
	
	    var newnode;
	    var children = node.children;
	    var primitives = node.primitives || node.Primitives || undefined;
	    var attributes = node.attributes || node.Attributes || undefined;
	    if ( primitives || attributes ) {
	
	        var geom = new Geometry();
	        setName( geom, node );
	        geom.stateset = node.stateset;
	        node = geom;
	
	        for ( var p = 0, lp = primitives.length; p < lp; p++ ) {
	            var mode = primitives[ p ].mode;
	            if ( primitives[ p ].indices ) {
	                var array = primitives[ p ].indices;
	                array = new BufferArray( BufferArray[ array.type ], array.elements, array.itemSize );
	                if ( !mode ) {
	                    mode = 'TRIANGLES';
	                } else {
	                    mode = PrimitiveSet[ mode ];
	                }
	                geom.getPrimitiveSetList().push( new DrawElements( mode, array ) );
	            } else {
	                mode = PrimitiveSet[ mode ];
	                var first = primitives[ p ].first;
	                var count = primitives[ p ].count;
	
	                geom.getPrimitiveSetList().push( new DrawArrays( mode, first, count ) );
	            }
	        }
	
	        var attrKeys = window.Object.keys( attributes );
	        for ( var i = 0, li = attrKeys.length; i < li; i++ ) {
	            var key = attrKeys[ i ];
	            var attributeArray = attributes[ key ];
	            geom.getVertexAttributeList()[ key ] = new BufferArray( attributeArray.type, attributeArray.elements, attributeArray.itemSize );
	        }
	
	    }
	
	    var stateset = getFieldBackwardCompatible( 'StateSet', node );
	    if ( stateset ) {
	        var newstateset = new StateSet();
	        setStateSet( newstateset, stateset );
	        node.stateset = newstateset;
	    }
	
	    var matrix = node.matrix || node.Matrix || undefined;
	    if ( matrix ) {
	        newnode = new MatrixTransform();
	        setName( newnode, node );
	
	        MACROUTILS.extend( newnode, node );
	        Matrix.copy( matrix, newnode.getMatrix() );
	        node = newnode;
	    }
	
	    var projection = node.projection || node.Projection || undefined;
	    if ( projection ) {
	        newnode = new Projection();
	        setName( newnode, node );
	        MACROUTILS.extend( newnode, node );
	        Matrix.copy( projection, newnode.setProjectionMatrix() );
	        node = newnode;
	    }
	
	    // default type
	    if ( node.typeID === undefined ) {
	        newnode = new Node();
	        setName( newnode, node );
	        MACROUTILS.extend( newnode, node );
	        node = newnode;
	    }
	
	
	    if ( children ) {
	        // disable children, it will be processed in the end
	        node.children = [];
	
	        for ( var child = 0, childLength = children.length; child < childLength; child++ ) {
	            node.addChild( ReaderParser.parseSceneGraphDeprecated( children[ child ] ) );
	        }
	    }
	
	    return node;
	};
	
	module.exports = ReaderParser;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	
	/**
	 *  Manage Blending mode
	 *  @class BlendFunc
	 */
	var BlendFunc = function ( sourceRGB, destinationRGB, sourceAlpha, destinationAlpha ) {
	    StateAttribute.call( this );
	    this._sourceFactor = BlendFunc.DISABLE;
	    this._destinationFactor = BlendFunc.DISABLE;
	    this._sourceFactorAlpha = this._sourceFactor;
	    this._destinationFactorAlpha = this._destinationFactor;
	    this._separate = false;
	    if ( sourceRGB !== undefined ) {
	        this.setSource( sourceRGB );
	    }
	    if ( destinationRGB !== undefined ) {
	        this.setDestination( destinationRGB );
	    }
	
	    if ( sourceAlpha !== undefined ) {
	        this.setSourceAlpha( sourceAlpha );
	    }
	    if ( destinationAlpha !== undefined ) {
	        this.setDestinationAlpha( destinationAlpha );
	    }
	};
	
	BlendFunc.DISABLE = -1;
	BlendFunc.ZERO = 0;
	BlendFunc.ONE = 1;
	BlendFunc.SRC_COLOR = 0x0300;
	BlendFunc.ONE_MINUS_SRC_COLOR = 0x0301;
	BlendFunc.SRC_ALPHA = 0x0302;
	BlendFunc.ONE_MINUS_SRC_ALPHA = 0x0303;
	BlendFunc.DST_ALPHA = 0x0304;
	BlendFunc.ONE_MINUS_DST_ALPHA = 0x0305;
	BlendFunc.DST_COLOR = 0x0306;
	BlendFunc.ONE_MINUS_DST_COLOR = 0x0307;
	BlendFunc.SRC_ALPHA_SATURATE = 0x0308;
	
	/* Separate Blend Functions */
	BlendFunc.BLEND_DST_RGB = 0x80C8;
	BlendFunc.BLEND_SRC_RGB = 0x80C9;
	BlendFunc.BLEND_DST_ALPHA = 0x80CA;
	BlendFunc.BLEND_SRC_ALPHA = 0x80CB;
	BlendFunc.CONSTANT_COLOR = 0x8001;
	BlendFunc.ONE_MINUS_CONSTANT_COLOR = 0x8002;
	BlendFunc.CONSTANT_ALPHA = 0x8003;
	BlendFunc.ONE_MINUS_CONSTANT_ALPHA = 0x8004;
	BlendFunc.BLEND_COLOR = 0x8005;
	
	
	/** @lends BlendFunc.prototype */
	BlendFunc.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	    /**
	  StateAttribute type of BlendFunc
	  @type String
	   */
	    attributeType: 'BlendFunc',
	    /**
	    Create an instance of this StateAttribute
	    */
	    cloneType: function () /**BlendFunc*/ {
	        return new BlendFunc();
	    },
	    setSource: function ( f ) {
	        this.setSourceRGB( f );
	        this.setSourceAlpha( f );
	    },
	    getSource: function () {
	        return this._sourceFactor;
	    },
	    setDestination: function ( f ) {
	        this.setDestinationRGB( f );
	        this.setDestinationAlpha( f );
	    },
	    getDestination: function () {
	        return this._destinationFactor;
	    },
	    getSeparate: function () {
	        return this._separate;
	    },
	    checkSeparate: function () {
	        return ( this._sourceFactor !== this._sourceFactorAlpha ||
	            this._destinationFactor !== this._destinationFactorAlpha );
	    },
	    setSourceRGB: function ( f ) {
	        if ( typeof f === 'string' ) {
	            this._sourceFactor = BlendFunc[ f ];
	        } else {
	            this._sourceFactor = f;
	        }
	        this._separate = this.checkSeparate();
	    },
	    getSourceRGB: function () {
	        return this._sourceFactor;
	    },
	    setSourceAlpha: function ( f ) {
	        if ( typeof f === 'string' ) {
	            this._sourceFactorAlpha = BlendFunc[ f ];
	        } else {
	            this._sourceFactorAlpha = f;
	        }
	        this._separate = this.checkSeparate();
	    },
	    getSourceAlpha: function () {
	        return this._sourceFactorAlpha;
	    },
	    setDestinationRGB: function ( f ) {
	        if ( typeof f === 'string' ) {
	            this._destinationFactor = BlendFunc[ f ];
	        } else {
	            this._destinationFactor = f;
	        }
	        this._separate = this.checkSeparate();
	    },
	    getDestinationRGB: function () {
	        return this._destinationFactor;
	    },
	    setDestinationAlpha: function ( f ) {
	        if ( typeof f === 'string' ) {
	            this._destinationFactorAlpha = BlendFunc[ f ];
	        } else {
	            this._destinationFactorAlpha = f;
	        }
	        this._separate = this.checkSeparate();
	    },
	    getDestinationAlpha: function () {
	        return this._destinationFactorAlpha;
	    },
	
	    /**
	      Apply the mode, must be called in the draw traversal
	      @param state
	  */
	    apply: function ( state ) {
	        var gl = state.getGraphicContext();
	        if ( this._sourceFactor === BlendFunc.DISABLE || this._destinationFactor === BlendFunc.DISABLE ) {
	            gl.disable( gl.BLEND );
	        } else {
	            gl.enable( gl.BLEND );
	            if ( this._separate ) {
	                gl.blendFuncSeparate( this._sourceFactor, this._destinationFactor,
	                    this._sourceFactorAlpha, this._destinationFactorAlpha );
	            } else {
	                gl.blendFunc( this._sourceFactor, this._destinationFactor );
	            }
	        }
	    }
	} ), 'osg', 'BlendFunc' );
	
	module.exports = BlendFunc;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Notify = __webpack_require__( 10 );
	var Object = __webpack_require__( 13 );
	var GLObject = __webpack_require__( 37 );
	var Timer = __webpack_require__( 9 );
	
	
	var getAttributeType = function ( array ) {
	    var type;
	
	    if ( array instanceof MACROUTILS.Float32Array ) type = 0x1406;
	    if ( array instanceof MACROUTILS.Uint32Array ) type = 0x1405;
	    if ( array instanceof MACROUTILS.Uint16Array ) type = 0x1403;
	    if ( array instanceof MACROUTILS.Uint8Array ) type = 0x1401;
	
	    return type;
	};
	
	/**
	 * BufferArray manage vertex / normal / ... array used by webgl.
	 * osgjs automatically converts array buffers to Float32Array and
	 * element array buffers to Uint16Array if not said explicitly with
	 * preserveArrayType variable in constructor.
	 * @class BufferArray
	 */
	
	var BufferArray = function ( target, elements, itemSize, preserveArrayType ) {
	
	    GLObject.call( this );
	    // maybe could inherit from Object
	    this._instanceID = Object.getInstanceID();
	
	    this.dirty();
	
	    this._itemSize = itemSize;
	    this._target = typeof target === 'string' ? BufferArray[ target ] : target;
	
	    // initialized by setElements
	    this._type = undefined;
	    this._normalize = false;
	
	    if ( elements !== undefined ) {
	        var typedArray = elements;
	        if ( !preserveArrayType ) {
	            if ( this._target === BufferArray.ELEMENT_ARRAY_BUFFER ) {
	                typedArray = elements instanceof MACROUTILS.Uint16Array ? elements : new MACROUTILS.Uint16Array( elements );
	            } else {
	                typedArray = elements instanceof MACROUTILS.Float32Array ? elements : new MACROUTILS.Float32Array( elements );
	            }
	        }
	        this.setElements( typedArray );
	    }
	};
	
	BufferArray.ELEMENT_ARRAY_BUFFER = 0x8893;
	BufferArray.ARRAY_BUFFER = 0x8892;
	
	// static cache of glBuffers flagged for deletion, which will actually
	// be deleted in the correct GL context.
	BufferArray._sDeletedGLBufferArrayCache = new window.Map();
	
	// static method to delete Program
	BufferArray.deleteGLBufferArray = function ( gl, buffer ) {
	    if ( !BufferArray._sDeletedGLBufferArrayCache.has( gl ) )
	        BufferArray._sDeletedGLBufferArrayCache.set( gl, [] );
	    BufferArray._sDeletedGLBufferArrayCache.get( gl ).push( buffer );
	};
	
	// static method to flush all the cached glPrograms which need to be deleted in the GL context specified
	BufferArray.flushDeletedGLBufferArrays = function ( gl, availableTime ) {
	    // if no time available don't try to flush objects.
	    if ( availableTime <= 0.0 ) return availableTime;
	    if ( !BufferArray._sDeletedGLBufferArrayCache.has( gl ) ) return availableTime;
	    var elapsedTime = 0.0;
	    var beginTime = Timer.instance().tick();
	    var deleteList = BufferArray._sDeletedGLBufferArrayCache.get( gl );
	    var numBuffers = deleteList.length;
	    for ( var i = numBuffers - 1; i >= 0 && elapsedTime < availableTime; i-- ) {
	        gl.deleteBuffer( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	    }
	    return availableTime - elapsedTime;
	};
	
	BufferArray.flushAllDeletedGLBufferArrays = function ( gl ) {
	    if ( !BufferArray._sDeletedGLBufferArrayCache.has( gl ) ) return;
	    var deleteList = BufferArray._sDeletedGLBufferArrayCache.get( gl );
	    var numBuffers = deleteList.length;
	    for ( var i = numBuffers - 1; i >= 0; i-- ) {
	        gl.deleteBuffer( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	    }
	};
	
	/** @lends BufferArray.prototype */
	BufferArray.prototype = MACROUTILS.objectInherit( GLObject.prototype, {
	    getInstanceID: function () {
	        return this._instanceID;
	    },
	    setItemSize: function ( size ) {
	        this._itemSize = size;
	    },
	    isValid: function () {
	        if ( this._buffer !== undefined ||
	            this._elements !== undefined ) {
	            return true;
	        }
	        return false;
	    },
	
	    releaseGLObjects: function () {
	        if ( this._buffer !== undefined && this._buffer !== null && this._gl !== undefined ) {
	            BufferArray.deleteGLBufferArray( this._gl, this._buffer );
	        }
	        this._buffer = undefined;
	    },
	
	    setNormalize: function ( normalize ) {
	        this._normalize = normalize;
	    },
	
	    getNormalize: function () {
	        return this._normalize;
	    },
	
	    bind: function ( gl ) {
	        if ( !this._gl ) this.setGraphicContext( gl );
	        var target = this._target;
	        var buffer = this._buffer;
	
	        if ( buffer ) {
	            gl.bindBuffer( target, buffer );
	            return;
	        }
	
	        if ( !buffer && this._elements.length > 0 ) {
	            this._buffer = gl.createBuffer();
	            this._numItems = this._elements.length / this._itemSize;
	            gl.bindBuffer( target, this._buffer );
	        }
	    },
	    getItemSize: function () {
	        return this._itemSize;
	    },
	    dirty: function () {
	        this._dirty = true;
	    },
	    isDirty: function () {
	        return this._dirty;
	    },
	    compile: function ( gl ) {
	        if ( this._dirty ) {
	            MACROUTILS.timeStamp( 'osgjs.metrics:bufferData' );
	            gl.bufferData( this._target, this._elements, gl.STATIC_DRAW );
	            this._dirty = false;
	        }
	    },
	    getElements: function () {
	        return this._elements;
	    },
	    setElements: function ( elements ) {
	        this._elements = elements;
	        this._type = getAttributeType( elements );
	        this._dirty = true;
	    },
	    getType: function () {
	        return this._type;
	    }
	
	} );
	
	BufferArray.create = function ( type, elements, itemSize ) {
	    Notify.log( 'BufferArray.create is deprecated, use new BufferArray with same arguments instead' );
	    return new BufferArray( type, elements, itemSize );
	};
	
	module.exports = BufferArray;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

	'use strict';
	var PrimitiveSet = {};
	PrimitiveSet.POINTS = 0x0000;
	PrimitiveSet.LINES = 0x0001;
	PrimitiveSet.LINE_LOOP = 0x0002;
	PrimitiveSet.LINE_STRIP = 0x0003;
	PrimitiveSet.TRIANGLES = 0x0004;
	PrimitiveSet.TRIANGLE_STRIP = 0x0005;
	PrimitiveSet.TRIANGLE_FAN = 0x0006;
	
	module.exports = PrimitiveSet;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var PrimitiveSet = __webpack_require__( 41 );
	
	
	/**
	 * DrawArrays manage rendering primitives
	 * @class DrawArrays
	 */
	var DrawArrays = function ( mode, first, count ) {
	    this.mode = mode;
	    if ( mode !== undefined ) {
	        if ( typeof ( mode ) === 'string' ) {
	            mode = PrimitiveSet[ mode ];
	        }
	        this.mode = mode;
	    }
	    this.first = first;
	    this.count = count;
	};
	
	/** @lends DrawArrays.prototype */
	DrawArrays.prototype = {
	    draw: function ( state ) {
	        if ( this.count === 0 )
	            return;
	        var gl = state.getGraphicContext();
	        gl.drawArrays( this.mode, this.first, this.count );
	    },
	    getMode: function () {
	        return this.mode;
	    },
	    getCount: function () {
	        return this.count;
	    },
	    getFirst: function () {
	        return this.first;
	    },
	    getNumIndices: function () {
	        return this.count;
	    },
	    index: function ( i ) {
	        return this.first + i;
	    }
	
	};
	DrawArrays.create = function ( mode, first, count ) {
	    Notify.log( 'DrawArrays.create is deprecated, use new DrawArrays with same arguments' );
	    var d = new DrawArrays( mode, first, count );
	    return d;
	};
	
	module.exports = DrawArrays;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var PrimitiveSet = __webpack_require__( 41 );
	
	
	/**
	 * DrawElements manage rendering of indexed primitives
	 * @class DrawElements
	 */
	var DrawElements = function ( mode, indices ) {
	    this.mode = PrimitiveSet.POINTS;
	    if ( mode !== undefined ) {
	        if ( typeof ( mode ) === 'string' ) {
	            mode = PrimitiveSet[ mode ];
	        }
	        this.mode = mode;
	    }
	    this.count = 0;
	    this.offset = 0;
	    this.indices = indices;
	    this.uType = DrawElements.UNSIGNED_SHORT;
	    if ( indices !== undefined ) {
	        this.setIndices( indices );
	    }
	};
	
	DrawElements.UNSIGNED_BYTE = 0x1401;
	DrawElements.UNSIGNED_SHORT = 0x1403;
	
	/** @lends DrawElements.prototype */
	DrawElements.prototype = {
	    getMode: function () {
	        return this.mode;
	    },
	    draw: function ( state ) {
	        if ( this.count === 0 )
	            return;
	        state.setIndexArray( this.indices );
	        this.drawElements( state );
	    },
	    drawElements: function ( state ) {
	        var gl = state.getGraphicContext();
	        gl.drawElements( this.mode, this.count, this.uType, this.offset );
	    },
	    setIndices: function ( indices ) {
	        this.indices = indices;
	        var elts = indices.getElements();
	        this.count = elts.length;
	        this.uType = elts.BYTES_PER_ELEMENT === 1 ? DrawElements.UNSIGNED_BYTE : DrawElements.UNSIGNED_SHORT;
	    },
	    getIndices: function () {
	        return this.indices;
	    },
	    setFirst: function ( val ) {
	        this.offset = val;
	    },
	    getFirst: function () {
	        return this.offset;
	    },
	    setCount: function ( val ) {
	        this.count = val;
	    },
	    getCount: function () {
	        return this.count;
	    },
	    getNumIndices: function () {
	        return this.indices.getElements().length;
	    },
	    index: function ( i ) {
	        return this.indices.getElements()[ i ];
	    }
	
	
	};
	
	DrawElements.create = function ( mode, indices ) {
	    Notify.log( 'DrawElements.create is deprecated, use new DrawElements with same arguments' );
	    return new DrawElements( mode, indices );
	};
	
	module.exports = DrawElements;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Matrix = __webpack_require__( 23 );
	var Transform = __webpack_require__( 11 );
	var TransformEnums = __webpack_require__( 29 );
	
	
	/**
	 *  MatrixTransform is a Transform Node that can be customized with user matrix
	 *  @class MatrixTransform
	 */
	var MatrixTransform = function () {
	    Transform.call( this );
	    this.matrix = Matrix.create();
	};
	
	/** @lends MatrixTransform.prototype */
	MatrixTransform.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Transform.prototype, {
	
	    getMatrix: function () {
	        return this.matrix;
	    },
	
	    setMatrix: function ( m ) {
	        this.matrix = m;
	        this.dirtyBound();
	    },
	
	    // local to "local world" (not Global World)
	    computeLocalToWorldMatrix: function ( matrix /*, nodeVisitor */ ) {
	
	        if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {
	            Matrix.preMult( matrix, this.matrix );
	        } else {
	            Matrix.copy( this.matrix, matrix );
	        }
	        return true;
	    },
	
	    computeWorldToLocalMatrix: ( function () {
	        var minverse = Matrix.create();
	        return function ( matrix /*, nodeVisitor */ ) {
	
	            Matrix.inverse( this.matrix, minverse );
	            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {
	                Matrix.postMult( minverse, matrix );
	            } else { // absolute
	                Matrix.copy( minverse, matrix );
	            }
	            return true;
	        };
	    } )()
	} ), 'osg', 'MatrixTransform' );
	MACROUTILS.setTypeID( MatrixTransform );
	
	module.exports = MatrixTransform;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Node = __webpack_require__( 12 );
	var Matrix = __webpack_require__( 23 );
	
	var Projection = function () {
	    Node.call( this );
	    this.projection = Matrix.create();
	};
	Projection.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    getProjectionMatrix: function () {
	        return this.projection;
	    },
	    setProjectionMatrix: function ( m ) {
	        this.projection = m;
	    }
	} );
	
	MACROUTILS.setTypeID( Projection );
	
	module.exports = Projection;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var P = __webpack_require__( 47 );
	var MACROUTILS = __webpack_require__( 6 );
	var osgNameSpace = __webpack_require__( 2 );
	var Options = __webpack_require__( 48 );
	var Notify = __webpack_require__( 10 );
	var Image = __webpack_require__( 36 );
	var BufferArray = __webpack_require__( 40 );
	var DrawArrays = __webpack_require__( 42 );
	var DrawArrayLengths = __webpack_require__( 49 );
	var DrawElements = __webpack_require__( 43 );
	var PrimitiveSet = __webpack_require__( 41 );
	
	
	var Input = function ( json, identifier ) {
	    this._json = json;
	    var map = identifier;
	    if ( map === undefined ) {
	        map = {};
	    }
	    this._identifierMap = map;
	    this._objectRegistry = {};
	
	    this._cacheReadObject = {}; //wrappers
	
	    // this._progressXHRCallback = undefined;
	    // this._prefixURL = '';
	    // this.setImageLoadingOptions( {
	    //     promise: true,
	    //     onload: undefined
	    // } );
	
	    this.setOptions( MACROUTILS.objectMix( {}, Options ) );
	
	    // {
	    //     prefixURL: '',
	    //     progressXHRCallback: undefined,
	    //     readImageURL: undefined,
	    //     imageLoadingUsePromise: undefined,
	    //     imageOnload: undefined,
	    // };
	};
	
	
	// keep one instance of image fallback
	if ( !Input.imageFallback ) {
	    Input.imageFallback = ( function () {
	        var fallback = new window.Image();
	        fallback.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQIW2P8DwQACgAD/il4QJ8AAAAASUVORK5CYII=';
	        return fallback;
	    } )();
	}
	
	Input.prototype = {
	
	    clone: function () {
	        var input = new Input();
	        input._objectRegistry = this._objectRegistry;
	        input._cacheReadObject = this._cacheReadObject;
	        return input;
	    },
	
	    setOptions: function ( options ) {
	        this._defaultOptions = options;
	    },
	    getOptions: function () {
	        return this._defaultOptions;
	    },
	    setProgressXHRCallback: function ( func ) {
	        this._defaultOptions.progressXHRCallback = func;
	    },
	    setReadNodeURLCallback: function ( func ) {
	        this._defaultOptions.readNodeURL = func;
	    },
	    // used to override the type from pathname
	    // typically if you want to create proxy object
	    registerObject: function ( fullyQualifiedObjectname, constructor ) {
	        this._objectRegistry[ fullyQualifiedObjectname ] = constructor;
	    },
	
	    getJSON: function () {
	        return this._json;
	    },
	
	    setJSON: function ( json ) {
	        this._json = json;
	        return this;
	    },
	
	    setPrefixURL: function ( prefix ) {
	        this._defaultOptions.prefixURL = prefix;
	    },
	
	    getPrefixURL: function () {
	        return this._defaultOptions.prefixURL;
	    },
	
	    setDatabasePath: function ( path ) {
	        this._defaultOptions.databasePath = path;
	    },
	
	    getDatabasePath: function () {
	        return this._defaultOptions.databasePath;
	    },
	
	    computeURL: function ( url ) {
	
	        if ( typeof this._defaultOptions.prefixURL === 'string' &&
	            this._defaultOptions.prefixURL.length > 0 ) {
	
	            return this._defaultOptions.prefixURL + url;
	        }
	
	        return url;
	    },
	
	
	    requestFile: function ( url, options ) {
	
	        var defer = P.defer();
	
	        var req = new XMLHttpRequest();
	        req.open( 'GET', url, true );
	
	        // handle responseType
	        if ( options && options.responseType )
	            req.responseType = options.responseType;
	
	        if ( options && options.progress ) {
	            req.addEventListener( 'progress', options.progress, false );
	        }
	
	        req.addEventListener( 'error', function () {
	            defer.reject();
	        }, false );
	
	        req.addEventListener( 'load', function ( /*oEvent */) {
	
	            if ( req.responseType === 'arraybuffer' )
	                defer.resolve( req.response );
	            else
	                defer.resolve( req.responseText );
	
	        } );
	
	        req.send( null );
	        return defer.promise;
	    },
	
	    getObjectWrapper: function ( path ) {
	        if ( this._objectRegistry[ path ] ) {
	            return new( this._objectRegistry[ path ] )();
	        }
	
	        var scope = osgNameSpace;
	        var splittedPath = path.split( '.' );
	        for ( var i = 0, l = splittedPath.length; i < l; i++ ) {
	            var obj = scope[ splittedPath[ i ] ];
	            if ( obj === undefined ) {
	                return undefined;
	            }
	            scope = obj;
	        }
	        this._objectRegistry[ path ] = scope;
	        // create the new obj
	        return new( scope )();
	    },
	
	    fetchImage: function ( image, url, options, defer ) {
	        var checkInlineImage = 'data:image/';
	        // crossOrigin does not work for inline data image
	        var isInlineImage = ( url.substring( 0, checkInlineImage.length ) === checkInlineImage );
	        var img = new window.Image();
	        img.onerror = function () {
	            Notify.warn( 'warning use white texture as fallback instead of ' + url );
	            image.setImage( Input.imageFallback );
	            if ( defer ) {
	                defer.resolve( image );
	            }
	        };
	
	        if ( !isInlineImage && options.imageCrossOrigin ) {
	            img.crossOrigin = options.imageCrossOrigin;
	        }
	
	        img.onload = function () {
	
	            if ( defer ) {
	                if ( options.imageOnload ) options.imageOnload.call( image );
	                defer.resolve( image );
	            } else if ( options.imageOnload )
	                options.imageOnload.call( image );
	
	        };
	
	        image.setURL( url );
	        image.setImage( img );
	
	        img.src = url;
	        return image;
	    },
	
	    readImageURL: function ( url, options ) {
	
	        if ( options === undefined ) {
	            options = this._defaultOptions;
	        }
	
	        // hook reader
	        if ( options.readImageURL ) {
	            // be carefull if you plan to call hook the call and after
	            // call the original readImageURL, you will need to remove
	            // from options the readImageURL if you dont want an infinte
	            // recursion call
	            return options.readImageURL.call( this, url, options );
	        }
	
	        // if image is on inline image skip url computation
	        if ( url.substr( 0, 10 ) !== 'data:image' ) {
	            url = this.computeURL( url );
	        }
	
	
	        var image = new Image();
	        if ( options.imageLoadingUsePromise !== true ) {
	            return this.fetchImage( image, url, options );
	        }
	
	        var defer = P.defer();
	        this.fetchImage( image, url, options, defer );
	
	        return defer.promise;
	    },
	
	
	    readNodeURL: function ( url, opt ) {
	
	        var options = opt;
	        if ( options === undefined ) {
	            options = this._defaultOptions;
	        }
	
	        // hook reader
	        if ( options.readNodeURL ) {
	            // be carefull if you plan to call hook the call and after
	            // call the original readNodeURL, you will need to remove
	            // from options the readNodeURL if you dont want an infinte
	            // recursion call
	            return options.readNodeURL.call( this, url, options );
	        }
	
	        url = this.computeURL( url );
	
	        var defer = P.defer();
	
	        // copy because we are going to modify it to have relative prefix to load assets
	        options = MACROUTILS.objectMix( {}, options );
	
	        // automatic prefix if non specfied
	        if ( !!!options.prefixURL ) {
	            var prefix = this.getPrefixURL();
	            var index = url.lastIndexOf( '/' );
	            if ( index !== -1 ) {
	                prefix = url.substring( 0, index + 1 );
	            }
	            options.prefixURL = prefix;
	        }
	
	        var self = this;
	
	        var ReaderParser = __webpack_require__( 38 );
	
	        var readSceneGraph = function ( data ) {
	
	            ReaderParser.parseSceneGraph( data, options ).then( function ( child ) {
	                defer.resolve( child );
	                Notify.log( 'loaded ' + url );
	            } ).catch( defer.reject.bind( defer ) );
	        };
	
	        var ungzipFile = function ( file ) {
	
	            function pad( n ) {
	                return n.length < 2 ? '0' + n : n;
	            }
	
	            function uintToString( uintArray ) {
	                var str = '';
	                for ( var i = 0, len = uintArray.length; i < len; ++i ) {
	                    str += ( '%' + pad( uintArray[ i ].toString( 16 ) ) );
	                }
	                str = decodeURIComponent( str );
	                return str;
	            }
	
	
	            var unpacked = self._unzipTypedArray( file );
	
	            var typedArray = new Uint8Array( unpacked );
	            var str = uintToString( typedArray );
	            return str;
	        };
	
	
	        // try to get the file as responseText to parse JSON
	        var fileTextPromise = self.requestFile( url );
	        fileTextPromise.then( function ( str ) {
	
	            var data;
	            try {
	
	                data = JSON.parse( str );
	
	            } catch ( error ) { // can't parse try with ungzip code path
	
	                Notify.error( 'cant parse url ' + url + ' try to gunzip' );
	
	            }
	
	            // we have the json, read it
	            if ( data )
	                return readSceneGraph( data );
	
	
	            // no data try with gunzip
	            var fileGzipPromise = self.requestFile( url, {
	                responseType: 'arraybuffer'
	            } );
	            fileGzipPromise.then( function ( file ) {
	
	                var str = ungzipFile( file );
	                data = JSON.parse( str );
	                readSceneGraph( data );
	
	            } ).catch( function ( status ) {
	
	                Notify.error( 'cant read file ' + url + ' status ' + status );
	                defer.reject();
	
	            } ).done();
	
	            return true;
	
	        } ).catch( function ( status ) {
	
	            Notify.error( 'cant get file ' + url + ' status ' + status );
	            defer.reject();
	
	        } ).done();
	
	        return defer.promise;
	    },
	
	    _unzipTypedArray: function ( binary ) {
	
	        var typedArray = new Uint8Array( binary );
	
	        // check magic number 1f8b
	        if ( typedArray[ 0 ] === 0x1f && typedArray[ 1 ] === 0x8b ) {
	            var zlib = __webpack_require__( 50 );
	
	            if ( !zlib ) {
	                Notify.error( 'osg failed to use a gunzip.min.js to uncompress a gz file.\n You can add this vendors to enable this feature or adds the good header in your gzip file served by your server' );
	            }
	
	            var zdec = new zlib.Gunzip( typedArray );
	            var result = zdec.decompress();
	            return result.buffer;
	        }
	
	        return binary;
	    },
	
	    readBinaryArrayURL: function ( url, options ) {
	
	        if ( options === undefined ) {
	            options = this._defaultOptions;
	        }
	
	        if ( options.readBinaryArrayURL ) {
	            return options.readBinaryArrayURL.call( this, url, options );
	        }
	
	        url = this.computeURL( url );
	
	
	        if ( this._identifierMap[ url ] !== undefined ) {
	            return this._identifierMap[ url ];
	        }
	        var defer = P.defer();
	
	        var filePromise = this.requestFile( url, {
	            responseType: 'arraybuffer',
	            progress: this._defaultOptions.progressXHRCallback
	        } );
	
	        this._identifierMap[ url ] = defer.promise;
	        filePromise.then( function ( file ) {
	            defer.resolve( this._unzipTypedArray( file ) );
	        }.bind( this ) );
	
	        return defer.promise;
	    },
	
	    initializeBufferArray: function ( vb, type, buf, options ) {
	        if ( options === undefined )
	            options = this.getOptions();
	        if ( options.initializeBufferArray )
	            return options.initializeBufferArray.call( this, vb, type, buf );
	
	        var url = vb.File;
	        var defer = P.defer();
	        this.readBinaryArrayURL( url ).then( function ( array ) {
	
	            var typedArray;
	            // manage endianness
	            var bigEndian;
	            ( function () {
	                var a = new Uint8Array( [ 0x12, 0x34 ] );
	                var b = new Uint16Array( a.buffer );
	                bigEndian = ( ( b[ 0 ] ).toString( 16 ) === '1234' );
	            } )();
	
	            var offset = 0;
	            if ( vb.Offset !== undefined ) {
	                offset = vb.Offset;
	            }
	
	            var bytesPerElement = MACROUTILS[ type ].BYTES_PER_ELEMENT;
	            var nbItems = vb.Size;
	            var nbCoords = buf.getItemSize();
	            var totalSizeInBytes = nbItems * bytesPerElement * nbCoords;
	
	            if ( bigEndian ) {
	                Notify.log( 'big endian detected' );
	                var TypedArray = MACROUTILS[ type ];
	                var tmpArray = new TypedArray( nbItems * nbCoords );
	                var data = new DataView( array, offset, totalSizeInBytes );
	                var i = 0,
	                    l = tmpArray.length;
	                if ( type === 'Uint16Array' ) {
	                    for ( ; i < l; i++ ) {
	                        tmpArray[ i ] = data.getUint16( i * bytesPerElement, true );
	                    }
	                } else if ( type === 'Float32Array' ) {
	                    for ( ; i < l; i++ ) {
	                        tmpArray[ i ] = data.getFloat32( i * bytesPerElement, true );
	                    }
	                }
	                typedArray = tmpArray;
	                data = null;
	            } else {
	                typedArray = new MACROUTILS[ type ]( array, offset, nbCoords * nbItems );
	            }
	
	            buf.setElements( typedArray );
	            defer.resolve( buf );
	        } ).catch( function () {
	            Notify.warn( 'Can\'t read binary array URL' );
	        } );
	        return defer.promise;
	    },
	
	    readBufferArray: function ( options ) {
	        var jsonObj = this.getJSON();
	
	        var uniqueID = jsonObj.UniqueID;
	        var osgjsObject;
	        if ( uniqueID !== undefined ) {
	            osgjsObject = this._identifierMap[ uniqueID ];
	            if ( osgjsObject !== undefined ) {
	                return osgjsObject;
	            }
	        }
	
	        if ( options === undefined )
	            options = this.getOptions();
	        if ( options.readBufferArray )
	            return options.readBufferArray.call( this );
	
	        if ( ( !jsonObj.Elements && !jsonObj.Array ) || !jsonObj.ItemSize || !jsonObj.Type )
	            return P.reject();
	
	        var promise;
	
	        // inline array
	        if ( jsonObj.Elements ) {
	            promise = P.resolve( new BufferArray( BufferArray[ jsonObj.Type ], jsonObj.Elements, jsonObj.ItemSize ) );
	
	        } else if ( jsonObj.Array ) {
	
	            var buf = new BufferArray( BufferArray[ jsonObj.Type ] );
	            buf.setItemSize( jsonObj.ItemSize );
	
	            var vb, type;
	            if ( jsonObj.Array.Float32Array ) {
	                vb = jsonObj.Array.Float32Array;
	                type = 'Float32Array';
	            } else if ( jsonObj.Array.Uint16Array ) {
	                vb = jsonObj.Array.Uint16Array;
	                type = 'Uint16Array';
	            } else if ( jsonObj.Array.Uint8Array ) {
	                vb = jsonObj.Array.Uint8Array;
	                type = 'Uint8Array';
	            }
	
	            if ( vb === undefined ) {
	                Notify.warn( 'Typed Array ' + window.Object.keys( jsonObj.Array )[ 0 ] );
	                return P.reject();
	            }
	
	            if ( vb.File ) {
	                promise = this.initializeBufferArray( vb, type, buf );
	            } else if ( vb.Elements ) {
	                buf.setElements( new MACROUTILS[ type ]( vb.Elements ) );
	                promise = P.resolve( buf );
	            }
	        }
	
	        if ( uniqueID !== undefined ) {
	            this._identifierMap[ uniqueID ] = promise;
	        }
	        return promise;
	    },
	
	    readUserDataContainer: function () {
	        var jsonObj = this.getJSON();
	        var osgjsObject;
	        var uniqueID = jsonObj.UniqueID;
	        if ( uniqueID !== undefined ) {
	            osgjsObject = this._identifierMap[ uniqueID ];
	            if ( osgjsObject !== undefined ) {
	                return osgjsObject.Values;
	            }
	        }
	
	        this._identifierMap[ uniqueID ] = jsonObj;
	        return jsonObj.Values;
	    },
	
	    readPrimitiveSet: function () {
	        var jsonObj = this.getJSON();
	        var uniqueID;
	        var osgjsObject;
	
	        var defer = P.defer();
	        var obj, mode, first, count;
	        var drawElementPrimitive = jsonObj.DrawElementUShort || jsonObj.DrawElementUByte || jsonObj.DrawElementUInt || jsonObj.DrawElementsUShort || jsonObj.DrawElementsUByte || jsonObj.DrawElementsUInt || undefined;
	        if ( drawElementPrimitive ) {
	
	            uniqueID = drawElementPrimitive.UniqueID;
	            if ( uniqueID !== undefined ) {
	                osgjsObject = this._identifierMap[ uniqueID ];
	                if ( osgjsObject !== undefined ) {
	                    return osgjsObject;
	                }
	            }
	
	            var jsonArray = drawElementPrimitive.Indices;
	            var prevJson = jsonObj;
	
	            mode = drawElementPrimitive.Mode;
	            if ( !mode ) {
	                mode = PrimitiveSet.TRIANGLES;
	            } else {
	                mode = PrimitiveSet[ mode ];
	            }
	            obj = new DrawElements( mode );
	
	            this.setJSON( jsonArray );
	            this.readBufferArray().then( function ( array ) {
	                obj.setIndices( array );
	                defer.resolve( obj );
	            } ).catch( function () {
	                Notify.warn( 'Error buffer array' );
	            } );
	            this.setJSON( prevJson );
	        }
	
	        var drawArrayPrimitive = jsonObj.DrawArray || jsonObj.DrawArrays;
	        if ( drawArrayPrimitive ) {
	
	            uniqueID = drawArrayPrimitive.UniqueID;
	            if ( uniqueID !== undefined ) {
	                osgjsObject = this._identifierMap[ uniqueID ];
	                if ( osgjsObject !== undefined ) {
	                    return osgjsObject;
	                }
	            }
	
	            mode = drawArrayPrimitive.Mode || drawArrayPrimitive.mode;
	            first = drawArrayPrimitive.First !== undefined ? drawArrayPrimitive.First : drawArrayPrimitive.first;
	            count = drawArrayPrimitive.Count !== undefined ? drawArrayPrimitive.Count : drawArrayPrimitive.count;
	            var drawArray = new DrawArrays( PrimitiveSet[ mode ], first, count );
	            defer.resolve( drawArray );
	        }
	
	        var drawArrayLengthsPrimitive = jsonObj.DrawArrayLengths || undefined;
	        if ( drawArrayLengthsPrimitive ) {
	
	            uniqueID = drawArrayLengthsPrimitive.UniqueID;
	            if ( uniqueID !== undefined ) {
	                osgjsObject = this._identifierMap[ uniqueID ];
	                if ( osgjsObject !== undefined ) {
	                    return osgjsObject;
	                }
	            }
	
	            mode = drawArrayLengthsPrimitive.Mode;
	            first = drawArrayLengthsPrimitive.First;
	            var array = drawArrayLengthsPrimitive.ArrayLengths;
	            var drawArrayLengths = new DrawArrayLengths( PrimitiveSet[ mode ], first, array );
	            defer.resolve( drawArrayLengths );
	        }
	
	        if ( uniqueID !== undefined ) {
	            this._identifierMap[ uniqueID ] = defer.promise;
	        }
	
	        return defer.promise;
	    },
	
	
	    readObject: function () {
	
	        var jsonObj = this.getJSON();
	        var prop = window.Object.keys( jsonObj )[ 0 ];
	        if ( !prop ) {
	            Notify.warn( 'can\'t find property for object ' + jsonObj );
	            return P.reject();
	        }
	
	        var uniqueID = jsonObj[ prop ].UniqueID;
	        var osgjsObject;
	        if ( uniqueID !== undefined ) {
	            osgjsObject = this._identifierMap[ uniqueID ];
	            if ( osgjsObject !== undefined ) {
	                return osgjsObject;
	            }
	        }
	
	        var obj = this.getObjectWrapper( prop );
	
	        if ( !obj ) {
	            Notify.warn( 'can\'t instanciate object ' + prop );
	            return P.reject();
	        }
	
	        var ReaderParser = __webpack_require__( 38 );
	        var scope = ReaderParser.ObjectWrapper.serializers;
	
	        if ( this._cacheReadObject[ prop ] ) {
	            scope = this._cacheReadObject[ prop ];
	        } else {
	
	            var splittedPath = prop.split( '.' );
	            for ( var i = 0, l = splittedPath.length; i < l; i++ ) {
	                var reader = scope[ splittedPath[ i ] ];
	                if ( reader === undefined ) {
	                    Notify.warn( 'can\'t find function to read object ' + prop + ' - undefined' );
	                    return P.reject();
	                }
	                scope = reader;
	            }
	            this._cacheReadObject[ prop ] = scope;
	        }
	
	        var promise = scope( this.setJSON( jsonObj[ prop ] ), obj );
	
	        if ( uniqueID !== undefined ) {
	            this._identifierMap[ uniqueID ] = promise;
	            obj._uniqueID = uniqueID;
	        }
	
	        return promise;
	    }
	};
	
	module.exports = Input;


/***/ }),
/* 47 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

	'use strict';
	var defaultOptions = {
	
	    // prefix to built url to load resource
	    prefixURL: '',
	
	    // database URL for PagedLOD structures
	    databasePath: '',
	
	    // callback used when loading data
	    progressXHRCallback: undefined,
	
	    // replacement of readImageURL to use your own code to load Nodes
	    // the function will be execute in the context of Input, see Input:readNodeURL
	    readNodeURL: undefined,
	
	    // replacement of readImageURL to use your own code to load osg.Image
	    // the function will be execute in the context of Input, see Input:readImageURL
	    readImageURL: undefined,
	
	    // replacement of readBinaryArrayURL to use your own code to load binary array
	    // the function will be execute in the context of Input, see Input:readBinaryArrayURL
	    readBinaryArrayURL: undefined,
	
	    imageLoadingUsePromise: true, // use promise to load image instead of returning Image
	    imageOnload: undefined, // use callback when loading an image
	    imageCrossOrigin: undefined // use callback when loading an image
	};
	
	module.exports = defaultOptions;


/***/ }),
/* 49 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * DrawArrayLengths manage rendering primitives
	 * @class DrawArrayLengths
	 */
	var DrawArrayLengths = function ( mode, first, array ) {
	    this._mode = mode;
	    this._first = first;
	    this._arrayLengths = array.slice( 0 );
	};
	
	/** @lends DrawArrayLengths.prototype */
	DrawArrayLengths.prototype = {
	    draw: function ( state ) {
	        var gl = state.getGraphicContext();
	        var mode = this._mode;
	        var first = this._first;
	        var array = this._arrayLengths;
	        for ( var i = 0, l = array.length; i < l; i++ ) {
	            var count = array[ i ];
	            gl.drawArrays( mode, first, count );
	            first += count;
	        }
	    },
	    getMode: function () {
	        return this._mode;
	    },
	    getNumIndices: function () {
	        var count = 0;
	        var array = this._arrayLengths;
	        for ( var i = 0, l = array.length; i < l; i++ ) {
	            count += array[ i ];
	        }
	        return count;
	    },
	    getCount: function () {
	        return this.getNumIndices();
	    },
	    getArrayLengths: function () {
	        return this._arrayLengths;
	    },
	    getFirst: function () {
	        return this._first;
	    },
	    setFirst: function ( first ) {
	        this._first = first;
	    }
	};
	
	module.exports = DrawArrayLengths;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_50__;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	var Vec4 = __webpack_require__( 25 );
	var Uniform = __webpack_require__( 35 );
	var Map = __webpack_require__( 20 );
	
	// Define a material attribute
	var Material = function () {
	    StateAttribute.call( this );
	    this._ambient = Vec4.createAndSet( 0.2, 0.2, 0.2, 1.0 );
	    this._diffuse = Vec4.createAndSet( 0.8, 0.8, 0.8, 1.0 );
	    this._specular = Vec4.createAndSet( 0.0, 0.0, 0.0, 1.0 );
	    this._emission = Vec4.createAndSet( 0.0, 0.0, 0.0, 1.0 );
	    this._shininess = 12.5;
	};
	
	Material.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Material',
	
	    cloneType: function () {
	        return new Material();
	    },
	
	    getParameterName: function ( name ) {
	        return this.getType() + '_uniform_' + name;
	    },
	
	    getOrCreateUniforms: function () {
	        var obj = Material;
	        if ( obj.uniforms ) return obj.uniforms;
	
	        var uniformList = {
	            ambient: Uniform.createFloat4( Vec4.create(), 'MaterialAmbient' ),
	            diffuse: Uniform.createFloat4( Vec4.create(), 'MaterialDiffuse' ),
	            specular: Uniform.createFloat4( Vec4.create(), 'MaterialSpecular' ),
	            emission: Uniform.createFloat4( Vec4.create(), 'MaterialEmission' ),
	            shininess: Uniform.createFloat1( [ 0 ], 'MaterialShininess' )
	        };
	
	        obj.uniforms = new Map( uniformList );
	        return obj.uniforms;
	    },
	
	    setEmission: function ( a ) {
	        Vec4.copy( a, this._emission );
	    },
	
	    getEmission: function () {
	        return this._emission;
	    },
	
	    setAmbient: function ( a ) {
	        Vec4.copy( a, this._ambient );
	    },
	
	    getAmbient: function () {
	        return this._ambient;
	    },
	
	    setSpecular: function ( a ) {
	        Vec4.copy( a, this._specular );
	    },
	
	    getSpecular: function () {
	        return this._specular;
	    },
	
	    setDiffuse: function ( a ) {
	        Vec4.copy( a, this._diffuse );
	    },
	
	    getDiffuse: function () {
	        return this._diffuse;
	    },
	
	    setShininess: function ( a ) {
	        this._shininess = a;
	    },
	
	    getShininess: function () {
	        return this._shininess;
	    },
	
	    setTransparency: function ( a ) {
	        this._diffuse[ 3 ] = 1.0 - a;
	    },
	
	    getTransparency: function () {
	        return this._diffuse[ 3 ];
	    },
	
	    apply: function () {
	        var uniforms = this.getOrCreateUniforms();
	
	        uniforms.ambient.setFloat4( this._ambient );
	        uniforms.diffuse.setFloat4( this._diffuse );
	        uniforms.specular.setFloat4( this._specular );
	        uniforms.emission.setFloat4( this._emission );
	        uniforms.shininess.setFloat( this._shininess );
	
	    }
	
	
	} ), 'osg', 'Material' );
	
	module.exports = Material;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Timer = __webpack_require__( 9 );
	
	
	var TextureProfile = function ( target, internalFormat, width, height ) {
	    this._target = target;
	    this._internalFormat = internalFormat;
	    this._width = width;
	    this._height = height;
	    this._size = 0;
	    this.computeSize();
	};
	
	TextureProfile.prototype = {
	    match: function ( textureProfile ) {
	        return textureProfile._target === this._target &&
	            textureProfile._internalFormat === this._internalFormat &&
	            textureProfile._width === this._width &&
	            textureProfile._height === this._height;
	    },
	    computeSize: function () {
	        var Texture = __webpack_require__( 34 );
	
	        var numBitsPerTexel = 0;
	        switch ( this._internalFormat ) {
	        case ( 1 ):
	            numBitsPerTexel = 8;
	            break;
	        case ( Texture.ALPHA ):
	            numBitsPerTexel = 8;
	            break;
	        case ( Texture.LUMINANCE ):
	            numBitsPerTexel = 8;
	            break;
	
	        case ( Texture.LUMINANCE_ALPHA ):
	            numBitsPerTexel = 16;
	            break;
	        case ( 2 ):
	            numBitsPerTexel = 16;
	            break;
	
	        case ( Texture.RGB ):
	            numBitsPerTexel = 24;
	            break;
	        case ( 3 ):
	            numBitsPerTexel = 24;
	            break;
	
	        case ( Texture.RGBA ):
	            numBitsPerTexel = 32;
	            break;
	        case ( 4 ):
	            numBitsPerTexel = 32;
	            break;
	
	        }
	        var size = ( Math.ceil( this._width * this._height * numBitsPerTexel ) / 8.0 );
	
	        if ( this._target === Texture.TEXTURE_CUBE_MAP )
	            size *= 6.0;
	
	        // add the mipmap overhead size even if not used
	        size += size / 3.0;
	
	        this._size = size;
	    },
	
	    getSize: function () {
	        return this._size;
	    }
	
	};
	TextureProfile.getHash = function () {
	    var array = Array.prototype.slice.call( arguments );
	    var hash = '';
	    array.forEach( function ( element ) {
	        hash += element;
	    } );
	    return hash;
	};
	
	
	var TextureObject = function ( texture, id, textureSet ) {
	    this._texture = texture;
	    this._id = id;
	    this._textureSet = textureSet;
	};
	
	TextureObject.prototype = {
	    target: function () {
	        return this._textureSet._profile._target;
	    },
	    id: function () {
	        return this._id;
	    },
	    getTextureSet: function () {
	        return this._textureSet;
	    },
	    reset: function () {
	        this._textureObject = null;
	        this._texture = undefined;
	    },
	    bind: function ( gl ) {
	        gl.bindTexture( this.target(), this._id );
	    }
	};
	
	var TextureObjectSet = function ( profile ) {
	    this._profile = profile;
	    this._usedTextureObjects = [];
	    this._orphanedTextureObjects = [];
	};
	
	TextureObjectSet.prototype = {
	    getProfile: function () {
	        return this._profile;
	    },
	    getUsedTextureObjects: function () {
	        return this._usedTextureObjects;
	    },
	    getOrphanedTextureObjects: function () {
	        return this._orphanedTextureObjects;
	    },
	
	    takeOrGenerate: function ( gl, texture ) {
	
	        var textureObject;
	        if ( this._orphanedTextureObjects.length > 0 ) {
	            textureObject = this.takeFromOrphans();
	            textureObject._texture = texture;
	            this._usedTextureObjects.push( textureObject );
	            return textureObject;
	        }
	
	        var textureID = gl.createTexture();
	        textureObject = new TextureObject( texture, textureID, this );
	        this._usedTextureObjects.push( textureObject );
	
	        return textureObject;
	    },
	
	    // get texture object from pool
	    takeFromOrphans: function () {
	
	        if ( this._orphanedTextureObjects.length )
	            return this._orphanedTextureObjects.pop();
	
	        return undefined;
	    },
	
	    // release texture object
	    orphan: function ( textureObject ) {
	        var index = this._usedTextureObjects.indexOf( textureObject );
	        if ( index !== -1 ) {
	            this._orphanedTextureObjects.push( this._usedTextureObjects[ index ] );
	            this._usedTextureObjects.splice( index, 1 );
	        }
	    },
	
	    flushDeletedTextureObjects: function ( gl, availableTime ) {
	        // if no time available don't try to flush objects.
	        if ( availableTime <= 0.0 ) return availableTime;
	        var nbTextures = this._orphanedTextureObjects.length;
	        // Should we use a maxSizeTexturePool value?
	        //var size = this.getProfile().getSize();
	        // We need to test if we have time to flush
	        var elapsedTime = 0.0;
	        var beginTime = Timer.instance().tick();
	        var i;
	        for ( i = 0; i < nbTextures && elapsedTime < availableTime; i++ ) {
	            gl.deleteTexture( this._orphanedTextureObjects[ i ].id() );
	            this._orphanedTextureObjects[ i ].reset();
	            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	        }
	        this._orphanedTextureObjects.splice( 0, i );
	        return availableTime - elapsedTime;
	    },
	
	    flushAllDeletedTextureObjects: function ( gl ) {
	        var nbTextures = this._orphanedTextureObjects.length;
	        var size = this.getProfile().getSize();
	        for ( var i = 0, j = nbTextures; i < j; ++i ) {
	            gl.deleteTexture( this._orphanedTextureObjects[ i ].id() );
	            this._orphanedTextureObjects[ i ].reset();
	        }
	        this._orphanedTextureObjects.length = 0;
	        Notify.info( 'TextureManager: released ' + nbTextures + ' with ' + ( nbTextures * size / ( 1024 * 1024 ) ) + ' MB' );
	    }
	};
	
	
	var TextureManager = function () {
	    this._textureSetMap = {};
	};
	
	TextureManager.prototype = {
	
	    generateTextureObject: function ( gl,
	        texture,
	        target,
	        internalFormat,
	        width,
	        height ) {
	        var hash = TextureProfile.getHash( target, internalFormat, width, height );
	
	        if ( this._textureSetMap[ hash ] === undefined ) {
	            this._textureSetMap[ hash ] = new TextureObjectSet( new TextureProfile( target, internalFormat, width, height ) );
	        }
	
	        var textureSet = this._textureSetMap[ hash ];
	        var textureObject = textureSet.takeOrGenerate( gl, texture );
	        return textureObject;
	    },
	
	    updateStats: function ( frameNumber, rStats ) {
	        var totalUsed = 0;
	        var totalUnused = 0;
	        window.Object.keys( this._textureSetMap ).forEach( function ( key ) {
	            var profile = this._textureSetMap[ key ].getProfile();
	            var size = profile.getSize();
	            var nbUsed = this._textureSetMap[ key ].getUsedTextureObjects().length;
	            var nbUnused = this._textureSetMap[ key ].getOrphanedTextureObjects().length;
	            totalUsed += nbUsed * size;
	            totalUnused += nbUnused * size;
	        }, this );
	
	        var MB = 1024 * 1024;
	        rStats( 'textureused' ).set( totalUsed / MB );
	        rStats( 'texturereserved' ).set( totalUnused / MB );
	        rStats( 'texturetotal' ).set( ( totalUsed + totalUnused ) / MB );
	    },
	
	    reportStats: function () {
	        var total = 0;
	        window.Object.keys( this._textureSetMap ).forEach( function ( key ) {
	            var profile = this._textureSetMap[ key ].getProfile();
	            var size = profile.getSize() / ( 1024 * 1024 );
	            var nb = this._textureSetMap[ key ].getUsedTextureObjects().length;
	            size *= nb;
	            total += size;
	            Notify.notice( String( size ) + ' MB with ' + nb + ' texture of ' + profile._width + 'x' + profile._height + ' ' + profile._internalFormat );
	        }, this );
	        Notify.notice( String( total ) + ' MB in total' );
	    },
	
	    flushAllDeletedTextureObjects: function ( gl ) {
	        window.Object.keys( this._textureSetMap ).forEach( function ( key ) {
	            this._textureSetMap[ key ].flushAllDeletedTextureObjects( gl );
	        }, this );
	    },
	
	    flushDeletedTextureObjects: function ( gl, availableTimeArg ) {
	        var availableTime = availableTimeArg;
	        var keys = window.Object.keys( this._textureSetMap );
	        for ( var i = 0, j = keys.length; i < j && availableTime > 0.0; i++ ) {
	            availableTime = this._textureSetMap[ keys[ i ] ].flushDeletedTextureObjects( gl, availableTime );
	        }
	        return availableTime;
	    },
	
	    releaseTextureObject: function ( textureObject ) {
	        if ( textureObject ) {
	            var ts = textureObject.getTextureSet();
	            ts.orphan( textureObject );
	        }
	    }
	
	};
	
	module.exports = TextureManager;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BufferArray = __webpack_require__( 40 );
	
	
	var BufferArrayProxy = function ( bufferArray ) {
	
	    this._initialBufferArray = undefined;
	    this._bufferArray = undefined;
	    if ( bufferArray ) {
	        this.setBufferArray( bufferArray );
	        this.setInitialBufferArray( bufferArray );
	    }
	
	};
	
	var prototype = {
	    setInitialBufferArray: function ( bufferArray ) {
	        this._initialBufferArray = bufferArray;
	    },
	    getInitialBufferArray: function () {
	        return this._initialBufferArray;
	    },
	    setBufferArray: function ( bufferArray ) {
	        this._bufferArray = bufferArray.getBufferArray ? bufferArray.getBufferArray() : bufferArray;
	    },
	    getBufferArray: function () {
	        return this._bufferArray;
	    }
	};
	
	// adds original method of BufferArray prototype for the proxy for convenient usage
	var keys = window.Object.keys( BufferArray.prototype );
	keys.forEach( function ( methodName ) {
	    prototype[ methodName ] = function () {
	        return BufferArray.prototype[ methodName ].apply( this._bufferArray, arguments );
	    };
	} );
	
	BufferArrayProxy.prototype = prototype;
	module.exports = BufferArrayProxy;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	
	
	var BillboardAttribute = function () {
	    StateAttribute.call( this );
	    this._attributeEnable = false;
	};
	
	BillboardAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Billboard',
	
	    cloneType: function () {
	        return new BillboardAttribute();
	    },
	
	    setEnabled: function ( state ) {
	        this._attributeEnable = state;
	    },
	
	    isEnabled: function () {
	        return this._attributeEnable;
	    },
	
	    apply: function () {}
	
	} ), 'osg', 'Billboard' );
	
	module.exports = BillboardAttribute;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	var Vec4 = __webpack_require__( 25 );
	
	/**
	 *  Manage BlendColor attribute
	 *  @class
	 *  @memberOf osg
	 *  @extends StateAttribute
	 */
	var BlendColor = function ( color ) {
	    StateAttribute.call( this );
	    this._constantColor = Vec4.create();
	    Vec4.set( 1.0, 1.0, 1.0, 1.0, this._constantColor );
	    if ( color !== undefined ) {
	        this.setConstantColor( color );
	    }
	};
	
	/**
	 * @lends BlendColor.prototype
	 */
	BlendColor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	    attributeType: 'BlendColor',
	    cloneType: function () {
	        return new BlendColor();
	    },
	
	    /**
	     *
	     * @param {} color
	     */
	    setConstantColor: function ( color ) {
	        Vec4.copy( color, this._constantColor );
	    },
	    getConstantColor: function () {
	        return this._constantColor;
	    },
	    apply: function ( state ) {
	        var gl = state.getGraphicContext();
	        gl.blendColor( this._constantColor[ 0 ],
	            this._constantColor[ 1 ],
	            this._constantColor[ 2 ],
	            this._constantColor[ 3 ] );
	    }
	} ), 'osg', 'BlendColor' );
	
	module.exports = BlendColor;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Transform = __webpack_require__( 11 );
	var CullSettings = __webpack_require__( 57 );
	var Matrix = __webpack_require__( 23 );
	var Texture = __webpack_require__( 34 );
	var TransformEnums = __webpack_require__( 29 );
	var Vec4 = __webpack_require__( 25 );
	
	
	/**
	 * Camera - is a subclass of Transform which represents encapsulates the settings of a Camera.
	 * @class Camera
	 * @inherits Transform CullSettings
	 */
	var Camera = function () {
	    Transform.call( this );
	    CullSettings.call( this );
	
	    this.viewport = undefined;
	    this._graphicContext = undefined;
	    this.setClearColor( Vec4.createAndSet( 0, 0, 0, 1.0 ) );
	    this.setClearDepth( 1.0 );
	
	    /*jshint bitwise: false */
	    this.setClearMask( Camera.COLOR_BUFFER_BIT | Camera.DEPTH_BUFFER_BIT );
	    /*jshint bitwise: true */
	
	    this.setViewMatrix( Matrix.create() );
	    this.setProjectionMatrix( Matrix.create() );
	    this.renderOrder = Camera.NESTED_RENDER;
	    this.renderOrderNum = 0;
	
	    this._view = undefined;
	    this._renderer = undefined;
	    this._attachments = {};
	};
	
	Camera.PRE_RENDER = 0;
	Camera.NESTED_RENDER = 1;
	Camera.POST_RENDER = 2;
	
	Camera.COLOR_BUFFER_BIT = 0x00004000;
	Camera.DEPTH_BUFFER_BIT = 0x00000100;
	Camera.STENCIL_BUFFER_BIT = 0x00000400;
	
	/** @lends Camera.prototype */
	Camera.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit(
	    CullSettings.prototype,
	    MACROUTILS.objectInherit( Transform.prototype, {
	        // at which view this camera is attached
	        getView: function () {
	            return this._view;
	        },
	
	        setView: function ( view ) {
	            this._view = view;
	        },
	
	        getRenderer: function () {
	            return this._renderer;
	        },
	
	        setRenderer: function ( renderer ) {
	            this._renderer = renderer;
	        },
	
	        // Set the final draw callback for custom operations
	        // to be done after the drawing of
	        // the camera's subgraph and pre render stages.
	        setFinalDrawCallback: function ( cb ) {
	
	            this._finalDrawCallback = cb;
	
	        },
	
	        getFinalDrawCallback: function () {
	
	            return this._finalDrawCallback;
	
	        },
	
	        // Set the initial draw callback for custom operations
	        // to be done before the drawing of
	        // the camera's subgraph and pre render stages.
	        setInitialDrawCallback: function ( cb ) {
	
	            this._initialDrawCallback = cb;
	
	        },
	
	        getInitialDrawCallback: function () {
	
	            return this._initialDrawCallback;
	
	        },
	
	
	        getAttachments: function () {
	            return this._attachments;
	        },
	
	        setGraphicContext: function ( gc ) {
	            this._graphicContext = gc;
	        },
	        getGraphicContext: function () {
	            return this._graphicContext;
	        },
	        setClearDepth: function ( depth ) {
	            this.clearDepth = depth;
	        },
	        getClearDepth: function () {
	            return this.clearDepth;
	        },
	
	        setClearMask: function ( mask ) {
	            this.clearMask = mask;
	        },
	        getClearMask: function () {
	            return this.clearMask;
	        },
	
	        setClearColor: function ( color ) {
	            this.clearColor = color;
	        },
	        getClearColor: function () {
	            return this.clearColor;
	        },
	
	        setViewport: function ( vp ) {
	            this.viewport = vp;
	            this.getOrCreateStateSet().setAttributeAndModes( vp );
	        },
	        getViewport: function () {
	            return this.viewport;
	        },
	
	
	        setViewMatrix: function ( matrix ) {
	            this.modelviewMatrix = matrix;
	        },
	        setViewMatrixAsLookAt: function ( eye, center, up ) {
	            Matrix.makeLookAt( eye, center, up, this.getViewMatrix() );
	        },
	        setProjectionMatrix: function ( matrix ) {
	            this.projectionMatrix = matrix;
	        },
	
	        /** Set to an orthographic projection. See OpenGL glOrtho for documentation further details.*/
	        setProjectionMatrixAsOrtho: function ( left, right,
	            bottom, top,
	            zNear, zFar ) {
	            Matrix.makeOrtho( left, right, bottom, top, zNear, zFar, this.getProjectionMatrix() );
	        },
	        isRenderToTextureCamera: function () {
	            return window.Object.keys( this._attachments ).length > 0;
	        },
	
	        getViewMatrix: function () {
	            return this.modelviewMatrix;
	        },
	        getProjectionMatrix: function () {
	            return this.projectionMatrix;
	        },
	        getRenderOrder: function () {
	            return this.renderOrder;
	        },
	        setRenderOrder: function ( order, orderNum ) {
	            this.renderOrder = order;
	            this.renderOrderNum = orderNum;
	        },
	
	        detachAll: function () {
	            this._attachments = {};
	
	            if ( this.frameBufferObject ) {
	                this.frameBufferObject.dirty();
	            }
	        },
	
	        // TODO: fix in case of shared fbo
	        // TODO: fix adding a resize case
	        resetAttachments: function () {
	
	
	            if ( this.frameBufferObject ) {
	
	                this.frameBufferObject.reset();
	                // remove framebuffer
	                this.frameBufferObject = 0;
	            }
	
	            // removes camera attachement
	            this._attachments = {};
	
	        },
	
	        attachTexture: function ( bufferComponent, texture, textureTarget ) {
	            if ( this.frameBufferObject ) {
	                this.frameBufferObject.dirty();
	            }
	
	            // because before the argument was level and the spec says
	            // it must always be 0 ! is valid for 0 or undefined
	            if ( !textureTarget ) {
	                textureTarget = Texture.TEXTURE_2D;
	            }
	
	            this._attachments[ bufferComponent ] = {
	                'attachment': bufferComponent,
	                'texture': texture,
	                'textureTarget': textureTarget
	            };
	        },
	
	        attachRenderBuffer: function ( bufferComponent, internalFormat ) {
	            if ( this.frameBufferObject ) {
	                this.frameBufferObject.dirty();
	            }
	            this._attachments[ bufferComponent ] = {
	                'format': internalFormat,
	                'attachment': bufferComponent
	            };
	        },
	
	        computeLocalToWorldMatrix: function ( matrix /*,nodeVisitor*/ ) {
	            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {
	                Matrix.preMult( matrix, this.modelviewMatrix );
	            } else { // absolute
	                Matrix.copy( this.modelviewMatrix, matrix );
	            }
	            return true;
	        },
	
	        computeWorldToLocalMatrix: ( function () {
	            var minverse = Matrix.create();
	            return function ( matrix /*, nodeVisitor */ ) {
	                Matrix.inverse( this.modelviewMatrix, minverse );
	                if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {
	                    Matrix.postMult( minverse, matrix );
	                } else {
	                    Matrix.copy( minverse, matrix );
	                }
	                return true;
	            };
	        } )()
	
	    } ) ), 'osg', 'Camera' );
	
	MACROUTILS.setTypeID( Camera );
	
	module.exports = Camera;


/***/ }),
/* 57 */
/***/ (function(module, exports) {

	'use strict';
	
	
	var CullSettings = function () {
	
	    // Not doing a this.reset()
	    // because of multiple inheritance
	    // it will call the wrong reset
	    // cullstack reset for isntance()
	    CullSettings.prototype.reset.call( this );
	
	};
	
	CullSettings.prototype = {
	    reset: function () {
	
	        this._computeNearFar = true;
	        this._nearFarRatio = 0.005;
	
	        // Magic numbers 3 & 4
	        this.bbCornerFar = 3;
	        this.bbCornerNear = 4;
	        // see code below for for the
	        // Code simplification origin
	        // var Vec3 = require( 'osg/Vec3' );
	        // var lookVector = Vec3.createAndSet( 0.0, 0.0, -1.0 );
	        // /*jshint bitwise: false */
	        // this.bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );
	        // this.bbCornerNear = ( ~this.bbCornerFar ) & 7;
	        // /*jshint bitwise: true */
	        // is equivalent to
	
	        this._enableFrustumCulling = false;
	
	        // who sets the parameter
	        // if it's cullvisitor
	        // it's an OVERRIDER for enableFrustumCulling
	        // allowing for global EnableFrustimCulling
	        this._settingsSourceOverrider = this;
	        //LOD bias for the CullVisitor to use
	        this._LODScale = 1.0;
	        // Custom clampProjectionMatrix
	        this._clampProjectionMatrixCallback = undefined;
	    },
	
	    setCullSettings: function ( settings ) {
	        this._computeNearFar = settings._computeNearFar;
	        this._nearFarRatio = settings._nearFarRatio;
	        this._enableFrustumCulling = settings._enableFrustumCulling;
	        this._settingsSourceOverrider = settings._settingsSourceOverrider;
	        this._clampProjectionMatrixCallback = settings._clampProjectionMatrixCallback;
	    },
	
	    setNearFarRatio: function ( ratio ) {
	        this._nearFarRatio = ratio;
	    },
	    getNearFarRatio: function () {
	        return this._nearFarRatio;
	    },
	    setComputeNearFar: function ( value ) {
	        this._computeNearFar = value;
	    },
	    getComputeNearFar: function () {
	        return this._computeNearFar;
	    },
	
	    setEnableFrustumCulling: function ( value ) {
	        this._enableFrustumCulling = value;
	    },
	    getEnableFrustumCulling: function () {
	        return this._enableFrustumCulling;
	    },
	
	    getSettingSourceOverrider: function () {
	        return this._settingsSourceOverrider;
	    },
	
	    setClampProjectionMatrixCallback: function ( callback ) {
	        this._clampProjectionMatrixCallback = callback;
	    },
	
	    getClampProjectionMatrixCallback: function () {
	        return this._clampProjectionMatrixCallback;
	    },
	
	    setLODScale: function ( scale ) {
	        this._LODScale = scale;
	    },
	    getLODScale: function () {
	        return this._LODScale;
	    }
	
	};
	
	module.exports = CullSettings;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	
	
	var ColorMask = function ( red, green, blue, alpha ) {
	
	    StateAttribute.call( this );
	
	    this._colorMask = [ true, true, true, true ];
	    this.setMask( red, green, blue, alpha );
	};
	
	ColorMask.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'ColorMask',
	
	    cloneType: function () {
	        return new ColorMask();
	    },
	
	    setMask: function ( red, green, blue, alpha ) {
	
	        if ( red !== undefined &&
	            green !== undefined &&
	            blue !== undefined &&
	            alpha !== undefined ) {
	
	            this._colorMask[ 0 ] = red;
	            this._colorMask[ 1 ] = green;
	            this._colorMask[ 2 ] = blue;
	            this._colorMask[ 3 ] = alpha;
	        }
	    },
	
	    apply: function ( state ) {
	        var gl = state.getGraphicContext();
	        var colorMask = this._colorMask;
	        gl.colorMask( colorMask[ 0 ], colorMask[ 1 ], colorMask[ 2 ], colorMask[ 3 ] );
	    }
	
	} ), 'osg', 'ColorMask' );
	
	module.exports = ColorMask;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	
	
	/**
	 *  Manage CullFace attribute
	 *  @class CullFace
	 */
	var CullFace = function ( mode ) {
	    StateAttribute.call( this );
	    this.setMode( mode !== undefined ? mode : CullFace.BACK );
	};
	
	CullFace.DISABLE = 0x0;
	CullFace.FRONT = 0x0404;
	CullFace.BACK = 0x0405;
	CullFace.FRONT_AND_BACK = 0x0408;
	
	/** @lends CullFace.prototype */
	CullFace.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'CullFace',
	
	    cloneType: function () {
	        return new CullFace();
	    },
	
	    setMode: function ( mode ) {
	        var value = mode;
	        if ( typeof value === 'string' ) value = CullFace[ value ];
	        this._mode = value;
	    },
	
	    getMode: function () {
	        return this._mode;
	    },
	
	    apply: function ( state ) {
	        var gl = state.getGraphicContext();
	        if ( this._mode === CullFace.DISABLE ) {
	            gl.disable( gl.CULL_FACE );
	        } else {
	            gl.enable( gl.CULL_FACE );
	            gl.cullFace( this._mode );
	        }
	
	    }
	} ), 'osg', 'CullFace' );
	
	module.exports = CullFace;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Polytope = __webpack_require__( 61 );
	
	var CullingSet = function () {
	
	    this._mask = CullingSet.DEFAULT_CULLING;
	    this._frustum = new Polytope();
	
	};
	
	CullingSet.prototype = {
	
	    reset: function () {
	        this._mask = CullingSet.DEFAULT_CULLING;
	        this._frustum.clear();
	    },
	    setCullingMask: function ( mask ) {
	        this._mask = mask;
	    },
	    getCullingMask: function () {
	        return this._mask;
	    },
	    setFrustum: function ( frustum ) {
	        this._frustum = frustum;
	    },
	    getFrustum: function () {
	        return this._frustum;
	    },
	    getCurrentResultMask: function () {
	        return this._frustum.getCurrentMask();
	    },
	    pushCurrentMask: function () {
	        this._frustum.pushCurrentMask();
	    },
	    popCurrentMask: function () {
	        this._frustum.popCurrentMask();
	    },
	    resetCullingMask: function () {
	        this._frustum.setResultMask( this._frustum.getCurrentMask() );
	    },
	    isBoundingBoxCulled: function ( bbox ) {
	        if ( this._mask & CullingSet.VIEW_FRUSTUM_CULLING ) {
	            // is it outside the view frustum...
	            if ( !this._frustum.containsBoundingBox( bbox ) ) return true;
	        }
	        return false;
	    },
	    isBoundingSphereCulled: function ( bs ) {
	        if ( this._mask & CullingSet.VIEW_FRUSTUM_CULLING ) {
	            // is it outside the view frustum...
	            if ( !this._frustum.containsBoundingSphere( bs ) ) return true;
	        }
	        return false;
	    },
	    isVerticesCulled: function ( vertices ) {
	        if ( this._mask & CullingSet.VIEW_FRUSTUM_CULLING ) {
	            // is it outside the view frustum...
	            if ( !this._frustum.containsVertices( vertices ) ) return true;
	        }
	        return false;
	    }
	};
	
	CullingSet.NO_CULLING = 0x0;
	
	CullingSet.VIEW_FRUSTUM_LEFT_CULLING = 0x1;
	CullingSet.VIEW_FRUSTUM_RIGHT_CULLING = 0x2;
	CullingSet.VIEW_FRUSTUM_TOP_CULLING = 0x3;
	CullingSet.VIEW_FRUSTUM_BOTTOM_CULLING = 0x4;
	CullingSet.NEAR_PLANE_CULLING = 0x5;
	CullingSet.FAR_PLANE_CULLING = 0x6;
	
	CullingSet.VIEW_FRUSTUM_SIDES_CULLING = CullingSet.VIEW_FRUSTUM_LEFT_CULLING | CullingSet.VIEW_FRUSTUM_RIGHT_CULLING | CullingSet.VIEW_FRUSTUM_BOTTOM_CULLING | CullingSet.VIEW_FRUSTUM_TOP_CULLING;
	
	CullingSet.VIEW_FRUSTUM_CULLING = CullingSet.VIEW_FRUSTUM_SIDES_CULLING | CullingSet.NEAR_PLANE_CULLING | CullingSet.FAR_PLANE_CULLING;
	
	CullingSet.DEFAULT_CULLING = CullingSet.VIEW_FRUSTUM_SIDES_CULLING;
	
	CullingSet.ENABLE_ALL_CULLING = CullingSet.VIEW_FRUSTUM_CULLING;
	
	module.exports = CullingSet;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Object = __webpack_require__( 13 );
	var Plane = __webpack_require__( 24 );
	var MACROUTILS = __webpack_require__( 6 );
	var Vec4 = __webpack_require__( 25 );
	/*jshint bitwise: false */
	/**
	 * Polytope class for representing convex clipping volumes made up of a set of planes.
	 * When adding planes, their normals should point inwards (into the volume)
	 * @class Polytope
	 */
	var Polytope = function () {
	
	    this._clippingMask = 0x0;
	
	    this._planeList = [ Plane.create(), Plane.create(), Plane.create(), Plane.create(), Plane.create(), Plane.create() ];
	    this._vertexList = [];
	
	    // stack of clipping masks
	    this._maskStack = [];
	
	    // init with a clear mask
	    this._resultMask = 0;
	    this._maskStack.push( this._resultMask );
	};
	
	Polytope.prototype = MACROUTILS.objectInherit( Object.prototype, {
	
	
	    getPlanes: function () {
	        return this._planeList;
	    },
	
	    setPlanes: function ( pl ) {
	        this._planeList = pl;
	        this.setupMask();
	    },
	
	    clear: function () {
	
	        this._clippingMask = 0x0;
	        if ( this._planeList ) {
	            for ( var i = 0, l = this._planeList.length; i < l; ++i ) {
	                Plane.init( this._planeList[ i ] );
	            }
	        }
	        this._vertexList = [];
	        this.setupMask();
	
	    },
	
	    /** Create a Polytope which is a cube, centered at 0,0,0, with sides of 2 units.*/
	    setToUnitFrustum: function ( withNear, withFar ) {
	        if ( withNear === undefined ) withNear = true;
	
	        if ( withFar === undefined ) withFar = true;
	
	        this._planeList.length = 0;
	        this._planeList.push( Vec4.set( 1.0, 0.0, 0.0, 1.0, Plane.create() ) ); // left plane.
	        this._planeList.push( Vec4.set( -1.0, 0.0, 0.0, 1.0, Plane.create() ) ); // right plane.
	        this._planeList.push( Vec4.set( 0.0, 1.0, 0.0, 1.0, Plane.create() ) ); // bottom plane.
	        this._planeList.push( Vec4.set( 0.0, -1.0, 0.0, 1.0, Plane.create() ) ); // top plane.
	        if ( withNear ) this._planeList.push( Vec4.set( 0.0, 0.0, 1.0, 1.0, Plane.create() ) ); // near plane
	        if ( withFar ) this._planeList.push( Vec4.set( 0.0, 0.0, -1.0, 1.0, Plane.create() ) ); // far plane
	        this.setupMask();
	    },
	
	
	    /** Create a Polytope which is a equivalent to BoundingBox.*/
	    setToBoundingBox: function ( bb ) {
	        this._planeList.length = 0;
	        this._planeList.push( Vec4.set( 1.0, 0.0, 0.0, -bb.getMin()[ 0 ], Plane.create() ) ); // left plane.
	        this._planeList.push( Vec4.set( -1.0, 0.0, 0.0, bb.getMax()[ 0 ], Plane.create() ) ); // right plane.
	        this._planeList.push( Vec4.set( 0.0, 1.0, 0.0, -bb.getMin()[ 1 ], Plane.create() ) ); // bottom plane.
	        this._planeList.push( Vec4.set( 0.0, -1.0, 0.0, bb.getMax()[ 1 ], Plane.create() ) ); // top plane.
	        this._planeList.push( Vec4.set( 0.0, 0.0, 1.0, -bb.getMin()[ 2 ], Plane.create() ) ); // near plane
	        this._planeList.push( Vec4.set( 0.0, 0.0, -1.0, bb.getMax()[ 2 ], Plane.create() ) ); // far plane
	        this.setupMask();
	    },
	
	    setAndTransformProvidingInverse: function ( pt, matrix ) {
	        this._referenceVertexList = pt._referenceVertexList;
	        var resultMask = pt._maskStack[ this._maskStack.length - 1 ];
	        if ( resultMask === 0 ) {
	            this._maskStack[ this._maskStack.length - 1 ] = 0;
	            this._resultMask = 0;
	            this._planeList.length = 0;
	            return;
	        }
	        var selectorMask = 0x1;
	
	        var numActivePlanes = 0;
	        // count number of active planes.
	        var i;
	        for ( i = 0; i !== pt._planeList.length; ++i ) {
	            if ( resultMask & selectorMask ) ++numActivePlanes;
	            selectorMask <<= 1;
	        }
	
	        this._planeList.length = numActivePlanes;
	        this._resultMask = 0;
	        selectorMask = 0x1;
	        var index = 0;
	        for ( i = 0; i !== pt._planeList.length; ++i ) {
	            if ( resultMask & selectorMask ) {
	                this._planeList[ index ] = pt._planeList[ i ];
	                Plane.transformProvidingInverse( this._planeList[ index++ ], matrix );
	                this._resultMask = ( this._resultMask << 1 ) | 1;
	            }
	            selectorMask <<= 1;
	        }
	
	        this._maskStack[ this._maskStack.length - 1 ] = this._resultMask;
	    },
	
	    voidset: function ( pl ) {
	        this._planeList = pl;
	        this.setupMask();
	    },
	
	
	    add: function ( pl ) {
	        this._planeList.push( pl );
	        this.setupMask();
	    },
	
	    empty: function () {
	        return this._planeList.length === 0;
	    },
	
	    getPlaneList: function () {
	        return this._planeList;
	    },
	
	    setReferenceVertexList: function ( vertices ) {
	        this._referenceVertexList = vertices;
	    },
	
	    getReferenceVertexList: function () {
	        return this._referenceVertexList;
	    },
	
	    setupMask: function ( plength ) {
	        this._resultMask = 0;
	        var pMasklength = ( plength !== undefined ) ? plength : this._planeList.length;
	        for ( var i = 0; i < pMasklength; ++i ) {
	            this._resultMask = ( this._resultMask << 1 ) | 1;
	        }
	        this._maskStack = [];
	        this._maskStack.push( this._resultMask );
	    },
	
	    getCurrentMask: function () {
	        return this._maskStack[ this._maskStack.length - 1 ];
	    },
	
	    setResultMask: function ( mask ) {
	        this._resultMask = mask;
	    },
	
	    getResultMask: function () {
	        return this._resultMask;
	    },
	
	    getMaskStack: function () {
	        return this._maskStack;
	    },
	
	
	    // push but keep current mask
	    pushCurrentMask: function () {
	        this._maskStack.push( this._resultMask );
	    },
	    // pop and restore previous mask
	    popCurrentMask: function () {
	        return this._maskStack.pop();
	    },
	
	
	    /** Check whether a vertex is contained within clipping set.*/
	    containsVertex: function ( v ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return true;
	
	        var selectorMask = 0x1;
	        for ( var i = 0; i < this._planeList.length; ++i ) {
	            if ( ( this._maskStack[ this._maskStack.length - 1 ] & selectorMask ) && ( Plane.distanceToPlane( this._planeList[ i ], v ) < 0.0 ) ) {
	                return false;
	            }
	            selectorMask <<= 1;
	        }
	        return true;
	    },
	
	    /** Check whether any part of vertex list is contained within clipping set.*/
	    containsVertices: function ( vertices ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return true;
	
	        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];
	
	        for ( var k = 0; k < vertices.length; ++k ) {
	            var v = vertices[ k ];
	            var outside = false;
	            var selectorMask = 0x1;
	            for ( var i = 0; !outside && i < this._planeList.length; ++i ) {
	                if ( ( this._maskStack[ this._maskStack.length - 1 ] & selectorMask ) && ( Plane.distanceToPlane( this._planeList[ i ], v ) < 0.0 ) ) {
	                    outside = true;
	                }
	                selectorMask <<= 1;
	            }
	
	            if ( !outside ) return true;
	        }
	        return false;
	    },
	
	    /** Check whether any part of a bounding sphere is contained within clipping set.
	        Using a mask to determine which planes should be used for the check, and
	        modifying the mask to turn off planes which wouldn't contribute to clipping
	        of any internal objects.  This feature is used in osgUtil::CullVisitor
	        to prevent redundant plane checking.*/
	    containsBoundingSphere: function ( bs ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] || !bs.valid() ) return true;
	
	        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];
	        var selectorMask = 0x1;
	
	        for ( var i = 0; i < this._planeList.length; ++i ) {
	            if ( this._resultMask & selectorMask ) {
	                var res = Plane.intersectsOrContainsBoundingSphere( this._planeList[ i ], bs );
	                if ( Plane.OUTSIDE === res ) {
	                    // totally outside a clipping set.
	                    return false;
	                } else if ( Plane.INSIDE === res ) {
	                    // subsequent checks against this plane not required.
	                    this._resultMask ^= selectorMask;
	                }
	                // else if ( Plane.INTERSECT === res ) { // last possible case
	                //   can say nothing.
	                // subsequent checks against this plane needed.
	                //}
	            }
	            selectorMask <<= 1;
	        }
	        return true;
	    },
	
	    /** Check whether any part of a bounding box is contained within clipping set.
	        Using a mask to determine which planes should be used for the check, and
	        modifying the mask to turn off planes which wouldn't contribute to clipping
	        of any internal objects.  This feature is used in osgUtil::CullVisitor
	        to prevent redundant plane checking.*/
	    containsBoundingBox: function ( bb ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return true;
	
	        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];
	        var selectorMask = 0x1;
	
	        for ( var i = 0; i < this._planeList.length; ++i ) {
	            if ( this._resultMask & selectorMask ) {
	                var res = Plane.intersectsOrContainsBoundingBox( this._planeList[ i ], bb );
	                if ( Plane.OUTSIDE === res ) return false; // outside clipping set.
	                else if ( Plane.INSIDE === res ) this._resultMask ^= selectorMask; // subsequent checks against this plane not required.
	                // else if ( Plane.INTERSECT === res ) the last case need
	                // no test here but further tests
	            }
	            selectorMask <<= 1;
	        }
	        // correct frustum culling should double check now for
	        // http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm
	        // which is inside one "plane", but outside the convex plane intersection
	        return true;
	    },
	
	    /** Check whether all of vertex list is contained with clipping set.*/
	    containsAllOfVertices: function ( vertices ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return false;
	
	        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];
	        var selectorMask = 0x1;
	
	        for ( var i = 0; i < this._planeList.length; ++i ) {
	            if ( this._resultMask & selectorMask ) {
	                var res = Plane.intersectsOrContainsVertices( this._planeList[ i ], vertices );
	                if ( res < 1 ) return false; // intersects, or is below plane.
	                this._resultMask ^= selectorMask; // subsequent checks against this plane not required.
	            }
	            selectorMask <<= 1;
	        }
	        return true;
	    },
	
	    /** Check whether the entire bounding sphere is contained within clipping set.*/
	    containsAllOfBoundingSphere: function ( bs ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return false;
	
	        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];
	        var selectorMask = 0x1;
	
	        for ( var i = 0; i < this._planeList.length; ++i ) {
	            if ( this._resultMask & selectorMask ) {
	                var res = Plane.intersectsOrContainsBoundingSphere( this._planeList[ i ], bs );
	                if ( res < 1 ) return false; // intersects, or is below plane.
	                this._resultMask ^= selectorMask; // subsequent checks against this plane not required.
	            }
	            selectorMask <<= 1;
	        }
	        return true;
	    },
	
	    /** Check whether the entire bounding box is contained within clipping set.*/
	    containsAllOfBoundingBox: function ( bbox ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return false;
	
	        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];
	        var selectorMask = 0x1;
	
	        for ( var i = 0; i < this._planeList.length; ++i ) {
	            if ( this._resultMask & selectorMask ) {
	                var res = Plane.intersectsOrContainsBoundingBox( this._planeList[ i ], bbox );
	                if ( res < 1 ) return false; // intersects, or is below plane.
	                this._resultMask ^= selectorMask; // subsequent checks against this plane not required.
	            }
	            selectorMask <<= 1;
	        }
	        return true;
	    },
	
	    /** Transform the clipping set by provide a pre inverted matrix.
	     * see transform for details. */
	    transformProvidingInverse: function ( matrix ) {
	        if ( !this._maskStack[ this._maskStack.length - 1 ] ) return;
	
	        this._resultMask = this._maskStack[ this._maskStack.length - 1 ];
	        var selectorMask = 0x1;
	        for ( var i = 0; i < this._planeList.length; ++i ) {
	            if ( this._resultMask & selectorMask ) {
	                Plane.transformProvidingInverse( this._planeList[ i ], matrix );
	                selectorMask <<= 1;
	            }
	        }
	    }
	
	
	
	} );
	
	/*jshint bitwise: true */
	
	module.exports = Polytope;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var BoundingSphere = __webpack_require__( 18 );
	var Camera = __webpack_require__( 56 );
	var ComputeMatrixFromNodePath = __webpack_require__( 28 );
	var CullSettings = __webpack_require__( 57 );
	var CullingSet = __webpack_require__( 60 );
	var Matrix = __webpack_require__( 23 );
	var MatrixMemoryPool = __webpack_require__( 27 );
	var Transform = __webpack_require__( 11 );
	var Notify = __webpack_require__( 10 );
	var TransformEnums = __webpack_require__( 29 );
	var Vec3 = __webpack_require__( 15 );
	
	var CullStack = function () {
	
	    this._modelViewMatrixStack = [];
	    this._projectionMatrixStack = [];
	    this._viewportStack = [];
	    this._cullingSetStack = [];
	    this._frustumVolume = -1.0;
	    this._bbCornerFar = 0;
	    this._bbCornerNear = 0;
	
	    // keep a matrix in memory to avoid to create matrix
	    this._reservedMatrixStack = new MatrixMemoryPool();
	
	    this._reserveCullingSetStack = [
	        new CullingSet()
	    ];
	    this._reserveCullingSetStack.current = 0;
	
	
	    // data for caching camera matrix inverse for computation of world/view
	    // contains index of the camera node in the nodepath
	    this._cameraIndexStack = [];
	    // contains index of the camera modelview matrix in the modelViewMatrixStack
	    this._cameraModelViewIndexStack = [];
	
	    // contains the id has a key to computed Inverse Matrix
	    this._cameraMatrixInverse = {};
	
	};
	
	CullStack.prototype = MACROUTILS.objectInherit( CullSettings.prototype, {
	
	    _getReservedCullingSet: function () {
	        var m = this._reserveCullingSetStack[ this._reserveCullingSetStack.current++ ];
	        if ( this._reserveCullingSetStack.current === this._reserveCullingSetStack.length ) {
	            this._reserveCullingSetStack.push( new CullingSet() );
	        }
	        return m;
	    },
	    reset: function () {
	        this._modelViewMatrixStack.length = 0;
	        this._projectionMatrixStack.length = 0;
	        this._cullingSetStack.length = 0;
	
	        this._reservedMatrixStack.reset();
	        this._reserveCullingSetStack.current = 0;
	
	        this._cameraModelViewIndexStack.length = 0;
	        this._cameraIndexStack.length = 0;
	        this._cameraMatrixInverse = {};
	    },
	
	    getProjectionMatrixStack: function () {
	        return this._projectionMatrixStack;
	    },
	    getCurrentProjectionMatrix: function () {
	        return this._projectionMatrixStack[ this._projectionMatrixStack.length - 1 ];
	    },
	
	    getCurrentModelViewMatrix: function () {
	        return this._modelViewMatrixStack[ this._modelViewMatrixStack.length - 1 ];
	    },
	
	    getCurrentModelviewMatrix: function () {
	        Notify.warn( 'deprecated switch to getCurrentModelViewMatrix' );
	        return this.getCurrentModelViewMatrix();
	    },
	
	    getCameraInverseMatrix: function () {
	
	        // Return or compute and cache the MatrixInverse of the last
	        // active camera in absolute reference
	
	        // if no index the camera inverse is the root with an fake id
	        if ( !this._cameraIndexStack.length )
	            return this._cameraMatrixInverse[ -1 ];
	
	        var idx = this._cameraIndexStack[ this._cameraIndexStack.length - 1 ];
	
	        // get the camera node
	        var camera = this.getNodePath()[ idx ];
	        var id = camera.getInstanceID();
	
	        if ( this._cameraMatrixInverse[ id ] === undefined ) {
	            var indexInModelViewMatrixStack = this._cameraModelViewIndexStack[ this._cameraModelViewIndexStack.length - 1 ];
	            var mat = this._modelViewMatrixStack[ indexInModelViewMatrixStack ];
	            var matInverse = this._reservedMatrixStack.get();
	            Matrix.inverse( mat, matInverse );
	            this._cameraMatrixInverse[ id ] = matInverse;
	        }
	        return this._cameraMatrixInverse[ id ];
	    },
	
	    getCurrentModelWorldMatrix: function () {
	        // Improvment could be to cache more things
	        // and / or use this method only if the shader use it
	        var invMatrix = this.getCameraInverseMatrix();
	        var m = this._reservedMatrixStack.get();
	        var world = Matrix.mult( invMatrix, this.getCurrentModelViewMatrix(), m );
	        return world;
	    },
	
	    getCurrentViewMatrix: function () {
	        // Improvment could be to cache more things
	        // and / or use this method only if the shader use it
	        if ( !this._cameraIndexStack.length )
	            return this._modelViewMatrixStack[ 0 ];
	
	        // also we could keep the index of the current to avoid lenght-1 at each access
	        // it's implemented in osg like that:
	        // https://github.com/openscenegraph/osg/blob/master/include/osg/fast_back_stack
	        var idx = this._cameraModelViewIndexStack[ this._cameraModelViewIndexStack.length - 1 ];
	        return this._modelViewMatrixStack[ idx ];
	    },
	
	    getViewport: function () {
	        if ( this._viewportStack.length === 0 ) {
	            return undefined;
	        }
	        return this._viewportStack[ this._viewportStack.length - 1 ];
	    },
	    getLookVectorLocal: function ( outLookVector ) {
	        var lookVectorLocal = this.getCurrentModelViewMatrix();
	        return Vec3.set( -lookVectorLocal[ 2 ], -lookVectorLocal[ 6 ], -lookVectorLocal[ 10 ], outLookVector );
	    },
	    pushViewport: function ( vp ) {
	        this._viewportStack.push( vp );
	    },
	    popViewport: function () {
	        this._viewportStack.pop();
	    },
	
	    pushCullingSet: function () {
	        var cs = this._getReservedCullingSet();
	        if ( this._enableFrustumCulling ) {
	            Matrix.getFrustumPlanes( this.getCurrentProjectionMatrix(), this.getCurrentModelViewMatrix(), cs.getFrustum().getPlanes(), false );
	            // TODO: no far no near.
	            // should check if we have them
	            // should add at least a near 0 clip if not
	            cs.getFrustum().setupMask( 4 );
	        }
	
	        this._cullingSetStack.push( cs );
	    },
	    popCullingSet: function () {
	        return this._cullingSetStack.pop();
	    },
	    getCurrentCullingSet: function () {
	        return this._cullingSetStack[ this._cullingSetStack.length - 1 ];
	    },
	
	
	    pushCurrentMask: function () {
	        var cs = this.getCurrentCullingSet();
	        if ( cs ) cs.pushCurrentMask();
	    },
	    popCurrentMask: function () {
	        var cs = this.getCurrentCullingSet();
	        if ( cs ) cs.popCurrentMask();
	    },
	
	    isVerticesCulled: function ( vertices ) {
	        if ( !this._enableFrustumCulling )
	            return false;
	        return this.getCurrentCullingSet().isVerticesCulled( vertices );
	    },
	
	    isBoundingBoxCulled: function ( bb ) {
	        if ( !this._enableFrustumCulling )
	            return false;
	        return bb.valid() && this.getCurrentCullingSet().isBoundingBoxCulled( bb );
	    },
	
	    isBoundingSphereCulled: function ( bs ) {
	        if ( !this._enableFrustumCulling )
	            return false;
	        return bs.valid() && this.getCurrentCullingSet().isBoundingSphereCulled( bs );
	    },
	
	    isCulled: ( function () {
	        var bsWorld = new BoundingSphere();
	        return function ( node, nodePath ) {
	            if ( !this._enableFrustumCulling )
	                return false;
	            if ( node.isCullingActive() ) {
	                if ( this.getCurrentCullingSet().getCurrentResultMask() === 0 )
	                    return false; // father bounding sphere totally inside
	
	                var matrix = this._reservedMatrixStack.get();
	
	                // TODO: Perf just get World Matrix at each node transform
	                // store it in a World Transform Node Path (only world matrix change)
	                // so that it's computed once and reused for each further node getCurrentModelWorld
	                // otherwise, it's 1 mult for each node, each matrix node, and each geometry
	                //matrix = this.getCurrentModelWorldMatrix();
	                // tricky: change push be before isculled, and pop in case of culling
	                // strange bug for now on frustum culling sample with that
	
	                if ( node instanceof Transform ) {
	
	                    // tricky: MatrixTransform getBound is already transformed to
	                    // its local space whereas nodepath also have its matrix ...
	                    // so to get world space, you HAVE to remove that matrix from nodePATH
	                    // TODO: GC Perf of array slice creating new array
	                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( nodePath.slice( 0, nodePath.length - 1 ), true, matrix );
	
	                } else {
	
	                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( nodePath, true, matrix );
	
	                }
	
	                Matrix.transformBoundingSphere( matrix, node.getBound(), bsWorld );
	                return this.getCurrentCullingSet().isBoundingSphereCulled( bsWorld );
	            } else {
	                this.getCurrentCullingSet().resetCullingMask();
	                return false;
	            }
	        };
	    } )(),
	
	
	
	    pushModelViewMatrix: ( function () {
	        var lookVector = Vec3.create();
	        return function ( matrix ) {
	
	            // When pushing a matrix, it can be a transform or camera. To compute
	            // differents matrix type in shader ( ViewMatrix/ModelWorldMatrix/ModelViewMatrix )
	            // we track camera node when using pushModelViewMatrix
	            // To detect a camera, we check on the nodepath the type of the node and if the
	            // camera is relatif or absolute.
	            // When we detect an absolute camera we keep it's index to get it when needed to
	            // compute the World/View matrix
	            // Th    ere is an exception for the root camera, the root camera is not pushed on the
	            // CullVisitor but only its matrixes, so to handle this we compute the inverse camera
	            // when the nodepath has a lenght of 0
	            // To avoid to compute too much inverse matrix, we keep a cache of them during the
	            // traverse and store the result under the instanceID key, except for the root we use
	            // the special id '-1'
	            var np = this.getNodePath();
	            var length = np.length;
	            if ( !length ) { // root
	                var matInverse = this._reservedMatrixStack.get();
	                Matrix.inverse( matrix, matInverse );
	                this._cameraMatrixInverse[ -1 ] = matInverse;
	            } else {
	                var index = length - 1;
	                if ( np[ index ].getTypeID() === Camera.getTypeID() && np[ index ].getReferenceFrame() === TransformEnums.ABSOLUTE_RF ) {
	                    this._cameraIndexStack.push( index );
	                    this._cameraModelViewIndexStack.push( this._modelViewMatrixStack.length );
	                }
	            }
	
	            this._modelViewMatrixStack.push( matrix );
	            this.getLookVectorLocal( lookVector );
	
	            /*jshint bitwise: false */
	            this._bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );
	            this._bbCornerNear = ( ~this._bbCornerFar ) & 7;
	            /*jshint bitwise: true */
	
	        };
	    } )(),
	    popModelViewMatrix: ( function () {
	        var lookVector = Vec3.create();
	
	        return function () {
	
	            // if same index it's a camera and we have to pop it
	            var np = this.getNodePath();
	            var index = np.length - 1;
	            if ( this._cameraIndexStack.length && index === this._cameraIndexStack[ this._cameraIndexStack.length - 1 ] ) {
	                this._cameraIndexStack.pop();
	                this._cameraModelViewIndexStack.pop();
	            }
	
	            this._modelViewMatrixStack.pop();
	
	            if ( this._modelViewMatrixStack.length !== 0 ) {
	                this.getLookVectorLocal( lookVector );
	            } else {
	                Vec3.set( 0.0, 0.0, -1.0, lookVector );
	            }
	
	            /*jshint bitwise: false */
	            this._bbCornerFar = ( lookVector[ 0 ] >= 0.0 ? 1.0 : 0.0 ) | ( lookVector[ 1 ] >= 0 ? 2.0 : 0.0 ) | ( lookVector[ 2 ] >= 0 ? 4.0 : 0.0 );
	            this._bbCornerNear = ( ~this._bbCornerFar ) & 7;
	            /*jshint bitwise: true */
	        };
	    } )(),
	
	    pushProjectionMatrix: function ( matrix ) {
	        this._projectionMatrixStack.push( matrix );
	
	        // need to recompute frustum volume.
	        this._frustumVolume = -1.0;
	
	        this.pushCullingSet();
	    },
	    popProjectionMatrix: function () {
	        this._projectionMatrixStack.pop();
	
	        // need to recompute frustum volume.
	        this._frustumVolume = -1.0;
	
	        this.popCullingSet();
	    },
	
	
	} );
	
	module.exports = CullStack;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var osgMath = __webpack_require__( 16 );
	var NodeVisitor = __webpack_require__( 22 );
	var CullSettings = __webpack_require__( 57 );
	var CullStack = __webpack_require__( 62 );
	var Matrix = __webpack_require__( 23 );
	var MatrixTransform = __webpack_require__( 44 );
	var AutoTransform = __webpack_require__( 5 );
	var Projection = __webpack_require__( 45 );
	var LightSource = __webpack_require__( 64 );
	var osgPool = __webpack_require__( 7 );
	var Geometry = __webpack_require__( 31 );
	var RenderLeaf = __webpack_require__( 65 );
	var RenderBin = __webpack_require__( 66 );
	var RenderStage = __webpack_require__( 67 );
	var Node = __webpack_require__( 12 );
	var Lod = __webpack_require__( 69 );
	var PagedLOD = __webpack_require__( 71 );
	var Camera = __webpack_require__( 56 );
	var TransformEnums = __webpack_require__( 29 );
	var Vec3 = __webpack_require__( 15 );
	var Skeleton = __webpack_require__( 72 );
	var RigGeometry = __webpack_require__( 78 );
	var Bone = __webpack_require__( 74 );
	var MorphGeometry = __webpack_require__( 79 );
	
	/**
	 * CullVisitor traverse the tree and collect Matrix/State for the rendering traverse
	 * @class CullVisitor
	 */
	var CullVisitor = function () {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ACTIVE_CHILDREN );
	    CullSettings.call( this );
	    CullStack.call( this );
	
	    this._rootStateGraph = undefined;
	    this._currentStateGraph = undefined;
	    this._currentRenderBin = undefined;
	    this._currentRenderStage = undefined;
	    this._rootRenderStage = undefined;
	    this._computedNear = Number.POSITIVE_INFINITY;
	    this._computedFar = Number.NEGATIVE_INFINITY;
	
	    var lookVector = Vec3.createAndSet( 0.0, 0.0, -1.0 );
	    this._camera = undefined;
	    /*jshint bitwise: false */
	    this._bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );
	    this._bbCornerNear = ( ~this._bbCornerFar ) & 7;
	    /*jshint bitwise: true */
	
	    this._reserveLeafStack = [ new RenderLeaf() ];
	    this._reserveLeafStackCurrent = 0;
	
	    this._reserveRenderStageStacks = {};
	
	    this._reserveCullSettingsStack = [ new CullSettings() ];
	    this._reserveCullSettingsStackCurrent = 0;
	
	    this._renderBinStack = [];
	    this.visitorType = NodeVisitor.CULL_VISITOR;
	
	    this._identityMatrix = Matrix.create();
	
	    this._renderer = undefined;
	    this._renderStageType = RenderStage;
	
	    this._numCamera = 0;
	    this._numMatrixTransform = 0;
	    this._numProjection = 0;
	    this._numNode = 0;
	    this._numLightSource = 0;
	    this._numGeometry = 0;
	
	};
	
	/** @lends CullVisitor.prototype */
	CullVisitor.prototype = MACROUTILS.objectInherit( CullStack.prototype, MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    distance: function ( coord, matrix ) {
	        return -( coord[ 0 ] * matrix[ 2 ] + coord[ 1 ] * matrix[ 6 ] + coord[ 2 ] * matrix[ 10 ] + matrix[ 14 ] );
	    },
	
	    getComputedNear: function () {
	        return this._computedNear;
	    },
	
	    getComputedFar: function () {
	        return this._computedFar;
	    },
	
	    resetStats: function () {
	        this._numCamera = 0;
	        this._numMatrixTransform = 0;
	        this._numProjection = 0;
	        this._numNode = 0;
	        this._numLightSource = 0;
	        this._numGeometry = 0;
	    },
	
	    handleCullCallbacksAndTraverse: function ( node ) {
	        var ccb = node.getCullCallback();
	        if ( ccb && !ccb.cull( node, this ) )
	            return;
	        this.traverse( node );
	    },
	
	    getCurrentCamera: function () {
	        return this._currentRenderBin.getStage().getCamera();
	    },
	
	    updateCalculatedNearFar: ( function () {
	        var nearVec = Vec3.create();
	        var farVec = Vec3.create();
	
	        return function ( matrix, drawable ) {
	
	            var bb = drawable.getBoundingBox();
	            var dNear, dFar;
	
	            // efficient computation of near and far, only taking into account the nearest and furthest
	            // corners of the bounding box.
	            dNear = this.distance( bb.corner( this._bbCornerNear, nearVec ), matrix );
	            dFar = this.distance( bb.corner( this._bbCornerFar, farVec ), matrix );
	
	            if ( dNear > dFar ) {
	                var tmp = dNear;
	                dNear = dFar;
	                dFar = tmp;
	            }
	
	            if ( dFar < 0.0 ) {
	                // whole object behind the eye point so discard
	                return false;
	            }
	
	            if ( dNear < this._computedNear ) {
	                this._computedNear = dNear;
	            }
	
	            if ( dFar > this._computedFar ) {
	                this._computedFar = dFar;
	            }
	
	            return true;
	
	        };
	    } )(),
	
	
	    setStateGraph: function ( sg ) {
	        this._rootStateGraph = sg;
	        this._currentStateGraph = sg;
	    },
	    setRenderStage: function ( rg ) {
	        this._rootRenderStage = rg;
	        this._currentRenderBin = rg;
	    },
	    setRenderer: function ( renderer ) {
	        this._renderer = renderer;
	    },
	    getRenderer: function () {
	        return this._renderer;
	    },
	
	    reset: function () {
	        CullStack.prototype.reset.call( this );
	        // Reset the stack before reseting the current leaf index.
	        // Reseting elements and refilling them later is faster than create new elements
	        // That's the reason to have a leafStack, see http://jsperf.com/refill/2
	        this.resetRenderLeafStack();
	        this._reserveLeafStackCurrent = 0;
	
	        this.resetCullSettingsStack();
	        this._reserveCullSettingsStackCurrent = 0;
	
	        // renderstage / renderbin pools
	        var resetStages = window.Object.keys( this._reserveRenderStageStacks );
	        for ( var i = 0, l = resetStages.length; i < l; i++ ) {
	            var key = resetStages[ i ];
	            this._reserveRenderStageStacks[ key ].reset();
	        }
	        RenderBin.resetStack();
	
	        this._computedNear = Number.POSITIVE_INFINITY;
	        this._computedFar = Number.NEGATIVE_INFINITY;
	    },
	
	    getCurrentRenderBin: function () {
	        return this._currentRenderBin;
	    },
	
	    setCurrentRenderBin: function ( rb ) {
	        this._currentRenderBin = rb;
	    },
	
	    // mimic the osg implementation
	    // in osg you can push 0, in this case an identity matrix will be loaded
	    addPositionedAttribute: function ( matrix, attribute ) {
	
	        var m = matrix ? matrix : this._identityMatrix;
	        this._currentRenderBin.getStage().positionedAttribute.push( [ m, attribute ] );
	
	    },
	
	    pushStateSet: function ( stateset ) {
	        this._currentStateGraph = this._currentStateGraph.findOrInsert( stateset );
	        if ( stateset.getBinName() !== undefined ) {
	            var renderBinStack = this._renderBinStack;
	            var currentRenderBin = this._currentRenderBin;
	            renderBinStack.push( currentRenderBin );
	            this._currentRenderBin = currentRenderBin.getStage().findOrInsert( stateset.getBinNumber(), stateset.getBinName() );
	        }
	    },
	
	    /** Pop the top state set and hence associated state group.
	     * Move the current state group to the parent of the popped
	     * state group.
	     */
	    popStateSet: function () {
	        var currentStateGraph = this._currentStateGraph;
	        var stateset = currentStateGraph.getStateSet();
	        this._currentStateGraph = currentStateGraph.parent;
	        if ( stateset.getBinName() !== undefined ) {
	            var renderBinStack = this._renderBinStack;
	            if ( renderBinStack.length === 0 ) {
	                this._currentRenderBin = this._currentRenderBin.getStage();
	            } else {
	                this._currentRenderBin = renderBinStack.pop();
	            }
	        }
	    },
	
	    popProjectionMatrix: function () {
	        if ( this._computeNearFar === true && this._computedFar >= this._computedNear ) {
	            var m = this.getCurrentProjectionMatrix();
	            if ( this._clampProjectionMatrixCallback !== undefined ) {
	                this._clampProjectionMatrixCallback( m, this._computedNear, this._computedFar, this._nearFarRatio );
	            } else {
	                Matrix.clampProjectionMatrix( m, this._computedNear, this._computedFar, this._nearFarRatio );
	            }
	        }
	        CullStack.prototype.popProjectionMatrix.call( this );
	    },
	
	    popCameraModelViewProjectionMatrix: function () {
	        this.popModelViewMatrix();
	        this.popProjectionMatrix();
	    },
	
	    pushCameraModelViewProjectionMatrix: function ( camera, modelview, projection ) {
	        this.pushModelViewMatrix( modelview );
	        this.pushProjectionMatrix( projection );
	    },
	
	    apply: function ( node ) {
	        this[ node.typeID ]( node );
	    },
	
	    createOrReuseRenderStage: function ( classInstance ) {
	
	        var type = !classInstance ? 'RenderStage' : classInstance.className();
	        var classCtor = !classInstance ? RenderStage : classInstance.constructor;
	
	        var stack;
	        if ( this._reserveRenderStageStacks[ type ] ) {
	            stack = this._reserveRenderStageStacks[ type ];
	        } else {
	            stack = new osgPool.OsgObjectMemoryStack( classCtor );
	            this._reserveRenderStageStacks[ type ] = stack;
	        }
	        return stack.get().init();
	
	    },
	
	    createOrReuseRenderLeaf: function () {
	        var l = this._reserveLeafStack[ this._reserveLeafStackCurrent++ ];
	        if ( this._reserveLeafStackCurrent === this._reserveLeafStack.length ) {
	            this._reserveLeafStack.push( new RenderLeaf() );
	        }
	        return l;
	    },
	
	    resetRenderLeafStack: function () {
	        for ( var i = 0, j = this._reserveLeafStackCurrent; i <= j; i++ ) {
	            this._reserveLeafStack[ i ].reset();
	        }
	    },
	
	    createOrReuseCullSettings: function () {
	        var l = this._reserveCullSettingsStack[ this._reserveCullSettingsStackCurrent++ ];
	
	        if ( this._reserveCullSettingsStackCurrent === this._reserveCullSettingsStack.length ) {
	
	            this._reserveCullSettingsStack.push( new CullSettings() );
	
	        }
	        return l;
	    },
	
	    resetCullSettingsStack: function () {
	        for ( var i = 0, j = this._reserveCullSettingsStackCurrent; i <= j; i++ ) {
	            this._reserveCullSettingsStack[ i ].reset();
	        }
	    },
	
	    // function call after the push state in the geometry apply function
	    // the idea is to avoid heavy copy-paste for the rigGeometry apply
	    // since the only difference is that we want to push an additional state
	    // Maybe it will be useful when we'll add morph target geometry or something...
	    postPushGeometry: function ( cull, node ) {
	
	        var sourceGeometry;
	        var geometryStateSetAnimation;
	
	        if ( node instanceof RigGeometry ) {
	
	            geometryStateSetAnimation = node.getStateSetAnimation();
	            if ( geometryStateSetAnimation ) cull.pushStateSet( geometryStateSetAnimation );
	
	            sourceGeometry = node.getSourceGeometry();
	
	            if ( sourceGeometry instanceof MorphGeometry ) {
	
	                geometryStateSetAnimation = sourceGeometry.getStateSetAnimation();
	                if ( geometryStateSetAnimation ) cull.pushStateSet( geometryStateSetAnimation );
	
	            }
	
	        } else if ( node instanceof MorphGeometry ) {
	
	            geometryStateSetAnimation = node.getStateSetAnimation();
	            if ( geometryStateSetAnimation ) cull.pushStateSet( geometryStateSetAnimation );
	
	        }
	
	    },
	
	    // same comment as above (postPushGeometry)
	    prePopGeometry: function ( cull, node ) {
	
	        if ( node instanceof RigGeometry ) {
	
	            var sourceGeometry = node.getSourceGeometry();
	
	            if ( sourceGeometry instanceof MorphGeometry ) {
	
	                if ( sourceGeometry.getStateSetAnimation() ) cull.popStateSet();
	
	            }
	
	            if ( node.getStateSetAnimation() ) cull.popStateSet();
	
	        } else if ( node instanceof MorphGeometry && node.getStateSetAnimation() ) {
	
	            cull.popStateSet();
	
	        }
	
	    },
	
	    pushLeaf: function ( node, depth ) {
	        var leafs = this._currentStateGraph.leafs;
	        if ( leafs.length === 0 ) {
	            this._currentRenderBin.addStateGraph( this._currentStateGraph );
	        }
	
	        var leaf = this.createOrReuseRenderLeaf();
	
	        leaf.init( this._currentStateGraph,
	            node,
	            this.getCurrentProjectionMatrix(),
	            this.getCurrentViewMatrix(),
	            this.getCurrentModelViewMatrix(),
	            this.getCurrentModelWorldMatrix(),
	            depth );
	
	        leafs.push( leaf );
	
	    }
	
	} ) );
	
	
	// Camera cull visitor call
	// ANY CHANGE, any change : double check in rendere Camera code
	// for the first camera
	CullVisitor.prototype[ Camera.typeID ] = function ( camera ) {
	    this._numCamera++;
	
	    var stateset = camera.getStateSet();
	    if ( stateset ) this.pushStateSet( stateset );
	
	    var modelview = this._reservedMatrixStack.get();
	    var projection = this._reservedMatrixStack.get();
	
	    if ( camera.getReferenceFrame() === TransformEnums.RELATIVE_RF ) {
	
	        var lastProjectionMatrix = this.getCurrentProjectionMatrix();
	        Matrix.mult( lastProjectionMatrix, camera.getProjectionMatrix(), projection );
	
	        var lastViewMatrix = this.getCurrentModelViewMatrix();
	        Matrix.mult( lastViewMatrix, camera.getViewMatrix(), modelview );
	
	    } else {
	
	        // absolute
	        Matrix.copy( camera.getViewMatrix(), modelview );
	        Matrix.copy( camera.getProjectionMatrix(), projection );
	
	    }
	
	
	    // save current state of the camera
	    var previousZnear = this._computedNear;
	    var previousZfar = this._computedFar;
	
	    // save cullSettings
	    // TODO Perf: why it's not a stack
	    // and is pollutin  GC ?
	    var previousCullsettings = this.createOrReuseCullSettings();
	    previousCullsettings.setCullSettings( this );
	
	    this._computedNear = Number.POSITIVE_INFINITY;
	    this._computedFar = Number.NEGATIVE_INFINITY;
	    //
	
	    this.setCullSettings( camera );
	    // global override
	    // upon who setted the parameter
	    // if it's cullvisitor
	    // it's an OVERRIDER for enableFrustumCulling
	    // allowing for global EnableFrustimCulling
	    if ( previousCullsettings.getSettingSourceOverrider() === this && previousCullsettings.getEnableFrustumCulling() ) {
	        this.setEnableFrustumCulling( true );
	    }
	
	
	    this.pushCameraModelViewProjectionMatrix( camera, modelview, projection );
	
	    if ( camera.getViewport() ) {
	        this.pushViewport( camera.getViewport() );
	    }
	
	
	    // nested camera
	    if ( camera.getRenderOrder() === Camera.NESTED_RENDER ) {
	
	        this.handleCullCallbacksAndTraverse( camera );
	
	    } else {
	        // not tested
	
	        var renderBin = this.getCurrentRenderBin();
	        var previousStage = renderBin.getStage();
	
	        // use render to texture stage
	        var rtts = this.createOrReuseRenderStage( this._rootRenderStage );
	
	        rtts.setCamera( camera );
	        rtts.setClearDepth( camera.getClearDepth() );
	        rtts.setClearColor( camera.getClearColor() );
	        rtts.setClearMask( camera.getClearMask() );
	
	        var vp;
	        if ( camera.getViewport() === undefined ) {
	            vp = previousStage.getViewport();
	        } else {
	            vp = camera.getViewport();
	        }
	        rtts.setViewport( vp );
	
	        // skip positional state for now
	        // ...
	
	        this.setCurrentRenderBin( rtts );
	
	        this.handleCullCallbacksAndTraverse( camera );
	
	        this.setCurrentRenderBin( renderBin );
	
	        if ( camera.getRenderOrder() === Camera.PRE_RENDER ) {
	            this.getCurrentRenderBin().getStage().addPreRenderStage( rtts, camera.renderOrderNum );
	        } else {
	            this.getCurrentRenderBin().getStage().addPostRenderStage( rtts, camera.renderOrderNum );
	        }
	    }
	
	    this.popCameraModelViewProjectionMatrix( camera );
	
	    if ( camera.getViewport() ) {
	        this.popViewport();
	    }
	
	    // restore previous state of the camera
	    this.setCullSettings( previousCullsettings );
	    this._computedNear = previousZnear;
	    this._computedFar = previousZfar;
	
	    if ( stateset ) this.popStateSet();
	
	};
	
	
	CullVisitor.prototype[ MatrixTransform.typeID ] = function ( node ) {
	    this._numMatrixTransform++;
	
	    // Camera and lights must enlarge node parent bounding boxes for this not to cull
	    if ( this.isCulled( node, this.nodePath ) ) {
	        return;
	    }
	    // push the culling mode.
	    this.pushCurrentMask();
	
	    var matrix = this._reservedMatrixStack.get();
	    var lastMatrixStack = this.getCurrentModelViewMatrix();
	    Matrix.copy( lastMatrixStack, matrix );
	    node.computeLocalToWorldMatrix( matrix );
	    this.pushModelViewMatrix( matrix );
	
	
	    var stateset = node.getStateSet();
	
	    if ( stateset ) this.pushStateSet( stateset );
	
	    this.handleCullCallbacksAndTraverse( node );
	
	    if ( stateset ) this.popStateSet();
	
	
	    this.popModelViewMatrix();
	
	    // pop the culling mode.
	    this.popCurrentMask();
	};
	
	CullVisitor.prototype[ Projection.typeID ] = function ( node ) {
	    this._numProjection++;
	
	    var lastMatrixStack = this.getCurrentProjectionMatrix();
	    var matrix = this._reservedMatrixStack.get();
	    Matrix.mult( lastMatrixStack, node.getProjectionMatrix(), matrix );
	    this.pushProjectionMatrix( matrix );
	
	    var stateset = node.getStateSet();
	    if ( stateset ) this.pushStateSet( stateset );
	
	    this.handleCullCallbacksAndTraverse( node );
	
	    if ( stateset ) this.popStateSet();
	
	    this.popProjectionMatrix();
	};
	
	// here it's treated as a group node for culling
	// as there's isn't any in osgjs
	// so frustumCulling is done here
	CullVisitor.prototype[ Node.typeID ] = function ( node ) {
	    this._numNode++;
	
	    // Camera and lights must enlarge node parent bounding boxes for this not to cull
	    if ( this.isCulled( node, this.nodePath ) ) {
	        return;
	    }
	
	    // push the culling mode.
	    this.pushCurrentMask();
	
	    var stateset = node.getStateSet();
	    if ( stateset ) this.pushStateSet( stateset );
	
	    this.handleCullCallbacksAndTraverse( node );
	
	    if ( stateset ) this.popStateSet();
	
	    // pop the culling mode.
	    this.popCurrentMask();
	};
	
	// same code like MatrixTransform
	CullVisitor.prototype[ AutoTransform.typeID ] = CullVisitor.prototype[ MatrixTransform.typeID ];
	
	// same code like Node
	CullVisitor.prototype[ Lod.typeID ] = CullVisitor.prototype[ Node.typeID ];
	
	// same code like Node
	CullVisitor.prototype[ PagedLOD.typeID ] = CullVisitor.prototype[ Node.typeID ];
	
	
	CullVisitor.prototype[ LightSource.typeID ] = function ( node ) {
	    this._numLightSource++;
	
	    var stateset = node.getStateSet();
	    if ( stateset ) this.pushStateSet( stateset );
	
	    var light = node.getLight();
	    if ( light ) {
	        if ( node.getReferenceFrame() === TransformEnums.RELATIVE_RF )
	            this.addPositionedAttribute( this.getCurrentModelViewMatrix(), light );
	        else
	            this.addPositionedAttribute( null, light );
	    }
	
	
	    this.handleCullCallbacksAndTraverse( node );
	
	    if ( stateset ) this.popStateSet();
	};
	
	CullVisitor.prototype[ Geometry.typeID ] = ( function () {
	
	    var tempVec = Vec3.create();
	    var loggedOnce = false;
	    return function ( node ) {
	
	        this._numGeometry++;
	
	        var modelview = this.getCurrentModelViewMatrix();
	        var bb = node.getBoundingBox();
	        if ( this._computeNearFar && bb.valid() ) {
	            if ( !this.updateCalculatedNearFar( modelview, node ) ) {
	                return;
	            }
	        }
	
	        // using modelview is not a pb because geometry
	        // is a leaf node, else traversing the graph would be an
	        // issue because we use modelview after
	        var ccb = node.getCullCallback();
	        if ( ccb && !ccb.cull( node, this ) )
	            return;
	
	        var stateset = node.getStateSet();
	        if ( stateset ) this.pushStateSet( stateset );
	
	        this.postPushGeometry( this, node );
	
	        var depth = 0;
	        if ( bb.valid() ) {
	            depth = this.distance( bb.center( tempVec ), modelview );
	        }
	        if ( osgMath.isNaN( depth ) ) {
	
	            if ( !loggedOnce ) {
	                Notify.warn( 'warning geometry has a NaN depth, ' + modelview + ' center ' + tempVec );
	                loggedOnce = true;
	            }
	
	        } else {
	
	            this.pushLeaf( node, depth );
	
	        }
	
	        this.prePopGeometry( this, node );
	        if ( stateset ) this.popStateSet();
	    };
	} )();
	
	CullVisitor.prototype[ Skeleton.typeID ] = CullVisitor.prototype[ MatrixTransform.typeID ];
	
	CullVisitor.prototype[ RigGeometry.typeID ] = CullVisitor.prototype[ Geometry.typeID ];
	
	CullVisitor.prototype[ MorphGeometry.typeID ] = CullVisitor.prototype[ Geometry.typeID ];
	
	CullVisitor.prototype[ Bone.typeID ] = CullVisitor.prototype[ MatrixTransform.typeID ];
	
	module.exports = CullVisitor;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Node = __webpack_require__( 12 );
	var TransformEnums = __webpack_require__( 29 );
	var Vec3 = __webpack_require__( 15 );
	
	/**
	 *  LightSource is a positioned node to use with StateAttribute Light
	 *  @class LightSource
	 */
	var LightSource = function () {
	    Node.call( this );
	    this._light = undefined;
	    this._referenceFrame = TransformEnums.RELATIVE_RF;
	};
	
	/** @lends LightSource.prototype */
	LightSource.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {
	    getLight: function () {
	        return this._light;
	    },
	    setLight: function ( light ) {
	        this._light = light;
	    },
	    setReferenceFrame: function ( value ) {
	        this._referenceFrame = value;
	    },
	    getReferenceFrame: function () {
	        return this._referenceFrame;
	    },
	    computeBoundingSphere: ( function () {
	        var tmp = Vec3.create();
	
	        return function ( bsphere ) {
	            Node.prototype.computeBoundingSphere.call( this, bsphere );
	
	            if ( this._light !== undefined && this._referenceFrame === TransformEnums.RELATIVE_RF ) {
	                var position = this._light.getPosition();
	
	                if ( position[ 3 ] !== 0.0 ) {
	                    bsphere.expandByVec3( Vec3.mult( position, 1.0 / position[ 3 ], tmp ) );
	                }
	            }
	
	            return bsphere;
	        };
	    } )()
	
	} ), 'osg', 'LightSource' );
	
	MACROUTILS.setTypeID( LightSource );
	
	module.exports = LightSource;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var StateGraph = __webpack_require__( 8 );
	
	var CacheUniformApply = function ( state, program ) {
	    this.modelWorldUniform = program._uniformsCache[ state.modelWorldMatrix.getName() ];
	    this.viewUniform = program._uniformsCache[ state.viewMatrix.getName() ];
	
	    this.apply = undefined;
	    this.generateUniformsApplyMethods();
	};
	
	CacheUniformApply.prototype = {
	
	
	    generateUniformsApplyMethods: function () {
	
	        var functionStr = [ '//generated by RenderLeaf\n' ];
	        functionStr.push( 'var gl = state.getGraphicContext();' );
	        functionStr.push( 'var matrixModelViewChanged = state.applyModelViewMatrix( modelview );' );
	        functionStr.push( 'state.applyProjectionMatrix( projection );' );
	
	        if ( this.modelWorldUniform !== undefined ) {
	            functionStr.push( 'if ( matrixModelViewChanged ) {' );
	            functionStr.push( '    var modelWorldMatrix = state.modelWorldMatrix;' );
	            functionStr.push( '    modelWorldMatrix.setMatrix4( modelworld );' );
	            functionStr.push( '    modelWorldMatrix.apply( gl, this.modelWorldUniform);' );
	            functionStr.push( '};' );
	        }
	
	        if ( this.viewUniform !== undefined ) {
	            functionStr.push( 'if ( matrixModelViewChanged ) {' );
	            functionStr.push( '    var viewMatrix = state.viewMatrix;' );
	            functionStr.push( '    viewMatrix.setMatrix4( view );' );
	            functionStr.push( '    viewMatrix.apply( gl, this.viewUniform);' );
	            functionStr.push( '};' );
	        }
	
	        // I am the evil, so please bother someone else
	        /*jshint evil: true */
	        // name the function
	        // http://stackoverflow.com/questions/5905492/dynamic-function-name-in-javascript
	        var func = ( new Function( 'state', 'modelview', 'modelworld', 'view', 'projection', 'return function RenderLeafApplyMatrixUniformCache( state, modelview, modelworld, view, projection ) { ' + functionStr.join( '\n' ) + '}' ) )();
	        /*jshint evil: false */
	
	        this.apply = func;
	    }
	};
	
	
	var RenderLeaf = function () {
	
	    this._parent = undefined;
	    this._geometry = undefined;
	    this._depth = 0.0;
	
	    this._projection = undefined;
	    this._view = undefined;
	    this._modelWorld = undefined;
	    this._modelView = undefined;
	};
	
	RenderLeaf.prototype = {
	
	    reset: function () {
	        this._parent = undefined;
	        this._geometry = undefined;
	        this._depth = 0.0;
	
	        this._projection = undefined;
	        this._view = undefined;
	        this._modelWorld = undefined;
	        this._modelView = undefined;
	    },
	
	    init: function ( parent, geom, projection, view, modelView, modelWorld, depth ) {
	
	        this._parent = parent;
	        this._geometry = geom;
	        this._depth = depth;
	
	        this._projection = projection;
	        this._view = view;
	        this._modelWorld = modelWorld;
	        this._modelView = modelView;
	
	    },
	
	    drawGeometry: ( function () {
	
	        return function ( state ) {
	
	
	            var program = state.getLastProgramApplied();
	            var programInstanceID = program.getInstanceID();
	            var cache = state.getCacheUniformsApplyRenderLeaf();
	            var obj = cache[ programInstanceID ];
	
	            if ( !obj ) {
	                obj = new CacheUniformApply( state, program );
	                cache[ programInstanceID ] = obj;
	            }
	
	            obj.apply( state, this._modelView, this._modelWorld, this._view, this._projection, this._normal );
	
	            this._geometry.drawImplementation( state );
	
	        };
	    } )(),
	
	    render: ( function () {
	        var previousHash;
	
	        return function ( state, previousLeaf ) {
	
	            var prevRenderGraph;
	            var prevRenderGraphParent;
	            var curRenderGraph = this._parent;
	            var curRenderGraphParent = curRenderGraph.parent;
	            var curRenderGraphStateSet = curRenderGraph.stateset;
	
	            // When rendering a RenderLeaf we try to limit the state change
	            // to do that Graph of State is created during the culling pass.
	            // this graph contains nodes of StateGraph type see the class StateGraph
	            //
	            // So to limit switching of StateSet we check where are the common parent
	            // between previous RenderLeaf and this current.
	            //
	            // There are 3 cases when there is a prev / current render leaf
	            //
	            //
	            // pRG: previousRenderGraph
	            // cRG: currentRenderGraph
	            // pRL: previousRenderLeaf
	            // cRL: currentRenderLeaf
	            // each RG contains a StateSet
	            //
	            //          A                        B                       C
	            // +-----+     +-----+            +-----+                 +-----+
	            // | pRG |     | cRG |         +--+ RG  +--+              | RG  |
	            // +--+--+     +--+--+         |  +-----+  |              +--+--+
	            //    |           |            |           |                 |
	            // +--v--+     +--v--+      +--v--+     +--v--+           +--v--+
	            // | pRG |     | cRG |      | pRG |     | cRG |        +--+ RG  +--+
	            // +--+--+     +--+--+      +--+--+     +--+--+        |  +-----+  |
	            //    |           |            |           |           |           |
	            // +--v--+     +--v--+      +--v--+     +--v--+     +--v--+     +--v--+
	            // | pRL |     | cRL |      | pRL |     | cRL |     | pRL |     | cRL |
	            // +-----+     +-----+      +-----+     +-----+     +-----+     +-----+
	            //
	            //
	            // Case A
	            // no common parent StateGraphNode we need to
	            // popStateSet until we find the common parent and then
	            // pushStateSet from the common parent to the current
	            // RenderLeaf
	            //
	            // Case B
	            // common parent StateGraphNode so we apply the current stateSet
	            //
	            // Case C
	            // the StateGraphNode is common to the previous RenderLeaf so we dont need
	            // to do anything except if we used an insertStateSet
	            //
	
	            if ( previousLeaf !== undefined ) {
	
	                // apply state if required.
	                prevRenderGraph = previousLeaf._parent;
	                prevRenderGraphParent = prevRenderGraph.parent;
	
	                if ( prevRenderGraphParent !== curRenderGraphParent ) {
	
	                    // Case A
	                    StateGraph.moveStateGraph( state, prevRenderGraphParent, curRenderGraphParent );
	
	                    state.applyStateSet( curRenderGraphStateSet );
	                    previousHash = state.getStateSetStackHash();
	
	                } else if ( curRenderGraph !== prevRenderGraph ) {
	
	                    // Case B
	                    state.applyStateSet( curRenderGraphStateSet );
	                    previousHash = state.getStateSetStackHash();
	
	                } else {
	
	                    // Case C
	
	                    // in osg we call apply but actually we dont need
	                    // except if the stateSetStack changed.
	                    // for example if insert/remove StateSet has been used
	                    var hash = state.getStateSetStackHash();
	                    if ( previousHash !== hash ) {
	                        state.applyStateSet( curRenderGraphStateSet );
	                        previousHash = hash;
	                    }
	                }
	
	            } else {
	
	                StateGraph.moveStateGraph( state, undefined, curRenderGraphParent );
	                state.applyStateSet( curRenderGraphStateSet );
	                previousHash = state.getStateSetStackHash();
	
	            }
	
	            this.drawGeometry( state );
	
	        };
	    } )()
	
	};
	
	module.exports = RenderLeaf;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Notify = __webpack_require__( 10 );
	var Object = __webpack_require__( 13 );
	var osgMath = __webpack_require__( 16 );
	
	
	/**
	 * RenderBin base class. Renderbin contains geometries to be rendered as a group,
	 * renderbins are rendered once each.  They can improve efficiency or
	 * use different rendering algorithms.
	 * A renderBin can contain further renderBins producing a tree hierarchy of renderBins.
	 *
	 * https://github.com/openscenegraph/osg/blob/master/include/osgUtil/RenderBin#L27-L32
	 */
	var RenderBin = function ( sortMode ) {
	    Object.call( this );
	
	    this._leafs = [];
	    this.positionedAttribute = [];
	    this.stateGraphList = [];
	
	    RenderBin.prototype.init.call( this, sortMode );
	};
	
	RenderBin.SORT_BY_STATE = 0;
	RenderBin.SORT_BACK_TO_FRONT = 1;
	RenderBin.SORT_FRONT_TO_BACK = 2;
	
	
	// change it at runtime for default RenderBin if needed
	RenderBin.defaultSortMode = RenderBin.SORT_BY_STATE;
	
	RenderBin.BinPrototypes = {
	    RenderBin: function () {
	        return RenderBin.getOrCreate().init();
	    },
	    DepthSortedBin: function () {
	        return RenderBin.getOrCreate().init( RenderBin.SORT_BACK_TO_FRONT );
	    }
	};
	
	
	var sortBackToFrontFunction = function ( a, b ) {
	    return b._depth - a._depth;
	};
	
	
	var sortFrontToBackFunction = function ( a, b ) {
	    return a._depth - b._depth;
	};
	
	var sortBinNumberFunction = function ( a, b ) {
	    return a._binNum - b._binNum;
	};
	
	
	RenderBin.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	
	    init: function ( sortMode ) {
	
	        this._leafs.length = 0;
	        this.positionedAttribute.length = 0;
	        this._renderStage = undefined;
	        this._bins = {};
	        this.stateGraphList.length = 0;
	        this._parent = undefined;
	        this._binNum = 0;
	
	        this._sorted = false;
	        this._sortMode = sortMode !== undefined ? sortMode : RenderBin.defaultSortMode;
	
	        this._drawCallback = undefined;
	
	        return this;
	    },
	
	    _createRenderBin: function ( binName ) {
	
	        // default render bin constructor
	        var renderBinConstructor = RenderBin.BinPrototypes.RenderBin;
	
	        if ( binName && RenderBin.BinPrototypes[ binName ] )
	            renderBinConstructor = RenderBin.BinPrototypes[ binName ];
	
	        return renderBinConstructor();
	    },
	
	    getStateGraphList: function () {
	        return this.stateGraphList;
	    },
	
	    copyLeavesFromStateGraphListToRenderLeafList: function () {
	
	        this._leafs.splice( 0, this._leafs.length );
	        var detectedNaN = false;
	
	        for ( var i = 0, l = this.stateGraphList.length; i < l; i++ ) {
	            var leafs = this.stateGraphList[ i ].leafs;
	            for ( var j = 0, k = leafs.length; j < k; j++ ) {
	                var leaf = leafs[ j ];
	                if ( osgMath.isNaN( leaf._depth ) ) {
	                    detectedNaN = true;
	                } else {
	                    this._leafs.push( leaf );
	                }
	            }
	        }
	
	        if ( detectedNaN ) {
	            Notify.debug( 'warning: RenderBin::copyLeavesFromStateGraphListToRenderLeafList() detected NaN depth values, database may be corrupted.' );
	        }
	        // empty the render graph list to prevent it being drawn along side the render leaf list (see drawImplementation.)
	        this.stateGraphList.splice( 0, this.stateGraphList.length );
	    },
	
	    getSortMode: function () {
	        return this._sortMode;
	    },
	
	    sortBackToFront: function () {
	        this.copyLeavesFromStateGraphListToRenderLeafList();
	        this._leafs.sort( sortBackToFrontFunction );
	    },
	
	    sortFrontToBack: function () {
	        this.copyLeavesFromStateGraphListToRenderLeafList();
	        this._leafs.sort( sortFrontToBackFunction );
	    },
	
	    sortImplementation: function () {
	        var SortMode = RenderBin;
	        switch ( this._sortMode ) {
	        case SortMode.SORT_BACK_TO_FRONT:
	            this.sortBackToFront();
	            break;
	        case SortMode.SORT_FRONT_TO_BACK:
	            this.sortFrontToBack();
	            break;
	        case SortMode.SORT_BY_STATE:
	            // do nothing
	            break;
	        }
	    },
	
	    sort: function () {
	        if ( this._sorted ) {
	            return;
	        }
	
	        var bins = this._bins;
	        var keys = window.Object.keys( bins );
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	            bins[ keys[ i ] ].sort();
	        }
	        this.sortImplementation();
	
	        this._sorted = true;
	    },
	
	    setParent: function ( parent ) {
	        this._parent = parent;
	    },
	
	    getParent: function () {
	        return this._parent;
	    },
	
	    getBinNumber: function () {
	        return this._binNum;
	    },
	
	    findOrInsert: function ( binNum, binName ) {
	        var bin = this._bins[ binNum ];
	
	        if ( !bin ) {
	            bin = this._createRenderBin( binName );
	            bin._parent = this;
	            bin._binNum = binNum;
	            bin._renderStage = this._renderStage;
	            this._bins[ binNum ] = bin;
	        }
	
	        return bin;
	    },
	
	    getStage: function () {
	        return this._renderStage;
	    },
	
	    addStateGraph: function ( sg ) {
	        this.stateGraphList.push( sg );
	    },
	
	    reset: function () {
	        this.stateGraphList.length = 0;
	        this._bins = {};
	        this.positionedAttribute.length = 0;
	        this._leafs.length = 0;
	        this._sorted = false;
	    },
	
	    draw: function ( state, previousRenderLeaf ) {
	
	        var previousLeaf = previousRenderLeaf;
	        // use callback drawImplementation if exist
	        if ( this._drawCallback && this._drawCallback.drawImplementation ) {
	            previousLeaf = this._drawCallback.drawImplementation( this, state, previousLeaf );
	        } else {
	            previousLeaf = this.drawImplementation( state, previousLeaf );
	        }
	
	        return previousLeaf;
	    },
	
	    applyPositionedAttribute: function ( state, positionedAttributes ) {
	        // the idea is to set uniform 'globally' in uniform map.
	        for ( var index = 0, l = positionedAttributes.length; index < l; index++ ) {
	            var element = positionedAttributes[ index ];
	            // add or set uniforms in state
	            var stateAttribute = element[ 1 ];
	            var matrix = element[ 0 ];
	            state.setGlobalDefaultAttribute( stateAttribute );
	            stateAttribute.apply( state );
	            stateAttribute.applyPositionedUniform( matrix, state );
	            state.haveAppliedAttribute( stateAttribute );
	        }
	    },
	
	    drawImplementation: function ( state, previousRenderLeaf ) {
	
	        var previousLeaf = previousRenderLeaf;
	        var binsKeys = window.Object.keys( this._bins );
	        var bins = this._bins;
	
	        var binsArray = [];
	
	        for ( var i = 0, l = binsKeys.length; i < l; i++ ) {
	            var k = binsKeys[ i ];
	            binsArray.push( bins[ k ] );
	        }
	
	        binsArray.sort( sortBinNumberFunction );
	
	        var current = 0;
	        var end = binsArray.length;
	
	        var bin;
	        // draw pre bins
	        for ( ; current < end; current++ ) {
	            bin = binsArray[ current ];
	            if ( bin.getBinNumber() > 0 ) {
	                break;
	            }
	            previousLeaf = bin.draw( state, previousLeaf );
	        }
	
	        // draw leafs
	        previousLeaf = this.drawLeafs( state, previousLeaf );
	
	        // draw post bins
	        for ( ; current < end; current++ ) {
	            bin = binsArray[ current ];
	            previousLeaf = bin.draw( state, previousLeaf );
	        }
	        return previousLeaf;
	    },
	
	
	    drawLeafs: function ( state, previousRenderLeaf ) {
	
	        var stateList = this.stateGraphList;
	        var leafs = this._leafs;
	        var previousLeaf = previousRenderLeaf;
	        var leaf;
	
	
	        // draw fine grained ordering.
	        for ( var d = 0, dl = leafs.length; d < dl; d++ ) {
	            leaf = leafs[ d ];
	            leaf.render( state, previousLeaf );
	            previousLeaf = leaf;
	        }
	
	
	        // draw coarse grained ordering.
	        for ( var i = 0, l = stateList.length; i < l; i++ ) {
	
	            var sg = stateList[ i ];
	
	            for ( var j = 0, ll = sg.leafs.length; j < ll; j++ ) {
	
	                leaf = sg.leafs[ j ];
	                leaf.render( state, previousLeaf );
	                previousLeaf = leaf;
	
	            }
	        }
	        return previousLeaf;
	    }
	} ), 'osg', 'RenderBin' );
	
	
	RenderBin.getOrCreate = function () {
	
	    var l = RenderBin._reservedStack[ RenderBin._reservedStackCurrent++ ];
	    if ( RenderBin._reservedStackCurrent === RenderBin._reservedStack.length ) {
	        RenderBin._reservedStack.push( new RenderBin() );
	    }
	    return l;
	
	};
	
	RenderBin.resetStack = function () {
	    RenderBin._reservedStackCurrent = 0;
	};
	
	RenderBin._reservedStack = [ new RenderBin() ];
	RenderBin._reservedStackCurrent = 0;
	
	module.exports = RenderBin;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Camera = __webpack_require__( 56 );
	var FrameBufferObject = __webpack_require__( 68 );
	var Notify = __webpack_require__( 10 );
	var RenderBin = __webpack_require__( 66 );
	var Vec4 = __webpack_require__( 25 );
	
	
	/**
	 * From OpenSceneGraph http://www.openscenegraph.org
	 * RenderStage base class. Used for encapsulate a complete stage in
	 * rendering - setting up of viewport, the projection and model
	 * matrices and rendering the RenderBin's enclosed with this RenderStage.
	 * RenderStage also has a dependency list of other RenderStages, each
	 * of which must be called before the rendering of this stage.  These
	 * 'pre' rendering stages are used for advanced rendering techniques
	 * like multistage pixel shading or impostors.
	 */
	var RenderStage = function () {
	
	    RenderBin.call( this );
	    this.clearColor = Vec4.create();
	    this.preRenderList = [];
	    this.postRenderList = [];
	    // calling prototype to make sure
	    // we call renderstage and not renderbin init
	    RenderStage.prototype.init.call( this );
	
	};
	
	RenderStage.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( RenderBin.prototype, {
	
	    // temporary, Utils.createPrototypeClass will solve this
	    constructor: RenderStage,
	
	
	    init: function () {
	
	        RenderBin.prototype.init.call( this );
	        this.positionedAttribute.length = 0;
	        this.clearDepth = 1.0;
	        Vec4.set( 0.0, 0.0, 0.0, 1.0, this.clearColor );
	        /*jshint bitwise: false */
	        this.clearMask = Camera.COLOR_BUFFER_BIT | Camera.DEPTH_BUFFER_BIT;
	        /*jshint bitwise: true */
	        this.camera = undefined;
	        this.viewport = undefined;
	        this.preRenderList.length = 0;
	        this.postRenderList.length = 0;
	        this._renderStage = this;
	
	        return this;
	    },
	
	    reset: function () {
	        RenderBin.prototype.reset.call( this );
	        this.preRenderList.length = 0;
	        this.postRenderList.length = 0;
	    },
	
	    setClearDepth: function ( depth ) {
	        this.clearDepth = depth;
	    },
	
	    getClearDepth: function () {
	        return this.clearDepth;
	    },
	
	    setClearColor: function ( color ) {
	        Vec4.copy( color, this.clearColor );
	    },
	
	    getClearColor: function () {
	        return this.clearColor;
	    },
	
	    setClearMask: function ( mask ) {
	        this.clearMask = mask;
	    },
	
	    getClearMask: function () {
	        return this.clearMask;
	    },
	
	    setViewport: function ( vp ) {
	        this.viewport = vp;
	    },
	
	    getViewport: function () {
	        return this.viewport;
	    },
	
	    setCamera: function ( camera ) {
	        this.camera = camera;
	    },
	
	    getCamera: function () {
	        return this.camera;
	    },
	
	    getPositionedAttribute: function () {
	        return this.positionedAttribute;
	    },
	
	    getPreRenderStageList: function () {
	        return this.preRenderList;
	    },
	
	    getPostRenderStageList: function () {
	        return this.postRenderList;
	    },
	
	    addPreRenderStage: function ( rs, order ) {
	        for ( var i = 0, l = this.preRenderList.length; i < l; i++ ) {
	            var render = this.preRenderList[ i ];
	            if ( order < render.order ) {
	                break;
	            }
	        }
	        if ( i < this.preRenderList.length ) {
	            this.preRenderList = this.preRenderList.splice( i, 0, {
	                'order': order,
	                'renderStage': rs
	            } );
	        } else {
	            this.preRenderList.push( {
	                'order': order,
	                'renderStage': rs
	            } );
	        }
	    },
	
	    addPostRenderStage: function ( rs, order ) {
	        for ( var i = 0, l = this.postRenderList.length; i < l; i++ ) {
	            var render = this.postRenderList[ i ];
	            if ( order < render.order ) {
	                break;
	            }
	        }
	        if ( i < this.postRenderList.length ) {
	            this.postRenderList = this.postRenderList.splice( i, 0, {
	                'order': order,
	                'renderStage': rs
	            } );
	        } else {
	            this.postRenderList.push( {
	                'order': order,
	                'renderStage': rs
	            } );
	        }
	    },
	
	    drawPreRenderStages: function ( state, previousRenderLeaf ) {
	        var previousLeaf = previousRenderLeaf;
	        for ( var i = 0, l = this.preRenderList.length; i < l; ++i ) {
	            var sg = this.preRenderList[ i ].renderStage;
	            previousLeaf = sg.draw( state, previousLeaf );
	        }
	        return previousLeaf;
	    },
	
	    draw: function ( state, previousRenderLeaf ) {
	
	        if ( this.camera && this.camera.getInitialDrawCallback() ) {
	            // if we have a camera with a final callback invoke it.
	            this.camera.getInitialDrawCallback()( state );
	        }
	
	        var previousLeaf = this.drawPreRenderStages( state, previousRenderLeaf );
	
	        previousLeaf = this.drawImplementation( state, previousLeaf );
	
	        previousLeaf = this.drawPostRenderStages( state, previousLeaf );
	
	        if ( this.camera && this.camera.getFinalDrawCallback() ) {
	            // if we have a camera with a final callback invoke it.
	            this.camera.getFinalDrawCallback()( state );
	        }
	
	        return previousLeaf;
	
	    },
	
	    sort: function () {
	        for ( var i = 0, l = this.preRenderList.length; i < l; ++i ) {
	            this.preRenderList[ i ].renderStage.sort();
	        }
	
	        RenderBin.prototype.sort.call( this );
	
	        for ( var j = 0, k = this.postRenderList.length; j < k; ++j ) {
	            this.postRenderList[ j ].renderStage.sort();
	        }
	    },
	
	    drawPostRenderStages: function ( state, previousRenderLeaf ) {
	        var previousLeaf = previousRenderLeaf;
	        for ( var i = 0, l = this.postRenderList.length; i < l; ++i ) {
	            var sg = this.postRenderList[ i ].renderStage;
	            previousLeaf = sg.draw( state, previousLeaf );
	        }
	        return previousLeaf;
	    },
	
	    applyCamera: function ( state ) {
	        var gl = state.getGraphicContext();
	        if ( this.camera === undefined ) {
	            gl.bindFramebuffer( gl.FRAMEBUFFER, null );
	            return;
	        }
	        var viewport = this.camera.getViewport();
	        var fbo = this.camera.frameBufferObject;
	
	        if ( !fbo ) {
	            fbo = new FrameBufferObject();
	            this.camera.frameBufferObject = fbo;
	        }
	
	        if ( fbo.isDirty() ) {
	
	            var attachments = this.camera.getAttachments();
	            // we should use a map in camera to avoid to regenerate the keys
	            // each time. But because we dont have a lot of camera I guess
	            // it does not change a lot
	            var keys = window.Object.keys( attachments );
	
	            if ( keys.length ) {
	
	                for ( var i = 0, l = keys.length; i < l; i++ ) {
	                    var key = keys[ i ];
	                    var a = attachments[ key ];
	
	                    var attach = {};
	                    attach.attachment = a.attachment;
	
	                    if ( a.texture === undefined ) { //renderbuffer
	
	                        attach.format = a.format;
	                        attach.width = viewport.width();
	                        attach.height = viewport.height();
	
	                    } else if ( a.texture !== undefined ) {
	
	                        attach.texture = a.texture;
	                        attach.textureTarget = a.textureTarget;
	
	                        if ( a.format ) {
	                            attach.format = a.format;
	                        }
	                    }
	
	                    fbo.setAttachment( attach );
	                }
	            }
	        }
	        fbo.apply( state );
	    },
	
	    drawImplementation: function ( state, previousRenderLeaf ) {
	        var gl = state.getGraphicContext();
	
	        this.applyCamera( state );
	
	        if ( this.viewport === undefined ) {
	            Notify.log( 'RenderStage does not have a valid viewport' );
	        }
	
	        state.applyAttribute( this.viewport );
	
	        /*jshint bitwise: false */
	        if ( this.clearMask !== 0x0 ) {
	            if ( this.clearMask & gl.COLOR_BUFFER_BIT ) {
	                gl.clearColor( this.clearColor[ 0 ], this.clearColor[ 1 ], this.clearColor[ 2 ], this.clearColor[ 3 ] );
	            }
	            if ( this.clearMask & gl.DEPTH_BUFFER_BIT ) {
	                gl.depthMask( true );
	                gl.clearDepth( this.clearDepth );
	            }
	            /*jshint bitwise: true */
	            gl.clear( this.clearMask );
	        }
	
	        if ( this.positionedAttribute.length !== 0 ) {
	            this.applyPositionedAttribute( state, this.positionedAttribute );
	        }
	
	        var previousLeaf = RenderBin.prototype.drawImplementation.call( this, state, previousRenderLeaf );
	
	        return previousLeaf;
	    }
	} ), 'osg', 'RenderStage' );
	
	
	module.exports = RenderStage;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var GLObject = __webpack_require__( 37 );
	var StateAttribute = __webpack_require__( 21 );
	var Timer = __webpack_require__( 9 );
	var WebglCaps = __webpack_require__( 32 );
	
	/**
	 * FrameBufferObject manage fbo / rtt
	 * @class FrameBufferObject
	 */
	var FrameBufferObject = function () {
	
	    GLObject.call( this );
	    StateAttribute.call( this );
	    this._fbo = undefined;
	    this._rbo = undefined;
	    this._attachments = [];
	    this._dirty = true;
	
	};
	
	FrameBufferObject.COLOR_ATTACHMENT0 = 0x8CE0;
	FrameBufferObject.DEPTH_ATTACHMENT = 0x8D00;
	FrameBufferObject.DEPTH_COMPONENT16 = 0x81A5;
	// static cache of glFrameBuffer flagged for deletion, which will actually
	// be deleted in the correct GL context.
	FrameBufferObject._sDeletedGLFrameBufferCache = new window.Map();
	
	// static method to delete FrameBuffers
	FrameBufferObject.deleteGLFrameBuffer = function ( gl, fb ) {
	
	    if ( !FrameBufferObject._sDeletedGLFrameBufferCache.has( gl ) )
	        FrameBufferObject._sDeletedGLFrameBufferCache.set( gl, [] );
	
	    FrameBufferObject._sDeletedGLFrameBufferCache.get( gl ).push( fb );
	};
	
	// static method to flush all the cached glFrameBuffers which need to be deleted in the GL context specified
	FrameBufferObject.flushDeletedGLFrameBuffers = function ( gl, availableTime ) {
	
	    // if no time available don't try to flush objects.
	    if ( availableTime <= 0.0 ) return availableTime;
	
	    if ( !FrameBufferObject._sDeletedGLFrameBufferCache.has( gl ) ) return availableTime;
	
	    var elapsedTime = 0.0;
	    var beginTime = Timer.instance().tick();
	    var deleteList = FrameBufferObject._sDeletedGLFrameBufferCache.get( gl );
	    var numBuffers = deleteList.length;
	
	    for ( var i = numBuffers - 1; i >= 0 && elapsedTime < availableTime; i-- ) {
	        gl.deleteFramebuffer( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	    }
	
	    return availableTime - elapsedTime;
	};
	
	FrameBufferObject.flushAllDeletedGLFrameBuffers = function ( gl ) {
	
	    if ( !FrameBufferObject._sDeletedGLFrameBufferCache.has( gl ) ) return;
	
	    var deleteList = FrameBufferObject._sDeletedGLFrameBufferCache.get( gl );
	    var numBuffers = deleteList.length;
	
	    for ( var i = numBuffers - 1; i >= 0; i-- ) {
	        gl.deleteFramebuffer( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	    }
	};
	
	
	// static cache of glRenderBuffer flagged for deletion, which will actually
	// be deleted in the correct GL context.
	FrameBufferObject._sDeletedGLRenderBufferCache = new window.Map();
	
	// static method to delete RenderBuffers
	FrameBufferObject.deleteGLRenderBuffer = function ( gl, fb ) {
	
	    if ( !FrameBufferObject._sDeletedGLRenderBufferCache.has( gl ) )
	        FrameBufferObject._sDeletedGLRenderBufferCache.set( gl, [] );
	
	    FrameBufferObject._sDeletedGLRenderBufferCache.get( gl ).push( fb );
	};
	
	
	// static method to flush all the cached glRenderBuffers which need to be deleted in the GL context specified
	FrameBufferObject.flushDeletedGLRenderBuffers = function ( gl, availableTime ) {
	
	    // if no time available don't try to flush objects.
	    if ( availableTime <= 0.0 ) return availableTime;
	
	    if ( !FrameBufferObject._sDeletedGLRenderBufferCache.has( gl ) ) return availableTime;
	
	    var elapsedTime = 0.0;
	    var beginTime = Timer.instance().tick();
	    var deleteList = FrameBufferObject._sDeletedGLRenderBufferCache.get( gl );
	    var numBuffers = deleteList.length;
	
	    for ( var i = numBuffers - 1; i >= 0 && elapsedTime < availableTime; i-- ) {
	        gl.deleteRenderbuffer( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	    }
	
	    return availableTime - elapsedTime;
	};
	
	FrameBufferObject.flushAllDeletedGLRenderBuffers = function ( gl ) {
	
	    if ( !FrameBufferObject._sDeletedGLRenderBufferCache.has( gl ) ) return;
	
	    var deleteList = FrameBufferObject._sDeletedGLRenderBufferCache.get( gl );
	    var numBuffers = deleteList.length;
	
	    for ( var i = numBuffers - 1; i >= 0; i-- ) {
	        gl.deleteRenderbuffer( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	    }
	};
	
	/** @lends FrameBufferObject.prototype */
	FrameBufferObject.prototype = MACROUTILS.objectInherit( GLObject.prototype, MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'FrameBufferObject',
	
	    cloneType: function () {
	        return new FrameBufferObject();
	    },
	
	    dirty: function () {
	        this._dirty = true;
	    },
	
	    isDirty: function () {
	        return this._dirty;
	    },
	
	    setAttachment: function ( attachment ) {
	        this._attachments.push( attachment );
	    },
	
	    releaseGLObjects: function () {
	
	        if ( this._fbo !== undefined && this._gl !== undefined ) {
	            FrameBufferObject.deleteGLFrameBuffer( this._gl, this._fbo );
	        }
	        this._fbo = undefined;
	
	        if ( this._rbo !== undefined && this._gl !== undefined ) {
	            FrameBufferObject.deleteGLRenderBuffer( this._gl, this._rbo );
	        }
	        this._rbo = undefined;
	
	    },
	
	    _reportFrameBufferError: function ( code ) {
	        switch ( code ) {
	        case 0x8CD6:
	            Notify.debug( 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT' );
	            break;
	        case 0x8CD7:
	            Notify.debug( 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT' );
	            break;
	        case 0x8CD9:
	            Notify.debug( 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS' );
	            break;
	        case 0x8CDD:
	            Notify.debug( 'FRAMEBUFFER_UNSUPPORTED' );
	            break;
	        default:
	            Notify.debug( 'FRAMEBUFFER unknown error ' + code.toString( 16 ) );
	        }
	    },
	
	    reset: function () {
	        this.releaseGLObjects();
	        this._attachments = [];
	    },
	
	    getFrameBufferObject: function () {
	        return this._fbo;
	    },
	
	    createFrameBufferObject: function ( state ) {
	        this.setGraphicContext( state.getGraphicContext() );
	        this._fbo = this._gl.createFramebuffer();
	    },
	
	    createRenderBuffer: function ( format, width, height ) {
	        var gl = this._gl;
	        var renderBuffer = gl.createRenderbuffer();
	        gl.bindRenderbuffer( gl.RENDERBUFFER, renderBuffer );
	        gl.renderbufferStorage( gl.RENDERBUFFER, format, width, height );
	
	        return renderBuffer;
	    },
	
	    framebufferRenderBuffer: function ( attachment, renderBuffer ) {
	
	        var gl = this._gl;
	        gl.bindRenderbuffer( gl.RENDERBUFFER, renderBuffer );
	        gl.framebufferRenderbuffer( gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer );
	
	    },
	
	    framebufferTexture2D: function ( state, attachment, textureTarget, texture ) {
	
	        var gl = this._gl;
	
	        // apply on unit 1 to init it
	        // make sure we do bind it whatever state stack
	        // texture is cached
	        state.applyTextureAttribute( 1, texture );
	
	        if ( texture.isDirty() || !texture.getTextureObject() ) {
	            // image wasn't ready, texture not allocated due to lack of gpu MEM
	            return false;
	        }
	
	        gl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, textureTarget, texture.getTextureObject().id(), 0 );
	
	
	        return true;
	    },
	
	    bindFrameBufferObject: function () {
	        var gl = this._gl;
	        gl.bindFramebuffer( gl.FRAMEBUFFER, this._fbo );
	    },
	
	    checkStatus: function () {
	
	        var gl = this._gl;
	        var status = gl.checkFramebufferStatus( gl.FRAMEBUFFER );
	        if ( status !== 0x8CD5 ) {
	            this._reportFrameBufferError( status );
	        }
	
	    },
	
	    _checkAllowedSize: function ( w, h ) {
	
	        var maxSize = WebglCaps.instance().getWebGLParameter( 'MAX_RENDERBUFFER_SIZE' );
	
	        if ( w === 0 || h === 0 || h > maxSize || w > maxSize ) {
	            Notify.error( 'width (' + w + ') or height (' + w + ') makes frame buffer not bindable. Max RenderBuffer is "' + maxSize + '"' );
	            return false;
	        }
	
	        return true;
	
	    },
	
	    apply: function ( state ) {
	
	        if ( !this._gl ) this.setGraphicContext( state.getGraphicContext() );
	        var gl = this._gl;
	
	        var attachments = this._attachments;
	
	        // if the fbo is created manually, we want to just bind it
	        if ( attachments.length > 0 || this._fbo ) {
	
	            if ( this.isDirty() ) {
	
	                if ( !this._fbo )
	                    this.createFrameBufferObject( state );
	
	                this.bindFrameBufferObject();
	
	                var hasRenderBuffer = false;
	
	                for ( var i = 0, l = attachments.length; i < l; ++i ) {
	
	                    var attachment = attachments[ i ];
	
	                    // render buffer
	                    if ( !attachment.texture ) {
	
	                        if ( !this._checkAllowedSize( attachment.width, attachment.height ) ) {
	                            this.releaseGLObjects();
	                            return;
	                        }
	
	                        this._rbo = this.createRenderBuffer( attachment.format, attachment.width, attachment.height );
	                        this.framebufferRenderBuffer( attachment.attachment, this._rbo );
	                        hasRenderBuffer = true;
	
	                    } else {
	
	                        // use texture
	                        var texture = attachment.texture;
	
	                        if ( !this._checkAllowedSize( texture.getWidth(), texture.getHeight() ) ) {
	                            this.releaseGLObjects();
	                            return;
	                        }
	
	                        if ( !this.framebufferTexture2D( state, attachment.attachment, attachment.textureTarget, texture ) ) {
	                            this.releaseGLObjects();
	                            return;
	
	                        }
	
	
	                    }
	
	                }
	
	                this.checkStatus();
	
	                // set it to null only if used renderbuffer
	                if ( hasRenderBuffer )
	                    gl.bindRenderbuffer( gl.RENDERBUFFER, null );
	
	                this._dirty = false;
	
	            } else {
	
	                gl.bindFramebuffer( gl.FRAMEBUFFER, this._fbo );
	
	                if ( Notify.reportWebGLError === true )
	                    this.checkStatus();
	
	            }
	
	        } else {
	            gl.bindFramebuffer( gl.FRAMEBUFFER, null );
	        }
	    }
	} ) );
	
	
	module.exports = FrameBufferObject;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Node = __webpack_require__( 12 );
	var NodeVisitor = __webpack_require__( 22 );
	var Matrix = __webpack_require__( 23 );
	var Vec2 = __webpack_require__( 70 );
	var Vec3 = __webpack_require__( 15 );
	var BoundingSphere = __webpack_require__( 18 );
	
	/**
	 *  Lod that can contains child node
	 *  @class Lod
	 */
	var Lod = function () {
	    Node.call( this );
	    this._radius = -1;
	    this._range = [];
	    this._rangeMode = Lod.DISTANCE_FROM_EYE_POINT;
	    this._userDefinedCenter = [];
	    this._centerMode = Lod.USE_BOUNDING_SPHERE_CENTER;
	};
	
	Lod.DISTANCE_FROM_EYE_POINT = 0;
	Lod.PIXEL_SIZE_ON_SCREEN = 1;
	
	Lod.USE_BOUNDING_SPHERE_CENTER = 0;
	Lod.USER_DEFINED_CENTER = 1;
	Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED = 2;
	
	/** @lends Lod.prototype */
	Lod.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {
	    // Functions here
	    getRadius: function () {
	        return this._radius;
	    },
	
	    /** Set the object-space reference radius of the volume enclosed by the LOD.
	     * Used to determine the bounding sphere of the LOD in the absence of any children.*/
	    setRadius: function ( radius ) {
	        this._radius = radius;
	    },
	
	    setCenter: function ( center ) {
	        if ( this._centerMode !== Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED )
	            this._centerMode = Lod.USER_DEFINED_CENTER;
	        this._userDefinedCenter = center;
	    },
	
	    getCenter: function () {
	        if ( ( this._centerMode === Lod.USER_DEFINED_CENTER ) || ( this._centerMode === Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED ) )
	            return this._userDefinedCenter;
	        else return this.getBound().center();
	    },
	
	    setCenterMode: function ( centerMode ) {
	        this._centerMode = centerMode;
	    },
	
	    computeBoundingSphere: function ( bsphere ) {
	        if ( this._centerMode === Lod.USER_DEFINED_CENTER && this._radius >= 0.0 ) {
	            bsphere.set( this._userDefinedCenter, this._radius );
	            return bsphere;
	        } else if ( this._centerMode === Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED && this._radius >= 0.0 ) {
	            bsphere.set( this._userDefinedCenter, this._radius );
	            var bs = new BoundingSphere();
	            bsphere.expandByBoundingSphere( Node.prototype.computeBoundingSphere.call( this, bs ) );
	            return bsphere;
	        } else {
	            Node.prototype.computeBoundingSphere.call( this, bsphere );
	            return bsphere;
	        }
	    },
	
	    projectBoundingSphere: ( function () {
	        // from http://www.iquilezles.org/www/articles/sphereproj/sphereproj.htm
	        // Sample code at http://www.shadertoy.com/view/XdBGzd?
	        var o = Vec3.create();
	        return function ( sph, camMatrix, fle ) {
	            Matrix.transformVec3( camMatrix, sph.center(), o );
	            var r2 = sph.radius2();
	            var z2 = o[ 2 ] * o[ 2 ];
	            var l2 = Vec3.length2( o );
	            var area = -Math.PI * fle * fle * r2 * Math.sqrt( Math.abs( ( l2 - r2 ) / ( r2 - z2 ) ) ) / ( r2 - z2 );
	            return area;
	        };
	    } )(),
	
	    setRangeMode: function ( mode ) {
	        //TODO: check if mode is correct
	        this._rangeMode = mode;
	    },
	
	    addChildNode: function ( node ) {
	
	        Node.prototype.addChild.call( this, node );
	        if ( this.children.length > this._range.length ) {
	            var r = [];
	            var max = 0.0;
	            if ( this._range.lenght > 0 )
	                max = this._range[ this._range.length - 1 ][ 1 ];
	            r.push( Vec2.createAndSet( max, max ) );
	            this._range.push( r );
	        }
	        return true;
	    },
	
	    addChild: function ( node, min, max ) {
	        Node.prototype.addChild.call( this, node );
	
	        if ( this.children.length > this._range.length ) {
	            var r = [];
	            r.push( Vec2.createAndSet( min, min ) );
	            this._range.push( r );
	        }
	        this._range[ this.children.length - 1 ][ 0 ] = min;
	        this._range[ this.children.length - 1 ][ 1 ] = max;
	        return true;
	    },
	
	    traverse: ( function () {
	
	        // avoid to generate variable on the heap to limit garbage collection
	        // instead create variable and use the same each time
	        var zeroVector = Vec3.create();
	        var eye = Vec3.create();
	        var viewModel = Matrix.create();
	
	        return function ( visitor ) {
	            var traversalMode = visitor.traversalMode;
	
	            switch ( traversalMode ) {
	
	            case NodeVisitor.TRAVERSE_ALL_CHILDREN:
	
	                for ( var index = 0; index < this.children.length; index++ ) {
	                    this.children[ index ].accept( visitor );
	                }
	                break;
	
	            case ( NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ):
	                var requiredRange = 0;
	                var matrix = visitor.getCurrentModelViewMatrix();
	                Matrix.inverse( matrix, viewModel );
	                // Calculate distance from viewpoint
	                if ( this._rangeMode === Lod.DISTANCE_FROM_EYE_POINT ) {
	                    Matrix.transformVec3( viewModel, zeroVector, eye );
	                    var d = Vec3.distance( eye, this.getBound().center() );
	                    requiredRange = d * visitor.getLODScale();
	                } else {
	                    // Let's calculate pixels on screen
	                    var projmatrix = visitor.getCurrentProjectionMatrix();
	                    // focal lenght is the value stored in projmatrix[0]
	                    requiredRange = this.projectBoundingSphere( this.getBound(), matrix, projmatrix[ 0 ] );
	                    // Multiply by a factor to get the real area value
	                    requiredRange = ( ( requiredRange * visitor.getViewport().width() * visitor.getViewport().width() ) * 0.25 ) / visitor.getLODScale();
	                }
	
	                var numChildren = this.children.length;
	                if ( this._range.length < numChildren ) numChildren = this._range.length;
	
	                for ( var j = 0; j < numChildren; ++j ) {
	                    if ( this._range[ j ][ 0 ] <= requiredRange && requiredRange < this._range[ j ][ 1 ] ) {
	                        this.children[ j ].accept( visitor );
	                    }
	                }
	                break;
	
	            default:
	                break;
	            }
	        };
	    } )()
	
	} ), 'osg', 'Lod' );
	
	MACROUTILS.setTypeID( Lod );
	module.exports = Lod;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osgMath = __webpack_require__( 16 );
	var config = __webpack_require__( 17 );
	
	var ArrayType = config.ArrayType;
	
	/** @class Vec2 Operations */
	var Vec2 = {
	    create: function () {
	        var out = new ArrayType( 2 );
	        out[ 0 ] = 0.0;
	        out[ 1 ] = 0.0;
	        return out;
	    },
	
	    createAndSet: function ( x, y ) {
	        var out = new ArrayType( 2 );
	        out[ 0 ] = x;
	        out[ 1 ] = y;
	        return out;
	    },
	
	    copy: function ( a, r ) {
	        r[ 0 ] = a[ 0 ];
	        r[ 1 ] = a[ 1 ];
	        return r;
	    },
	
	    set: function ( a, b, r ) {
	        r[ 0 ] = a;
	        r[ 1 ] = b;
	        return r;
	    },
	
	    valid: function ( a ) {
	        if ( osgMath.isNaN( a[ 0 ] ) ) return false;
	        if ( osgMath.isNaN( a[ 1 ] ) ) return false;
	        return true;
	    },
	
	    mult: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] * b;
	        r[ 1 ] = a[ 1 ] * b;
	        return r;
	    },
	
	    length2: function ( a ) {
	        return a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ];
	    },
	
	    length: function ( a ) {
	        return Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] );
	    },
	
	    distance2: function ( a, b ) {
	        var x = a[ 0 ] - b[ 0 ];
	        var y = a[ 1 ] - b[ 1 ];
	        return x * x + y * y;
	    },
	
	    distance: function ( a, b ) {
	        var x = a[ 0 ] - b[ 0 ];
	        var y = a[ 1 ] - b[ 1 ];
	        return Math.sqrt( x * x + y * y );
	    },
	
	    /**
	      normalize an Array of 2 elements and write it in r
	   */
	    normalize: function ( a, r ) {
	        var norm = this.length2( a );
	        if ( norm > 0.0 ) {
	            var inv = 1.0 / Math.sqrt( norm );
	            r[ 0 ] = a[ 0 ] * inv;
	            r[ 1 ] = a[ 1 ] * inv;
	        } else {
	            r[ 0 ] = a[ 0 ];
	            r[ 1 ] = a[ 1 ];
	        }
	        return r;
	    },
	
	    /**
	      Compute the dot product
	  */
	    dot: function ( a, b ) {
	        return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ];
	    },
	
	    /**
	     Compute a - b and put the result in r
	   */
	    sub: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] - b[ 0 ];
	        r[ 1 ] = a[ 1 ] - b[ 1 ];
	        return r;
	    },
	
	    add: function ( a, b, r ) {
	        r[ 0 ] = a[ 0 ] + b[ 0 ];
	        r[ 1 ] = a[ 1 ] + b[ 1 ];
	        return r;
	    },
	
	    neg: function ( a, r ) {
	        r[ 0 ] = -a[ 0 ];
	        r[ 1 ] = -a[ 1 ];
	        return r;
	    },
	
	    lerp: function ( t, a, b, r ) {
	        var tmp = 1.0 - t;
	        r[ 0 ] = a[ 0 ] * tmp + t * b[ 0 ];
	        r[ 1 ] = a[ 1 ] * tmp + t * b[ 1 ];
	        return r;
	    }
	
	};
	
	module.exports = Vec2;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Lod = __webpack_require__( 69 );
	var NodeVisitor = __webpack_require__( 22 );
	var Matrix = __webpack_require__( 23 );
	var Vec3 = __webpack_require__( 15 );
	
	
	/**
	 *  PagedLOD that can contains paged child nodes
	 *  @class PagedLod
	 */
	var PagedLOD = function () {
	    Lod.call( this );
	    this._perRangeDataList = [];
	    this._loading = false;
	    this._expiryTime = 0.0;
	    this._expiryFrame = 0;
	    this._centerMode = Lod.USER_DEFINED_CENTER;
	    this._frameNumberOfLastTraversal = 0;
	    this._databasePath = '';
	    this._numChildrenThatCannotBeExpired = 0;
	};
	
	/**
	 *  PerRangeData utility structure to store per range values
	 *  @class PerRangeData
	 */
	var PerRangeData = function () {
	    this.filename = '';
	    this.function = undefined;
	    this.loaded = false;
	    this.timeStamp = 0.0;
	    this.frameNumber = 0;
	    this.frameNumberOfLastTraversal = 0;
	    this.dbrequest = undefined;
	};
	
	/** @lends PagedLOD.prototype */
	PagedLOD.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Lod.prototype, {
	    // Functions here
	    setRange: function ( childNo, min, max ) {
	        if ( childNo >= this._range.length ) {
	            var r = [];
	            r.push( [ min, min ] );
	            this._range.push( r );
	        }
	        this._range[ childNo ][ 0 ] = min;
	        this._range[ childNo ][ 1 ] = max;
	    },
	
	    setExpiryTime: function ( expiryTime ) {
	        this._expiryTime = expiryTime;
	    },
	
	    setDatabasePath: function ( path ) {
	        this._databasePath = path;
	    },
	
	    getDatabasePath: function () {
	        return this._databasePath;
	    },
	
	    setFileName: function ( childNo, filename ) {
	        // May we should expand the vector first?
	        if ( childNo >= this._perRangeDataList.length ) {
	            var rd = new PerRangeData();
	            rd.filename = filename;
	            this._perRangeDataList.push( rd );
	        } else {
	            this._perRangeDataList[ childNo ].filename = filename;
	        }
	    },
	    setFunction: function ( childNo, func ) {
	        if ( childNo >= this._perRangeDataList.length ) {
	            var rd = new PerRangeData();
	            rd.function = func;
	            this._perRangeDataList.push( rd );
	        } else {
	            this._perRangeDataList[ childNo ].function = func;
	        }
	    },
	
	    addChild: function ( node, min, max ) {
	        Lod.prototype.addChild.call( this, node, min, max );
	        this._perRangeDataList.push( new PerRangeData() );
	    },
	
	    addChildNode: function ( node ) {
	        Lod.prototype.addChildNode.call( this, node );
	    },
	
	    setFrameNumberOfLastTraversal: function ( frameNumber ) {
	        this._frameNumberOfLastTraversal = frameNumber;
	    },
	
	    getFrameNumberOfLastTraversal: function () {
	        return this._frameNumberOfLastTraversal;
	    },
	    setTimeStamp: function ( childNo, timeStamp ) {
	        this._perRangeDataList[ childNo ].timeStamp = timeStamp;
	    },
	    setFrameNumber: function ( childNo, frameNumber ) {
	        this._perRangeDataList[ childNo ].frameNumber = frameNumber;
	    },
	    setNumChildrenThatCannotBeExpired: function ( num ) {
	        this._numChildrenThatCannotBeExpired = num;
	    },
	    getNumChildrenThatCannotBeExpired: function () {
	        return this._numChildrenThatCannotBeExpired;
	    },
	    getDatabaseRequest: function ( childNo ) {
	        return this._perRangeDataList[ childNo ].dbrequest;
	    },
	    removeExpiredChildren: function ( expiryTime, expiryFrame, removedChildren ) {
	        if ( this.children.length <= this._numChildrenThatCannotBeExpired ) return;
	        var i = this.children.length - 1;
	        var timed, framed;
	        timed = this._perRangeDataList[ i ].timeStamp + this._expiryTime;
	        framed = this._perRangeDataList[ i ].frameNumber + this._expiryFrame;
	        if ( timed < expiryTime && framed < expiryFrame && ( this._perRangeDataList[ i ].filename.length > 0 ||
	                this._perRangeDataList[ i ].function !== undefined ) ) {
	            removedChildren.push( this.children[ i ] );
	            this.removeChild( this.children[ i ] );
	            this._perRangeDataList[ i ].loaded = false;
	            if ( this._perRangeDataList[ i ].dbrequest !== undefined ) {
	                this._perRangeDataList[ i ].dbrequest._groupExpired = true;
	            }
	        }
	    },
	
	    traverse: ( function () {
	
	        // avoid to generate variable on the heap to limit garbage collection
	        // instead create variable and use the same each time
	        var zeroVector = Vec3.create();
	        var eye = Vec3.create();
	        var viewModel = Matrix.create();
	
	        return function ( visitor ) {
	
	            var traversalMode = visitor.traversalMode;
	            var updateTimeStamp = false;
	
	            if ( visitor.getVisitorType() === NodeVisitor.CULL_VISITOR ) {
	                this._frameNumberOfLastTraversal = visitor.getFrameStamp().getFrameNumber();
	                updateTimeStamp = true;
	            }
	
	            switch ( traversalMode ) {
	
	            case NodeVisitor.TRAVERSE_ALL_CHILDREN:
	
	                for ( var index = 0; index < this.children.length; index++ ) {
	                    this.children[ index ].accept( visitor );
	                }
	                break;
	
	            case ( NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ):
	                var requiredRange = 0;
	
	                // Calculate distance from viewpoint
	                var matrix = visitor.getCurrentModelViewMatrix();
	                Matrix.inverse( matrix, viewModel );
	                if ( this._rangeMode === Lod.DISTANCE_FROM_EYE_POINT ) {
	                    Matrix.transformVec3( viewModel, zeroVector, eye );
	                    var d = Vec3.distance( eye, this.getBound().center() );
	                    requiredRange = d * visitor.getLODScale();
	                } else {
	                    // Calculate pixels on screen
	                    var projmatrix = visitor.getCurrentProjectionMatrix();
	                    // focal lenght is the value stored in projmatrix[0]
	                    requiredRange = this.projectBoundingSphere( this.getBound(), matrix, projmatrix[ 0 ] );
	                    // Get the real area value and apply LODScale
	                    requiredRange = ( ( requiredRange * visitor.getViewport().width() * visitor.getViewport().width() ) * 0.25 ) / visitor.getLODScale();
	                    if ( requiredRange < 0 ) requiredRange = this._range[ this._range.length - 1 ][ 0 ];
	                }
	
	                var needToLoadChild = false;
	                var lastChildTraversed = -1;
	                for ( var j = 0; j < this._range.length; ++j ) {
	                    if ( this._range[ j ][ 0 ] <= requiredRange && requiredRange < this._range[ j ][ 1 ] ) {
	                        if ( j < this.children.length ) {
	
	                            if ( updateTimeStamp ) {
	                                this._perRangeDataList[ j ].timeStamp = visitor.getFrameStamp().getSimulationTime();
	                                this._perRangeDataList[ j ].frameNumber = visitor.getFrameStamp().getFrameNumber();
	                            }
	
	                            this.children[ j ].accept( visitor );
	                            lastChildTraversed = j;
	                        } else {
	                            needToLoadChild = true;
	                        }
	                    }
	                }
	                if ( needToLoadChild ) {
	                    var numChildren = this.children.length;
	                    if ( numChildren > 0 && ( ( numChildren - 1 ) !== lastChildTraversed ) ) {
	
	                        if ( updateTimeStamp ) {
	                            this._perRangeDataList[ numChildren - 1 ].timeStamp = visitor.getFrameStamp().getSimulationTime();
	                            this._perRangeDataList[ numChildren - 1 ].frameNumber = visitor.getFrameStamp().getFrameNumber();
	                        }
	
	                        this.children[ numChildren - 1 ].accept( visitor );
	                    }
	                    // now request the loading of the next unloaded child.
	                    if ( numChildren < this._perRangeDataList.length ) {
	                        // compute priority from where abouts in the required range the distance falls.
	                        var priority = ( this._range[ numChildren ][ 0 ] - requiredRange ) / ( this._range[ numChildren ][ 1 ] - this._range[ numChildren ][ 0 ] );
	                        if ( this._rangeMode === Lod.PIXEL_SIZE_ON_SCREEN ) {
	                            priority = -priority;
	                        }
	                        // Here we do the request
	                        var group = visitor.nodePath[ visitor.nodePath.length - 1 ];
	                        if ( this._perRangeDataList[ numChildren ].loaded === false ) {
	                            this._perRangeDataList[ numChildren ].loaded = true;
	                            var dbhandler = visitor.getDatabaseRequestHandler();
	                            this._perRangeDataList[ numChildren ].dbrequest = dbhandler.requestNodeFile( this._perRangeDataList[ numChildren ].function, this._databasePath + this._perRangeDataList[ numChildren ].filename, group, visitor.getFrameStamp().getSimulationTime(), priority );
	                        } else {
	                            // Update timestamp of the request.
	                            if ( this._perRangeDataList[ numChildren ].dbrequest !== undefined ) {
	                                this._perRangeDataList[ numChildren ].dbrequest._timeStamp = visitor.getFrameStamp().getSimulationTime();
	                                this._perRangeDataList[ numChildren ].dbrequest._priority = priority;
	                            } else {
	                                // The DB request is undefined, so the DBPager was not accepting requests, we need to ask for the child again.
	                                this._perRangeDataList[ numChildren ].loaded = false;
	                            }
	                        }
	                    }
	                }
	                break;
	            default:
	                break;
	            }
	        };
	    } )()
	
	
	} ), 'osg', 'PagedLOD' );
	
	MACROUTILS.setTypeID( PagedLOD );
	module.exports = PagedLOD;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var MatrixTransform = __webpack_require__( 44 );
	var UpdateSkeleton = __webpack_require__( 73 );
	var NodeVisitor = __webpack_require__( 22 );
	var UpdateMatrixTransform = __webpack_require__( 76 );
	var Bone = __webpack_require__( 74 );
	
	
	var ResetRestPoseVisitor = function () {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );
	};
	ResetRestPoseVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    apply: function ( node ) {
	        if ( node.getTypeID() === Bone.getTypeID() ) {
	            var cb = node.getUpdateCallback();
	            if ( cb instanceof UpdateMatrixTransform ) {
	                var stackedTransforms = cb._stackedTransforms;
	                for ( var st = 0, l = stackedTransforms.length; st < l; st++ ) {
	                    var stackedTransform = stackedTransforms[ st ];
	                    stackedTransform.resetToDefaultValue();
	                }
	                cb.computeChannels();
	            }
	        }
	        this.traverse( node );
	    }
	} );
	
	var resetter = new ResetRestPoseVisitor();
	
	var Skeleton = function () {
	    MatrixTransform.call( this );
	};
	
	Skeleton.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( MatrixTransform.prototype, {
	
	    setDefaultUpdateCallback: function () {
	        this.setUpdateCallback( new UpdateSkeleton() );
	    },
	
	    setRestPose: function () {
	        this.accept( resetter );
	    }
	
	} ), 'osgAnimation', 'Skeleton' );
	MACROUTILS.setTypeID( Skeleton );
	
	module.exports = Skeleton;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Bone = __webpack_require__( 74 );
	var NodeVisitor = __webpack_require__( 22 );
	var Notify = __webpack_require__( 10 );
	var Object = __webpack_require__( 13 );
	
	
	/**
	 *  ValidateSkeletonVisitor
	 *  @class ValidateSkeletonVisitor
	 */
	var ValidateSkeletonVisitor = function () {
	    NodeVisitor.call( this );
	};
	
	ValidateSkeletonVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    apply: function ( node ) {
	        if ( node.getTypeID() !== Bone.getTypeID() ) {
	            return;
	        }
	        var foundNonBone = false;
	
	        var children = node.getChildren();
	        for ( var i = 0, l = node.getChildren().length; i < l; i++ ) {
	            var child = children[ i ];
	            if ( child.getTypeID() === Bone.getTypeID() ) {
	                if ( foundNonBone ) {
	                    Notify.warn( 'Warning: a Bone was found after a non-Bone child ' +
	                        'within a Skeleton. Children of a Bone must be ordered ' +
	                        'with all child Bones first for correct update order.' );
	                    //this.traversalMode = NodeVisitor.TRAVERSE_NONE;
	                    return;
	                }
	            } else {
	                foundNonBone = true;
	            }
	        }
	        this.traverse( node );
	    }
	
	} );
	
	var compareBone = function ( x, y ) {
	    var a = x instanceof Bone ? 0 : 1;
	    var b = y instanceof Bone ? 0 : 1;
	
	    return a - b;
	};
	
	/**
	 *  UpdateSkeleton
	 *  @class UpdateSkeleton
	 */
	var UpdateSkeleton = function () {
	    this._needValidate = true;
	};
	
	UpdateSkeleton.prototype = MACROUTILS.objectInherit( Object.prototype, {
	    needToValidate: function () {
	        return this._needValidate;
	    },
	
	    update: function ( node, nv ) {
	        if ( this._needValidate && nv.getVisitorType() === NodeVisitor.UPDATE_VISITOR ) {
	            if ( node.className && node.className() === 'Skeleton' ) {
	                var validateSkeletonVisitor = new ValidateSkeletonVisitor();
	                var children = node.getChildren();
	                for ( var i = 0, l = children.length; i < l; i++ ) {
	                    var child = children[ i ];
	                    child.accept( validateSkeletonVisitor );
	                }
	
	                //Re-order skeleton children to force correct bones update, we should put bones first
	                children.sort( compareBone );
	
	                this._needValidate = false;
	            }
	        }
	        return true;
	    }
	} );
	
	module.exports = UpdateSkeleton;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var BoundingBox = __webpack_require__( 14 );
	var Matrix = __webpack_require__( 23 );
	var MatrixTransform = __webpack_require__( 44 );
	var UpdateBone = __webpack_require__( 75 );
	
	
	/**
	 *  Bone
	 *  @class Bone
	 */
	var Bone = function ( name ) {
	    if ( name !== undefined )
	        this.setName( name );
	
	    MatrixTransform.call( this );
	    this._invBindInSkeletonSpace = Matrix.create();
	    this._boneInSkeletonSpace = Matrix.create();
	    this._boneBoundingBox = new BoundingBox();
	};
	
	Bone.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( MatrixTransform.prototype, {
	
	    // consistent color depending of id
	    // _rand: function ( id ) {
	    //     var x = Math.sin( id * 45.233 ) * 43758.5453;
	    //     return x - Math.floor( x );
	    // },
	    // _generateBoneColor: function ( id ) {
	    //     return Vec3.createAndSet( this._rand( id + 2.16 ), this._rand( id * 57.27 ), this._rand( id * 0.874 ) );
	    // },
	
	    getOrCreateDebugColor: function () {
	        // for bone display (debugging, etc)
	        if ( this._boneColor ) return this._boneColor;
	        // this._boneColor = this._generateBoneColor( this.getInstanceID() );
	        this._boneColor = Vec3.createAndSet( Math.random(), Math.random(), Math.random() );
	        return this._boneColor;
	    },
	
	    getBoneBoundingBox: function () {
	        return this._boneBoundingBox;
	    },
	
	    setBoneBoundingBox: function ( bb ) {
	        this._boneBoundingBox = bb;
	    },
	
	    getMatrixInSkeletonSpace: function () {
	        return this._boneInSkeletonSpace;
	    },
	
	    getInvBindMatrixInSkeletonSpace: function () {
	        return this._invBindInSkeletonSpace;
	    },
	
	    setMatrixInSkeletonSpace: function ( m ) {
	        Matrix.copy( m, this._boneInSkeletonSpace );
	    },
	
	    setInvBindMatrixInSkeletonSpace: function ( m ) {
	        Matrix.copy( m, this._invBindInSkeletonSpace );
	    },
	
	    getBoneParent: function () {
	        var parents = this.getParents();
	        for ( var i = 0, l = parents.length; i < l; i++ ) {
	            var typeID = parents[ i ].getTypeID();
	            if ( typeID === Bone.getTypeID() ) {
	                return parents[ i ];
	            }
	        }
	        return undefined;
	    },
	
	    setDefaultUpdateCallback: function ( name ) {
	        this.setUpdateCallback( new UpdateBone( ( name !== undefined ) ? name : this.getName() ) );
	    }
	} ), 'osgAnimation', 'Bone' );
	MACROUTILS.setTypeID( Bone );
	
	module.exports = Bone;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Notify = __webpack_require__( 10 );
	var UpdateMatrixTransform = __webpack_require__( 76 );
	var Matrix = __webpack_require__( 23 );
	var NodeVisitor = __webpack_require__( 22 );
	
	
	/**
	 *  UpdateBone
	 *  @class UpdateBone
	 */
	var UpdateBone = function () {
	    UpdateMatrixTransform.call( this );
	};
	
	/** @lends UpdateBone.prototype */
	UpdateBone.prototype = MACROUTILS.objectInherit( UpdateMatrixTransform.prototype, {
	
	    update: function ( node, nv ) {
	
	        if ( nv.getVisitorType() === NodeVisitor.UPDATE_VISITOR ) {
	
	            if ( node.className && node.className() !== 'Bone' ) {
	                Notify.warn( 'Warning: UpdateBone set on non-Bone object.' );
	                return false;
	            }
	
	            var bone = node;
	
	            UpdateMatrixTransform.prototype.update.call( this, node );
	            bone.setMatrix( bone.getMatrix() );
	            var matrix = bone.getMatrix();
	            var parent = bone.getBoneParent();
	
	            if ( parent ) {
	                Matrix.mult( parent.getMatrixInSkeletonSpace(), matrix, bone.getMatrixInSkeletonSpace() );
	            } else {
	                bone.setMatrixInSkeletonSpace( matrix );
	            }
	        }
	        return true;
	    }
	
	} );
	
	module.exports = UpdateBone;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Matrix = __webpack_require__( 23 );
	var AnimationUpdateCallback = __webpack_require__( 77 );
	
	
	/**
	 *  UpdateMatrixTransform
	 */
	var UpdateMatrixTransform = function () {
	    AnimationUpdateCallback.call( this );
	
	    // maybe could have a more generic name and used by all AnimationUpdateCallback
	    this._stackedTransforms = [];
	
	    this._matrix = Matrix.create();
	
	    this._dirty = false;
	};
	
	
	UpdateMatrixTransform.prototype = MACROUTILS.objectInherit( AnimationUpdateCallback.prototype, {
	
	    getStackedTransforms: function () {
	        return this._stackedTransforms;
	    },
	
	    computeChannels: function () {
	        this._dirty = true;
	        var matrix = this._matrix;
	        Matrix.makeIdentity( matrix );
	        var transforms = this._stackedTransforms;
	
	        for ( var i = 0, l = transforms.length; i < l; i++ ) {
	            var transform = transforms[ i ];
	            transform.applyToMatrix( matrix );
	        }
	    },
	
	    update: function ( node /*, nv */ ) {
	        Matrix.copy( this._matrix, node.getMatrix() );
	        if ( this._dirty ) {
	            node.dirtyBound();
	            this._dirty = false;
	        }
	        return true;
	    }
	
	} );
	
	module.exports = UpdateMatrixTransform;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var MatrixTransform = __webpack_require__( 44 );
	
	
	/**
	 *  AnimationUpdateCallback
	 *  @class AnimationUpdateCallback
	 */
	var AnimationUpdateCallback = function () {
	    Object.call( this );
	};
	
	// check if the path is animated, it could be elsewhere though
	AnimationUpdateCallback.checkPathIsAnimated = function ( path ) {
	
	    for ( var i = 0, nbNodes = path.length; i < nbNodes; ++i ) {
	        var node = path[ i ];
	
	        if ( node instanceof MatrixTransform ) {
	            var ups = node.getUpdateCallbackList();
	            for ( var j = 0, nbUp = ups.length; j < nbUp; ++j ) {
	                if ( ups[ j ] instanceof AnimationUpdateCallback )
	                    return true;
	            }
	        }
	
	    }
	
	    return false;
	};
	
	/** @lends AnimationUpdateCallback.prototype */
	AnimationUpdateCallback.prototype = MACROUTILS.objectInherit( Object.prototype, {
	
	    linkChannel: function () {},
	    linkAnimation: function ( anim ) {
	        var name = this.getName();
	        if ( name.length === 0 ) {
	            Notify.log( 'no name on an update callback, discard' );
	            return 0;
	        }
	        var nbLinks = 0;
	        var channels = anim.getChannels();
	        for ( var i = 0, l = channels.length; i < l; i++ ) {
	            var channel = channels[ i ];
	            if ( channel.getTargetName() === name ) {
	                this.linkChannel( channel );
	                nbLinks++;
	            }
	        }
	        return nbLinks;
	    }
	} );
	
	module.exports = AnimationUpdateCallback;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var Geometry = __webpack_require__( 31 );
	var Notify = __webpack_require__( 10 );
	var Matrix = __webpack_require__( 23 );
	var StateSet = __webpack_require__( 19 );
	var MorphGeometry = __webpack_require__( 79 );
	var UpdateRigGeometry = __webpack_require__( 81 );
	var RigTransformHardware = __webpack_require__( 83 );
	var AnimationUpdateCallback = __webpack_require__( 77 );
	var ComputeMatrixFromNodePath = __webpack_require__( 28 );
	
	
	// RigGeometry is a Geometry deformed by bones
	// To connect bones to RigGeometry it requires:
	//     - a map of bones with index / weight eg also called VertexInfluenceMap
	// {
	//     bone0: { index: [],  // vertex index
	//              weight: []  // weight for this index
	//            },
	//     bone2: { index: [],
	//              weight: []
	//            }
	// }
	
	
	var RigGeometry = function () {
	
	    Geometry.call( this );
	
	    this._shape = null; // by default no kdtree/shape for rig
	
	    this.setUpdateCallback( new UpdateRigGeometry() );
	
	    // handle matrixFromSkeletonToGeometry and invMatrixFromSkeletonToGeometry computation
	    this._root = undefined;
	    this._pathToRoot = undefined;
	    this._isAnimatedPath = false;
	
	    this._boneNameID = {};
	
	    this._matrixFromSkeletonToGeometry = Matrix.create();
	    this._invMatrixFromSkeletonToGeometry = Matrix.create();
	
	    this._rigTransformImplementation = new RigTransformHardware();
	
	    // RigGeometry have a special stateset that will be pushed at the very end of the culling
	    // this stateSet only represents animation (and shouldn't contain any rendering attributes)
	    // It's a way to make every RigGeometry unique (in term of stateSet stack)
	    this._stateSetAnimation = new StateSet();
	
	    this._needToComputeMatrix = true;
	
	};
	
	RigGeometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Geometry.prototype, {
	
	    getStateSetAnimation: function () {
	        return this._stateSetAnimation;
	    },
	
	    getSkeleton: function () {
	        return this._root;
	    },
	
	    setSkeleton: function ( root ) {
	        this._root = root;
	    },
	
	    setPathToSkeleton: function ( path ) {
	        this._pathToRoot = path;
	        this._isAnimatedPath = AnimationUpdateCallback.checkPathIsAnimated( path );
	    },
	
	    setNeedToComputeMatrix: function ( needToComputeMatrix ) {
	        this._needToComputeMatrix = needToComputeMatrix;
	    },
	
	    getNeedToComputeMatrix: function () {
	        return this._needToComputeMatrix;
	    },
	
	    computeBoundingBox: function ( boundingBox ) {
	
	        boundingBox.init();
	
	        var vertexArray = this.getVertexAttributeList().Vertex;
	        var weightsArray = this.getVertexAttributeList().Weights;
	        // mainly copy paste of geometry computeBoundingBox code, except we only
	        // take into account the non-influenced vertices
	
	        // we do that only for the non-influenced vertices because the rigged ones
	        // can't be statically computed (full moving bbox of rigs should be computed externally
	        // through bones or cpu rigged colision mesh, etc)
	        // bbox is important for culling (near/far)
	
	        if ( vertexArray && weightsArray && vertexArray.getElements() && vertexArray.getItemSize() > 2 ) {
	
	            var weights = weightsArray.getElements();
	            var vertexes = vertexArray.getElements();
	            var itemSize = vertexArray.getItemSize();
	
	            var min = boundingBox.getMin();
	            var max = boundingBox.getMax();
	
	            var minx = min[ 0 ];
	            var miny = min[ 1 ];
	            var minz = min[ 2 ];
	            var maxx = max[ 0 ];
	            var maxy = max[ 1 ];
	            var maxz = max[ 2 ];
	
	            for ( var idx = 0, idb = 0, l = vertexes.length; idx < l; idx += itemSize, idb += 4 ) {
	
	                if ( weights[ idx ] !== 0.0 || weights[ idx + 1 ] !== 0.0 || weights[ idx + 2 ] !== 0.0 || weights[ idx + 3 ] !== 0.0 )
	                    continue;
	
	                var v1 = vertexes[ idx ];
	                var v2 = vertexes[ idx + 1 ];
	                var v3 = vertexes[ idx + 2 ];
	                if ( v1 < minx ) minx = v1;
	                if ( v1 > maxx ) maxx = v1;
	                if ( v2 < miny ) miny = v2;
	                if ( v2 > maxy ) maxy = v2;
	                if ( v3 < minz ) minz = v3;
	                if ( v3 > maxz ) maxz = v3;
	            }
	
	            min[ 0 ] = minx;
	            min[ 1 ] = miny;
	            min[ 2 ] = minz;
	            max[ 0 ] = maxx;
	            max[ 1 ] = maxy;
	            max[ 2 ] = maxz;
	        }
	
	        return boundingBox;
	    },
	
	    computeMatrixFromRootSkeleton: function () {
	
	        if ( !this._root ) {
	            Notify.warn( 'Warning ' + this.className() + '.computeMatrixFromRootSkeleton if you have this message it means you miss to call buildTransformer( root ), or your RigGeometry (' + this.getName() + ') is not attached to a Skeleton subgraph' );
	            return;
	        }
	
	        Matrix.makeIdentity( this._matrixFromSkeletonToGeometry );
	        ComputeMatrixFromNodePath.computeLocalToWorld( this._pathToRoot, true, this._matrixFromSkeletonToGeometry );
	        Matrix.inverse( this._matrixFromSkeletonToGeometry, this._invMatrixFromSkeletonToGeometry );
	
	        if ( !this._isAnimatedPath )
	            this._needToComputeMatrix = false;
	    },
	
	    getMatrixFromSkeletonToGeometry: function () {
	        return this._matrixFromSkeletonToGeometry;
	    },
	
	    getInvMatrixFromSkeletonToGeometry: function () {
	        return this._invMatrixFromSkeletonToGeometry;
	    },
	
	    getSourceGeometry: function () {
	        return this._geometry;
	    },
	
	    setSourceGeometry: function ( geometry ) {
	        this._geometry = geometry;
	    },
	
	    mergeChildrenVertexAttributeList: function () {
	
	        if ( this._geometry instanceof MorphGeometry )
	            this._geometry.mergeChildrenVertexAttributeList();
	
	        var sourceGeometryVertexAttributeList = this._geometry.getVertexAttributeList();
	
	        Geometry.appendVertexAttributeToList( sourceGeometryVertexAttributeList, this.getVertexAttributeList() );
	
	    },
	
	    mergeChildrenData: function () {
	
	        // move to the rig the vertex attributes, the primitives and the stateset
	
	        this.mergeChildrenVertexAttributeList();
	        var primitiveSetList = this._geometry.getPrimitiveSetList();
	
	        this.getPrimitiveSetList().length = 0;
	        for ( var i = 0, il = primitiveSetList.length; i < il; i++ )
	            this.getPrimitiveSetList()[ i ] = primitiveSetList[ i ];
	
	        if ( this.getStateSet() )
	            console.error( 'A stateset in the rig is already present : ' + this.getStateSet() );
	        this.setStateSet( this._geometry.getStateSet() );
	    },
	
	    update: function () {
	        this._rigTransformImplementation.update( this );
	    },
	
	    computeTransformedVertex: function ( id, out ) {
	        out = out || Vec3.create();
	
	        var vList = this.getVertexAttributeList();
	        var vWeights = vList.Weights.getElements();
	        var vBones = vList.Bones.getElements();
	
	        var x = 0.0;
	        var y = 0.0;
	        var z = 0.0;
	        if ( this._geometry.computeTransformedVertex ) {
	            this._geometry.computeTransformedVertex( id, out );
	            x = out[ 0 ];
	            y = out[ 1 ];
	            z = out[ 2 ];
	        } else {
	            var verts = vList.Vertex.getElements();
	            x = verts[ id * 3 ];
	            y = verts[ id * 3 + 1 ];
	            z = verts[ id * 3 + 2 ];
	        }
	
	        var id4 = id * 4;
	
	        var palette = this._rigTransformImplementation._skinningAttribute.getMatrixPalette();
	        var m0 = 0.0;
	        var m1 = 0.0;
	        var m2 = 0.0;
	        var m4 = 0.0;
	        var m5 = 0.0;
	        var m6 = 0.0;
	        var m8 = 0.0;
	        var m9 = 0.0;
	        var m10 = 0.0;
	        var m12 = 0.0;
	        var m13 = 0.0;
	        var m14 = 0.0;
	        var m15 = 0.0;
	
	        var doSkin = false;
	        for ( var i = 0; i < 4; ++i ) {
	            var w = vWeights[ id4 + i ];
	            if ( w === 0.0 )
	                continue;
	
	            var idBone = vBones[ id4 + i ] * 12;
	
	            m0 += palette[ idBone + 0 ] * w;
	            m4 += palette[ idBone + 1 ] * w;
	            m8 += palette[ idBone + 2 ] * w;
	            m12 += palette[ idBone + 3 ] * w;
	
	            m1 += palette[ idBone + 4 ] * w;
	            m5 += palette[ idBone + 5 ] * w;
	            m9 += palette[ idBone + 6 ] * w;
	            m13 += palette[ idBone + 7 ] * w;
	
	            m2 += palette[ idBone + 8 ] * w;
	            m6 += palette[ idBone + 9 ] * w;
	            m10 += palette[ idBone + 10 ] * w;
	            m14 += palette[ idBone + 11 ] * w;
	
	            m15 += w;
	            doSkin = true;
	        }
	
	        if ( !doSkin ) {
	            out[ 0 ] = x;
	            out[ 1 ] = y;
	            out[ 2 ] = z;
	        }
	
	        var d = 1.0 / m15;
	        out[ 0 ] = ( m0 * x + m4 * y + m8 * z + m12 ) * d;
	        out[ 1 ] = ( m1 * x + m5 * y + m9 * z + m13 ) * d;
	        out[ 2 ] = ( m2 * x + m6 * y + m10 * z + m14 ) * d;
	
	        return out;
	    },
	
	    computeTransformedVertices: function () {
	
	        // obviously slow as it can't rely on kdTree AND we transform everything cpu side
	
	        var vList = this.getVertexAttributeList();
	        var verts = this._geometry.computeTransformedVertices ? this._geometry.computeTransformedVertices() : vList.Vertex.getElements();
	        var vWeights = vList.Weights.getElements();
	        var vBones = vList.Bones.getElements();
	
	        var riggedVerts = this._riggedVerts || new Float32Array( verts.length );
	
	        // /!\ if the geometry has several parents inside a skeleton
	        // it might not work as it will just take the last compute matrix palette
	        var palette = this._rigTransformImplementation._skinningAttribute.getMatrixPalette();
	
	        // verbose... but fast
	        for ( var idv = 0, idr = 0, len = verts.length; idv < len; idv += 3, idr += 4 ) {
	
	            var m0 = 0.0;
	            var m1 = 0.0;
	            var m2 = 0.0;
	
	            var m4 = 0.0;
	            var m5 = 0.0;
	            var m6 = 0.0;
	
	            var m8 = 0.0;
	            var m9 = 0.0;
	            var m10 = 0.0;
	
	            var m12 = 0.0;
	            var m13 = 0.0;
	            var m14 = 0.0;
	            var m15 = 0.0;
	
	            var doSkin = false;
	
	            var w = vWeights[ idr ];
	            var idBone;
	            if ( w !== 0.0 ) {
	                idBone = vBones[ idr ] * 12;
	                m0 += palette[ idBone + 0 ] * w;
	                m4 += palette[ idBone + 1 ] * w;
	                m8 += palette[ idBone + 2 ] * w;
	                m12 += palette[ idBone + 3 ] * w;
	
	                m1 += palette[ idBone + 4 ] * w;
	                m5 += palette[ idBone + 5 ] * w;
	                m9 += palette[ idBone + 6 ] * w;
	                m13 += palette[ idBone + 7 ] * w;
	
	                m2 += palette[ idBone + 8 ] * w;
	                m6 += palette[ idBone + 9 ] * w;
	                m10 += palette[ idBone + 10 ] * w;
	                m14 += palette[ idBone + 11 ] * w;
	
	                m15 += w;
	                doSkin = true;
	            }
	
	            w = vWeights[ idr + 1 ];
	            if ( w !== 0.0 ) {
	                idBone = vBones[ idr + 1 ] * 12;
	                m0 += palette[ idBone + 0 ] * w;
	                m4 += palette[ idBone + 1 ] * w;
	                m8 += palette[ idBone + 2 ] * w;
	                m12 += palette[ idBone + 3 ] * w;
	
	                m1 += palette[ idBone + 4 ] * w;
	                m5 += palette[ idBone + 5 ] * w;
	                m9 += palette[ idBone + 6 ] * w;
	                m13 += palette[ idBone + 7 ] * w;
	
	                m2 += palette[ idBone + 8 ] * w;
	                m6 += palette[ idBone + 9 ] * w;
	                m10 += palette[ idBone + 10 ] * w;
	                m14 += palette[ idBone + 11 ] * w;
	
	                m15 += w;
	                doSkin = true;
	            }
	
	            w = vWeights[ idr + 2 ];
	            if ( w !== 0.0 ) {
	                idBone = vBones[ idr + 2 ] * 12;
	
	                m0 += palette[ idBone + 0 ] * w;
	                m4 += palette[ idBone + 1 ] * w;
	                m8 += palette[ idBone + 2 ] * w;
	                m12 += palette[ idBone + 3 ] * w;
	
	                m1 += palette[ idBone + 4 ] * w;
	                m5 += palette[ idBone + 5 ] * w;
	                m9 += palette[ idBone + 6 ] * w;
	                m13 += palette[ idBone + 7 ] * w;
	
	                m2 += palette[ idBone + 8 ] * w;
	                m6 += palette[ idBone + 9 ] * w;
	                m10 += palette[ idBone + 10 ] * w;
	                m14 += palette[ idBone + 11 ] * w;
	
	                m15 += w;
	                doSkin = true;
	            }
	
	            w = vWeights[ idr + 3 ];
	            if ( w !== 0.0 ) {
	                idBone = vBones[ idr + 3 ] * 12;
	
	                m0 += palette[ idBone + 0 ] * w;
	                m4 += palette[ idBone + 1 ] * w;
	                m8 += palette[ idBone + 2 ] * w;
	                m12 += palette[ idBone + 3 ] * w;
	
	                m1 += palette[ idBone + 4 ] * w;
	                m5 += palette[ idBone + 5 ] * w;
	                m9 += palette[ idBone + 6 ] * w;
	                m13 += palette[ idBone + 7 ] * w;
	
	                m2 += palette[ idBone + 8 ] * w;
	                m6 += palette[ idBone + 9 ] * w;
	                m10 += palette[ idBone + 10 ] * w;
	                m14 += palette[ idBone + 11 ] * w;
	
	                m15 += w;
	                doSkin = true;
	            }
	
	            var x = verts[ idv ];
	            var y = verts[ idv + 1 ];
	            var z = verts[ idv + 2 ];
	
	            if ( !doSkin ) {
	                riggedVerts[ idv ] = x;
	                riggedVerts[ idv + 1 ] = y;
	                riggedVerts[ idv + 2 ] = z;
	                continue;
	            }
	
	            var d = 1.0 / m15;
	            riggedVerts[ idv ] = ( m0 * x + m4 * y + m8 * z + m12 ) * d;
	            riggedVerts[ idv + 1 ] = ( m1 * x + m5 * y + m9 * z + m13 ) * d;
	            riggedVerts[ idv + 2 ] = ( m2 * x + m6 * y + m10 * z + m14 ) * d;
	        }
	
	        return riggedVerts;
	    }
	
	} ), 'osgAnimation', 'RigGeometry' );
	
	MACROUTILS.setTypeID( RigGeometry );
	
	module.exports = RigGeometry;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var BufferArrayProxy = __webpack_require__( 53 );
	var Notify = __webpack_require__( 10 );
	var Vec3 = __webpack_require__( 15 );
	var Geometry = __webpack_require__( 31 );
	var StateSet = __webpack_require__( 19 );
	var MorphAttribute = __webpack_require__( 80 );
	var StateAttribute = __webpack_require__( 21 );
	var BoundingBox = __webpack_require__( 14 );
	
	
	/**
	 * MorphGeometry manage up to 4 morphTargets
	 * @class MorphGeometry
	 * @inherits Geometry
	 */
	
	var MorphGeometry = function () {
	    Geometry.call( this );
	
	    this._shape = null; // by default no kdtree/shape for morph
	
	    this._targets = []; // Target list (Geometry)
	    this._stateSetAnimation = new StateSet(); // StateSet to handle morphAttribute
	    this._targetWeights = new Float32Array( 4 ); // Fixed length array feed by UpdateMorph
	
	    this._morphTargetNames = undefined;
	    this._updateMorph = undefined;
	
	    this._isInitialized = false;
	};
	
	// sync with UpdateMorph
	var EFFECTIVE_EPS = MorphGeometry.EFFECTIVE_EPS = 0.05;
	
	MorphGeometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Geometry.prototype, {
	
	    init: function () {
	        var animAttrib = new MorphAttribute( Math.min( 4, this.getMorphTargets().length ) );
	        this.getStateSetAnimation().setAttributeAndModes( animAttrib, StateAttribute.ON );
	        animAttrib.setTargetWeights( this.getTargetsWeight() );
	
	
	        if ( this._targets[ 0 ] ) {
	            this._morphTargetNames = window.Object.keys( this._targets[ 0 ].getVertexAttributeList() );
	            animAttrib.copyTargetNames( this._morphTargetNames );
	        } else {
	            this._morphTargetNames = [];
	            Notify.error( 'No Targets in the MorphGeometry !' );
	        }
	
	        this._isInitialized = true;
	        return true;
	    },
	
	    getMorphTargetNames: function () {
	        return this._morphTargetNames;
	    },
	
	    getStateSetAnimation: function () {
	        return this._stateSetAnimation;
	    },
	
	    getMorphTargets: function () {
	        return this._targets;
	    },
	
	    isInitialized: function () {
	        return this._isInitialized;
	    },
	
	    getTargetsWeight: function () {
	        return this._targetWeights;
	    },
	
	    computeBoundingBox: ( function () {
	        var tmpBox = new BoundingBox();
	
	        return function ( boundingBox ) {
	            Geometry.prototype.computeBoundingBox.call( this, boundingBox );
	
	            // expand bb with targets
	            // Note : if the morphs have many many targets it can be done more smartly in
	            // the UpdateMorph on each frame by just taking into account the "active morphs"
	            for ( var i = 0, l = this._targets.length; i < l; i++ ) {
	                boundingBox.expandByBoundingBox( this._targets[ i ].computeBoundingBox( tmpBox ) );
	            }
	
	            return boundingBox;
	        };
	    } )(),
	
	    mergeChildrenVertexAttributeList: function () {
	
	        for ( var i = 0, l = this._targets.length; i < l; i++ ) {
	
	            var target = this._targets[ i ];
	
	            // change BufferArray to BufferArrayProxy
	            var attributeList = target.getVertexAttributeList();
	            var names = window.Object.keys( attributeList );
	            for ( var j = 0, jn = names.length; j < jn; j++ ) {
	
	                var name = names[ j ];
	                var att = attributeList[ name ];
	                // check it's a buffer array before swtiching to proxy
	                if ( att && !att.getBufferArray ) {
	
	                    attributeList[ name ] = new BufferArrayProxy( att );
	
	                }
	
	            }
	
	            Geometry.appendVertexAttributeToList( target.getVertexAttributeList(), this.getVertexAttributeList(), i );
	
	        }
	
	    },
	
	    _computeEffectiveSumWeights: function () {
	        var sum = 0.0;
	        var weights = this._targetWeights;
	        for ( var i = 0, nb = weights.length; i < nb; ++i ) {
	
	            var weight = weights[ i ];
	            if ( Math.abs( weight ) < EFFECTIVE_EPS )
	                continue;
	
	            sum += weight;
	        }
	        var eps = 1e-5;
	        if ( Math.abs( sum ) > eps ) return sum;
	        return sum < 0.0 ? -eps : eps;
	    },
	
	    computeTransformedVertex: function ( id, out ) {
	        out = out || Vec3.create();
	
	        var id3 = id * 3;
	
	        var weights = this._targetWeights;
	        var vList = this.getVertexAttributeList();
	
	        var baseVerts = vList.Vertex.getElements();
	
	        var sumWeights = 1.0 - this._computeEffectiveSumWeights();
	        out[ 0 ] = sumWeights * baseVerts[ id3 ];
	        out[ 1 ] = sumWeights * baseVerts[ id3 + 1 ];
	        out[ 2 ] = sumWeights * baseVerts[ id3 + 2 ];
	
	        for ( var j = 0, nb = weights.length; j < nb; ++j ) {
	
	            var weight = weights[ j ];
	            if ( Math.abs( weight ) < EFFECTIVE_EPS )
	                continue;
	
	            var morphElts = vList[ 'Vertex_' + j ].getElements();
	            out[ 0 ] += weight * morphElts[ id3 ];
	            out[ 1 ] += weight * morphElts[ id3 + 1 ];
	            out[ 2 ] += weight * morphElts[ id3 + 2 ];
	        }
	
	        return out;
	    },
	
	    computeTransformedVertices: function () {
	
	        var weights = this._targetWeights;
	        var vList = this.getVertexAttributeList();
	
	        var baseVerts = vList.Vertex.getElements();
	        var vertexLen = baseVerts.length;
	
	        var morphedVerts = this._morphedVerts = this._morphedVerts || new Float32Array( vertexLen );
	
	        // base vertex influence
	        var baseWeight = 1.0 - this._computeEffectiveSumWeights();
	        for ( var i = 0; i < vertexLen; ++i ) {
	            morphedVerts[ i ] = baseWeight * baseVerts[ i ];
	        }
	
	        for ( var j = 0, nb = weights.length; j < nb; ++j ) {
	
	            var weight = weights[ j ];
	            if ( Math.abs( weight ) < EFFECTIVE_EPS )
	                continue;
	
	            // important : we should not take getInitialBufferArray as we should take the partially computed cpu morph from UpdateMorph
	            var morphElts = vList[ 'Vertex_' + j ].getElements();
	            for ( var k = 0; k < vertexLen; ++k ) {
	                morphedVerts[ k ] += weight * morphElts[ k ];
	            }
	        }
	
	        return morphedVerts;
	    }
	
	
	} ), 'osgAnimation', 'MorphGeometry' );
	
	MACROUTILS.setTypeID( MorphGeometry );
	
	module.exports = MorphGeometry;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Map = __webpack_require__( 20 );
	var StateAttribute = __webpack_require__( 21 );
	var Uniform = __webpack_require__( 35 );
	
	
	/**
	 * MorphAttribute encapsulate Animation State
	 * @class MorphAttribute
	 * @inherits StateAttribute
	 */
	var MorphAttribute = function ( nbTarget, disable ) {
	    StateAttribute.call( this );
	    this._nbTarget = nbTarget;
	    this._enable = !disable;
	
	    this._targetNames = {};
	    this._hashNames = ''; // compute only once target hash names
	};
	
	MorphAttribute.uniforms = {};
	
	MorphAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Morph',
	
	    cloneType: function () {
	        return new MorphAttribute( undefined, true );
	    },
	
	    hasTarget: function ( name ) {
	        return !!this._targetNames[ name ];
	    },
	
	    copyTargetNames: function ( names ) {
	        var tNames = this._targetNames;
	        var hash = '';
	        var nbNames = tNames.length = names.length;
	
	        for ( var i = 0; i < nbNames; ++i ) {
	            var att = names[ i ];
	            tNames[ att ] = true;
	            hash += att;
	        }
	
	        this._hashNames = hash;
	    },
	
	    getOrCreateUniforms: function () {
	        var obj = MorphAttribute;
	        var unifHash = this.getNumTargets();
	
	        if ( obj.uniforms[ unifHash ] ) return obj.uniforms[ unifHash ];
	
	        var uniforms = {};
	        uniforms.uTargetWeights = Uniform.createFloat4( 'uTargetWeights' );
	        obj.uniforms[ unifHash ] = new Map( uniforms );
	
	        return obj.uniforms[ unifHash ];
	    },
	
	    getNumTargets: function () {
	        return this._nbTarget;
	    },
	
	    setTargetWeights: function ( targetWeight ) {
	        this._targetWeights = targetWeight;
	    },
	
	    getTargetWeights: function () {
	        return this._targetWeights;
	    },
	
	    isEnabled: function () {
	        return this._enable;
	    },
	
	    getHash: function () {
	        return this.getTypeMember() + this._hashNames + this.getNumTargets() + this.isEnabled();
	    },
	
	    apply: function () {
	
	        if ( !this._enable ) return;
	
	        var uniformMap = this.getOrCreateUniforms();
	        uniformMap.uTargetWeights.setFloat4( this._targetWeights );
	
	    }
	
	} ), 'osgAnimation', 'MorphAttribute' );
	
	MACROUTILS.setTypeID( MorphAttribute );
	
	module.exports = MorphAttribute;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Notify = __webpack_require__( 10 );
	var ObjectBase = __webpack_require__( 13 );
	var FindNearestParentSkeleton = __webpack_require__( 82 );
	
	
	// converted from C++ probably it could be merged into RigGeometry
	// it could probably inlined into RigGeometry code
	var UpdateRigGeometry = function () {
	    ObjectBase.call( this );
	};
	
	UpdateRigGeometry.prototype = MACROUTILS.objectInherit( ObjectBase.prototype, {
	
	    init: function ( geom ) {
	
	        var finder = new FindNearestParentSkeleton();
	        if ( geom.getParents().length > 1 )
	            Notify.warn( 'A RigGeometry should not have multi parent ( ' + geom.getName() + ' )' );
	
	        geom.getParents()[ 0 ].accept( finder );
	
	        if ( !finder._root ) {
	            Notify.warn( 'A RigGeometry did not find a parent skeleton for RigGeometry ( ' + geom.getName() + ' )' );
	            return;
	        }
	
	        geom.setSkeleton( finder._root );
	        geom.setPathToSkeleton( finder._pathToRoot );
	    },
	
	    update: function ( node /*, nv*/ ) {
	
	        // Circular ref
	        if ( node && node.className() !== 'RigGeometry' ) return true;
	
	        var geom = node;
	
	        // maybe this code could simpler
	        if ( !geom.getSkeleton() && geom.getParents().length !== 0 ) this.init( geom );
	        if ( !geom.getSkeleton() ) return true;
	
	        if ( geom.getNeedToComputeMatrix() ) geom.computeMatrixFromRootSkeleton();
	
	        geom.update();
	
	        return true;
	    }
	
	} );
	
	module.exports = UpdateRigGeometry;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var Skeleton = __webpack_require__( 72 );
	
	
	/**
	 * FindNearestParentSkeleton
	 */
	
	var FindNearestParentSkeleton = function () {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_PARENTS );
	    this._root = undefined;
	
	    // node path to skeleton (without skeleton node though)
	    this._pathToRoot = undefined;
	};
	
	FindNearestParentSkeleton.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	
	    apply: function ( node ) {
	
	        if ( this._root ) return;
	
	        if ( node.typeID === Skeleton.typeID ) {
	            this._root = node;
	            this._pathToRoot = this.nodePath.slice( 1 );
	            return;
	        }
	
	        this.traverse( node );
	    }
	} );
	
	module.exports = FindNearestParentSkeleton;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Matrix = __webpack_require__( 23 );
	var StateAttribute = __webpack_require__( 21 );
	var SkinningAttribute = __webpack_require__( 84 );
	var CollectBoneVisitor = __webpack_require__( 85 );
	
	
	/**
	 * Hardware implementation for rigGeometry
	 *
	 */
	var RigTransformHardware = function () {
	    this._isInitialized = false;
	
	    // bones are sorted to be used directly by
	    // computeMatrixPalette
	    // means the
	    this._bones = [];
	};
	
	
	RigTransformHardware.prototype = {
	
	    // boneNameID contains a map: boneName: id
	    // {
	    //    'bone0' : 1,
	    //    'bone4' : 0,
	    // }
	    //
	    // boneMap contains a map: boneName: Bone
	    // {
	    //    'bone0: : Bone object,
	    //    'bone1: : Bone object,
	    // }
	    //
	    // return index / bone object
	    // [
	    //    Bone4 object,
	    //    Bone0 object
	    // ]
	    computeBonePalette: function ( boneMap, boneNameID ) {
	        var keys = window.Object.keys( boneMap );
	        var size = keys.length;
	        var bones = this._bones;
	
	
	        for ( var i = 0; i < size; i++ ) {
	            var bName = keys[ i ];
	            var index = boneNameID[ bName ];
	            var bone = boneMap[ bName ];
	
	            if ( index !== undefined )
	                bones[ index ] = bone;
	        }
	
	        return bones;
	    },
	
	
	    init: function ( geom ) {
	
	        // init the bones map
	
	        // stop here
	        // compute bonemap / index
	        var mapVisitor = new CollectBoneVisitor();
	        geom.getSkeleton().accept( mapVisitor );
	        var bm = mapVisitor.getBoneMap();
	
	        this.computeBonePalette( bm, geom._boneNameID );
	
	        // matrix are 4x3
	        var nbVec4Uniforms = this._bones.length * 3;
	        var animAttrib = this._skinningAttribute = new SkinningAttribute();
	        animAttrib.setMatrixPalette( new Float32Array( nbVec4Uniforms * 4 ) );
	        geom.getStateSetAnimation().setAttributeAndModes( animAttrib, StateAttribute.ON );
	
	        this._isInitialized = true;
	        return true;
	    },
	
	
	    computeMatrixPalette: ( function () {
	
	        var mTmp = Matrix.create();
	
	        return function ( transformFromSkeletonToGeometry, invTransformFromSkeletonToGeometry ) {
	
	            var bones = this._bones;
	            var matPalette = this._skinningAttribute.getMatrixPalette();
	            var uniformIndex = 0;
	
	            for ( var i = 0, l = bones.length; i < l; i++ ) {
	                var bone = bones[ i ];
	
	                var invBindMatrix = bone.getInvBindMatrixInSkeletonSpace();
	                var boneMatrix = bone.getMatrixInSkeletonSpace();
	
	                Matrix.mult( boneMatrix, invBindMatrix, mTmp );
	                Matrix.postMult( invTransformFromSkeletonToGeometry, mTmp );
	                Matrix.preMult( mTmp, transformFromSkeletonToGeometry );
	
	                // TODO: maybe change upload order so that we can use
	                // glsl constructor :
	                // mat4(uBones[index], uBones[index+1], uBones[index+2], vec4(0.0, 0.0, 0.0, 1.0))
	                // for faster glsl
	                matPalette[ uniformIndex++ ] = mTmp[ 0 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 4 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 8 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 12 ];
	
	                matPalette[ uniformIndex++ ] = mTmp[ 1 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 5 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 9 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 13 ];
	
	                matPalette[ uniformIndex++ ] = mTmp[ 2 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 6 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 10 ];
	                matPalette[ uniformIndex++ ] = mTmp[ 14 ];
	            }
	        };
	
	    } )(),
	
	    update: function ( geom ) {
	
	        if ( !this._isInitialized )
	            this.init( geom );
	
	        this.computeMatrixPalette( geom.getMatrixFromSkeletonToGeometry(), geom.getInvMatrixFromSkeletonToGeometry() );
	    }
	};
	
	
	module.exports = RigTransformHardware;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Map = __webpack_require__( 20 );
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	var Uniform = __webpack_require__( 35 );
	
	
	/**
	 * SkinningAttribute encapsulate Animation State
	 * @class SkinningAttribute
	 * @inherits StateAttribute
	 */
	var SkinningAttribute = function ( disable, boneUniformSize ) {
	    StateAttribute.call( this );
	    this._enable = !disable;
	    // optional, if it's not provided, it will fall back to the maximum bone uniform size
	    // boneUniformSize represents the number of vec4 (uniform) used in the shader for all the bones
	    this._boneUniformSize = boneUniformSize;
	};
	
	SkinningAttribute.uniforms = {};
	SkinningAttribute.maxBoneUniformSize = 1;
	SkinningAttribute.maxBoneUniformAllowed = Infinity; // can be overriden by application specific limit on startup (typically gl limit)
	
	SkinningAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Skinning',
	
	    cloneType: function () {
	        return new SkinningAttribute( true );
	    },
	
	    setBoneUniformSize: function ( boneUniformSize ) {
	        this._boneUniformSize = boneUniformSize;
	    },
	
	    getBoneUniformSize: function () {
	        return this._boneUniformSize !== undefined ? this._boneUniformSize : SkinningAttribute.maxBoneUniformSize;
	    },
	
	    getOrCreateUniforms: function () {
	        var obj = SkinningAttribute;
	        var unifHash = this.getBoneUniformSize();
	
	        if ( obj.uniforms[ unifHash ] ) return obj.uniforms[ unifHash ];
	
	        var uniforms = {};
	        uniforms.uBones = Uniform.createFloat4Array( 'uBones' );
	        obj.uniforms[ unifHash ] = new Map( uniforms );
	
	        return obj.uniforms[ unifHash ];
	    },
	
	    setMatrixPalette: function ( matrixPalette ) {
	        this._matrixPalette = matrixPalette;
	        // update max bone size
	        if ( this._boneUniformSize === undefined ) {
	            SkinningAttribute.maxBoneUniformSize = Math.max( SkinningAttribute.maxBoneUniformSize, matrixPalette.length / 4 );
	            SkinningAttribute.maxBoneUniformSize = Math.min( SkinningAttribute.maxBoneUniformAllowed, SkinningAttribute.maxBoneUniformSize );
	        }
	    },
	
	    getMatrixPalette: function () {
	        return this._matrixPalette;
	    },
	
	    // need a isEnabled to let the ShaderGenerator to filter
	    // StateAttribute from the shader compilation
	    isEnabled: function () {
	        return this._enable;
	    },
	
	    getHash: function () {
	        // bonesize is important, as the shader itself
	        // has a different code and uniform are not shared
	        // geoms have each their own bones matrix palette
	        // it's up to rigGeometry to use same anim Attrib per
	        // same bone matrix palette
	        // as uniform array size must be statically declared
	        // in shader code
	        return this.getTypeMember() + this.getBoneUniformSize() + this.isEnabled();
	    },
	
	    apply: function () {
	
	        if ( !this._enable ) return;
	
	        this.getOrCreateUniforms().uBones.setInternalArray( this._matrixPalette );
	
	    }
	
	} ), 'osgAnimation', 'SkinningAttribute' );
	
	MACROUTILS.setTypeID( SkinningAttribute );
	
	module.exports = SkinningAttribute;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var Notify = __webpack_require__( 10 );
	var Bone = __webpack_require__( 74 );
	
	
	var CollectBoneVisitor = function () {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );
	    this._boneMap = {};
	};
	
	CollectBoneVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	
	    apply: function ( node ) {
	
	        if ( node.typeID === Bone.typeID ) {
	
	            var name = node.getName();
	
	            if ( !name ) {
	                Notify.warn( 'found Bone without name' );
	            } else {
	                this._boneMap[ name ] = node;
	            }
	        }
	
	        this.traverse( node );
	    },
	
	    getBoneMap: function () {
	        return this._boneMap;
	    }
	
	} );
	
	module.exports = CollectBoneVisitor;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	
	var Depth = function ( func, near, far, writeMask ) {
	    StateAttribute.call( this );
	
	    this._func = Depth.LESS;
	    this._near = 0.0;
	    this._far = 1.0;
	    this._writeMask = true;
	
	    if ( func !== undefined ) {
	        if ( typeof ( func ) === 'string' ) {
	            this._func = Depth[ func ];
	        } else {
	            this._func = func;
	        }
	    }
	    if ( near !== undefined ) {
	        this._near = near;
	    }
	    if ( far !== undefined ) {
	        this._far = far;
	    }
	    if ( writeMask !== undefined ) {
	        this._writeMask = writeMask;
	    }
	};
	
	Depth.DISABLE = 0x0000;
	Depth.NEVER = 0x0200;
	Depth.LESS = 0x0201;
	Depth.EQUAL = 0x0202;
	Depth.LEQUAL = 0x0203;
	Depth.GREATER = 0x0204;
	Depth.NOTEQUAL = 0x0205;
	Depth.GEQUAL = 0x0206;
	Depth.ALWAYS = 0x0207;
	
	Depth.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	    attributeType: 'Depth',
	    cloneType: function () {
	        return new Depth();
	    },
	    setRange: function ( near, far ) {
	        this._near = near;
	        this._far = far;
	    },
	    setWriteMask: function ( mask ) {
	        this._writeMask = mask;
	    },
	    getWriteMask: function () {
	        return this._writeMask;
	    },
	    getFunc: function () {
	        return this._func;
	    },
	    apply: function ( state ) {
	        var gl = state.getGraphicContext();
	        if ( this._func === 0 ) {
	            gl.disable( gl.DEPTH_TEST );
	        } else {
	            gl.enable( gl.DEPTH_TEST );
	            gl.depthFunc( this._func );
	            gl.depthMask( this._writeMask );
	            gl.depthRange( this._near, this._far );
	        }
	    }
	} ), 'osg', 'Depth' );
	
	module.exports = Depth;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Matrix = __webpack_require__( 23 );
	var Vec3 = __webpack_require__( 15 );
	
	
	var EllipsoidModel = function () {
	    this._radiusEquator = EllipsoidModel.WGS_84_RADIUS_EQUATOR;
	    this._radiusPolar = EllipsoidModel.WGS_84_RADIUS_POLAR;
	    this.computeCoefficients();
	};
	
	EllipsoidModel.WGS_84_RADIUS_EQUATOR = 6378137.0;
	EllipsoidModel.WGS_84_RADIUS_POLAR = 6356752.3142;
	
	EllipsoidModel.prototype = {
	    setRadiusEquator: function ( radius ) {
	        this._radiusEquator = radius;
	        this.computeCoefficients();
	    },
	    getRadiusEquator: function () {
	        return this._radiusEquator;
	    },
	    setRadiusPolar: function ( radius ) {
	        this._radiusPolar = radius;
	        this.computeCoefficients();
	    },
	    getRadiusPolar: function () {
	        return this._radiusPolar;
	    },
	    convertLatLongHeightToXYZ: function ( latitude, longitude, height, result ) {
	        if ( result === undefined ) {
	            Notify.warn( 'deprecated, use this signature convertLatLongHeightToXYZ( latitude, longitude, height, result )' );
	            result = Vec3.create();
	        }
	        var sinLatitude = Math.sin( latitude );
	        var cosLatitude = Math.cos( latitude );
	        var N = this._radiusEquator / Math.sqrt( 1.0 - this._eccentricitySquared * sinLatitude * sinLatitude );
	        var X = ( N + height ) * cosLatitude * Math.cos( longitude );
	        var Y = ( N + height ) * cosLatitude * Math.sin( longitude );
	        var Z = ( N * ( 1.0 - this._eccentricitySquared ) + height ) * sinLatitude;
	        result[ 0 ] = X;
	        result[ 1 ] = Y;
	        result[ 2 ] = Z;
	        return result;
	    },
	    convertXYZToLatLongHeight: function ( X, Y, Z, result ) {
	        if ( result === undefined ) {
	            Notify.warn( 'deprecated, use this signature convertXYZToLatLongHeight( X,  Y,  Z , result)' );
	            result = Vec3.create();
	        }
	        // http://www.colorado.edu/geography/gcraft/notes/datum/gif/xyzllh.gif
	        var p = Math.sqrt( X * X + Y * Y );
	        var theta = Math.atan2( Z * this._radiusEquator, ( p * this._radiusPolar ) );
	        var eDashSquared = ( this._radiusEquator * this._radiusEquator - this._radiusPolar * this._radiusPolar ) / ( this._radiusPolar * this._radiusPolar );
	
	        var sinTheta = Math.sin( theta );
	        var cosTheta = Math.cos( theta );
	
	        var latitude = Math.atan( ( Z + eDashSquared * this._radiusPolar * sinTheta * sinTheta * sinTheta ) /
	            ( p - this._eccentricitySquared * this._radiusEquator * cosTheta * cosTheta * cosTheta ) );
	        var longitude = Math.atan2( Y, X );
	
	        var sinLatitude = Math.sin( latitude );
	        var N = this._radiusEquator / Math.sqrt( 1.0 - this._eccentricitySquared * sinLatitude * sinLatitude );
	
	        var cosLat = Math.cos( latitude );
	        if ( cosLat === 0 ) cosLat = 1;
	        var height = p / cosLat - N;
	        result[ 0 ] = latitude;
	        result[ 1 ] = longitude;
	        result[ 2 ] = height;
	        return result;
	    },
	    computeLocalUpVector: function ( X, Y, Z ) {
	        // Note latitude is angle between normal to ellipsoid surface and XY-plane
	        var latitude, longitude, altitude;
	        var coord = this.convertXYZToLatLongHeight( X, Y, Z, latitude, longitude, altitude );
	        latitude = coord[ 0 ];
	        longitude = coord[ 1 ];
	        altitude = coord[ 2 ];
	
	        // Compute up vector
	        return [ Math.cos( longitude ) * Math.cos( latitude ),
	            Math.sin( longitude ) * Math.cos( latitude ),
	            Math.sin( latitude )
	        ];
	    },
	    isWGS84: function () {
	        return ( this._radiusEquator === EllipsoidModel.WGS_84_RADIUS_EQUATOR && this._radiusPolar === EllipsoidModel.WGS_84_RADIUS_POLAR );
	    },
	
	    computeCoefficients: function () {
	        var flattening = ( this._radiusEquator - this._radiusPolar ) / this._radiusEquator;
	        this._eccentricitySquared = 2.0 * flattening - flattening * flattening;
	    },
	    computeLocalToWorldTransformFromLatLongHeight: function ( latitude, longitude, height, result ) {
	        if ( result === undefined ) {
	            Notify.warn( 'deprecated, use this signature computeLocalToWorldTransformFromLatLongHeight(latitude, longitude, height, result)' );
	            result = Matrix.create();
	        }
	        var pos = this.convertLatLongHeightToXYZ( latitude, longitude, height, result );
	        Matrix.makeTranslate( pos[ 0 ], pos[ 1 ], pos[ 2 ], result );
	        this.computeCoordinateFrame( latitude, longitude, result );
	        return result;
	    },
	    computeLocalToWorldTransformFromXYZ: function ( X, Y, Z ) {
	        var lla = this.convertXYZToLatLongHeight( X, Y, Z );
	        var m = Matrix.makeTranslate( X, Y, Z, Matrix.create() );
	        this.computeCoordinateFrame( lla[ 0 ], lla[ 1 ], m );
	        return m;
	    },
	    computeCoordinateFrame: ( function () {
	        var up = Vec3.create();
	        var east = Vec3.create();
	        var north = Vec3.create();
	        return function ( latitude, longitude, localToWorld ) {
	            // Compute up vector
	            up[ 0 ] = Math.cos( longitude ) * Math.cos( latitude );
	            up[ 1 ] = Math.sin( longitude ) * Math.cos( latitude );
	            up[ 2 ] = Math.sin( latitude );
	
	            // Compute east vector
	            east[ 0 ] = -Math.sin( longitude );
	            east[ 1 ] = -Math.cos( longitude );
	
	            // Compute north vector = outer product up x east
	            Vec3.cross( up, east, north );
	
	            // set matrix
	            Matrix.set( localToWorld, 0, 0, east[ 0 ] );
	            Matrix.set( localToWorld, 0, 1, east[ 1 ] );
	            Matrix.set( localToWorld, 0, 2, east[ 2 ] );
	
	            Matrix.set( localToWorld, 1, 0, north[ 0 ] );
	            Matrix.set( localToWorld, 1, 1, north[ 1 ] );
	            Matrix.set( localToWorld, 1, 2, north[ 2 ] );
	
	            Matrix.set( localToWorld, 2, 0, up[ 0 ] );
	            Matrix.set( localToWorld, 2, 1, up[ 1 ] );
	            Matrix.set( localToWorld, 2, 2, up[ 2 ] );
	        };
	    } )()
	};
	
	module.exports = EllipsoidModel;


/***/ }),
/* 88 */
/***/ (function(module, exports) {

	'use strict';
	
	var FrameStamp = function () {
	    this._frame = 0;
	    this._startSimulation = 0.0;
	    this._currentSimulation = 0.0;
	    this._deltaTime = 0.0; // last time elapsed since the next traversal
	};
	
	FrameStamp.prototype = {
	    setReferenceTime: function ( s ) {
	        this._startSimulation = s;
	    },
	    getReferenceTime: function () {
	        return this._startSimulation;
	    },
	    setSimulationTime: function ( s ) {
	        this._currentSimulation = s;
	    },
	    getSimulationTime: function () {
	        return this._currentSimulation;
	    },
	    setDeltaTime: function ( d ) {
	        this._deltaTime = d;
	    },
	    getDeltaTime: function () {
	        return this._deltaTime;
	    },
	    setFrameNumber: function ( n ) {
	        this._frame = n;
	    },
	    getFrameNumber: function () {
	        return this._frame;
	    }
	};
	
	module.exports = FrameStamp;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var P = __webpack_require__( 47 );
	var MACROUTILS = __webpack_require__( 6 );
	var Image = __webpack_require__( 36 );
	
	
	var ImageStream = function ( video ) {
	    Image.call( this, video );
	    this._canPlayDefered = undefined;
	};
	
	ImageStream.PAUSE = 0;
	ImageStream.PLAYING = 1;
	
	ImageStream.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Image.prototype, {
	
	    isDirty: function () {
	        return this._status === ImageStream.PLAYING; // video is dirty if playing
	    },
	
	    setImage: function ( video ) {
	        Image.prototype.setImage.call( this, video );
	
	        this._status = ImageStream.STOP;
	
	        // event at the end of the stream
	        video.addEventListener( 'ended', function () {
	            if ( !this._imageObject.loop )
	                this.stop();
	        }.bind( this ), true );
	
	        this.dirty();
	    },
	
	    setLooping: function ( bool ) {
	        this._imageObject.loop = bool;
	    },
	
	    play: function () {
	        this._imageObject.play();
	        this._status = ImageStream.PLAYING;
	    },
	
	    stop: function () {
	        this._imageObject.pause();
	        this._status = ImageStream.PAUSE;
	    },
	
	    whenReady: function () {
	
	        if ( !this._imageObject ) {
	            return P.reject();
	        }
	
	        if ( !this._canPlayDefered ) {
	            this._canPlayDefered = P.defer();
	            this._imageObject.addEventListener( 'canplaythrough', this._canPlayDefered.resolve.bind( this._canPlayDefered, this ), true );
	        }
	
	        return this._canPlayDefered.promise;
	    }
	
	
	} ), 'osg', 'ImageStream' );
	
	MACROUTILS.setTypeID( ImageStream );
	
	module.exports = ImageStream;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var BoundingBox = __webpack_require__( 14 );
	var TriangleIndexFunctor = __webpack_require__( 91 );
	var PrimitiveSet = __webpack_require__( 41 );
	var KdTreeRayIntersector = __webpack_require__( 92 );
	var KdTreeSphereIntersector = __webpack_require__( 94 );
	
	
	// **** GENERAL INFO ON KDTREE ****
	// A KdTree is a Spatial Partitionning Tree (http://en.wikipedia.org/wiki/Space_partitioning)
	// The type of tree is sort of defined by the splitting axis method:
	// - Per Axis split (octree/ kdtree)
	// - Arbritrary direction split (bsp)
	
	// The algorithm used for splitting, the name for finding best split is 'Surface Area Heuristic (SAH)'
	// Octree divide the space in 8 subspace (one box -> 8 sub boxes)
	// whereas kdtree does it by splitting population number in two equal group
	
	// Kd Tree http://en.wikipedia.org/wiki/K-d_tree
	// a given set of points is sorted along one Axis (e.g. X).
	// The sorted list is split at the median.
	// The result are two sets, one for each half-space (left and right).
	
	// Then, for the current node, the splitting-plane position (or the median-point) and depth is saved.
	// Finally, if the point-set has more than n point and the tree depth is below m
	// (with n,m chosen by the user, as build options), two child-nodes (L/R one for each point-set)
	// are created which themselfs repeat the pocedure.
	
	// The split-axis gets alternated at each depth, the split order is computed by checking the main
	// bounding box the length of its axis
	// **** GENERAL INFO ON KDTREE ****
	
	// The KdTree implemented here is flattened, ie, a node and its children all lie in the same array
	// The most important thing is the understanding of the variables first and second for each node
	// Their semantic depend if the node is a leaf or not
	// if it's a leaf :
	//   first and second defines a range in the triangles array (triangles in the cell)
	// if it's not a leaf :
	// - first and second respectively represents the left and right sub children
	// We know that a node is a leaf if first is negative, in that case the range will be defined by
	// [ -first - 1, -first-1 + second ]
	var KdNode = function ( first, second ) {
	    this._bb = new BoundingBox();
	    this._first = first;
	    this._second = second;
	    // These variables represent the local clipped ray (for intersection test)
	    // They are mostly temporary because they are recomputed for each intersection test
	    this._nodeRayStart = Vec3.create();
	    this._nodeRayEnd = Vec3.create();
	};
	
	var BuildKdTree = function ( kdTree ) {
	    this._kdTree = kdTree;
	    this._bb = new BoundingBox();
	    this._primitiveIndices = null; // Uint32Array
	    this._centers = null; // Float32Array
	    this._axisOrder = Vec3.create();
	    this._stackLength = 0;
	};
	
	BuildKdTree.prototype = {
	    build: function ( options, geom ) {
	        var targetTris = options._targetNumTrianglesPerLeaf;
	        var vertexAttrib = geom.getVertexAttributeList().Vertex;
	        if ( !vertexAttrib )
	            return false;
	        var vertices = vertexAttrib.getElements();
	        if ( !vertices )
	            return false;
	        var nbVertices = vertices.length / 3;
	        if ( nbVertices < targetTris )
	            return false;
	
	        this._bb.copy( geom.getBoundingBox() );
	        this._kdTree.setVertices( vertices );
	
	        this.computeDivisions( options );
	        options._numVerticesProcessed += nbVertices;
	
	        this.computeTriangles( geom );
	
	        var node = new KdNode( -1, this._primitiveIndices.length );
	        node._bb.copy( this._bb );
	        var nodeNum = this._kdTree.addNode( node );
	
	        var bb = new BoundingBox();
	        bb.copy( this._bb );
	        nodeNum = this.divide( options, bb, nodeNum, 0 );
	
	        // Here we re-order the triangle list so that we can have a flat tree
	        // _primitiveIndices is the ordered array of the triangle indices
	        var triangles = this._kdTree.getTriangles();
	        var primitives = this._primitiveIndices;
	        var nbPrimitives = primitives.length;
	        var triangleOrdered = new MACROUTILS.Uint32Array( triangles.length );
	        for ( var i = 0, j = 0; i < nbPrimitives; ++i, j += 3 ) {
	            var id = primitives[ i ] * 3;
	            triangleOrdered[ j ] = triangles[ id ];
	            triangleOrdered[ j + 1 ] = triangles[ id + 1 ];
	            triangleOrdered[ j + 2 ] = triangles[ id + 2 ];
	        }
	        this._kdTree.setTriangles( triangleOrdered );
	        return this._kdTree.getNodes().length > 0;
	    },
	    // The function first gather all the triangles of the geometry
	    // It then computes the centroid for each triangle and initialize
	    // of triangles indices that will refer to the main triangles array
	    computeTriangles: function ( geom ) {
	        var kdTree = this._kdTree;
	
	        var totalLenArray = 0;
	        var geomPrimitives = geom.primitives;
	        var nbPrimitives = geomPrimitives.length;
	        var i = 0;
	        for ( i = 0; i < nbPrimitives; i++ ) {
	            var prim = geomPrimitives[ i ];
	            var mode = prim.getMode();
	            // ignore points and line stuffs
	            if ( mode === PrimitiveSet.TRIANGLES )
	                totalLenArray += prim.getCount();
	            else if ( mode === PrimitiveSet.TRIANGLE_STRIP || mode === PrimitiveSet.TRIANGLE_FAN )
	                totalLenArray += ( prim.getCount() - 2 ) * 3;
	        }
	        var indices = new MACROUTILS.Uint32Array( totalLenArray );
	        var next = 0;
	        var cb = function ( i1, i2, i3 ) {
	            if ( i1 === i2 || i1 === i3 || i2 === i3 )
	                return;
	            indices[ next ] = i1;
	            indices[ next + 1 ] = i2;
	            indices[ next + 2 ] = i3;
	            next += 3;
	        };
	
	
	        var tif = new TriangleIndexFunctor();
	        tif.init( geom, cb );
	        tif.apply();
	
	        indices = indices.subarray( 0, next );
	
	        var nbTriangles = indices.length;
	        kdTree.setTriangles( indices );
	
	        var vertices = kdTree.getVertices();
	
	        this._centers = new MACROUTILS.Float32Array( nbTriangles );
	        var centers = this._centers;
	        this._primitiveIndices = new MACROUTILS.Uint32Array( nbTriangles / 3 );
	        var primitives = this._primitiveIndices;
	
	        var j = 0;
	        for ( i = 0, j = 0; i < nbTriangles; i += 3, ++j ) {
	            var iv0 = indices[ i ];
	            var iv1 = indices[ i + 1 ];
	            var iv2 = indices[ i + 2 ];
	
	            // discard degenerate points
	            if ( iv0 === iv1 || iv1 === iv2 || iv0 === iv2 )
	                return;
	
	            iv0 *= 3;
	            iv1 *= 3;
	            iv2 *= 3;
	
	            var v0x = vertices[ iv0 ];
	            var v0y = vertices[ iv0 + 1 ];
	            var v0z = vertices[ iv0 + 2 ];
	
	            var v1x = vertices[ iv1 ];
	            var v1y = vertices[ iv1 + 1 ];
	            var v1z = vertices[ iv1 + 2 ];
	
	            var v2x = vertices[ iv2 ];
	            var v2y = vertices[ iv2 + 1 ];
	            var v2z = vertices[ iv2 + 2 ];
	
	            var minx = Math.min( v0x, Math.min( v1x, v2x ) );
	            var miny = Math.min( v0y, Math.min( v1y, v2y ) );
	            var minz = Math.min( v0z, Math.min( v1z, v2z ) );
	
	            var maxx = Math.max( v0x, Math.max( v1x, v2x ) );
	            var maxy = Math.max( v0y, Math.max( v1y, v2y ) );
	            var maxz = Math.max( v0z, Math.max( v1z, v2z ) );
	            centers[ i ] = ( minx + maxx ) * 0.5;
	            centers[ i + 1 ] = ( miny + maxy ) * 0.5;
	            centers[ i + 2 ] = ( minz + maxz ) * 0.5;
	            primitives[ j ] = j;
	        }
	    },
	    computeDivisions: function ( options ) {
	        this._stackLength = options._maxNumLevels;
	        var max = this._bb._max;
	        var min = this._bb._min;
	        var dx = max[ 0 ] - min[ 0 ];
	        var dy = max[ 1 ] - min[ 1 ];
	        var dz = max[ 2 ] - min[ 2 ];
	        var axisOrder = this._axisOrder;
	
	        // We set the cutting order (longest edge aabb first)
	        axisOrder[ 0 ] = ( dx >= dy && dx >= dz ) ? 0 : ( dy >= dz ) ? 1 : 2;
	        axisOrder[ 2 ] = ( dx < dy && dx < dz ) ? 0 : ( dy < dz ) ? 1 : 2;
	        var sum = axisOrder[ 0 ] + axisOrder[ 2 ];
	        axisOrder[ 1 ] = sum === 3 ? 0 : sum === 2 ? 1 : 2;
	    },
	    // The core function of the kdtree building
	    // It checks if the node need to be subdivide or not
	    // If it decides it's a leaf, it computes the final bounding box of the node
	    // and it ends here
	    // If it's a node, then it puts the splitting axis position on the median population
	    // On the same time it reorder the triangle index array
	    divide: function ( options, bb, nodeIndex, level ) {
	        var kdTree = this._kdTree;
	        var primitives = this._primitiveIndices;
	        var nodes = kdTree.getNodes();
	        var node = nodes[ nodeIndex ];
	
	        var first = node._first;
	        var second = node._second;
	
	        var needToDivide = level < this._stackLength && first < 0 && second > options._targetNumTrianglesPerLeaf;
	        var istart = -first - 1;
	        var iend = istart + second - 1;
	
	        if ( !needToDivide ) {
	            if ( first < 0 ) {
	                // leaf is done, now compute bound on it.
	                this.computeNodeBox( node, istart, iend );
	            }
	            return nodeIndex;
	        }
	
	        if ( first >= 0 )
	            return nodeIndex;
	        // leaf node as first < 0, so look at dividing it.
	
	        var axis = this._axisOrder[ level % 3 ];
	        var originalMin = bb._min[ axis ];
	        var originalMax = bb._max[ axis ];
	
	        var mid = ( originalMin + originalMax ) * 0.5;
	
	        var originalLeftChildIndex = 0;
	        var originalRightChildIndex = 0;
	        var insitueDivision = false;
	
	        var left = istart;
	        var right = iend;
	
	        var centers = this._centers;
	        while ( left < right ) {
	            while ( left < right && ( centers[ primitives[ left ] * 3 + axis ] <= mid ) ) {
	                ++left;
	            }
	
	            while ( left < right && ( centers[ primitives[ right ] * 3 + axis ] > mid ) ) {
	                --right;
	            }
	
	            if ( left < right ) {
	                var tmp = primitives[ left ];
	                primitives[ left ] = primitives[ right ];
	                primitives[ right ] = tmp;
	                ++left;
	                --right;
	            }
	        }
	
	        if ( left === right ) {
	            if ( centers[ primitives[ left ] * 3 + axis ] <= mid ) ++left;
	            else --right;
	        }
	
	        if ( ( right - istart ) <= -1 ) {
	            originalLeftChildIndex = 0;
	            originalRightChildIndex = nodeIndex;
	            insitueDivision = true;
	        } else if ( ( iend - left ) <= -1 ) {
	            originalLeftChildIndex = nodeIndex;
	            originalRightChildIndex = 0;
	            insitueDivision = true;
	        } else {
	            originalLeftChildIndex = kdTree.addNode( new KdNode( -istart - 1, ( right - istart ) + 1 ) );
	            originalRightChildIndex = kdTree.addNode( new KdNode( -left - 1, ( iend - left ) + 1 ) );
	        }
	
	
	        var restore = bb._max[ axis ];
	        bb._max[ axis ] = mid;
	
	        var leftChildIndex = originalLeftChildIndex !== 0 ? this.divide( options, bb, originalLeftChildIndex, level + 1 ) : 0;
	
	        bb._max[ axis ] = restore;
	
	        restore = bb._min[ axis ];
	        bb._min[ axis ] = mid;
	
	        var rightChildIndex = originalRightChildIndex !== 0 ? this.divide( options, bb, originalRightChildIndex, level + 1 ) : 0;
	
	        bb._min[ axis ] = restore;
	
	        if ( !insitueDivision ) {
	            node._first = leftChildIndex;
	            node._second = rightChildIndex;
	
	            insitueDivision = true;
	
	            var bnode = node._bb;
	            bnode.init();
	            if ( leftChildIndex !== 0 ) bnode.expandByBoundingBox( nodes[ leftChildIndex ]._bb );
	            if ( rightChildIndex !== 0 ) bnode.expandByBoundingBox( nodes[ rightChildIndex ]._bb );
	        }
	        return nodeIndex;
	    },
	    // It computes the bounding box of the node so that the box contains all the triangles
	    // of the cell
	    computeNodeBox: function ( node, istart, iend ) {
	        var minx = Infinity,
	            miny = Infinity,
	            minz = Infinity,
	            maxx = -Infinity,
	            maxy = -Infinity,
	            maxz = -Infinity;
	        var triangles = this._kdTree.getTriangles();
	        var vertices = this._kdTree.getVertices();
	        var primitives = this._primitiveIndices;
	        for ( var i = istart; i <= iend; ++i ) {
	            var id = primitives[ i ] * 3;
	            var iv0 = triangles[ id ] * 3;
	            var iv1 = triangles[ id + 1 ] * 3;
	            var iv2 = triangles[ id + 2 ] * 3;
	
	            var v0x = vertices[ iv0 ];
	            var v0y = vertices[ iv0 + 1 ];
	            var v0z = vertices[ iv0 + 2 ];
	
	            var v1x = vertices[ iv1 ];
	            var v1y = vertices[ iv1 + 1 ];
	            var v1z = vertices[ iv1 + 2 ];
	
	            var v2x = vertices[ iv2 ];
	            var v2y = vertices[ iv2 + 1 ];
	            var v2z = vertices[ iv2 + 2 ];
	
	            minx = Math.min( minx, Math.min( v0x, Math.min( v1x, v2x ) ) );
	            miny = Math.min( miny, Math.min( v0y, Math.min( v1y, v2y ) ) );
	            minz = Math.min( minz, Math.min( v0z, Math.min( v1z, v2z ) ) );
	
	            maxx = Math.max( maxx, Math.max( v0x, Math.max( v1x, v2x ) ) );
	            maxy = Math.max( maxy, Math.max( v0y, Math.max( v1y, v2y ) ) );
	            maxz = Math.max( maxz, Math.max( v0z, Math.max( v1z, v2z ) ) );
	        }
	        var epsilon = 1E-6;
	        var bnode = node._bb;
	        var bmin = bnode._min;
	        var bmax = bnode._max;
	        bmin[ 0 ] = minx - epsilon;
	        bmin[ 1 ] = miny - epsilon;
	        bmin[ 2 ] = minz - epsilon;
	        bmax[ 0 ] = maxx + epsilon;
	        bmax[ 1 ] = maxy + epsilon;
	        bmax[ 2 ] = maxz + epsilon;
	    }
	};
	
	var KdTree = function () {
	    this._vertices = null;
	    this._kdNodes = [];
	    this._triangles = null; // Float32Array
	};
	
	KdTree.prototype = MACROUTILS.objectLibraryClass( {
	    getVertices: function () {
	        return this._vertices;
	    },
	    setVertices: function ( vertices ) {
	        this._vertices = vertices;
	    },
	    getNodes: function () {
	        return this._kdNodes;
	    },
	    getTriangles: function () {
	        return this._triangles;
	    },
	    setTriangles: function ( triangles ) {
	        this._triangles = triangles;
	    },
	    addNode: function ( node ) {
	        this._kdNodes.push( node );
	        return this._kdNodes.length - 1;
	    },
	    build: function ( options, geom ) {
	        var buildTree = new BuildKdTree( this );
	        return buildTree.build( options, geom );
	    },
	    intersectRay: function ( start, end, intersections, nodePath ) {
	        if ( this._kdNodes.length === 0 ) {
	            return false;
	        }
	
	        var numIntersectionsBefore = intersections.length;
	
	        if ( !this._rayIntersector ) {
	            this._rayIntersector = new KdTreeRayIntersector();
	            this._rayIntersector.setKdtree( this._vertices, this._kdNodes, this._triangles );
	        }
	        this._rayIntersector.init( intersections, start, end, nodePath );
	        this._rayIntersector.intersect( this.getNodes()[ 0 ], start, end );
	
	        return numIntersectionsBefore !== intersections.length;
	    },
	    intersectSphere: function ( center, radius, intersections, nodePath ) {
	        if ( this._kdNodes.length === 0 ) {
	            return false;
	        }
	
	        var numIntersectionsBefore = intersections.length;
	
	        if ( !this._sphereIntersector ) {
	            this._sphereIntersector = new KdTreeSphereIntersector();
	            this._sphereIntersector.setKdtree( this._vertices, this._kdNodes, this._triangles );
	        }
	        this._sphereIntersector.init( intersections, center, radius, nodePath );
	        this._sphereIntersector.intersect( this.getNodes()[ 0 ] );
	
	        return numIntersectionsBefore !== intersections.length;
	    }
	}, 'osg', 'KdTree' );
	
	module.exports = KdTree;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var PrimitiveSet = __webpack_require__( 41 );
	var Notify = __webpack_require__( 10 );
	
	// This class can be used to visit all the triangles of a geometry
	var TriangleIndexFunctor = function () {
	
	    if ( arguments && arguments.length ) {
	        Notify.warn( 'using ctor as initialiser is deprecated, use init(geom, cb)' );
	    }
	
	};
	
	TriangleIndexFunctor.prototype = {
	
	    // You feed it with a callback that will be called for each triangle
	    // (with the 3 indexes of vertices as arguments)
	    init: function ( geom, cb ) {
	        this._geom = geom;
	        this._cb = cb;
	    },
	    applyDrawElementsTriangles: function ( count, indexes ) {
	        var cb = this._cb;
	        for ( var i = 0; i < count; i += 3 ) {
	            cb( indexes[ i ], indexes[ i + 1 ], indexes[ i + 2 ] );
	        }
	    },
	
	    applyDrawElementsTriangleStrip: function ( count, indexes ) {
	        var cb = this._cb;
	        for ( var i = 2, j = 0; i < count; ++i, ++j ) {
	            if ( i % 2 ) cb( indexes[ j ], indexes[ j + 2 ], indexes[ j + 1 ] );
	            else cb( indexes[ j ], indexes[ j + 1 ], indexes[ j + 2 ] );
	        }
	    },
	
	    applyDrawElementsTriangleFan: function ( count, indexes ) {
	        var cb = this._cb;
	        var first = indexes[ 0 ];
	        for ( var i = 2, j = 1; i < count; ++i, ++j ) {
	            cb( first, indexes[ j ], indexes[ j + 1 ] );
	        }
	    },
	
	    applyDrawArraysTriangles: function ( first, count ) {
	        var cb = this._cb;
	        for ( var i = 2, pos = first; i < count; i += 3, pos += 3 ) {
	            cb( pos, pos + 1, pos + 2 );
	        }
	    },
	
	    applyDrawArraysTriangleStrip: function ( first, count ) {
	        var cb = this._cb;
	        for ( var i = 2, pos = first; i < count; ++i, ++pos ) {
	            if ( i % 2 ) cb( pos, pos + 2, pos + 1 );
	            else cb( pos, pos + 1, pos + 2 );
	        }
	    },
	
	    applyDrawArraysTriangleFan: function ( first, count ) {
	        var cb = this._cb;
	        for ( var i = 2, pos = first + 1; i < count; ++i, ++pos ) {
	            cb( first, pos, pos + 1 );
	        }
	    },
	
	    apply: function () {
	        var geom = this._geom;
	        var primitives = geom.primitives;
	        if ( !primitives )
	            return;
	        var nbPrimitives = primitives.length;
	        for ( var i = 0; i < nbPrimitives; i++ ) {
	            var primitive = primitives[ i ];
	            if ( primitive.getIndices !== undefined ) {
	                var indexes = primitive.indices.getElements();
	                switch ( primitive.getMode() ) {
	                case PrimitiveSet.TRIANGLES:
	                    this.applyDrawElementsTriangles( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.TRIANGLE_STRIP:
	                    this.applyDrawElementsTriangleStrip( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.TRIANGLE_FAN:
	                    this.applyDrawElementsTriangleFan( primitive.getCount(), indexes );
	                    break;
	                }
	            } else { // draw array
	                switch ( primitive.getMode() ) {
	                case PrimitiveSet.TRIANGLES:
	                    this.applyDrawArraysTriangles( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.TRIANGLE_STRIP:
	                    this.applyDrawArraysTriangleStrip( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.TRIANGLE_FAN:
	                    this.applyDrawArraysTriangleFan( primitive.getFirst(), primitive.getCount() );
	                    break;
	                }
	            }
	        }
	    }
	};
	
	module.exports = TriangleIndexFunctor;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var TriangleIntersector = __webpack_require__( 93 );
	var Notify = __webpack_require__( 10 );
	
	var KdTreeRayIntersector = function () {
	
	    if ( arguments && arguments.length ) {
	        Notify.warn( 'using ctor as initialiser is deprecated, use init(intersections, start, end, nodePath) and/or     setKdtree: function ( vertices, nodes, triangles )' );
	    }
	
	    this._intersector = new TriangleIntersector();
	    this._dInvX = Vec3.create();
	    this._dInvY = Vec3.create();
	    this._dInvZ = Vec3.create();
	
	};
	
	KdTreeRayIntersector.prototype = {
	    setKdtree: function ( vertices, nodes, triangles ) {
	        this._vertices = vertices;
	        this._kdNodes = nodes;
	        this._triangles = triangles;
	    },
	    init: ( function () {
	
	        var dir = Vec3.create();
	
	        return function ( intersections, start, end, nodePath ) {
	            var d = Vec3.sub( end, start, dir );
	            var len = Vec3.length( d );
	            var invLen = 0.0;
	            if ( len !== 0.0 )
	                invLen = 1.0 / len;
	            Vec3.mult( d, invLen, d );
	            if ( d[ 0 ] !== 0.0 ) Vec3.mult( d, 1.0 / d[ 0 ], this._dInvX );
	            if ( d[ 1 ] !== 0.0 ) Vec3.mult( d, 1.0 / d[ 1 ], this._dInvY );
	            if ( d[ 2 ] !== 0.0 ) Vec3.mult( d, 1.0 / d[ 2 ], this._dInvZ );
	
	            this._intersector._intersections = intersections;
	            this._intersector.setNodePath( nodePath );
	            this._intersector.set( start, end );
	        };
	    } )(),
	    // Classic ray intersection test
	    // If it's a leaf it does ray-triangles intersection with the triangles in the cell
	    // If it's not a leaf, it descend in the tree in a recursive way as long as the ray
	    // intersects the boundinbox of the nodes
	    intersect: ( function () {
	
	        var v0 = Vec3.create();
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	
	        return function ( node, ls, le ) {
	            var first = node._first;
	            var second = node._second;
	            var triangles = this._triangles;
	            var vertices = this._vertices;
	
	            if ( first < 0 ) {
	                // treat as a leaf
	                var istart = -first - 1;
	                var iend = istart + second;
	                var intersector = this._intersector;
	                intersector.index = istart;
	
	                for ( var i = istart; i < iend; ++i ) {
	                    var id = i * 3;
	                    var iv0 = triangles[ id ];
	                    var iv1 = triangles[ id + 1 ];
	                    var iv2 = triangles[ id + 2 ];
	
	                    var j = iv0 * 3;
	                    v0[ 0 ] = vertices[ j ];
	                    v0[ 1 ] = vertices[ j + 1 ];
	                    v0[ 2 ] = vertices[ j + 2 ];
	
	                    j = iv1 * 3;
	                    v1[ 0 ] = vertices[ j ];
	                    v1[ 1 ] = vertices[ j + 1 ];
	                    v1[ 2 ] = vertices[ j + 2 ];
	
	                    j = iv2 * 3;
	                    v2[ 0 ] = vertices[ j ];
	                    v2[ 1 ] = vertices[ j + 1 ];
	                    v2[ 2 ] = vertices[ j + 2 ];
	
	                    intersector.intersect( v0, v1, v2, iv0, iv1, iv2 );
	                }
	            } else {
	                var s = node._nodeRayStart;
	                var e = node._nodeRayEnd;
	                Vec3.copy( ls, s );
	                Vec3.copy( le, e );
	                if ( first > 0 ) {
	                    if ( this.intersectAndClip( s, e, this._kdNodes[ first ]._bb ) ) {
	                        this.intersect( this._kdNodes[ first ], s, e );
	                    }
	                }
	                if ( second > 0 ) {
	                    Vec3.copy( ls, s );
	                    Vec3.copy( le, e );
	                    if ( this.intersectAndClip( s, e, this._kdNodes[ second ]._bb ) ) {
	                        this.intersect( this._kdNodes[ second ], s, e );
	                    }
	                }
	            }
	        };
	    } )(),
	    // This method do 2 things
	    // It test if the ray intersects the node
	    // If so... it clip the ray so that the start and end point of the ray are
	    // snapped to the bounding box of the nodes
	    intersectAndClip: ( function () {
	
	        // needed because of precision picking
	        var tmp = new Float64Array( 3 );
	
	        return function ( s, e, bb ) {
	            var min = bb._min;
	            var xmin = min[ 0 ];
	            var ymin = min[ 1 ];
	            var zmin = min[ 2 ];
	
	            var max = bb._max;
	            var xmax = max[ 0 ];
	            var ymax = max[ 1 ];
	            var zmax = max[ 2 ];
	
	            var invX = this._dInvX;
	            var invY = this._dInvY;
	            var invZ = this._dInvZ;
	
	            if ( s[ 0 ] <= e[ 0 ] ) {
	                // trivial reject of segment wholely outside.
	                if ( e[ 0 ] < xmin ) return false;
	                if ( s[ 0 ] > xmax ) return false;
	
	                if ( s[ 0 ] < xmin ) {
	                    // clip s to xMin.
	                    Vec3.mult( invX, xmin - s[ 0 ], tmp );
	                    Vec3.add( s, tmp, s );
	                }
	
	                if ( e[ 0 ] > xmax ) {
	                    // clip e to xMax.
	                    Vec3.mult( invX, xmax - s[ 0 ], tmp );
	                    Vec3.add( s, tmp, e );
	                }
	            } else {
	                if ( s[ 0 ] < xmin ) return false;
	                if ( e[ 0 ] > xmax ) return false;
	
	                if ( e[ 0 ] < xmin ) {
	                    // clip s to xMin.
	                    Vec3.mult( invX, xmin - s[ 0 ], tmp );
	                    Vec3.add( s, tmp, e );
	                }
	
	                if ( s[ 0 ] > xmax ) {
	                    // clip e to xMax.
	                    Vec3.mult( invX, xmax - s[ 0 ], tmp );
	                    Vec3.add( s, tmp, s );
	                }
	            }
	
	            // compate s and e against the yMin to yMax range of bb.
	            if ( s[ 1 ] <= e[ 1 ] ) {
	
	                // trivial reject of segment wholely outside.
	                if ( e[ 1 ] < ymin ) return false;
	                if ( s[ 1 ] > ymax ) return false;
	
	                if ( s[ 1 ] < ymin ) {
	                    // clip s to yMin.
	                    Vec3.mult( invY, ymin - s[ 1 ], tmp );
	                    Vec3.add( s, tmp, s );
	                }
	
	                if ( e[ 1 ] > ymax ) {
	                    // clip e to yMax.
	                    Vec3.mult( invY, ymax - s[ 1 ], tmp );
	                    Vec3.add( s, tmp, e );
	                }
	            } else {
	                if ( s[ 1 ] < ymin ) return false;
	                if ( e[ 1 ] > ymax ) return false;
	
	                if ( e[ 1 ] < ymin ) {
	                    // clip s to yMin.
	                    Vec3.mult( invY, ymin - s[ 1 ], tmp );
	                    Vec3.add( s, tmp, e );
	                }
	
	                if ( s[ 1 ] > ymax ) {
	                    // clip e to yMax.
	                    Vec3.mult( invY, ymax - s[ 1 ], tmp );
	                    Vec3.add( s, tmp, s );
	                }
	            }
	
	            // compate s and e against the zMin to zMax range of bb.
	            if ( s[ 2 ] <= e[ 2 ] ) {
	                // trivial reject of segment wholely outside.
	                if ( e[ 2 ] < zmin ) return false;
	                if ( s[ 2 ] > zmax ) return false;
	
	                if ( s[ 2 ] < zmin ) {
	                    // clip s to zMin.
	                    Vec3.mult( invZ, zmin - s[ 2 ], tmp );
	                    Vec3.add( s, tmp, s );
	                }
	
	                if ( e[ 2 ] > zmax ) {
	                    // clip e to zMax.
	                    Vec3.mult( invZ, zmax - s[ 2 ], tmp );
	                    Vec3.add( s, tmp, e );
	                }
	            } else {
	                if ( s[ 2 ] < zmin ) return false;
	                if ( e[ 2 ] > zmax ) return false;
	
	                if ( e[ 2 ] < zmin ) {
	                    // clip s to zMin.
	                    Vec3.mult( invZ, zmin - s[ 2 ], tmp );
	                    Vec3.add( s, tmp, e );
	                }
	
	                if ( s[ 2 ] > zmax ) {
	                    // clip e to zMax.
	                    Vec3.mult( invZ, zmax - s[ 2 ], tmp );
	                    Vec3.add( s, tmp, s );
	                }
	            }
	            return true;
	        };
	    } )()
	};
	
	module.exports = KdTreeRayIntersector;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var TriangleIndexFunctor = __webpack_require__( 91 );
	var Notify = __webpack_require__( 10 );
	
	var TriangleIntersection = function ( normal, i1, i2, i3, r1, r2, r3 ) {
	    this.normal = normal;
	
	    this.i1 = i1;
	    this.i2 = i2;
	    this.i3 = i3;
	
	    this.r1 = r1;
	    this.r2 = r2;
	    this.r3 = r3;
	};
	
	var TriangleIntersector = function () {
	
	    if ( arguments && arguments.length ) {
	        Notify.warn( 'using ctor as initialiser is deprecated, use set(start, end)' );
	    }
	
	    this._intersections = [];
	    this._nodePath = [];
	    this._dir = Vec3.create();
	};
	
	TriangleIntersector.prototype = {
	    reset: function () {
	        this._intersections.length = 0;
	    },
	    setNodePath: function ( np ) {
	        this._nodePath = np;
	    },
	    set: function ( start, end ) {
	        this._start = start;
	        this._end = end;
	        this._dir = Vec3.sub( end, start, this._dir );
	        this._length = Vec3.length( this._dir );
	        this._invLength = 1.0 / this._length;
	        Vec3.mult( this._dir, this._invLength, this._dir );
	    },
	
	    apply: ( function () {
	
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        var v3 = Vec3.create();
	        var tif = new TriangleIndexFunctor();
	
	        return function ( node ) {
	
	            if ( !node.getAttributes().Vertex ) {
	                return;
	            }
	            var vertices = node.getAttributes().Vertex.getElements();
	            var self = this;
	
	            var cb = function ( i1, i2, i3 ) {
	
	                if ( i1 === i2 || i1 === i3 || i2 === i3 )
	                    return;
	
	                var j = i1 * 3;
	                v1[ 0 ] = vertices[ j ];
	                v1[ 1 ] = vertices[ j + 1 ];
	                v1[ 2 ] = vertices[ j + 2 ];
	
	                j = i2 * 3;
	                v2[ 0 ] = vertices[ j ];
	                v2[ 1 ] = vertices[ j + 1 ];
	                v2[ 2 ] = vertices[ j + 2 ];
	
	                j = i3 * 3;
	                v3[ 0 ] = vertices[ j ];
	                v3[ 1 ] = vertices[ j + 1 ];
	                v3[ 2 ] = vertices[ j + 2 ];
	
	                self.intersect( v1, v2, v3, i1, i2, i3 );
	            };
	            tif.init( node, cb );
	            tif.apply();
	
	        };
	    } )(),
	
	    intersect: ( function () {
	
	        var normal = Vec3.create();
	        var e2 = Vec3.create();
	        var e1 = Vec3.create();
	        var tvec = Vec3.create();
	        var pvec = Vec3.create();
	        var qvec = Vec3.create();
	        var epsilon = 1E-20;
	
	        return function ( v0, v1, v2, i0, i1, i2 ) {
	
	            var d = this._dir;
	
	            Vec3.sub( v2, v0, e2 );
	            Vec3.sub( v1, v0, e1 );
	            Vec3.cross( d, e2, pvec );
	
	            var det = Vec3.dot( pvec, e1 );
	            if ( det > -epsilon && det < epsilon )
	                return;
	            var invDet = 1.0 / det;
	
	            Vec3.sub( this._start, v0, tvec );
	
	            var u = Vec3.dot( pvec, tvec ) * invDet;
	            if ( u < 0.0 || u > 1.0 )
	                return;
	
	            Vec3.cross( tvec, e1, qvec );
	
	            var v = Vec3.dot( qvec, d ) * invDet;
	            if ( v < 0.0 || ( u + v ) > 1.0 )
	                return;
	
	            var t = Vec3.dot( qvec, e2 ) * invDet;
	
	            if ( t < epsilon || t > this._length ) //no intersection
	                return;
	
	            var r0 = 1.0 - u - v;
	            var r1 = u;
	            var r2 = v;
	            var r = t * this._invLength;
	
	            var interX = v0[ 0 ] * r0 + v1[ 0 ] * r1 + v2[ 0 ] * r2;
	            var interY = v0[ 1 ] * r0 + v1[ 1 ] * r1 + v2[ 1 ] * r2;
	            var interZ = v0[ 2 ] * r0 + v1[ 2 ] * r1 + v2[ 2 ] * r2;
	
	            Vec3.cross( e1, e2, normal );
	            Vec3.normalize( normal, normal );
	
	            // GC TriangleIntersection & Point
	            this._intersections.push( {
	                ratio: r,
	                backface: det < 0.0,
	                nodepath: this._nodePath.slice( 0 ), // Note: If you are computing intersections from a viewer the first node is the camera of the viewer
	                TriangleIntersection: new TriangleIntersection( Vec3.copy( normal, Vec3.create() ), i0, i1, i2, r0, r1, r2 ),
	                point: Vec3.createAndSet( interX, interY, interZ )
	            } );
	            this.hit = true;
	        };
	    } )()
	};
	
	module.exports = TriangleIntersector;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var KdTreeRayIntersector = __webpack_require__( 92 );
	var TriangleSphereIntersector = __webpack_require__( 95 );
	
	
	var KdTreeSphereIntersector = function () {
	
	    this._intersector = new TriangleSphereIntersector();
	
	};
	
	KdTreeSphereIntersector.prototype = MACROUTILS.objectInherit( KdTreeRayIntersector.prototype, {
	
	    init: function ( intersections, center, radius, nodePath ) {
	
	        this._intersector._intersections = intersections;
	        this._intersector.setNodePath( nodePath );
	        this._intersector.set( center, radius );
	        this._center = center;
	        this._radius = radius;
	
	    },
	
	    intersect: ( function () {
	
	        var v0 = Vec3.create();
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	
	        return function ( node ) {
	            var first = node._first;
	            var second = node._second;
	            var triangles = this._triangles;
	            var vertices = this._vertices;
	
	            if ( first < 0 ) {
	                // treat as a leaf
	                var istart = -first - 1;
	                var iend = istart + second;
	                var intersector = this._intersector;
	                intersector.index = istart;
	
	                for ( var i = istart; i < iend; ++i ) {
	                    var id = i * 3;
	                    var iv0 = triangles[ id ];
	                    var iv1 = triangles[ id + 1 ];
	                    var iv2 = triangles[ id + 2 ];
	
	                    var j = iv0 * 3;
	                    v0[ 0 ] = vertices[ j ];
	                    v0[ 1 ] = vertices[ j + 1 ];
	                    v0[ 2 ] = vertices[ j + 2 ];
	
	                    j = iv1 * 3;
	                    v1[ 0 ] = vertices[ j ];
	                    v1[ 1 ] = vertices[ j + 1 ];
	                    v1[ 2 ] = vertices[ j + 2 ];
	
	                    j = iv2 * 3;
	                    v2[ 0 ] = vertices[ j ];
	                    v2[ 1 ] = vertices[ j + 1 ];
	                    v2[ 2 ] = vertices[ j + 2 ];
	
	                    intersector.intersect( v0, v1, v2, iv0, iv1, iv2 );
	                }
	            } else {
	                if ( first > 0 ) {
	                    if ( this.intersectSphere( this._kdNodes[ first ]._bb ) ) {
	                        this.intersect( this._kdNodes[ first ] );
	                    }
	                }
	                if ( second > 0 ) {
	                    if ( this.intersectSphere( this._kdNodes[ second ]._bb ) ) {
	                        this.intersect( this._kdNodes[ second ] );
	                    }
	                }
	            }
	        };
	    } )(),
	    intersectSphere: ( function () {
	        var tmp = Vec3.create();
	        return function ( bb ) {
	            var r = this._radius + bb.radius();
	            return Vec3.distance2( this._center, bb.center( tmp ) ) <= r * r;
	        };
	    } )()
	} );
	
	module.exports = KdTreeSphereIntersector;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var TriangleIntersector = __webpack_require__( 93 );
	var Notify = __webpack_require__( 10 );
	
	var TriangleIntersection = function ( normal, i1, i2, i3 ) {
	    this.normal = normal;
	
	    this.i1 = i1;
	    this.i2 = i2;
	    this.i3 = i3;
	};
	
	var TriangleSphereIntersector = function () {
	    TriangleIntersector.apply( this, arguments );
	
	    if ( arguments && arguments.length ) {
	        Notify.warn( 'using ctor as initialiser is deprecated, use set(center, radius)' );
	    }
	};
	
	TriangleSphereIntersector.prototype = MACROUTILS.objectInherit( TriangleIntersector.prototype, {
	    set: function ( center, radius ) {
	        this._center = center;
	        this._radius = radius;
	    },
	
	    //
	    // \2|
	    //  \|
	    //   \
	    // 3 |\  1
	    //   |0\
	    // __|__\___
	    // 4 | 5 \ 6
	    //
	    // from http://www.geometrictools.com/Source/Distance3D.html#PointPlanar
	    // js : https://github.com/stephomi/sculptgl/blob/master/src/math3d/Geometry.js#L89
	    intersect: ( function () {
	        var edge1 = Vec3.create();
	        var edge2 = Vec3.create();
	        var diff = Vec3.create();
	        return function ( v1, v2, v3, i1, i2, i3 ) {
	
	            // sphere is a 'volume' here (so if the triangle is inside the ball it will intersects)
	
	            Vec3.sub( v2, v1, edge1 );
	            Vec3.sub( v3, v1, edge2 );
	            var a00 = Vec3.length2( edge1 );
	            var a01 = Vec3.dot( edge1, edge2 );
	            var a11 = Vec3.length2( edge2 );
	
	            Vec3.sub( v1, this._center, diff );
	            var b0 = Vec3.dot( diff, edge1 );
	            var b1 = Vec3.dot( diff, edge2 );
	            var c = Vec3.length2( diff );
	            var det = Math.abs( a00 * a11 - a01 * a01 );
	            if ( det < 1e-10 )
	                return;
	
	            var s = a01 * b1 - a11 * b0;
	            var t = a01 * b0 - a00 * b1;
	            var sqrDistance;
	            var zone = 4;
	
	            if ( s + t <= det ) {
	                if ( s < 0.0 ) {
	                    if ( t < 0.0 ) { // region 4
	                        zone = 4;
	                        if ( b0 < 0.0 ) {
	                            t = 0.0;
	                            if ( -b0 >= a00 ) {
	                                s = 1.0;
	                                sqrDistance = a00 + 2.0 * b0 + c;
	                            } else {
	                                s = -b0 / a00;
	                                sqrDistance = b0 * s + c;
	                            }
	                        } else {
	                            s = 0.0;
	                            if ( b1 >= 0.0 ) {
	                                t = 0.0;
	                                sqrDistance = c;
	                            } else if ( -b1 >= a11 ) {
	                                t = 1.0;
	                                sqrDistance = a11 + 2.0 * b1 + c;
	                            } else {
	                                t = -b1 / a11;
	                                sqrDistance = b1 * t + c;
	                            }
	                        }
	                    } else { // region 3
	                        zone = 3;
	                        s = 0.0;
	                        if ( b1 >= 0.0 ) {
	                            t = 0.0;
	                            sqrDistance = c;
	                        } else if ( -b1 >= a11 ) {
	                            t = 1.0;
	                            sqrDistance = a11 + 2.0 * b1 + c;
	                        } else {
	                            t = -b1 / a11;
	                            sqrDistance = b1 * t + c;
	                        }
	                    }
	                } else if ( t < 0.0 ) { // region 5
	                    zone = 5;
	                    t = 0.0;
	                    if ( b0 >= 0.0 ) {
	                        s = 0.0;
	                        sqrDistance = c;
	                    } else if ( -b0 >= a00 ) {
	                        s = 1.0;
	                        sqrDistance = a00 + 2.0 * b0 + c;
	                    } else {
	                        s = -b0 / a00;
	                        sqrDistance = b0 * s + c;
	                    }
	                } else { // region 0
	                    zone = 0;
	                    // minimum at interior point
	                    var invDet = 1.0 / det;
	                    s *= invDet;
	                    t *= invDet;
	                    sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;
	                }
	            } else {
	                var tmp0, tmp1, numer, denom;
	
	                if ( s < 0.0 ) { // region 2
	                    zone = 2;
	                    tmp0 = a01 + b0;
	                    tmp1 = a11 + b1;
	                    if ( tmp1 > tmp0 ) {
	                        numer = tmp1 - tmp0;
	                        denom = a00 - 2.0 * a01 + a11;
	                        if ( numer >= denom ) {
	                            s = 1.0;
	                            t = 0.0;
	                            sqrDistance = a00 + 2.0 * b0 + c;
	                        } else {
	                            s = numer / denom;
	                            t = 1.0 - s;
	                            sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;
	                        }
	                    } else {
	                        s = 0.0;
	                        if ( tmp1 <= 0.0 ) {
	                            t = 1.0;
	                            sqrDistance = a11 + 2.0 * b1 + c;
	                        } else if ( b1 >= 0.0 ) {
	                            t = 0.0;
	                            sqrDistance = c;
	                        } else {
	                            t = -b1 / a11;
	                            sqrDistance = b1 * t + c;
	                        }
	                    }
	                } else if ( t < 0.0 ) { // region 6
	                    zone = 6;
	                    tmp0 = a01 + b1;
	                    tmp1 = a00 + b0;
	                    if ( tmp1 > tmp0 ) {
	                        numer = tmp1 - tmp0;
	                        denom = a00 - 2.0 * a01 + a11;
	                        if ( numer >= denom ) {
	                            t = 1.0;
	                            s = 0.0;
	                            sqrDistance = a11 + 2.0 * b1 + c;
	                        } else {
	                            t = numer / denom;
	                            s = 1.0 - t;
	                            sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;
	                        }
	                    } else {
	                        t = 0.0;
	                        if ( tmp1 <= 0.0 ) {
	                            s = 1.0;
	                            sqrDistance = a00 + 2.0 * b0 + c;
	                        } else if ( b0 >= 0.0 ) {
	                            s = 0.0;
	                            sqrDistance = c;
	                        } else {
	                            s = -b0 / a00;
	                            sqrDistance = b0 * s + c;
	                        }
	                    }
	                } else { // region 1
	                    zone = 1;
	                    numer = a11 + b1 - a01 - b0;
	                    if ( numer <= 0.0 ) {
	                        s = 0.0;
	                        t = 1.0;
	                        sqrDistance = a11 + 2.0 * b1 + c;
	                    } else {
	                        denom = a00 - 2.0 * a01 + a11;
	                        if ( numer >= denom ) {
	                            s = 1.0;
	                            t = 0.0;
	                            sqrDistance = a00 + 2.0 * b0 + c;
	                        } else {
	                            s = numer / denom;
	                            t = 1.0 - s;
	                            sqrDistance = s * ( a00 * s + a01 * t + 2.0 * b0 ) + t * ( a01 * s + a11 * t + 2.0 * b1 ) + c;
	                        }
	                    }
	                }
	            }
	
	            // Account for numerical round-off error.
	            if ( sqrDistance < 0.0 )
	                sqrDistance = 0.0;
	
	            if ( sqrDistance > ( this._radius * this._radius ) )
	                return;
	
	            var closest = Vec3.create();
	            if ( closest ) {
	                closest[ 0 ] = v1[ 0 ] + s * edge1[ 0 ] + t * edge2[ 0 ];
	                closest[ 1 ] = v1[ 1 ] + s * edge1[ 1 ] + t * edge2[ 1 ];
	                closest[ 2 ] = v1[ 2 ] + s * edge1[ 2 ] + t * edge2[ 2 ];
	            }
	
	            var normal = Vec3.create();
	            Vec3.cross( edge1, edge2, normal );
	            Vec3.normalize( normal, normal );
	
	            // TODO: gc TriangleIntersection, closest, normal ? (stack pool)
	            this._intersections.push( {
	                ratio: Math.sqrt( sqrDistance ),
	                nodepath: this._nodePath.slice( 0 ),
	                TriangleIntersection: new TriangleIntersection( normal, i1, i2, i3 ),
	                point: closest,
	                zone: zone
	            } );
	            this.hit = true;
	        };
	    } )()
	} );
	
	module.exports = TriangleSphereIntersector;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var KdTree = __webpack_require__( 90 );
	
	
	var KdTreeBuilder = function ( options ) {
	    NodeVisitor.call( this );
	    this._buildOptions = options !== undefined ? options : {
	        _numVerticesProcessed: 0,
	        _targetNumTrianglesPerLeaf: 50,
	        _maxNumLevels: 20
	    };
	};
	
	KdTreeBuilder.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    apply: function ( node ) {
	        if ( node.getShape ) {
	            var shape = node.getShape();
	            // we test if the kdTree is already built and if we can build it (null means we skip it)
	            if ( shape === undefined ) {
	                var kdTree = new KdTree();
	                if ( kdTree.build( this._buildOptions, node ) ) {
	                    node.setShape( kdTree );
	                }
	            }
	        }
	        this.traverse( node );
	    }
	} );
	
	module.exports = KdTreeBuilder;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	var Uniform = __webpack_require__( 35 );
	var Matrix = __webpack_require__( 23 );
	var Vec3 = __webpack_require__( 15 );
	var Vec4 = __webpack_require__( 25 );
	var Map = __webpack_require__( 20 );
	var Notify = __webpack_require__( 10 );
	
	
	// use the same kind of opengl lights
	// see http://www.glprogramming.com/red/chapter05.html
	
	
	var Light = function ( lightNum, disable ) {
	    StateAttribute.call( this );
	
	    var lightNumber = lightNum !== undefined ? lightNum : 0;
	
	    this._ambient = Vec4.createAndSet( 0.2, 0.2, 0.2, 1.0 );
	    this._diffuse = Vec4.createAndSet( 0.8, 0.8, 0.8, 1.0 );
	    this._specular = Vec4.createAndSet( 0.2, 0.2, 0.2, 1.0 );
	
	    // Default is directional as postion[3] is 0
	    this._position = Vec4.createAndSet( 0.0, 0.0, 1.0, 0.0 );
	    this._direction = Vec3.createAndSet( 0.0, 0.0, -1.0 );
	
	    // TODO : refactor lights management w=1.0 (isHemi), w=-1.0
	    // (isNotHemi) _ground contains the color but w says if it's
	    // an hemi or not
	    this._ground = Vec4.createAndSet( 0.2, 0.2, 0.2, -1.0 );
	
	    this._spotCutoff = 180.0;
	    this._spotBlend = 0.01;
	
	    // the array contains constant, linear, quadratic factor
	    this._attenuation = Vec4.createAndSet( 1.0, 0.0, 0.0, 0.0 );
	
	    this._lightUnit = lightNumber;
	
	    this._invMatrix = Matrix.create();
	
	    this._enable = !disable;
	
	};
	
	Light.DIRECTION = 'DIRECTION';
	Light.SPOT = 'SPOT';
	Light.POINT = 'POINT';
	Light.HEMI = 'HEMI';
	
	Light.uniforms = {};
	Light.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Light',
	
	    cloneType: function () {
	        return new Light( this._lightUnit, true );
	    },
	
	    getTypeMember: function () {
	        return this.attributeType + this._lightUnit;
	    },
	
	    getUniformName: function ( name ) {
	        var prefix = this.getType() + this._lightUnit.toString();
	        return prefix + '_uniform_' + name;
	    },
	
	    getHash: function () {
	        return this.getTypeMember() + this.getLightType() + this.isEnabled().toString();
	    },
	
	    getOrCreateUniforms: function () {
	
	        var obj = Light;
	        var typeMember = this.getTypeMember();
	
	        if ( obj.uniforms[ typeMember ] ) return obj.uniforms[ typeMember ];
	
	        var uniformList = {
	            ambient: 'createFloat4',
	            diffuse: 'createFloat4',
	            specular: 'createFloat4',
	
	            attenuation: 'createFloat4',
	            position: 'createFloat4',
	            direction: 'createFloat3',
	
	            spotCutOff: 'createFloat1',
	            spotBlend: 'createFloat1',
	
	            ground: 'createFloat4',
	
	            matrix: 'createMatrix4',
	            invMatrix: 'createMatrix4'
	        };
	
	        var uniforms = {};
	
	        window.Object.keys( uniformList ).forEach( function ( key ) {
	
	            var type = uniformList[ key ];
	            var func = Uniform[ type ];
	            uniforms[ key ] = func( this.getUniformName( key ) );
	
	        }.bind( this ) );
	
	        obj.uniforms[ typeMember ] = new Map( uniforms );
	
	        return obj.uniforms[ typeMember ];
	    },
	
	    // enable / disable is not implemented in uniform
	    // we should add it
	    isEnabled: function () {
	        return this._enable;
	    },
	
	    setEnabled: function ( bool ) {
	        this._enable = bool;
	    },
	
	    // Deprecated methods, should be removed in the future
	    isEnable: function () {
	        Notify.log( 'Light.isEnable() is deprecated, use isEnabled instead' );
	        return this.isEnabled();
	    },
	
	    setEnable: function ( bool ) {
	        Notify.log( 'Light.setEnable() is deprecated, use setEnabled instead' );
	        this.setEnabled( bool );
	    },
	
	    // colors
	    setAmbient: function ( a ) {
	        Vec4.copy( a, this._ambient );
	    },
	
	    getAmbient: function () {
	        return this._ambient;
	    },
	
	    setDiffuse: function ( a ) {
	        Vec4.copy( a, this._diffuse );
	    },
	
	    getDiffuse: function () {
	        return this._diffuse;
	    },
	
	    setSpecular: function ( a ) {
	        Vec4.copy( a, this._specular );
	    },
	
	    getSpecular: function () {
	        return this._specular;
	    },
	
	
	    // position, also used for directional light
	    // position[3] === 0 means directional
	    // see creating lightsources http://www.glprogramming.com/red/chapter05.html
	    setPosition: function ( a ) {
	        Vec4.copy( a, this._position );
	    },
	
	    getPosition: function () {
	        return this._position;
	    },
	
	    // unused for directional
	    setDirection: function ( a ) {
	        Vec3.copy( a, this._direction );
	    },
	
	    getDirection: function () {
	        return this._direction;
	    },
	
	
	    setSpotCutoff: function ( a ) {
	        this._spotCutoff = a;
	    },
	
	    getSpotCutoff: function () {
	        return this._spotCutoff;
	    },
	
	    setSpotBlend: function ( a ) {
	        this._spotBlend = a;
	    },
	
	    getSpotBlend: function () {
	        return this._spotBlend;
	    },
	
	    // set/get the color of the ground
	    setGround: function ( a ) {
	        Vec3.copy( a, this._ground );
	    },
	
	    getGround: function () {
	        return this._ground;
	    },
	
	    // attenuation coeff
	    setConstantAttenuation: function ( value ) {
	        this._attenuation[ 0 ] = value;
	    },
	
	    getConstantAttenuation: function () {
	        return this._attenuation[ 0 ];
	    },
	
	    setLinearAttenuation: function ( value ) {
	        this._attenuation[ 1 ] = value;
	    },
	
	    getLinearAttenuation: function () {
	        return this._attenuation[ 1 ];
	    },
	
	    setQuadraticAttenuation: function ( value ) {
	        this._attenuation[ 2 ] = value;
	    },
	
	    getQuadraticAttenuation: function () {
	        return this._attenuation[ 2 ];
	    },
	
	    setLightType: function ( type ) {
	        if ( type === Light.DIRECTION )
	            return this.setLightAsDirection();
	        else if ( type === Light.SPOT )
	            return this.setLightAsSpot();
	        else if ( type === Light.HEMI )
	            return this.setLightAsHemi();
	        return this.setLightAsPoint();
	    },
	
	    getLightType: function () {
	        if ( this.isDirectionLight() )
	            return Light.DIRECTION;
	        else if ( this.isSpotLight() )
	            return Light.SPOT;
	        else if ( this.isHemiLight() )
	            return Light.HEMI;
	        return Light.POINT;
	    },
	
	    setLightAsSpot: function () {
	        Vec4.set( 0.0, 0.0, 0.0, 1.0, this._position );
	        Vec3.set( 0.0, 0.0, -1.0, this._direction );
	        this._ground[ 3 ] = -1.0;
	        this._spotCutoff = 90;
	    },
	
	    setLightAsPoint: function () {
	        Vec4.set( 0.0, 0.0, 0.0, 1.0, this._position );
	        Vec3.set( 0.0, 0.0, -1.0, this._direction );
	        this._ground[ 3 ] = -1.0;
	    },
	
	    setLightAsDirection: function () {
	        Vec4.set( 0.0, 0.0, 1.0, 0.0, this._position );
	        this._spotCutoff = 180;
	        this._ground[ 3 ] = -1.0;
	    },
	
	    setLightAsHemi: function () {
	        Vec4.set( 0.0, 0.0, 1.0, 0.0, this._position );
	        this._spotCutoff = 180;
	        this._ground[ 3 ] = 1.0;
	    },
	
	    setLightNumber: function ( unit ) {
	        this._lightUnit = unit;
	    },
	
	    getLightNumber: function () {
	        return this._lightUnit;
	    },
	
	    // internal helper
	    isSpotLight: function () {
	        return this._spotCutoff < 180.0;
	    },
	
	    isDirectionLight: function () {
	        return this._position[ 3 ] === 0.0 && this._ground[ 3 ] < 0.0;
	    },
	
	    isHemiLight: function () {
	        return this._ground[ 3 ] >= 0.0;
	    },
	
	    // matrix is current model view, which can mean:
	    // world (node refAbsolute)
	    // world+camera (camera is refAbsolute)
	    // world+camera+camera+... (camera relative...)
	    applyPositionedUniform: function ( matrix ) {
	
	        var uniformMap = this.getOrCreateUniforms();
	
	        var matrixArray = uniformMap.matrix.getInternalArray();
	        var invMatrixArray = uniformMap.invMatrix.getInternalArray();
	
	        Matrix.copy( matrix, matrixArray );
	        Matrix.copy( matrix, invMatrixArray );
	
	        invMatrixArray[ 12 ] = 0.0;
	        invMatrixArray[ 13 ] = 0.0;
	        invMatrixArray[ 14 ] = 0.0;
	
	        Matrix.inverse( invMatrixArray, invMatrixArray );
	        Matrix.transpose( invMatrixArray, invMatrixArray );
	    },
	
	    apply: function () {
	
	        if ( !this._enable ) return;
	
	        var uniformMap = this.getOrCreateUniforms();
	
	        uniformMap.position.setFloat4( this._position );
	
	        if ( this.isSpotLight() ) {
	            var spotsize = Math.cos( this._spotCutoff * Math.PI / 180.0 );
	            uniformMap.spotCutOff.setFloat( spotsize );
	            uniformMap.spotBlend.setFloat( ( 1.0 - spotsize ) * this._spotBlend );
	            uniformMap.direction.setFloat3( this._direction );
	        }
	
	        if ( this.isHemiLight() )
	            uniformMap.ground.setFloat4( this._ground );
	
	        uniformMap.attenuation.setFloat4( this._attenuation );
	        uniformMap.diffuse.setFloat4( this._diffuse );
	        uniformMap.specular.setFloat4( this._specular );
	        uniformMap.ambient.setFloat4( this._ambient );
	    }
	
	} ), 'osg', 'Light' );
	
	MACROUTILS.setTypeID( Light );
	
	module.exports = Light;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	
	var LineWidth = function ( lineWidth ) {
	    StateAttribute.call( this );
	    this.lineWidth = 1.0;
	    if ( lineWidth !== undefined ) {
	        this.lineWidth = lineWidth;
	    }
	};
	LineWidth.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	    attributeType: 'LineWidth',
	    cloneType: function () {
	        return new LineWidth();
	    },
	    apply: function ( state ) {
	        state.getGraphicContext().lineWidth( this.lineWidth );
	    }
	} ), 'osg', 'LineWidth' );
	
	module.exports = LineWidth;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var PrimitiveSet = __webpack_require__( 41 );
	
	/**
	 * PrimitiveFunctor emulates the TemplatePrimitiveFunctor class in OSG and can
	 * be used to get access to the vertices that compose the things drawn by osgjs.
	 * Feed it with a callback that will be called for geometry.
	 * The callback must be a closure and have the next structure:
	 *
	 * var myCallback = function(  ) {
	 *     return {
	 *          operatorPoint : function ( v ) { }, // Do your point operations here
	 *          operatorLine : function ( v1, v2 ){ }, // Do you line operations here
	 *          operatorTriangle : function ( v1, v2, v3 ) { } // Do your triangle operations here
	 *      }
	 * };
	 *
	 * Important Note: You should take into account that you are accesing the actual vertices of the primitive
	 * you might want to do a copy of these values in your callback to avoid to modify the primitive geometry
	 *  @class PrimitiveFunctor
	 */
	
	var PrimitiveFunctor = function ( geom, cb, vertices ) {
	    this._geom = geom;
	    this._cb = cb;
	    this._vertices = vertices;
	};
	
	PrimitiveFunctor.prototype = {
	    applyDrawElementsPoints: ( function () {
	        var v = Vec3.create();
	        return function ( count, indexes ) {
	            var cb = this._cb();
	            for ( var i = 0; i < count; ++i ) {
	                var j = indexes[ i ] * 3;
	                v[ 0 ] = this._vertices[ j ];
	                v[ 1 ] = this._vertices[ j + 1 ];
	                v[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorPoint( v );
	            }
	        };
	    } )(),
	    applyDrawElementsLines: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        return function ( count, indexes ) {
	            var cb = this._cb();
	            for ( var i = 0; i < count - 1; i += 2 ) {
	                var j = indexes[ i ] * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ i + 1 ] * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorLine( v1, v2 );
	            }
	        };
	    } )(),
	
	    applyDrawElementsLineStrip: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        return function ( count, indexes ) {
	            var cb = this._cb();
	            for ( var i = 0; i < count - 1; ++i ) {
	                var j = indexes[ i ] * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ i + 1 ] * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorLine( v1, v2 );
	            }
	        };
	    } )(),
	
	    applyDrawElementsLineLoop: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        return function ( count, indexes ) {
	            var cb = this._cb();
	            var last = count - 1;
	            for ( var i = 0; i < last; ++i ) {
	                var j = indexes[ i ] * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ i + 1 ] * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorLine( v1, v2 );
	            }
	            last = indexes[ last ] * 3;
	            v1[ 0 ] = this._vertices[ last ];
	            v1[ 1 ] = this._vertices[ last + 1 ];
	            v1[ 2 ] = this._vertices[ last + 2 ];
	            var first = indexes[ 0 ] * 3;
	            v2[ 0 ] = this._vertices[ first ];
	            v2[ 1 ] = this._vertices[ first + 1 ];
	            v2[ 2 ] = this._vertices[ first + 2 ];
	            cb.operatorLine( v1, v2 );
	        };
	    } )(),
	
	    applyDrawElementsTriangles: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        var v3 = Vec3.create();
	        return function ( count, indexes ) {
	            var cb = this._cb();
	            for ( var i = 0; i < count; i += 3 ) {
	                var j = indexes[ i ] * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ i + 1 ] * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ i + 2 ] * 3;
	                v3[ 0 ] = this._vertices[ j ];
	                v3[ 1 ] = this._vertices[ j + 1 ];
	                v3[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorTriangle( v1, v2, v3 );
	            }
	        };
	    } )(),
	
	    applyDrawElementsTriangleStrip: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        var v3 = Vec3.create();
	        return function ( count, indexes ) {
	            var cb = this._cb();
	            for ( var i = 2, pos = 0; i < count; ++i, ++pos ) {
	                var j = indexes[ pos ] * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ pos + 1 ] * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ pos + 2 ] * 3;
	                v3[ 0 ] = this._vertices[ j ];
	                v3[ 1 ] = this._vertices[ j + 1 ];
	                v3[ 2 ] = this._vertices[ j + 2 ];
	                if ( i % 2 ) {
	                    cb.operatorTriangle( v1, v3, v2 );
	                } else {
	                    cb.operatorTriangle( v1, v2, v3 );
	                }
	            }
	        };
	    } )(),
	
	    applyDrawElementsTriangleFan: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        var v3 = Vec3.create();
	        return function ( count, indexes ) {
	            var cb = this._cb();
	            var first = indexes[ 0 ];
	            for ( var i = 2, pos = 1; i < count; ++i, ++pos ) {
	                v1[ 0 ] = this._vertices[ first ];
	                v1[ 1 ] = this._vertices[ first + 1 ];
	                v1[ 2 ] = this._vertices[ first + 2 ];
	                var j = indexes[ pos ] * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                j = indexes[ pos + 1 ] * 3;
	                v3[ 0 ] = this._vertices[ j ];
	                v3[ 1 ] = this._vertices[ j + 1 ];
	                v3[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorTriangle( v1, v2, v3 );
	            }
	        };
	    } )(),
	
	    applyDrawArraysPoints: ( function () {
	        var v = Vec3.create();
	        return function ( first, count ) {
	            var cb = this._cb();
	            for ( var i = first; i < first + count; ++i ) {
	                var j = i * 3;
	                v[ 0 ] = this._vertices[ j ];
	                v[ 1 ] = this._vertices[ j + 1 ];
	                v[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorPoint( v );
	            }
	        };
	    } )(),
	
	    applyDrawArraysLines: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        return function ( first, count ) {
	            var cb = this._cb();
	            for ( var i = first; i < first + count - 1; i += 2 ) {
	                var j = i * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = ( i + 1 ) * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorLine( v1, v2 );
	            }
	        };
	    } )(),
	
	    applyDrawArraysLineStrip: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        return function ( first, count ) {
	            var cb = this._cb();
	            for ( var i = first; i < first + count - 1; ++i ) {
	                var j = i * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = ( i + 1 ) * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorLine( v1, v2 );
	            }
	        };
	    } )(),
	    applyDrawArraysLineLoop: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        return function ( first, count ) {
	            var cb = this._cb();
	            var last = first + count - 1;
	            for ( var i = first; i < last; ++i ) {
	                var j = i * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = ( i + 1 ) * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorLine( v1, v2 );
	            }
	            last = last * 3;
	            v1[ 0 ] = this._vertices[ last ];
	            v1[ 1 ] = this._vertices[ last + 1 ];
	            v1[ 2 ] = this._vertices[ last + 2 ];
	            first = first * 3;
	            v2[ 0 ] = this._vertices[ first ];
	            v2[ 1 ] = this._vertices[ first + 1 ];
	            v2[ 2 ] = this._vertices[ first + 2 ];
	            cb.operatorLine( v1, v2 );
	        };
	    } )(),
	
	    applyDrawArraysTriangles: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        var v3 = Vec3.create();
	        return function ( first, count ) {
	            var cb = this._cb();
	            for ( var i = first; i < first + count; i += 3 ) {
	                var j = i * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = ( i + 1 ) * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                j = ( i + 2 ) * 3;
	                v3[ 0 ] = this._vertices[ j ];
	                v3[ 1 ] = this._vertices[ j + 1 ];
	                v3[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorTriangle( v1, v2, v3 );
	            }
	        };
	    } )(),
	
	    applyDrawArraysTriangleStrip: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        var v3 = Vec3.create();
	        return function ( first, count ) {
	            var cb = this._cb();
	            for ( var i = 2, pos = first; i < count; ++i, ++pos ) {
	                var j = pos * 3;
	                v1[ 0 ] = this._vertices[ j ];
	                v1[ 1 ] = this._vertices[ j + 1 ];
	                v1[ 2 ] = this._vertices[ j + 2 ];
	                j = ( pos + 1 ) * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                j = ( pos + 2 ) * 3;
	                v3[ 0 ] = this._vertices[ j ];
	                v3[ 1 ] = this._vertices[ j + 1 ];
	                v3[ 2 ] = this._vertices[ j + 2 ];
	                if ( i % 2 ) {
	                    cb.operatorTriangle( v1, v3, v2 );
	                } else {
	                    cb.operatorTriangle( v1, v2, v3 );
	                }
	            }
	        };
	    } )(),
	
	    applyDrawArraysTriangleFan: ( function () {
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	        var v3 = Vec3.create();
	        return function ( first, count ) {
	            var cb = this._cb();
	            for ( var i = 2, pos = first + 1; i < count; ++i, ++pos ) {
	                v1[ 0 ] = this._vertices[ first ];
	                v1[ 1 ] = this._vertices[ first + 1 ];
	                v1[ 2 ] = this._vertices[ first + 2 ];
	                var j = pos * 3;
	                v2[ 0 ] = this._vertices[ j ];
	                v2[ 1 ] = this._vertices[ j + 1 ];
	                v2[ 2 ] = this._vertices[ j + 2 ];
	                j = ( pos + 1 ) * 3;
	                v3[ 0 ] = this._vertices[ j ];
	                v3[ 1 ] = this._vertices[ j + 1 ];
	                v3[ 2 ] = this._vertices[ j + 2 ];
	                cb.operatorTriangle( v1, v2, v3 );
	            }
	        };
	    } )(),
	
	    apply: function () {
	        var geom = this._geom;
	        var primitives = geom.primitives;
	        if ( !primitives )
	            return;
	        var nbPrimitives = primitives.length;
	        for ( var i = 0; i < nbPrimitives; i++ ) {
	            var primitive = primitives[ i ];
	            if ( primitive.getIndices !== undefined ) {
	                var indexes = primitive.indices.getElements();
	                switch ( primitive.getMode() ) {
	                case PrimitiveSet.POINTS:
	                    this.applyDrawElementsPoints( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.LINES:
	                    this.applyDrawElementsLines( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.LINE_STRIP:
	                    this.applyDrawElementsLineStrip( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.LINE_LOOP:
	                    this.applyDrawElementsLineLoop( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.TRIANGLES:
	                    this.applyDrawElementsTriangles( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.TRIANGLE_STRIP:
	                    this.applyDrawElementsTriangleStrip( primitive.getCount(), indexes );
	                    break;
	                case PrimitiveSet.TRIANGLE_FAN:
	                    this.applyDrawElementsTriangleFan( primitive.getCount(), indexes );
	                    break;
	                }
	            } else { // draw array
	                switch ( primitive.getMode() ) {
	                case PrimitiveSet.POINTS:
	                    this.applyDrawArraysPoints( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.LINES:
	                    this.applyDrawArraysLines( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.LINE_STRIP:
	                    this.applyDrawArraysLineStrip( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.LINE_LOOP:
	                    this.applyDrawArraysLineLoop( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.TRIANGLES:
	                    this.applyDrawArraysTriangles( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.TRIANGLE_STRIP:
	                    this.applyDrawArraysTriangleStrip( primitive.getFirst(), primitive.getCount() );
	                    break;
	                case PrimitiveSet.TRIANGLE_FAN:
	                    this.applyDrawArraysTriangleFan( primitive.getFirst(), primitive.getCount() );
	                    break;
	                }
	            }
	        }
	    }
	};
	
	module.exports = PrimitiveFunctor;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Notify = __webpack_require__( 10 );
	var GLObject = __webpack_require__( 37 );
	var StateAttribute = __webpack_require__( 21 );
	var CustomMap = __webpack_require__( 20 );
	var Timer = __webpack_require__( 9 );
	
	/**
	 * Program encapsulate an vertex and fragment shader
	 * @class Program
	 */
	var Program = function ( vShader, fShader ) {
	    GLObject.call( this );
	    StateAttribute.call( this );
	    this._program = null;
	
	    // used to know if it's a default program
	    // a default program does nothing but avoid to do some
	    // useless logic
	    // if we vertex or fragment shader are set it's not a default
	    // program anymore
	    this._nullProgram = true;
	
	    this._vertex = undefined;
	    this._fragment = undefined;
	
	    this._uniformsCache = undefined;
	    this._attributesCache = undefined;
	    this._activeUniforms = undefined;
	    this._foreignUniforms = undefined;
	    this._trackAttributes = undefined;
	
	    if ( vShader )
	        this.setVertexShader( vShader );
	
	    if ( fShader )
	        this.setFragmentShader( fShader );
	
	    this._dirty = true;
	};
	
	// static cache of glPrograms flagged for deletion, which will actually
	// be deleted in the correct GL context.
	Program._sDeletedGLProgramCache = new window.Map();
	
	// static method to delete Program
	Program.deleteGLProgram = function ( gl, program ) {
	
	    if ( !Program._sDeletedGLProgramCache.has( gl ) )
	        Program._sDeletedGLProgramCache.set( gl, [] );
	
	    Program._sDeletedGLProgramCache.get( gl ).push( program );
	};
	
	// static method to flush all the cached glPrograms which need to be deleted in the GL context specified
	Program.flushDeletedGLPrograms = function ( gl, availableTime ) {
	
	    // if no time available don't try to flush objects.
	    if ( availableTime <= 0.0 ) return availableTime;
	
	    if ( !Program._sDeletedGLProgramCache.has( gl ) ) return availableTime;
	
	    var elapsedTime = 0.0;
	    var beginTime = Timer.instance().tick();
	    var deleteList = Program._sDeletedGLProgramCache.get( gl );
	    var numPrograms = deleteList.length;
	
	    for ( var i = numPrograms - 1; i >= 0 && elapsedTime < availableTime; i-- ) {
	        gl.deleteProgram( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	    }
	
	    return availableTime - elapsedTime;
	};
	
	Program.flushAllDeletedGLPrograms = function ( gl ) {
	
	    if ( !Program._sDeletedGLProgramCache.has( gl ) ) return;
	
	    var deleteList = Program._sDeletedGLProgramCache.get( gl );
	    var numPrograms = deleteList.length;
	
	    for ( var i = numPrograms - 1; i >= 0; i-- ) {
	        gl.deleteProgram( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	    }
	};
	
	/** @lends Program.prototype */
	Program.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( GLObject.prototype, MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Program',
	
	    cloneType: function () {
	        return new Program();
	    },
	
	    setVertexShader: function ( vs ) {
	        this._vertex = vs;
	        this._nullProgram = false;
	    },
	
	    setFragmentShader: function ( fs ) {
	        this._fragment = fs;
	        this._nullProgram = false;
	    },
	
	    getVertexShader: function () {
	        return this._vertex;
	    },
	    getFragmentShader: function () {
	        return this._fragment;
	    },
	
	    getProgram: function () {
	        return this._program;
	    },
	
	    setActiveUniforms: function ( activeUniforms ) {
	        this._activeUniforms = activeUniforms;
	    },
	
	    getActiveUniforms: function () {
	        return this._activeUniforms;
	    },
	
	    setForeignUniforms: function ( foreignUniforms ) {
	        this._foreignUniforms = foreignUniforms;
	    },
	
	    getForeignUniforms: function () {
	        return this._foreignUniforms;
	    },
	
	    setUniformsCache: function ( uniformsCache ) {
	        this._uniformsCache = uniformsCache;
	    },
	
	    getUniformsCache: function () {
	        return this._uniformsCache;
	    },
	
	    setAttributesCache: function ( attributesCache ) {
	        this._attributesCache = attributesCache;
	    },
	
	    getAttributesCache: function () {
	        return this._attributesCache;
	    },
	
	    setTrackAttributes: function ( trackAttributes ) {
	        this._trackAttributes = trackAttributes;
	    },
	
	    getTrackAttributes: function () {
	        return this._trackAttributes;
	    },
	
	    releaseGLObjects: function () {
	        // Call to releaseGLOBjects on shaders
	        if ( this._vertex !== undefined ) this._vertex.releaseGLObjects();
	        if ( this._fragment !== undefined ) this._fragment.releaseGLObjects();
	        if ( this._program === null ) return;
	        if ( this._gl !== undefined ) {
	            Program.deleteGLProgram( this._gl, this._program );
	        }
	        this._program = undefined;
	    },
	
	    apply: function ( state ) {
	
	        if ( this._nullProgram ) return;
	
	        if ( !this._gl ) {
	            this.setGraphicContext( state.getGraphicContext() );
	        }
	        var gl = this._gl;
	        if ( !this._program || this._dirty ) {
	
	            var compileClean;
	
	            if ( !this._vertex.shader ) {
	                compileClean = this._vertex.compile( gl );
	            }
	
	            if ( !this._fragment.shader ) {
	                compileClean = this._fragment.compile( gl );
	            }
	
	            if ( compileClean ) {
	
	                this._program = gl.createProgram();
	
	                gl.attachShader( this._program, this._vertex.shader );
	                gl.attachShader( this._program, this._fragment.shader );
	                MACROUTILS.timeStamp( 'osgjs.metrics:linkShader' );
	                gl.linkProgram( this._program );
	
	                if ( !gl.getProgramParameter( this._program, gl.LINK_STATUS ) && !gl.isContextLost() ) {
	                    var errLink = gl.getProgramInfoLog( this._program );
	
	                    Notify.error( errLink );
	                    Notify.log( 'can\'t link program\n' + 'vertex shader:\n' + this._vertex.text + '\n fragment shader:\n' + this._fragment.text, true, false );
	                    // rawgl trick is for webgl inspector
	                    var debugShader = ( gl.rawgl !== undefined ? gl.rawgl : gl );
	                    if ( debugShader !== undefined && debugShader.getExtension !== undefined ) debugShader = debugShader.getExtension( 'WEBGL_debug_shaders' );
	                    if ( debugShader && errLink === 'Failed to create D3D shaders.\n' ) {
	
	                        Notify.error( debugShader.getTranslatedShaderSource( this._vertex.shader ), true, false );
	                        Notify.error( debugShader.getTranslatedShaderSource( this._fragment.shader ), true, false );
	                    }
	
	                    compileClean = false;
	                }
	                // TODO: better usage of validate.
	                // as it's intended at shader program usage
	                // validating against current gl state
	                // Not for compilation stage
	                // gl.validateProgram( this._program );
	
	            }
	
	            if ( !compileClean ) {
	                // Any error, Any
	                // Pink must die.
	                if ( !Program.prototype._failSafeCache ) {
	
	                    var program = gl.createProgram();
	                    this._vertex.failSafe( gl );
	                    this._fragment.failSafe( gl );
	
	                    gl.attachShader( program, this._vertex.shader );
	                    gl.attachShader( program, this._fragment.shader );
	                    gl.linkProgram( program );
	                    gl.validateProgram( program );
	
	                    // cache to compile and allocate only once
	                    // not polluting the inspector
	                    Program.prototype._failSafeCache = program;
	                }
	                Notify.warn( 'FailSafe shader Activated ' );
	                this._program = this._failSafeCache;
	            }
	
	            this._uniformsCache = new CustomMap();
	            this._attributesCache = new CustomMap();
	
	            this.cacheUniformList( gl, this._vertex.text );
	            this.cacheUniformList( gl, this._fragment.text );
	
	            this.cacheAttributeList( gl, this._vertex.text );
	
	            this._dirty = false;
	        }
	
	        state.applyProgram( this._program );
	    },
	
	    cacheUniformList: function ( gl, str ) {
	
	        var r = str.match( /uniform\s+\w+\s+\w+((\s)?\[(.*?)\])?/g );
	        var map = this._uniformsCache;
	        if ( r !== null ) {
	            for ( var i = 0, l = r.length; i < l; i++ ) {
	                var uniform = r[ i ].match( /uniform\s+\w+\s+(\w+)/ )[ 1 ];
	                var uniformName = r[ i ].match( /uniform\s+\w+\s+(\w+)(\s?\[.*?\])?/ )[ 1 ];
	                var location = gl.getUniformLocation( this._program, uniform );
	                if ( location !== undefined && location !== null ) {
	                    if ( map[ uniformName ] === undefined ) {
	                        map[ uniformName ] = location;
	                        this._uniformsCache.dirty();
	                    }
	                }
	            }
	        }
	
	    },
	
	    cacheAttributeList: function ( gl, str ) {
	        var r = str.match( /attribute\s+\w+\s+\w+/g );
	        var map = this._attributesCache;
	        if ( r !== null ) {
	            for ( var i = 0, l = r.length; i < l; i++ ) {
	                var attr = r[ i ].match( /attribute\s+\w+\s+(\w+)/ )[ 1 ];
	                var location = gl.getAttribLocation( this._program, attr );
	                if ( location !== -1 && location !== undefined ) {
	                    if ( map[ attr ] === undefined ) {
	                        map[ attr ] = location;
	                        this._attributesCache.dirty();
	                    }
	                }
	            }
	        }
	    }
	} ) ), 'osg', 'Program' );
	
	module.exports = Program;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Timer = __webpack_require__( 9 );
	var GLObject = __webpack_require__( 37 );
	
	
	/**
	 * Shader manage shader for vertex and fragment, you need both to create a glsl program.
	 * @class Shader
	 */
	var Shader = function ( type, text ) {
	    GLObject.call( this );
	    var t = type;
	    if ( typeof ( type ) === 'string' ) {
	        t = Shader[ type ];
	    }
	    this.type = t;
	    this.setText( text );
	};
	
	Shader.VERTEX_SHADER = 0x8B31;
	Shader.FRAGMENT_SHADER = 0x8B30;
	
	// Debug Pink shader for when shader fails
	Shader.VS_DBG = 'attribute vec3 Vertex;uniform mat4 ModelViewMatrix;uniform mat4 ProjectionMatrix;void main(void) {  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);}';
	Shader.FS_DBG = 'precision lowp float; void main(void) { gl_FragColor = vec4(1.0, 0.6, 0.6, 1.0);}';
	
	var debugName = '\n#define SHADER_NAME FailSafe\n';
	Shader.VS_DBG += debugName;
	Shader.FS_DBG += debugName;
	
	
	// static cache of glShaders flagged for deletion, which will actually
	// be deleted in the correct GL context.
	Shader._sDeletedGLShaderCache = new window.Map();
	
	// static method to delete Program 
	Shader.deleteGLShader = function ( gl, shader ) {
	    if ( !Shader._sDeletedGLShaderCache.has( gl ) )
	        Shader._sDeletedGLShaderCache.set( gl, [] );
	    Shader._sDeletedGLShaderCache.get( gl ).push( shader );
	};
	
	// static method to flush all the cached glShaders which need to be deleted in the GL context specified
	Shader.flushDeletedGLShaders = function ( gl, availableTime ) {
	    // if no time available don't try to flush objects.
	    if ( availableTime <= 0.0 ) return availableTime;
	    if ( !Shader._sDeletedGLShaderCache.has( gl ) ) return availableTime;
	    var elapsedTime = 0.0;
	    var beginTime = Timer.instance().tick();
	    var deleteList = Shader._sDeletedGLShaderCache.get( gl );
	    var numShaders = deleteList.length;
	    for ( var i = numShaders - 1; i >= 0 && elapsedTime < availableTime; i-- ) {
	        gl.deleteShader( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	        elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	    }
	    return availableTime -= elapsedTime;
	};
	
	Shader.flushAllDeletedGLShaders = function ( gl ) {
	    if ( !Shader._sDeletedGLShaderCache.has( gl ) ) return;
	    var deleteList = Shader._sDeletedGLShaderCache.get( gl );
	    var numShaders = deleteList.length;
	    for ( var i = numShaders - 1; i >= 0; i-- ) {
	        gl.deleteShader( deleteList[ i ] );
	        deleteList.splice( i, 1 );
	    }
	    return;
	};
	
	/** @lends Shader.prototype */
	Shader.prototype = MACROUTILS.objectInherit( GLObject.prototype, {
	    setText: function ( text ) {
	        this.text = text;
	    },
	    getText: function () {
	        return this.text;
	    },
	    // this is where it creates a fail safe shader that should work everywhere
	    failSafe: function ( gl ) {
	        this.shader = gl.createShader( this.type );
	        gl.shaderSource( this.shader, this.type === Shader.VERTEX_SHADER ? Shader.VS_DBG : Shader.FS_DBG );
	        gl.compileShader( this.shader );
	    },
	    // webgl shader compiler error to source contextualization
	    // for better console log messages
	    processErrors: function ( errors, source ) {
	        // regex to extract error message and line from webgl compiler reporting
	        var r = /ERROR: [\d]+:([\d]+): (.+)/gmi;
	        // split sources in indexable per line array
	        var lines = source.split( '\n' );
	        var linesLength = lines.length;
	        if ( linesLength === 0 ) return;
	
	        var i, m;
	
	        // IE reporting is not the same
	        if ( r.exec( errors ) === null ) {
	            r = /Shader compilation errors\n\((\d+)\, \d+\): (.+)/gmi;
	        }
	
	        // reset index to start.
	        r.lastIndex = 0;
	
	        while ( ( m = r.exec( errors ) ) != null ) {
	            if ( m.index === r.lastIndex ) {
	                r.lastIndex++; // moving between errors
	            }
	            // get error line
	            var line = parseInt( m[ 1 ] );
	
	            if ( line > linesLength ) continue;
	            // webgl error report.
	            Notify.error( 'ERROR ' + m[ 2 ] + ' in line ' + line, false, true );
	
	            var minLine = Math.max( 0, line - 7 );
	            var maxLine = Math.max( 0, line - 2 );
	            // for context
	            // log surrounding line priori to error with bof check
	            for ( i = minLine; i <= maxLine; i++ ) {
	                Notify.warn( lines[ i ].replace( /^[ \t]+/g, '' ), false, true );
	            }
	
	            // Warn adds a lovely /!\ icon in front of the culprit line
	            maxLine = Math.max( 0, line - 1 );
	            Notify.error( lines[ maxLine ].replace( /^[ \t]+/g, '' ), false, true );
	
	            minLine = Math.min( linesLength, line );
	            maxLine = Math.min( linesLength, line + 5 );
	            // for context
	            // surrounding line posterior to error (with eof check)
	            for ( i = minLine; i < maxLine; i++ ) {
	                Notify.warn( lines[ i ].replace( /^[ \t]+/g, '' ), false, true );
	            }
	        }
	    },
	
	    compile: function ( gl ) {
	        if ( !this._gl ) this.setGraphicContext( gl );
	        this.shader = gl.createShader( this.type );
	        gl.shaderSource( this.shader, this.text );
	        MACROUTILS.timeStamp( 'osgjs.metrics:compileShader' );
	        gl.compileShader( this.shader );
	        if ( !gl.getShaderParameter( this.shader, gl.COMPILE_STATUS ) && !gl.isContextLost() ) {
	
	            var err = gl.getShaderInfoLog( this.shader );
	            this.processErrors( err, this.text );
	
	
	            var tmpText = '\n' + this.text;
	            var splittedText = tmpText.split( '\n' );
	            var newText = '\n';
	            for ( var i = 0, l = splittedText.length; i < l; ++i ) {
	                newText += i + ' ' + splittedText[ i ] + '\n';
	            }
	            // still logging whole source but folded
	            Notify.debug( 'can\'t compile shader:\n' + newText, true );
	
	            return false;
	        }
	        return true;
	    },
	    releaseGLObjects: function () {
	        if ( this._gl !== undefined ) {
	            Shader.deleteGLShader( this._gl, this.shader );
	        }
	        this.shader = undefined;
	    }
	} );
	
	Shader.create = function ( type, text ) {
	    Notify.log( 'Shader.create is deprecated, use new Shader with the same arguments instead' );
	    return new Shader( type, text );
	};
	
	module.exports = Shader;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Vec3 = __webpack_require__( 15 );
	var BufferArray = __webpack_require__( 40 );
	var Geometry = __webpack_require__( 31 );
	var PrimitiveSet = __webpack_require__( 41 );
	var DrawArrays = __webpack_require__( 42 );
	var DrawElements = __webpack_require__( 43 );
	var Program = __webpack_require__( 100 );
	var Shader = __webpack_require__( 101 );
	var MACROUTILS = __webpack_require__( 6 );
	
	
	/**
	 * Create a Textured Box on the given center with given size
	 * @name createTexturedBox
	 */
	var createTexturedBoxGeometry = function ( cx, cy, cz,
	    sx, sy, sz ) {
	
	    var centerx = cx !== undefined ? cx : 0.0;
	    var centery = cy !== undefined ? cy : 0.0;
	    var centerz = cz !== undefined ? cz : 0.0;
	
	    var sizex = sx !== undefined ? sx : 1.0;
	    var sizey = sy !== undefined ? sy : 1.0;
	    var sizez = sz !== undefined ? sz : 1.0;
	
	    var g = new Geometry();
	    var dx, dy, dz;
	    dx = sizex / 2.0;
	    dy = sizey / 2.0;
	    dz = sizez / 2.0;
	
	    var vertexes = new MACROUTILS.Float32Array( 72 );
	    var uv = new MACROUTILS.Float32Array( 48 );
	    var normal = new MACROUTILS.Float32Array( 72 );
	
	    // -ve y plane
	    vertexes[ 0 ] = centerx - dx;
	    vertexes[ 1 ] = centery - dy;
	    vertexes[ 2 ] = centerz + dz;
	    normal[ 0 ] = 0.0;
	    normal[ 1 ] = -1.0;
	    normal[ 2 ] = 0.0;
	    uv[ 0 ] = 0.0;
	    uv[ 1 ] = 1.0;
	
	    vertexes[ 3 ] = centerx - dx;
	    vertexes[ 4 ] = centery - dy;
	    vertexes[ 5 ] = centerz - dz;
	    normal[ 3 ] = 0.0;
	    normal[ 4 ] = -1.0;
	    normal[ 5 ] = 0.0;
	    uv[ 2 ] = 0.0;
	    uv[ 3 ] = 0.0;
	
	    vertexes[ 6 ] = centerx + dx;
	    vertexes[ 7 ] = centery - dy;
	    vertexes[ 8 ] = centerz - dz;
	    normal[ 6 ] = 0.0;
	    normal[ 7 ] = -1.0;
	    normal[ 8 ] = 0.0;
	    uv[ 4 ] = 1.0;
	    uv[ 5 ] = 0.0;
	
	    vertexes[ 9 ] = centerx + dx;
	    vertexes[ 10 ] = centery - dy;
	    vertexes[ 11 ] = centerz + dz;
	    normal[ 9 ] = 0.0;
	    normal[ 10 ] = -1.0;
	    normal[ 11 ] = 0.0;
	    uv[ 6 ] = 1.0;
	    uv[ 7 ] = 1.0;
	
	
	    // +ve y plane
	    vertexes[ 12 ] = centerx + dx;
	    vertexes[ 13 ] = centery + dy;
	    vertexes[ 14 ] = centerz + dz;
	    normal[ 12 ] = 0.0;
	    normal[ 13 ] = 1.0;
	    normal[ 14 ] = 0.0;
	    uv[ 8 ] = 0.0;
	    uv[ 9 ] = 1.0;
	
	    vertexes[ 15 ] = centerx + dx;
	    vertexes[ 16 ] = centery + dy;
	    vertexes[ 17 ] = centerz - dz;
	    normal[ 15 ] = 0.0;
	    normal[ 16 ] = 1.0;
	    normal[ 17 ] = 0.0;
	    uv[ 10 ] = 0.0;
	    uv[ 11 ] = 0.0;
	
	    vertexes[ 18 ] = centerx - dx;
	    vertexes[ 19 ] = centery + dy;
	    vertexes[ 20 ] = centerz - dz;
	    normal[ 18 ] = 0.0;
	    normal[ 19 ] = 1.0;
	    normal[ 20 ] = 0.0;
	    uv[ 12 ] = 1.0;
	    uv[ 13 ] = 0.0;
	
	    vertexes[ 21 ] = centerx - dx;
	    vertexes[ 22 ] = centery + dy;
	    vertexes[ 23 ] = centerz + dz;
	    normal[ 21 ] = 0.0;
	    normal[ 22 ] = 1.0;
	    normal[ 23 ] = 0.0;
	    uv[ 14 ] = 1.0;
	    uv[ 15 ] = 1.0;
	
	
	    // +ve x plane
	    vertexes[ 24 ] = centerx + dx;
	    vertexes[ 25 ] = centery - dy;
	    vertexes[ 26 ] = centerz + dz;
	    normal[ 24 ] = 1.0;
	    normal[ 25 ] = 0.0;
	    normal[ 26 ] = 0.0;
	    uv[ 16 ] = 0.0;
	    uv[ 17 ] = 1.0;
	
	    vertexes[ 27 ] = centerx + dx;
	    vertexes[ 28 ] = centery - dy;
	    vertexes[ 29 ] = centerz - dz;
	    normal[ 27 ] = 1.0;
	    normal[ 28 ] = 0.0;
	    normal[ 29 ] = 0.0;
	    uv[ 18 ] = 0.0;
	    uv[ 19 ] = 0.0;
	
	    vertexes[ 30 ] = centerx + dx;
	    vertexes[ 31 ] = centery + dy;
	    vertexes[ 32 ] = centerz - dz;
	    normal[ 30 ] = 1.0;
	    normal[ 31 ] = 0.0;
	    normal[ 32 ] = 0.0;
	    uv[ 20 ] = 1.0;
	    uv[ 21 ] = 0.0;
	
	    vertexes[ 33 ] = centerx + dx;
	    vertexes[ 34 ] = centery + dy;
	    vertexes[ 35 ] = centerz + dz;
	    normal[ 33 ] = 1.0;
	    normal[ 34 ] = 0.0;
	    normal[ 35 ] = 0.0;
	    uv[ 22 ] = 1.0;
	    uv[ 23 ] = 1.0;
	
	    // -ve x plane
	    vertexes[ 36 ] = centerx - dx;
	    vertexes[ 37 ] = centery + dy;
	    vertexes[ 38 ] = centerz + dz;
	    normal[ 36 ] = -1.0;
	    normal[ 37 ] = 0.0;
	    normal[ 38 ] = 0.0;
	    uv[ 24 ] = 0.0;
	    uv[ 25 ] = 1.0;
	
	    vertexes[ 39 ] = centerx - dx;
	    vertexes[ 40 ] = centery + dy;
	    vertexes[ 41 ] = centerz - dz;
	    normal[ 39 ] = -1.0;
	    normal[ 40 ] = 0.0;
	    normal[ 41 ] = 0.0;
	    uv[ 26 ] = 0.0;
	    uv[ 27 ] = 0.0;
	
	    vertexes[ 42 ] = centerx - dx;
	    vertexes[ 43 ] = centery - dy;
	    vertexes[ 44 ] = centerz - dz;
	    normal[ 42 ] = -1.0;
	    normal[ 43 ] = 0.0;
	    normal[ 44 ] = 0.0;
	    uv[ 28 ] = 1.0;
	    uv[ 29 ] = 0.0;
	
	    vertexes[ 45 ] = centerx - dx;
	    vertexes[ 46 ] = centery - dy;
	    vertexes[ 47 ] = centerz + dz;
	    normal[ 45 ] = -1.0;
	    normal[ 46 ] = 0.0;
	    normal[ 47 ] = 0.0;
	    uv[ 30 ] = 1.0;
	    uv[ 31 ] = 1.0;
	
	    // top
	    // +ve z plane
	    vertexes[ 48 ] = centerx - dx;
	    vertexes[ 49 ] = centery + dy;
	    vertexes[ 50 ] = centerz + dz;
	    normal[ 48 ] = 0.0;
	    normal[ 49 ] = 0.0;
	    normal[ 50 ] = 1.0;
	    uv[ 32 ] = 0.0;
	    uv[ 33 ] = 1.0;
	
	    vertexes[ 51 ] = centerx - dx;
	    vertexes[ 52 ] = centery - dy;
	    vertexes[ 53 ] = centerz + dz;
	    normal[ 51 ] = 0.0;
	    normal[ 52 ] = 0.0;
	    normal[ 53 ] = 1.0;
	    uv[ 34 ] = 0.0;
	    uv[ 35 ] = 0.0;
	
	    vertexes[ 54 ] = centerx + dx;
	    vertexes[ 55 ] = centery - dy;
	    vertexes[ 56 ] = centerz + dz;
	    normal[ 54 ] = 0.0;
	    normal[ 55 ] = 0.0;
	    normal[ 56 ] = 1.0;
	    uv[ 36 ] = 1.0;
	    uv[ 37 ] = 0.0;
	
	    vertexes[ 57 ] = centerx + dx;
	    vertexes[ 58 ] = centery + dy;
	    vertexes[ 59 ] = centerz + dz;
	    normal[ 57 ] = 0.0;
	    normal[ 58 ] = 0.0;
	    normal[ 59 ] = 1.0;
	    uv[ 38 ] = 1.0;
	    uv[ 39 ] = 1.0;
	
	    // bottom
	    // -ve z plane
	    vertexes[ 60 ] = centerx + dx;
	    vertexes[ 61 ] = centery + dy;
	    vertexes[ 62 ] = centerz - dz;
	    normal[ 60 ] = 0.0;
	    normal[ 61 ] = 0.0;
	    normal[ 62 ] = -1.0;
	    uv[ 40 ] = 0.0;
	    uv[ 41 ] = 1.0;
	
	    vertexes[ 63 ] = centerx + dx;
	    vertexes[ 64 ] = centery - dy;
	    vertexes[ 65 ] = centerz - dz;
	    normal[ 63 ] = 0.0;
	    normal[ 64 ] = 0.0;
	    normal[ 65 ] = -1.0;
	    uv[ 42 ] = 0.0;
	    uv[ 43 ] = 0.0;
	
	    vertexes[ 66 ] = centerx - dx;
	    vertexes[ 67 ] = centery - dy;
	    vertexes[ 68 ] = centerz - dz;
	    normal[ 66 ] = 0.0;
	    normal[ 67 ] = 0.0;
	    normal[ 68 ] = -1.0;
	    uv[ 44 ] = 1.0;
	    uv[ 45 ] = 0.0;
	
	    vertexes[ 69 ] = centerx - dx;
	    vertexes[ 70 ] = centery + dy;
	    vertexes[ 71 ] = centerz - dz;
	    normal[ 69 ] = 0.0;
	    normal[ 70 ] = 0.0;
	    normal[ 71 ] = -1.0;
	    uv[ 46 ] = 1.0;
	    uv[ 47 ] = 1.0;
	
	    var indexes = new MACROUTILS.Uint16Array( 36 );
	    indexes[ 0 ] = 0;
	    indexes[ 1 ] = 1;
	    indexes[ 2 ] = 2;
	    indexes[ 3 ] = 0;
	    indexes[ 4 ] = 2;
	    indexes[ 5 ] = 3;
	
	    indexes[ 6 ] = 4;
	    indexes[ 7 ] = 5;
	    indexes[ 8 ] = 6;
	    indexes[ 9 ] = 4;
	    indexes[ 10 ] = 6;
	    indexes[ 11 ] = 7;
	
	    indexes[ 12 ] = 8;
	    indexes[ 13 ] = 9;
	    indexes[ 14 ] = 10;
	    indexes[ 15 ] = 8;
	    indexes[ 16 ] = 10;
	    indexes[ 17 ] = 11;
	
	    indexes[ 18 ] = 12;
	    indexes[ 19 ] = 13;
	    indexes[ 20 ] = 14;
	    indexes[ 21 ] = 12;
	    indexes[ 22 ] = 14;
	    indexes[ 23 ] = 15;
	
	    indexes[ 24 ] = 16;
	    indexes[ 25 ] = 17;
	    indexes[ 26 ] = 18;
	    indexes[ 27 ] = 16;
	    indexes[ 28 ] = 18;
	    indexes[ 29 ] = 19;
	
	    indexes[ 30 ] = 20;
	    indexes[ 31 ] = 21;
	    indexes[ 32 ] = 22;
	    indexes[ 33 ] = 20;
	    indexes[ 34 ] = 22;
	    indexes[ 35 ] = 23;
	
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );
	    g.getAttributes().Normal = new BufferArray( BufferArray.ARRAY_BUFFER, normal, 3 );
	    g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uv, 2 );
	
	    var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );
	    g.getPrimitives().push( primitive );
	    return g;
	};
	
	// better perf
	// no more pixel shader hurt for nothing
	// http://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
	// It's a Singleton, as it's rendering invariant
	// so same remove uneeded state change when same geom
	var createTexturedFullScreenFakeQuadGeometry = ( function () {
	    var g = new Geometry();
	
	    var uvs = new MACROUTILS.Float32Array( [ -1.0, -1.0, -1.0, 4.0, 4.0, -1.0 ] );
	    var vertexes = new MACROUTILS.Float32Array( [ -1.0, -1.0, -1.0, 4.0, 4.0, -1.0 ] );
	
	    var indexes = new MACROUTILS.Uint16Array( 3 );
	    indexes[ 0 ] = 2;
	    indexes[ 1 ] = 1;
	    indexes[ 2 ] = 0;
	
	    // Further optim: no index, no uv (uv.xy = position.xy in vertex shader)
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 2 );
	    g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uvs, 2 );
	
	    var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );
	    g.getPrimitives().push( primitive );
	
	    return function () {
	        return g;
	    };
	} )();
	
	
	var createTexturedQuadGeometry = function ( cornerx, cornery, cornerz,
	    wx, wy, wz,
	    hx, hy, hz,
	    l, b, r, t ) {
	
	    if ( r === undefined && t === undefined ) {
	        r = l;
	        t = b;
	        l = 0.0;
	        b = 0.0;
	    }
	
	    var g = new Geometry();
	
	    var vertexes = new MACROUTILS.Float32Array( 12 );
	    vertexes[ 0 ] = cornerx + hx;
	    vertexes[ 1 ] = cornery + hy;
	    vertexes[ 2 ] = cornerz + hz;
	
	    vertexes[ 3 ] = cornerx;
	    vertexes[ 4 ] = cornery;
	    vertexes[ 5 ] = cornerz;
	
	    vertexes[ 6 ] = cornerx + wx;
	    vertexes[ 7 ] = cornery + wy;
	    vertexes[ 8 ] = cornerz + wz;
	
	    vertexes[ 9 ] = cornerx + wx + hx;
	    vertexes[ 10 ] = cornery + wy + hy;
	    vertexes[ 11 ] = cornerz + wz + hz;
	
	    if ( r === undefined ) {
	        r = 1.0;
	    }
	    if ( t === undefined ) {
	        t = 1.0;
	    }
	
	    var uvs = new MACROUTILS.Float32Array( 8 );
	    uvs[ 0 ] = l;
	    uvs[ 1 ] = t;
	
	    uvs[ 2 ] = l;
	    uvs[ 3 ] = b;
	
	    uvs[ 4 ] = r;
	    uvs[ 5 ] = b;
	
	    uvs[ 6 ] = r;
	    uvs[ 7 ] = t;
	
	    var n = Vec3.createAndSet( wx, wy, wz );
	    Vec3.cross( n, Vec3.createAndSet( hx, hy, hz ), n );
	    Vec3.normalize( n, n );
	
	    var normal = new MACROUTILS.Float32Array( 12 );
	    normal[ 0 ] = n[ 0 ];
	    normal[ 1 ] = n[ 1 ];
	    normal[ 2 ] = n[ 2 ];
	
	    normal[ 3 ] = n[ 0 ];
	    normal[ 4 ] = n[ 1 ];
	    normal[ 5 ] = n[ 2 ];
	
	    normal[ 6 ] = n[ 0 ];
	    normal[ 7 ] = n[ 1 ];
	    normal[ 8 ] = n[ 2 ];
	
	    normal[ 9 ] = n[ 0 ];
	    normal[ 10 ] = n[ 1 ];
	    normal[ 11 ] = n[ 2 ];
	
	
	    var indexes = new MACROUTILS.Uint16Array( 6 );
	    indexes[ 0 ] = 0;
	    indexes[ 1 ] = 1;
	    indexes[ 2 ] = 2;
	    indexes[ 3 ] = 0;
	    indexes[ 4 ] = 2;
	    indexes[ 5 ] = 3;
	
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );
	    g.getAttributes().Normal = new BufferArray( BufferArray.ARRAY_BUFFER, normal, 3 );
	    g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uvs, 2 );
	
	    var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );
	    g.getPrimitives().push( primitive );
	    return g;
	};
	
	var createTexturedBox = function ( centerx, centery, centerz,
	    sizex, sizey, sizez ) {
	    Notify.log( 'createTexturedBox is deprecated use instead createTexturedBoxGeometry' );
	    return createTexturedBoxGeometry( centerx, centery, centerz,
	        sizex, sizey, sizez );
	};
	
	var createTexturedQuad = function ( cornerx, cornery, cornerz,
	    wx, wy, wz,
	    hx, hy, hz,
	    l, b, r, t ) {
	    Notify.log( 'createTexturedQuad is deprecated use instead createTexturedQuadGeometry' );
	    return createTexturedQuadGeometry( cornerx, cornery, cornerz,
	        wx, wy, wz,
	        hx, hy, hz,
	        l, b, r, t );
	};
	
	var createAxisGeometry = function ( size ) {
	    if ( size === undefined ) {
	        size = 5.0;
	    }
	    if ( createAxisGeometry.getShader === undefined ) {
	        createAxisGeometry.getShader = function () {
	            if ( createAxisGeometry.getShader.program === undefined ) {
	                var vertexshader = [
	                    '#ifdef GL_ES',
	                    'precision highp float;',
	                    '#endif',
	                    'attribute vec3 Vertex;',
	                    'attribute vec4 Color;',
	                    'uniform mat4 ModelViewMatrix;',
	                    'uniform mat4 ProjectionMatrix;',
	                    '',
	                    'varying vec4 FragColor;',
	                    '',
	                    'vec4 ftransform() {',
	                    'return ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);',
	                    '}',
	                    '',
	                    'void main(void) {',
	                    'gl_Position = ftransform();',
	                    'FragColor = Color;',
	                    '}'
	                ].join( '\n' );
	
	                var fragmentshader = [
	                    '#ifdef GL_ES',
	                    'precision highp float;',
	                    '#endif',
	                    'varying vec4 FragColor;',
	
	                    'void main(void) {',
	                    'gl_FragColor = FragColor;',
	                    '}'
	                ].join( '\n' );
	
	                var program = new Program( new Shader( 'VERTEX_SHADER', vertexshader ),
	                    new Shader( 'FRAGMENT_SHADER', fragmentshader ) );
	                createAxisGeometry.getShader.program = program;
	            }
	            return createAxisGeometry.getShader.program;
	        };
	    }
	
	    var g = new Geometry();
	
	    var vertexes = new MACROUTILS.Float32Array( 18 );
	    vertexes[ 3 ] = size;
	    vertexes[ 10 ] = size;
	    vertexes[ 17 ] = size;
	
	    var colors = new MACROUTILS.Float32Array( 24 );
	    //red color
	    colors[ 0 ] = colors[ 3 ] = 1.0;
	    colors[ 4 ] = colors[ 4 + 3 ] = 1.0;
	    //green color
	    colors[ 4 * 2 + 1 ] = colors[ 4 * 2 + 3 ] = 1.0;
	    colors[ 4 * 3 + 1 ] = colors[ 4 * 3 + 3 ] = 1.0;
	    //blue color
	    colors[ 4 * 4 + 2 ] = colors[ 4 * 4 + 3 ] = 1.0;
	    colors[ 4 * 5 + 2 ] = colors[ 4 * 5 + 3 ] = 1.0;
	
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );
	    g.getAttributes().Color = new BufferArray( BufferArray.ARRAY_BUFFER, colors, 4 );
	
	    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, 6 );
	    g.getPrimitives().push( primitive );
	    g.getOrCreateStateSet().setAttributeAndModes( createAxisGeometry.getShader() );
	
	    return g;
	};
	
	/**
	 * Create a Textured Sphere on the given center with given radius
	 * @name createTexturedSphere
	 * @author Darrell Esau
	 */
	var createTexturedSphere = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	    radius = radius || 50.0;
	
	    phiStart = phiStart !== undefined ? phiStart : 0.0;
	    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
	    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
	    var segmentsX = Math.max( 3, Math.floor( widthSegments ) || 8 );
	    var segmentsY = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
	    var useDrawArrays = ( ( segmentsX * segmentsY ) / 3 ) >= 65536;
	    var nbPrim = useDrawArrays ? segmentsX * segmentsY * 6 : segmentsX * segmentsY * 4;
	    var fullVerticesList = new MACROUTILS.Float32Array( nbPrim * 3 );
	    var fullNormalsList = new MACROUTILS.Float32Array( nbPrim * 3 );
	    var fullUVList = new MACROUTILS.Float32Array( nbPrim * 2 );
	    var indexes = !useDrawArrays ? new MACROUTILS.Uint16Array( segmentsX * segmentsY * 6 ) : undefined;
	    var vtxCount = 0;
	    var triCount = 0;
	
	    var v1 = new MACROUTILS.Float32Array( 3 );
	    var v2 = new MACROUTILS.Float32Array( 3 );
	    var v3 = new MACROUTILS.Float32Array( 3 );
	    var v4 = new MACROUTILS.Float32Array( 3 );
	    var n1 = new MACROUTILS.Float32Array( 3 );
	    var n2 = new MACROUTILS.Float32Array( 3 );
	    var n3 = new MACROUTILS.Float32Array( 3 );
	    var n4 = new MACROUTILS.Float32Array( 3 );
	    var uv1 = new MACROUTILS.Float32Array( 2 );
	    var uv2 = new MACROUTILS.Float32Array( 2 );
	    var uv3 = new MACROUTILS.Float32Array( 2 );
	    var uv4 = new MACROUTILS.Float32Array( 2 );
	    var getCoordAndUvSphere = function ( u, v, coord, norm, uv ) {
	        coord[ 0 ] = -radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	        coord[ 1 ] = radius * Math.cos( thetaStart + v * thetaLength );
	        coord[ 2 ] = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	        Vec3.normalize( coord, norm );
	        uv[ 0 ] = u;
	        uv[ 1 ] = 1 - v;
	    };
	    for ( var y = 0; y < segmentsY; y++ ) {
	        for ( var x = 0; x < segmentsX; x++ ) {
	            getCoordAndUvSphere( ( x + 1 ) / segmentsX, y / segmentsY, v1, n1, uv1 );
	            getCoordAndUvSphere( x / segmentsX, y / segmentsY, v2, n2, uv2 );
	            getCoordAndUvSphere( x / segmentsX, ( y + 1 ) / segmentsY, v3, n3, uv3 );
	            getCoordAndUvSphere( ( x + 1 ) / segmentsX, ( y + 1 ) / segmentsY, v4, n4, uv4 );
	
	            var idv = vtxCount * 3;
	            fullVerticesList[ idv ] = v1[ 0 ];
	            fullVerticesList[ idv + 1 ] = v1[ 1 ];
	            fullVerticesList[ idv + 2 ] = v1[ 2 ];
	            fullVerticesList[ idv + 3 ] = v2[ 0 ];
	            fullVerticesList[ idv + 4 ] = v2[ 1 ];
	            fullVerticesList[ idv + 5 ] = v2[ 2 ];
	            fullVerticesList[ idv + 6 ] = v3[ 0 ];
	            fullVerticesList[ idv + 7 ] = v3[ 1 ];
	            fullVerticesList[ idv + 8 ] = v3[ 2 ];
	
	            fullNormalsList[ idv ] = n1[ 0 ];
	            fullNormalsList[ idv + 1 ] = n1[ 1 ];
	            fullNormalsList[ idv + 2 ] = n1[ 2 ];
	            fullNormalsList[ idv + 3 ] = n2[ 0 ];
	            fullNormalsList[ idv + 4 ] = n2[ 1 ];
	            fullNormalsList[ idv + 5 ] = n2[ 2 ];
	            fullNormalsList[ idv + 6 ] = n3[ 0 ];
	            fullNormalsList[ idv + 7 ] = n3[ 1 ];
	            fullNormalsList[ idv + 8 ] = n3[ 2 ];
	
	            var idu = vtxCount * 2;
	            fullUVList[ idu ] = uv1[ 0 ];
	            fullUVList[ idu + 1 ] = uv1[ 1 ];
	            fullUVList[ idu + 2 ] = uv2[ 0 ];
	            fullUVList[ idu + 3 ] = uv2[ 1 ];
	            fullUVList[ idu + 4 ] = uv3[ 0 ];
	            fullUVList[ idu + 5 ] = uv3[ 1 ];
	
	            vtxCount += 3;
	            if ( useDrawArrays ) {
	                idv = vtxCount * 3;
	                fullVerticesList[ idv ] = v1[ 0 ];
	                fullVerticesList[ idv + 1 ] = v1[ 1 ];
	                fullVerticesList[ idv + 2 ] = v1[ 2 ];
	                fullVerticesList[ idv + 3 ] = v3[ 0 ];
	                fullVerticesList[ idv + 4 ] = v3[ 1 ];
	                fullVerticesList[ idv + 5 ] = v3[ 2 ];
	                fullVerticesList[ idv + 6 ] = v4[ 0 ];
	                fullVerticesList[ idv + 7 ] = v4[ 1 ];
	                fullVerticesList[ idv + 8 ] = v4[ 2 ];
	
	                fullNormalsList[ idv ] = n1[ 0 ];
	                fullNormalsList[ idv + 1 ] = n1[ 1 ];
	                fullNormalsList[ idv + 2 ] = n1[ 2 ];
	                fullNormalsList[ idv + 3 ] = n3[ 0 ];
	                fullNormalsList[ idv + 4 ] = n3[ 1 ];
	                fullNormalsList[ idv + 5 ] = n3[ 2 ];
	                fullNormalsList[ idv + 6 ] = n4[ 0 ];
	                fullNormalsList[ idv + 7 ] = n4[ 1 ];
	                fullNormalsList[ idv + 8 ] = n4[ 2 ];
	
	                idu = vtxCount * 2;
	                fullUVList[ idu ] = uv1[ 0 ];
	                fullUVList[ idu + 1 ] = uv1[ 1 ];
	                fullUVList[ idu + 2 ] = uv3[ 0 ];
	                fullUVList[ idu + 3 ] = uv3[ 1 ];
	                fullUVList[ idu + 4 ] = uv4[ 0 ];
	                fullUVList[ idu + 5 ] = uv4[ 1 ];
	                vtxCount += 3;
	            } else {
	                idv = vtxCount * 3;
	                fullVerticesList[ idv ] = v4[ 0 ];
	                fullVerticesList[ idv + 1 ] = v4[ 1 ];
	                fullVerticesList[ idv + 2 ] = v4[ 2 ];
	
	                fullNormalsList[ idv ] = n4[ 0 ];
	                fullNormalsList[ idv + 1 ] = n4[ 1 ];
	                fullNormalsList[ idv + 2 ] = n4[ 2 ];
	
	                idu = vtxCount * 2;
	                fullUVList[ idu ] = uv4[ 0 ];
	                fullUVList[ idu + 1 ] = uv4[ 1 ];
	
	                var iStart = triCount * 3;
	                var tristart = vtxCount - 3;
	                indexes[ iStart ] = tristart;
	                indexes[ iStart + 1 ] = tristart + 1;
	                indexes[ iStart + 2 ] = tristart + 2;
	                indexes[ iStart + 3 ] = tristart;
	                indexes[ iStart + 4 ] = tristart + 2;
	                indexes[ iStart + 5 ] = tristart + 3;
	                triCount += 2;
	                vtxCount += 1;
	            }
	        }
	    }
	
	    var g = new Geometry();
	    g.getAttributes().Vertex = new BufferArray( 'ARRAY_BUFFER', fullVerticesList, 3 );
	    g.getAttributes().Normal = new BufferArray( 'ARRAY_BUFFER', fullNormalsList, 3 );
	    g.getAttributes().TexCoord0 = new BufferArray( 'ARRAY_BUFFER', fullUVList, 2 );
	
	    if ( useDrawArrays )
	        g.getPrimitives().push( new DrawArrays( PrimitiveSet.TRIANGLES, 0, fullVerticesList.length / 3 ) );
	    else
	        g.getPrimitives().push( new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( 'ELEMENT_ARRAY_BUFFER', indexes, 1 ) ) );
	    return g;
	};
	
	var createGridGeometry = function ( cx, cy, cz, wx, wy, wz, hx, hy, hz, res1, res2 ) {
	    cx = cx !== undefined ? cx : -0.5;
	    cy = cy !== undefined ? cy : -0.5;
	    cz = cz !== undefined ? cz : 0.0;
	
	    wx = wx !== undefined ? wx : 1.0;
	    wy = wy !== undefined ? wy : 0.0;
	    wz = wz !== undefined ? wz : 0.0;
	
	    hx = hx !== undefined ? hx : 0.0;
	    hy = hy !== undefined ? hy : 1.0;
	    hz = hz !== undefined ? hz : 0.0;
	
	    res1 = res1 !== undefined ? res1 : 5;
	    res2 = res2 !== undefined ? res2 : res1;
	    res1 += 2;
	    res2 += 2;
	
	    var g = new Geometry();
	    var vertices = new Float32Array( ( res1 + res2 ) * 2 * 3 );
	    var i = 0;
	    var j = 0;
	    var sx = wx / ( res1 - 1 );
	    var sy = wy / ( res1 - 1 );
	    var sz = wz / ( res1 - 1 );
	    var ux = cx + wx + hx;
	    var uy = cy + wy + hy;
	    var uz = cz + wz + hz;
	    for ( i = 0; i < res1; ++i ) {
	        j = i * 6;
	        vertices[ j ] = cx + sx * i;
	        vertices[ j + 1 ] = cy + sy * i;
	        vertices[ j + 2 ] = cz + sz * i;
	        vertices[ j + 3 ] = ux - sx * ( res1 - i - 1 );
	        vertices[ j + 4 ] = uy - sy * ( res1 - i - 1 );
	        vertices[ j + 5 ] = uz - sz * ( res1 - i - 1 );
	    }
	    sx = hx / ( res2 - 1 );
	    sy = hy / ( res2 - 1 );
	    sz = hz / ( res2 - 1 );
	    for ( i = 0; i < res2; ++i ) {
	        j = ( res1 + i ) * 6;
	        vertices[ j ] = cx + sx * i;
	        vertices[ j + 1 ] = cy + sy * i;
	        vertices[ j + 2 ] = cz + sz * i;
	        vertices[ j + 3 ] = ux - sx * ( res2 - i - 1 );
	        vertices[ j + 4 ] = uy - sy * ( res2 - i - 1 );
	        vertices[ j + 5 ] = uz - sz * ( res2 - i - 1 );
	    }
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );
	    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, ( res1 + res2 ) * 2 );
	    g.getPrimitives().push( primitive );
	    return g;
	};
	
	module.exports = {
	    createTexturedBoxGeometry: createTexturedBoxGeometry,
	    createTexturedQuadGeometry: createTexturedQuadGeometry,
	    createTexturedSphereGeometry: createTexturedSphere,
	    createTexturedBox: createTexturedBox,
	    createTexturedFullScreenFakeQuadGeometry: createTexturedFullScreenFakeQuadGeometry,
	    createTexturedQuad: createTexturedQuad,
	    createAxisGeometry: createAxisGeometry,
	    createTexturedSphere: createTexturedSphere,
	    createGridGeometry: createGridGeometry
	};


/***/ }),
/* 103 */
/***/ (function(module, exports) {

	'use strict';
	var Stack = function () {
	    this.globalDefault = undefined;
	    this.lastApplied = undefined;
	    this.asChanged = false;
	
	    this._values = [];
	    this._back = undefined;
	};
	
	Stack.prototype = {
	    empty: function () {
	        return this._values.length === 0;
	    },
	    values: function () {
	        return this._values;
	    },
	    back: function () {
	        return this._back;
	    },
	    push: function ( value ) {
	        this._values.push( value );
	        this._back = value;
	    },
	    pop: function () {
	        var value = this._values.pop();
	        this._back = this._values[ this._values.length - 1 ];
	        return value;
	    }
	};
	
	module.exports = Stack;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Map = __webpack_require__( 20 );
	var Matrix = __webpack_require__( 23 );
	var Notify = __webpack_require__( 10 );
	var Object = __webpack_require__( 13 );
	var Program = __webpack_require__( 100 );
	var StateAttribute = __webpack_require__( 21 );
	var Stack = __webpack_require__( 103 );
	var Uniform = __webpack_require__( 35 );
	var MACROUTILS = __webpack_require__( 6 );
	var WebGLCaps = __webpack_require__( 32 );
	
	var State = function ( shaderGeneratorProxy ) {
	    Object.call( this );
	
	    this._graphicContext = undefined;
	    this._shaderGeneratorProxy = shaderGeneratorProxy;
	
	    if ( shaderGeneratorProxy === undefined )
	        console.break();
	
	    this._currentVAO = null;
	    this._currentIndexVBO = null;
	
	    this.vertexAttribList = [];
	    this.stateSets = new Stack();
	    this._shaderGeneratorNames = new Stack();
	    this.uniforms = new Map();
	
	    this.textureAttributeMapList = [];
	
	    this.attributeMap = new Map();
	
	    this.modelWorldMatrix = Uniform.createMatrix4( Matrix.create(), 'ModelWorldMatrix' );
	    this.viewMatrix = Uniform.createMatrix4( Matrix.create(), 'ViewMatrix' );
	    this.modelViewMatrix = Uniform.createMatrix4( Matrix.create(), 'ModelViewMatrix' );
	    this.projectionMatrix = Uniform.createMatrix4( Matrix.create(), 'ProjectionMatrix' );
	    this.normalMatrix = Uniform.createMatrix4( Matrix.create(), 'NormalMatrix' );
	
	    // track uniform for color array enabled
	    var arrayColorEnable = new Stack();
	    arrayColorEnable.globalDefault = Uniform.createFloat1( 0.0, 'ArrayColorEnabled' );
	
	    this.uniforms.setMap( {
	        ArrayColorEnabled: arrayColorEnable
	    } );
	
	
	    this._previousColorAttribPair = {};
	    this.vertexAttribMap = {};
	    this.vertexAttribMap._disable = [];
	    this.vertexAttribMap._keys = [];
	
	    this._frameStamp = undefined;
	
	    // we dont use Map because in this use case with a few entries
	    // {} is faster
	    this._programCommonUniformsCache = {};
	
	    // keep pointer on the last applied modelview matrix
	    this._modelViewMatrix = undefined;
	    // keep pointer on the last applied projection matrix
	    this._projectionMatrix = undefined;
	
	
	    // keep track of last applied program
	    this._program = undefined;
	    // inject a default program to initialize the stack Program
	    this.applyAttribute( new Program() );
	
	    this._numPushStateSet = 0;
	};
	
	State.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	
	    getCacheUniformsApplyRenderLeaf: function () {
	        return this._programCommonUniformsCache;
	    },
	
	    setGraphicContext: function ( graphicContext ) {
	        this._graphicContext = graphicContext;
	        this._extVAO = WebGLCaps.instance( graphicContext ).getWebGLExtension( 'OES_vertex_array_object' );
	    },
	
	    getGraphicContext: function () {
	        return this._graphicContext;
	    },
	
	    getShaderGeneratorProxy: function () {
	        return this._shaderGeneratorProxy;
	    },
	
	    pushCheckOverride: function ( stack, object, maskValue ) {
	        // object can be a Uniform, an Attribute, or a shader generator name
	        if ( stack.values().length === 0 ) {
	            stack.push( this.getObjectPair( object, maskValue ) );
	        } else if ( ( stack.back().value & StateAttribute.OVERRIDE ) && !( maskValue & StateAttribute.PROTECTED ) ) {
	            stack.push( stack.back() );
	        } else {
	            stack.push( this.getObjectPair( object, maskValue ) );
	        }
	    },
	
	    pushStateSet: function ( stateset ) {
	        this._numPushStateSet++;
	        this.stateSets.push( stateset );
	
	        if ( stateset.attributeMap ) {
	            this.pushAttributeMap( this.attributeMap, stateset.attributeMap );
	        }
	
	        if ( stateset.textureAttributeMapList ) {
	            var list = stateset.textureAttributeMapList;
	            for ( var textureUnit = 0, l = list.length; textureUnit < l; textureUnit++ ) {
	                if ( !list[ textureUnit ] ) {
	                    continue;
	                }
	
	                var textureUnitAttributeMap = this.getOrCreateTextureAttributeMap( textureUnit );
	                this.pushAttributeMap( textureUnitAttributeMap, list[ textureUnit ] );
	            }
	        }
	
	        if ( stateset.uniforms ) {
	            this.pushUniformsList( this.uniforms, stateset.uniforms );
	        }
	        var generatorPair = stateset.getShaderGeneratorPair();
	        if ( generatorPair )
	            this.pushCheckOverride( this._shaderGeneratorNames, generatorPair.getShaderGeneratorName(), generatorPair.getValue() );
	    },
	
	    getStateSetStackSize: function () {
	        return this.stateSets.values().length;
	    },
	
	    insertStateSet: ( function () {
	        var tmpStack = [];
	
	        return function ( pos, stateSet ) {
	
	            tmpStack.length = 0;
	            var length = this.getStateSetStackSize();
	            while ( length > pos ) {
	                tmpStack.push( this.stateSets.back() );
	                this.popStateSet();
	                length--;
	            }
	
	            this.pushStateSet( stateSet );
	
	            for ( var i = tmpStack.length - 1; i >= 0; i-- ) {
	                this.pushStateSet( tmpStack[ i ] );
	            }
	
	        };
	    } )(),
	
	    removeStateSet: ( function () {
	        var tmpStack = [];
	
	        return function ( pos ) {
	
	            var length = this.getStateSetStackSize();
	            if ( pos >= length ) {
	                Notify.warn( 'Warning State:removeStateSet ', pos, ' out of range' );
	                return;
	            }
	
	            tmpStack.length = 0;
	
	            // record the StateSet above the one we intend to remove
	            while ( length - 1 > pos ) {
	                tmpStack.push( this.stateSets.back() );
	                this.popStateSet();
	                length--;
	            }
	
	            // remove the intended StateSet as well
	            this.popStateSet();
	
	            // push back the original ones that were above the remove StateSet
	            for ( var i = tmpStack.length - 1; i >= 0; i-- ) {
	                this.pushStateSet( tmpStack[ i ] );
	            }
	
	        };
	    } )(),
	
	
	    // needed because we use a cache during the frame to avoid
	    // applying uniform or operation. At each frame we need to
	    // invalidate those informations
	    resetCacheFrame: function () {
	        this._modelViewMatrix = this._projectionMatrix = undefined;
	    },
	
	    resetStats: function () {
	        this._numPushStateSet = 0;
	    },
	
	    // apply program if needed
	    applyProgram: function ( program ) {
	        if ( this._program === program ) return;
	        this._program = program;
	        this.getGraphicContext().useProgram( program );
	    },
	
	    applyModelViewMatrix: ( function () {
	
	        var normal = Matrix.create();
	
	        return function StateApplyModelViewMatrix( matrix ) {
	
	            if ( this._modelViewMatrix === matrix ) return false;
	
	            var program = this.getLastProgramApplied();
	            var uniformCache = program.getUniformsCache();
	            var mu = this.modelViewMatrix;
	            var mul = uniformCache.ModelViewMatrix;
	            var gc = this.getGraphicContext();
	            if ( mul ) {
	
	                mu.setMatrix4( matrix );
	                mu.apply( gc, mul );
	            }
	
	            var sendNormal;
	            if ( this._modelViewMatrix ) {
	
	                // check if we need to push normal
	                // test rotation component, if not diff
	                // we dont need to send normal
	                var m2 = this._modelViewMatrix;
	                for ( var i = 0; i < 11; i++ ) {
	                    if ( matrix[ i ] !== m2[ i ] ) {
	                        sendNormal = true;
	                        break;
	                    }
	                }
	            } else {
	                sendNormal = true;
	            }
	
	            if ( sendNormal ) {
	                mu = this.normalMatrix;
	                mul = uniformCache.NormalMatrix;
	                if ( mul ) {
	
	                    normal[ 0 ] = matrix[ 0 ];
	                    normal[ 1 ] = matrix[ 1 ];
	                    normal[ 2 ] = matrix[ 2 ];
	                    normal[ 4 ] = matrix[ 4 ];
	                    normal[ 5 ] = matrix[ 5 ];
	                    normal[ 6 ] = matrix[ 6 ];
	                    normal[ 8 ] = matrix[ 8 ];
	                    normal[ 9 ] = matrix[ 9 ];
	                    normal[ 10 ] = matrix[ 10 ];
	
	                    Matrix.inverse( normal, normal );
	                    Matrix.transpose( normal, normal );
	
	                    mu.setMatrix4( normal );
	                    mu.apply( gc, mul );
	                }
	            }
	
	            this._modelViewMatrix = matrix;
	            return true;
	        };
	    } )(),
	
	
	    applyModelViewMatrixEperiment: ( function () {
	
	        var normal = Matrix.create();
	
	        var checkMatrix = function ( m0, m1 ) {
	            if ( m0[ 0 ] !== m1[ 0 ] ) return true;
	            if ( m0[ 1 ] !== m1[ 1 ] ) return true;
	            if ( m0[ 2 ] !== m1[ 2 ] ) return true;
	            if ( m0[ 4 ] !== m1[ 4 ] ) return true;
	            if ( m0[ 5 ] !== m1[ 5 ] ) return true;
	            if ( m0[ 6 ] !== m1[ 6 ] ) return true;
	            if ( m0[ 8 ] !== m1[ 8 ] ) return true;
	            if ( m0[ 9 ] !== m1[ 9 ] ) return true;
	            if ( m0[ 10 ] !== m1[ 10 ] ) return true;
	            return false;
	        };
	
	        var epsilon = 1e-6;
	        var scaleEpsilonMax = 1.0 + epsilon;
	        var scaleEpsilonMin = 1.0 - epsilon;
	
	        return function StateApplyModelViewMatrix( matrix ) {
	            if ( this._modelViewMatrix === matrix ) return false;
	
	            var program = this.getLastProgramApplied();
	
	            var mu = this.modelViewMatrix;
	            var mul = program.getUniformsCache().ModelViewMatrix;
	            if ( mul ) {
	
	                mu.setMatrix4( matrix );
	                mu.apply( this.getGraphicContext(), mul );
	            }
	
	            var sendNormal = true;
	            if ( this._modelViewMatrix ) {
	                sendNormal = checkMatrix( matrix, this._modelViewMatrix );
	                // check if we need to push normal
	                // test rotation component, if not diff
	                // we dont need to send normal
	                // for ( var i = 0; i < 11; i++ ) {
	                //     if ( matrix[ i ] !== this._modelViewMatrix[ i ] ) {
	                //         sendNormal = true;
	                //         break;
	                //     }
	                // }
	            }
	
	            if ( sendNormal ) {
	                mu = this.normalMatrix;
	                mul = program.getUniformsCache().NormalMatrix;
	                if ( mul ) {
	
	                    // Matrix.copy( matrix, normal );
	                    normal[ 0 ] = matrix[ 0 ];
	                    normal[ 1 ] = matrix[ 1 ];
	                    normal[ 2 ] = matrix[ 2 ];
	                    normal[ 4 ] = matrix[ 4 ];
	                    normal[ 5 ] = matrix[ 5 ];
	                    normal[ 6 ] = matrix[ 6 ];
	                    normal[ 8 ] = matrix[ 8 ];
	                    normal[ 9 ] = matrix[ 9 ];
	                    normal[ 10 ] = matrix[ 10 ];
	
	                    // check for scaling
	                    var xlen = normal[ 0 ] * normal[ 0 ] + normal[ 4 ] * normal[ 4 ] + normal[ 8 ] * normal[ 8 ];
	                    var ylen = normal[ 1 ] * normal[ 1 ] + normal[ 5 ] * normal[ 5 ] + normal[ 9 ] * normal[ 9 ];
	                    var zlen = normal[ 2 ] * normal[ 2 ] + normal[ 6 ] * normal[ 6 ] + normal[ 10 ] * normal[ 10 ];
	
	                    // http://www.gamedev.net/topic/637192-detect-non-uniform-scaling-in-matrix/
	                    if ( xlen > scaleEpsilonMax || xlen < scaleEpsilonMin ||
	                        ylen > scaleEpsilonMax || ylen < scaleEpsilonMin ||
	                        zlen > scaleEpsilonMax || zlen < scaleEpsilonMin ) {
	
	                        Matrix.inverse( normal, normal );
	                        Matrix.transpose( normal, normal );
	                    }
	
	                    mu.setMatrix4( normal );
	                    mu.apply( this.getGraphicContext(), mul );
	                }
	            }
	
	            this._modelViewMatrix = matrix;
	            return true;
	        };
	    } )(),
	
	    applyProjectionMatrix: function ( matrix ) {
	
	        if ( this._projectionMatrix === matrix ) return;
	
	        this._projectionMatrix = matrix;
	        var program = this.getLastProgramApplied();
	        var mu = this.projectionMatrix;
	
	        var mul = program.getUniformsCache()[ mu.getName() ];
	        if ( mul ) {
	
	            mu.setMatrix4( matrix );
	            mu.apply( this.getGraphicContext(), mul );
	
	        }
	    },
	
	    applyStateSet: function ( stateset ) {
	        this.pushStateSet( stateset );
	        this.apply();
	        this.popStateSet();
	    },
	
	    getStateSetStackHash: function () {
	        var values = this.stateSets.values();
	        var sum = 0;
	        for ( var i = 0, l = values.length; i < l; i++ )
	            sum += values[ i ].getInstanceID();
	        return sum;
	    },
	
	    popAllStateSets: function () {
	        while ( this.stateSets.values().length ) {
	            this.popStateSet();
	        }
	    },
	
	    popStateSet: function () {
	
	        if ( this.stateSets.empty() ) return;
	
	        var stateset = this.stateSets.pop();
	
	        if ( stateset.attributeMap ) {
	            this.popAttributeMap( this.attributeMap, stateset.attributeMap );
	        }
	
	        if ( stateset.textureAttributeMapList ) {
	            var list = stateset.textureAttributeMapList;
	            for ( var textureUnit = 0, l = list.length; textureUnit < l; textureUnit++ ) {
	                if ( !list[ textureUnit ] ) {
	                    continue;
	                }
	                this.popAttributeMap( this.textureAttributeMapList[ textureUnit ], list[ textureUnit ] );
	            }
	        }
	
	        if ( stateset.uniforms ) {
	            this.popUniformsList( this.uniforms, stateset.uniforms );
	        }
	
	        if ( stateset.getShaderGeneratorPair() ) {
	            this._shaderGeneratorNames.pop();
	        }
	    },
	
	    _createAttributeStack: function ( attributeMap, key, globalDefault ) {
	
	        var attributeStack = new Stack();
	
	        attributeMap[ key ] = attributeStack;
	        attributeMap[ key ].globalDefault = globalDefault;
	        attributeMap.dirty();
	
	        return attributeStack;
	
	    },
	
	    haveAppliedAttribute: function ( attribute ) {
	
	        var key = attribute.getTypeMember();
	        var attributeStack = this.attributeMap[ key ];
	        if ( !attributeStack ) {
	            attributeStack = this._createAttributeStack( this.attributeMap, key, attribute.cloneType() );
	        }
	        attributeStack.lastApplied = attribute;
	        attributeStack.asChanged = true;
	
	    },
	
	    applyAttribute: function ( attribute ) {
	
	        var key = attribute.getTypeMember();
	
	        var attributeMap = this.attributeMap;
	        var attributeStack = attributeMap[ key ];
	        if ( !attributeStack ) {
	            attributeStack = this._createAttributeStack( this.attributeMap, key, attribute.cloneType() );
	        }
	
	        if ( attributeStack.lastApplied !== attribute ) {
	
	            if ( attribute.apply ) {
	                attribute.apply( this );
	            }
	            attributeStack.lastApplied = attribute;
	            attributeStack.asChanged = true;
	        }
	    },
	
	    applyTextureAttribute: function ( unit, attribute ) {
	
	
	        var gl = this.getGraphicContext();
	        gl.activeTexture( gl.TEXTURE0 + unit );
	        var key = attribute.getTypeMember();
	
	        if ( !this.textureAttributeMapList[ unit ] ) {
	            this.textureAttributeMapList[ unit ] = new Map();
	        }
	
	        var textureUnitAttributeMap = this.getOrCreateTextureAttributeMap( unit );
	        var attributeStack = textureUnitAttributeMap[ key ];
	        if ( !attributeStack ) {
	            attributeStack = this._createAttributeStack( textureUnitAttributeMap, key, attribute.cloneType() );
	        }
	
	
	        if ( attributeStack.lastApplied !== attribute ) {
	
	            if ( attribute.apply ) {
	
	                // there is a texture we bind it.
	                attribute.apply( this, unit );
	
	                // TODO: optimization:
	                // if attribute.isTextureNull()
	                // only bind if last Framebuffer Texture Binded
	                // are the same as those we try to write from
	                // need rewrite of the fbo attachments system to keep history
	                // and state to keep last fbo textures binded.
	                // (applyTextureAttributeStack concerned too)
	            }
	            attributeStack.lastApplied = attribute;
	            attributeStack.asChanged = true;
	        }
	    },
	
	    getLastProgramApplied: function () {
	        return this.attributeMap.Program.lastApplied;
	    },
	
	    applyDefault: function () {
	        // reset GL State To Default
	        // we skip the textures/uniforms/shaders call since they are not necessary
	
	        // noticed that we accumulate lot of stack, maybe because of the stateGraph
	        // CP: ^^ really ? check it / report an issue
	        this.popAllStateSets();
	
	        this.applyAttributeMap( this.attributeMap );
	        this.applyTextureAttributeMapList( this.textureAttributeMapList );
	    },
	
	    apply: function () {
	
	        var lastProgram = this.getLastProgramApplied();
	
	        this.applyAttributeMap( this.attributeMap );
	        this.applyTextureAttributeMapList( this.textureAttributeMapList );
	
	        var generatedProgram = this._generateAndApplyProgram();
	
	        if ( generatedProgram ) {
	            // will cache uniform and apply them with the program
	
	            this._applyGeneratedProgramUniforms( this.attributeMap.Program.lastApplied );
	
	        } else {
	
	            // custom program so we will iterate on uniform from the program and apply them
	            // but in order to be able to use Attribute in the state graph we will check if
	            // our program want them. It must be defined by the user
	            this._applyCustomProgramUniforms( this.attributeMap.Program.lastApplied );
	
	        }
	
	        // reset reference of last applied matrix
	        if ( lastProgram !== this.getLastProgramApplied() ) {
	            this._modelViewMatrix = undefined;
	            this._projectionMatrix = undefined;
	        }
	    },
	
	
	    applyAttributeMap: function ( attributeMap ) {
	
	        var attributeStack;
	        var attributeMapKeys = attributeMap.getKeys();
	
	        for ( var i = 0, l = attributeMapKeys.length; i < l; i++ ) {
	            var key = attributeMapKeys[ i ];
	
	            attributeStack = attributeMap[ key ];
	            if ( !attributeStack || !attributeStack.asChanged ) {
	                continue;
	            }
	
	            var attribute;
	            if ( attributeStack.values().length === 0 ) {
	                attribute = attributeStack.globalDefault;
	            } else {
	                attribute = attributeStack.back().object;
	            }
	
	
	
	            if ( attributeStack.lastApplied !== attribute ) {
	
	                if ( attribute.apply )
	                    attribute.apply( this );
	
	                attributeStack.lastApplied = attribute;
	
	            }
	            attributeStack.asChanged = false;
	
	        }
	    },
	
	    getObjectPair: function ( object, value ) {
	        return {
	            object: object,
	            value: value
	        };
	    },
	
	    pushUniformsList: function ( uniformMap, stateSetUniformMap ) {
	        /*jshint bitwise: false */
	        var name;
	        var uniform;
	
	        var stateSetUniformMapKeys = stateSetUniformMap.getKeys();
	
	        for ( var i = 0, l = stateSetUniformMapKeys.length; i < l; i++ ) {
	            var key = stateSetUniformMapKeys[ i ];
	            var uniformPair = stateSetUniformMap[ key ];
	            uniform = uniformPair.getUniform();
	            name = uniform.getName();
	            if ( !uniformMap[ name ] ) {
	                this._createAttributeStack( uniformMap, name, uniform );
	            }
	
	            this.pushCheckOverride( uniformMap[ name ], uniform, uniformPair.getValue() );
	        }
	        /*jshint bitwise: true */
	    },
	
	    popUniformsList: function ( uniformMap, stateSetUniformMap ) {
	
	        var stateSetUniformMapKeys = stateSetUniformMap.getKeys();
	
	        for ( var i = 0, l = stateSetUniformMapKeys.length; i < l; i++ ) {
	            var key = stateSetUniformMapKeys[ i ];
	            uniformMap[ key ].pop();
	        }
	    },
	
	
	    // this funtion must called only if stack has changed
	    // check applyTextureAttributeMapList
	    _applyTextureAttributeStack: function ( gl, textureUnit, attributeStack ) {
	
	        var attribute;
	        if ( attributeStack.values().length === 0 ) {
	            attribute = attributeStack.globalDefault;
	        } else {
	            attribute = attributeStack.back().object;
	        }
	
	        // if the the stack has changed but the last applied attribute is the same
	        // then we dont need to apply it again
	        if ( attributeStack.lastApplied !== attribute ) {
	
	            gl.activeTexture( gl.TEXTURE0 + textureUnit );
	            attribute.apply( this, textureUnit );
	
	            attributeStack.lastApplied = attribute;
	        }
	
	        attributeStack.asChanged = false;
	    },
	
	    applyTextureAttributeMapList: function ( textureAttributesMapList ) {
	        var gl = this._graphicContext;
	        var textureAttributeMap;
	
	        for ( var textureUnit = 0, l = textureAttributesMapList.length; textureUnit < l; textureUnit++ ) {
	            textureAttributeMap = textureAttributesMapList[ textureUnit ];
	            if ( !textureAttributeMap ) {
	                continue;
	            }
	
	
	            var textureAttributeMapKeys = textureAttributeMap.getKeys();
	
	            for ( var i = 0, lt = textureAttributeMapKeys.length; i < lt; i++ ) {
	                var key = textureAttributeMapKeys[ i ];
	
	                var attributeStack = textureAttributeMap[ key ];
	
	                // skip if not stack or not changed in stack
	                if ( !attributeStack || !attributeStack.asChanged ) continue;
	
	                this._applyTextureAttributeStack( gl, textureUnit, attributeStack );
	                // var attribute;
	                // if ( attributeStack.values().length === 0 ) {
	                //     attribute = attributeStack.globalDefault;
	                // } else {
	                //     attribute = attributeStack.back().object;
	                // }
	                // if ( attributeStack.asChanged ) {
	
	                //     gl.activeTexture( gl.TEXTURE0 + textureUnit );
	                //     attribute.apply( this, textureUnit );
	                //     attributeStack.lastApplied = attribute;
	                //     attributeStack.asChanged = false;
	
	                // }
	            }
	        }
	    },
	
	    setGlobalDefaultValue: function ( attribute ) {
	        Notify.log( 'setGlobalDefaultValue is deprecated, use instead setGlobalDefaultAttribute' );
	        this.setGlobalDefaultAttribute( attribute );
	    },
	
	    setGlobalDefaultAttribute: function ( attribute ) {
	        var typeMember = attribute.getTypeMember();
	        var attributeMap = this.attributeMap;
	
	        if ( attributeMap[ typeMember ] === undefined ) {
	            this._createAttributeStack( attributeMap, typeMember, attribute );
	        } else {
	            attributeMap[ typeMember ].globalDefault = attribute;
	        }
	    },
	
	    getGlobalDefaultAttribute: function ( typeMember ) {
	        var attributeMap = this.attributeMap;
	        if ( attributeMap[ typeMember ] === undefined ) return undefined;
	
	        return attributeMap[ typeMember ].globalDefault;
	    },
	
	    setGlobalDefaultTextureAttribute: function ( unit, attribute ) {
	        var attributeMap = this.getOrCreateTextureAttributeMap( unit );
	
	        var typeMember = attribute.getTypeMember();
	
	        if ( attributeMap[ typeMember ] === undefined ) {
	            this._createAttributeStack( attributeMap, typeMember, attribute );
	        } else {
	            attributeMap[ typeMember ].globalDefault = attribute;
	        }
	
	    },
	
	    getGlobalDefaultTextureAttribute: function ( unit, typeMember ) {
	        var attributeMap = this.getOrCreateTextureAttributeMap( unit );
	        var as = attributeMap[ typeMember ];
	        return as.globalDefault;
	    },
	
	    getOrCreateTextureAttributeMap: function ( unit ) {
	        if ( !this.textureAttributeMapList[ unit ] ) this.textureAttributeMapList[ unit ] = new Map();
	        return this.textureAttributeMapList[ unit ];
	    },
	
	    pushAttributeMap: function ( attributeMap, stateSetAttributeMap ) {
	        /*jshint bitwise: false */
	        var attributeStack;
	        var stateSetAttributeMapKeys = stateSetAttributeMap.getKeys();
	
	        for ( var i = 0, l = stateSetAttributeMapKeys.length; i < l; i++ ) {
	
	            var type = stateSetAttributeMapKeys[ i ];
	            var attributePair = stateSetAttributeMap[ type ];
	            var attribute = attributePair.getAttribute();
	
	            if ( attributeMap[ type ] === undefined ) {
	                this._createAttributeStack( attributeMap, type, attribute.cloneType() );
	            }
	
	            attributeStack = attributeMap[ type ];
	            this.pushCheckOverride( attributeStack, attribute, attributePair.getValue() );
	            attributeStack.asChanged = true;
	        }
	        /*jshint bitwise: true */
	    },
	
	    popAttributeMap: function ( attributeMap, stateSetAttributeMap ) {
	
	        var attributeStack;
	        var stateSetAttributeMapKeys = stateSetAttributeMap.getKeys();
	
	        for ( var i = 0, l = stateSetAttributeMapKeys.length; i < l; i++ ) {
	
	            var type = stateSetAttributeMapKeys[ i ];
	            attributeStack = attributeMap[ type ];
	            attributeStack.pop();
	            attributeStack.asChanged = true;
	
	        }
	    },
	
	    setIndexArray: function ( array ) {
	
	        var gl = this._graphicContext;
	
	        if ( this._currentIndexVBO !== array ) {
	            array.bind( gl );
	            this._currentIndexVBO = array;
	        }
	
	        if ( array.isDirty() ) {
	            array.compile( gl );
	        }
	
	    },
	
	    lazyDisablingOfVertexAttributes: function () {
	        var keys = this.vertexAttribMap._keys;
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	            var attr = keys[ i ];
	            if ( this.vertexAttribMap[ attr ] ) {
	                this.vertexAttribMap._disable[ attr ] = true;
	            }
	        }
	    },
	
	    enableVertexColor: function () {
	
	        var program = this.attributeMap.Program.lastApplied;
	
	        if ( !program.getUniformsCache().ArrayColorEnabled ||
	            !program.getAttributesCache().Color ) return; // no color uniform or attribute used, exit
	
	        // update uniform
	        var uniform = this.uniforms.ArrayColorEnabled.globalDefault;
	
	        var previousColorEnabled = this._previousColorAttribPair[ program.getInstanceID() ];
	
	        if ( !previousColorEnabled ) {
	            uniform.setFloat( 1.0 );
	            uniform.apply( this.getGraphicContext(), program.getUniformsCache().ArrayColorEnabled );
	            this._previousColorAttribPair[ program.getInstanceID() ] = true;
	        }
	
	    },
	
	
	    disableVertexColor: function () {
	
	        var program = this.attributeMap.Program.lastApplied;
	
	        if ( !program.getUniformsCache().ArrayColorEnabled ||
	            !program.getAttributesCache().Color ) return; // no color uniform or attribute used, exit
	
	        // update uniform
	        var uniform = this.uniforms.ArrayColorEnabled.globalDefault;
	
	        var previousColorEnabled = this._previousColorAttribPair[ program.getInstanceID() ];
	
	        if ( previousColorEnabled ) {
	            uniform.setFloat( 0.0 );
	            uniform.apply( this.getGraphicContext(), program.getUniformsCache().ArrayColorEnabled );
	            this._previousColorAttribPair[ program.getInstanceID() ] = false;
	        }
	
	    },
	
	
	    applyDisablingOfVertexAttributes: function () {
	
	        var keys = this.vertexAttribMap._keys;
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	            if ( this.vertexAttribMap._disable[ keys[ i ] ] === true ) {
	                var attr = keys[ i ];
	                this._graphicContext.disableVertexAttribArray( attr );
	                this.vertexAttribMap._disable[ attr ] = false;
	                this.vertexAttribMap[ attr ] = false;
	            }
	        }
	    },
	
	    clearVertexAttribCache: function () {
	
	        var vertexAttribMap = this.vertexAttribMap;
	        var keys = vertexAttribMap._keys;
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	            var attr = keys[ i ];
	            vertexAttribMap[ attr ] = undefined;
	            vertexAttribMap._disable[ attr ] = false;
	        }
	
	        this.vertexAttribMap._disable.length = 0;
	        this.vertexAttribMap._keys.length = 0;
	
	    },
	
	    /**
	     *  set a vertex array object.
	     *  return true if binded the vao and false
	     *  if was already binded
	     */
	    setVertexArrayObject: function ( vao ) {
	
	        if ( this._currentVAO !== vao ) {
	
	            this._extVAO.bindVertexArrayOES( vao );
	            this._currentVAO = vao;
	
	            // disable cache to force a re enable of array
	            if ( !vao ) this.clearVertexAttribCache();
	
	            // disable currentIndexVBO to force to bind indexArray from Geometry
	            // if there is a change of vao
	            this._currentIndexVBO = undefined;
	
	            return true;
	        }
	        return false;
	    },
	
	    setVertexAttribArray: function ( attrib, array, normalize ) {
	
	        var vertexAttribMap = this.vertexAttribMap;
	        vertexAttribMap._disable[ attrib ] = false;
	        var gl = this._graphicContext;
	        var binded = false;
	
	        if ( array.isDirty() ) {
	            array.bind( gl );
	            array.compile( gl );
	            binded = true;
	        }
	
	        var currentArray = vertexAttribMap[ attrib ];
	        if ( currentArray !== array ) {
	
	            if ( !binded ) {
	                array.bind( gl );
	            }
	
	            if ( !currentArray ) {
	                gl.enableVertexAttribArray( attrib );
	
	                // can be === false (so undefined check is important)
	                if ( currentArray === undefined )
	                    vertexAttribMap._keys.push( attrib );
	
	            }
	
	            vertexAttribMap[ attrib ] = array;
	            gl.vertexAttribPointer( attrib, array.getItemSize(), array.getType(), normalize, 0, 0 );
	        }
	    },
	
	
	    _getActiveUniformsFromProgramAttributes: function ( program, activeUniformsList ) {
	
	        var attributeMapStack = this.attributeMap;
	
	        var attributeKeys = program.getTrackAttributes().attributeKeys;
	
	        if ( attributeKeys.length > 0 ) {
	
	            for ( var i = 0, l = attributeKeys.length; i < l; i++ ) {
	
	                var key = attributeKeys[ i ];
	                var attributeStack = attributeMapStack[ key ];
	                if ( attributeStack === undefined ) {
	                    continue;
	                }
	
	                // we just need the uniform list and not the attribute itself
	                var attribute = attributeStack.globalDefault;
	                if ( attribute.getOrCreateUniforms === undefined ) {
	                    continue;
	                }
	
	                var uniformMap = attribute.getOrCreateUniforms();
	                var uniformKeys = uniformMap.getKeys();
	
	                for ( var a = 0, b = uniformKeys.length; a < b; a++ ) {
	                    activeUniformsList.push( uniformMap[ uniformKeys[ a ] ] );
	                }
	            }
	
	        }
	    },
	
	    _getActiveUniformsFromProgramTextureAttributes: function ( program, activeUniformsList ) {
	
	        var textureAttributeKeysList = program.getTrackAttributes().textureAttributeKeys;
	        if ( textureAttributeKeysList === undefined ) return;
	
	        for ( var unit = 0, nbUnit = textureAttributeKeysList.length; unit < nbUnit; unit++ ) {
	
	            var textureAttributeKeys = textureAttributeKeysList[ unit ];
	            if ( textureAttributeKeys === undefined ) continue;
	
	            var unitTextureAttributeList = this.textureAttributeMapList[ unit ];
	            if ( unitTextureAttributeList === undefined ) continue;
	
	            for ( var i = 0, l = textureAttributeKeys.length; i < l; i++ ) {
	                var key = textureAttributeKeys[ i ];
	
	                var attributeStack = unitTextureAttributeList[ key ];
	                if ( attributeStack === undefined ) {
	                    continue;
	                }
	                // we just need the uniform list and not the attribute itself
	                var attribute = attributeStack.globalDefault;
	                if ( attribute.getOrCreateUniforms === undefined ) {
	                    continue;
	                }
	                var uniformMap = attribute.getOrCreateUniforms();
	                var uniformMapKeys = uniformMap.getKeys();
	
	                for ( var a = 0, b = uniformMapKeys.length; a < b; a++ ) {
	                    activeUniformsList.push( uniformMap[ uniformMapKeys[ a ] ] );
	                }
	            }
	        }
	    },
	
	    _cacheUniformsForCustomProgram: function ( program, activeUniformsList ) {
	
	        this._getActiveUniformsFromProgramAttributes( program, activeUniformsList );
	
	        this._getActiveUniformsFromProgramTextureAttributes( program, activeUniformsList );
	
	        var gl = this._graphicContext;
	
	        // now we have a list on uniforms we want to track but we will filter them to use only what is needed by our program
	        // not that if you create a uniforms whith the same name of a tracked attribute, and it will override it
	        var uniformsFinal = new Map();
	
	        for ( var i = 0, l = activeUniformsList.length; i < l; i++ ) {
	            var u = activeUniformsList[ i ];
	            var uniformName = u.getName();
	            var loc = gl.getUniformLocation( program._program, uniformName );
	            if ( loc !== undefined && loc !== null ) {
	                uniformsFinal[ uniformName ] = u;
	            }
	        }
	        uniformsFinal.dirty();
	        program.trackUniforms = uniformsFinal;
	
	    },
	
	    _applyCustomProgramUniforms: ( function () {
	
	        var activeUniformsList = [];
	
	        return function ( program ) {
	
	            // custom program so we will iterate on uniform from the program and apply them
	            // but in order to be able to use Attribute in the state graph we will check if
	            // our program want them. It must be defined by the user
	
	            // first time we see attributes key, so we will keep a list of uniforms from attributes
	            activeUniformsList.length = 0;
	
	            // fill the program with cached active uniforms map from attributes and texture attributes
	            if ( program.getTrackAttributes() !== undefined && program.trackUniforms === undefined ) {
	                this._cacheUniformsForCustomProgram( program, activeUniformsList );
	            }
	
	            var programUniformMap = program.getUniformsCache();
	            var programUniformKeys = programUniformMap.getKeys();
	            var uniformMapStackContent = this.uniforms;
	
	            var programTrackUniformMap;
	            if ( program.trackUniforms )
	                programTrackUniformMap = program.trackUniforms;
	
	            var uniform;
	            for ( var i = 0, l = programUniformKeys.length; i < l; i++ ) {
	                var uniformKey = programUniformKeys[ i ];
	                var location = programUniformMap[ uniformKey ];
	                var uniformStack = uniformMapStackContent[ uniformKey ];
	
	                if ( uniformStack === undefined ) {
	
	                    if ( programTrackUniformMap !== undefined ) {
	                        uniform = programTrackUniformMap[ uniformKey ];
	                        if ( uniform !== undefined ) {
	                            uniform.apply( this._graphicContext, location );
	                        }
	                    }
	
	                } else {
	
	                    if ( uniformStack.values().length === 0 ) {
	                        uniform = uniformStack.globalDefault;
	                    } else {
	                        uniform = uniformStack.back().object;
	                    }
	                    uniform.apply( this._graphicContext, location );
	
	                }
	            }
	        };
	    } )(),
	
	
	    // apply a generated program if necessary
	    // It build a Shader from the shader generator
	    // it apply for the following condition
	    // the user has not put a Pogram in the stack or if he has he added one with OFF
	    _generateAndApplyProgram: function () {
	
	        var attributeMap = this.attributeMap;
	        if ( attributeMap.Program !== undefined && attributeMap.Program.values().length !== 0 && attributeMap.Program.back().value !== StateAttribute.OFF )
	            return undefined;
	
	        // no custom program look into the stack of ShaderGenerator name
	        // what we should use to generate a program
	
	        var last = this._shaderGeneratorNames.back();
	        var shaderGenerator = this._shaderGeneratorProxy.getShaderGenerator( last ? last.object : undefined );
	
	        var program = shaderGenerator.getOrCreateProgram( this );
	        this.applyAttribute( program );
	        return program;
	    },
	
	    _computeForeignUniforms: function ( programUniformMap, activeUniformMap ) {
	
	        var uniformMapKeys = programUniformMap.getKeys();
	        var uniformMap = programUniformMap;
	
	        var foreignUniforms = [];
	        for ( var i = 0, l = uniformMapKeys.length; i < l; i++ ) {
	
	            var name = uniformMapKeys[ i ];
	            var location = uniformMap[ name ];
	
	            if ( location !== undefined && activeUniformMap[ name ] === undefined ) {
	
	                // filter 'standard' uniform matrix that will be applied for all shader
	                if ( name !== this.modelViewMatrix.getName() &&
	                    name !== this.modelWorldMatrix.getName() &&
	                    name !== this.viewMatrix.getName() &&
	                    name !== this.projectionMatrix.getName() &&
	                    name !== this.normalMatrix.getName() &&
	                    name !== 'ArrayColorEnabled' ) {
	                    foreignUniforms.push( name );
	                }
	            }
	
	        }
	
	        return foreignUniforms;
	    },
	
	    _removeUniformsNotRequiredByProgram: function ( activeUniformMap, programUniformMap ) {
	
	        var activeUniformMapKeys = activeUniformMap.getKeys();
	
	        for ( var i = 0, l = activeUniformMapKeys.length; i < l; i++ ) {
	            var name = activeUniformMapKeys[ i ];
	            var location = programUniformMap[ name ];
	            if ( location === undefined || location === null ) {
	                delete activeUniformMap[ name ];
	                activeUniformMap.dirty();
	            }
	        }
	    },
	
	
	    _cacheUniformsForGeneratedProgram: function ( program ) {
	
	        var foreignUniforms = this._computeForeignUniforms( program.getUniformsCache(), program.getActiveUniforms() );
	        program.setForeignUniforms( foreignUniforms );
	
	
	        // remove uniforms listed by attributes (getActiveUniforms) but not required by the program
	        this._removeUniformsNotRequiredByProgram( program.getActiveUniforms(), program.getUniformsCache() );
	
	    },
	
	    _applyGeneratedProgramUniforms: function ( program ) {
	
	        // note that about TextureAttribute that need uniform on unit we would need to improve
	        // the current uniformList ...
	
	        // when we apply the shader for the first time, we want to compute the active uniforms for this shader and the list of uniforms not extracted from attributes called foreignUniforms
	
	        // typically the following code will be executed once on the first execution of generated program
	
	        var foreignUniformKeys = program.getForeignUniforms();
	        if ( !foreignUniformKeys ) {
	            this._cacheUniformsForGeneratedProgram( program );
	            foreignUniformKeys = program.getForeignUniforms();
	        }
	
	
	        var programUniformMap = program.getUniformsCache();
	        var activeUniformMap = program.getActiveUniforms();
	
	
	        // apply active uniforms
	        // caching uniforms from attribtues make it impossible to overwrite uniform with a custom uniform instance not used in the attributes
	        var i, l, name, location;
	        var activeUniformKeys = activeUniformMap.getKeys();
	
	        for ( i = 0, l = activeUniformKeys.length; i < l; i++ ) {
	
	            name = activeUniformKeys[ i ];
	            location = programUniformMap[ name ];
	            activeUniformMap[ name ].apply( this._graphicContext, location );
	
	        }
	
	        var uniformMapStack = this.uniforms;
	
	        // apply now foreign uniforms, it's uniforms needed by the program but not contains in attributes used to generate this program
	        for ( i = 0, l = foreignUniformKeys.length; i < l; i++ ) {
	
	            name = foreignUniformKeys[ i ];
	            var uniformStack = uniformMapStack[ name ];
	            location = programUniformMap[ name ];
	            var uniform;
	            if ( uniformStack !== undefined ) {
	                if ( uniformStack.values().length === 0 ) {
	                    uniform = uniformStack.globalDefault;
	                    Notify.warn( 'Uniform Default Not attached to a StateSet in Scene Hierarchy: ' + uniformStack.globalDefault.getName() );
	                } else {
	                    uniform = uniformStack.back().object;
	                }
	
	                uniform.apply( this._graphicContext, location );
	            }
	
	        }
	    }
	
	
	} ), 'osg', 'State' );
	
	module.exports = State;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Image = __webpack_require__( 36 );
	var Notify = __webpack_require__( 10 );
	var Texture = __webpack_require__( 34 );
	
	
	/**
	 * TextureCubeMap
	 * @class TextureCubeMap
	 * @inherits Texture
	 */
	var TextureCubeMap = function () {
	
	    Texture.call( this );
	    this._images = {};
	
	    // pre allocated all textures faces slots
	    for ( var i = 0; i < 6; i++ ) {
	        this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X + i ] = new Image();
	    }
	
	};
	
	/** @lends TextureCubeMap.prototype */
	TextureCubeMap.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Texture.prototype, {
	
	    setDefaultParameters: function () {
	        Texture.prototype.setDefaultParameters.call( this );
	        this._textureTarget = Texture.TEXTURE_CUBE_MAP;
	
	        this._flipY = false;
	    },
	
	    cloneType: function () {
	        return new TextureCubeMap();
	    },
	
	    setImage: function ( imageFace, img, imageFormat ) {
	
	        var face = imageFace;
	
	        if ( typeof face === 'string' )
	            face = Texture[ face ];
	
	        this._images[ face ].setImage( img, imageFormat );
	
	        this.setImageFormat( imageFormat );
	        this.setTextureSize( this._images[ face ].getWidth(), this._images[ face ].getHeight() );
	
	        this._textureNull = false;
	        this.dirty();
	    },
	
	    getImage: function ( face ) {
	        return this._images[ face ].getImage();
	    },
	
	    initCubemapContent: function ( gl ) {
	
	        var internalFormat = this._internalFormat;
	
	        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );
	
	        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );
	
	        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );
	
	        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );
	
	        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );
	
	        this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, internalFormat, this._textureWidth, this._textureHeight, 0, internalFormat, this._type, null );
	
	        return true;
	    },
	
	    // handle mipmap logic, if images for mipmap are provided or not
	    generateMipmap: function ( gl, target ) {
	
	        if ( !this.hasMipmapFilter() ) return;
	
	        // manual mipmap provided
	        if ( this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X ].hasMipmap() ) {
	
	            for ( var face = 0; face < 6; face++ ) {
	                var faceImage = this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X + face ];
	                if ( !faceImage.hasMipmap() ) {
	                    Notify.error( 'mipmap not set correctly for TextureCubemap' );
	                }
	
	                var internalFormat = this._internalFormat;
	                for ( var level = 1; level < faceImage.getMipmap().length; level++ ) {
	                    var size = faceImage.getMipmap()[ level ].getWidth();
	
	                    this.applyTexImage2D( gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, level, internalFormat, size, size, 0, internalFormat, this._type, faceImage.getMipmap()[ level ].getImage() );
	                }
	            }
	
	        } else {
	
	            // automatic mipmap
	            gl.generateMipmap( target );
	        }
	
	        this._dirtyMipmap = false;
	    },
	
	    applyImageTarget: function ( gl, internalFormat, target ) {
	
	        var faceImage = this._images[ target ];
	
	        if ( !faceImage.getImage() ) return 0;
	
	        if ( !faceImage.isReady() ) return 0;
	
	        if ( !faceImage.isDirty() ) return 1;
	
	        this.setTextureSize( faceImage.getWidth(), faceImage.getHeight() );
	
	        faceImage.setDirty( false );
	
	        if ( faceImage.isTypedArray() ) {
	            this.applyTexImage2D( gl,
	                target,
	                0,
	                internalFormat,
	                this._textureWidth,
	                this._textureHeight,
	                0,
	                internalFormat,
	                this._type,
	                faceImage.getImage() );
	        } else {
	            this.applyTexImage2D( gl,
	                target,
	                0,
	                internalFormat,
	                internalFormat,
	                this._type,
	                faceImage.getImage() );
	        }
	
	        // release here only if no mipmap
	        if ( this._unrefImageDataAfterApply &&
	            !( this.hasMipmap() && faceImage.hasMipmap() ) ) {
	
	            faceImage.release();
	        }
	
	        return 1;
	    },
	
	    initCubemapContentImage: function ( gl ) {
	
	        var internalFormat = this._internalFormat;
	        var valid = 0;
	        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_X );
	        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_X );
	
	        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_Y );
	        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y );
	
	        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_Z );
	        valid += this.applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z );
	
	        if ( valid === 6 )
	            return true;
	
	        return false;
	    },
	
	    apply: function ( state ) {
	
	        var gl = state.getGraphicContext();
	        // if need to release the texture
	        if ( this._dirtyTextureObject )
	            this.releaseGLObjects();
	
	        if ( this._textureObject !== undefined && !this.isDirty() ) {
	            this._textureObject.bind( gl );
	
	            // If we have modified the texture via Rtt or texSubImage2D and _need_ updated mipmaps,
	            // then we must regenerate the mipmaps explicitely.
	            // In all other cases, don't set this flag because it can be costly
	            if ( this.isDirtyMipmap() ) {
	                this.generateMipmap( gl, this._textureTarget );
	            }
	
	        } else if ( this._textureNull ) {
	
	            gl.bindTexture( this._textureTarget, null );
	
	        } else {
	
	            if ( !this._textureObject ) {
	
	                // must be called before init
	                this.computeTextureFormat();
	
	                this.init( state );
	            }
	            this._textureObject.bind( gl );
	
	            var valid;
	
	            // no images it's must be a cubemap filled from rtt
	            if ( !this._images[ Texture.TEXTURE_CUBE_MAP_POSITIVE_X ].getImage() ) {
	
	                valid = this.initCubemapContent( gl );
	
	            } else {
	
	                valid = this.initCubemapContentImage( gl );
	
	            }
	
	            if ( valid ) {
	                this._dirty = false;
	                this.applyFilterParameter( gl, this._textureTarget );
	                this.generateMipmap( gl, this._textureTarget );
	            }
	        } // render to cubemap not yet implemented
	    }
	
	} ), 'osg', 'TextureCubeMap' );
	
	MACROUTILS.setTypeID( TextureCubeMap );
	
	module.exports = TextureCubeMap;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	
	
	var UpdateVisitor = function () {
	    NodeVisitor.call( this );
	    this.visitorType = NodeVisitor.UPDATE_VISITOR;
	    this._numUpdateCallback = 0;
	};
	
	UpdateVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	
	    resetStats: function () {
	        this._numUpdateCallback = 0;
	    },
	
	    apply: function ( node ) {
	
	        // a way to avoid extra call is to implement getNumChildrenRequiringUpdateTraversal
	        // and stateset.requiresUpdateTraversal()
	
	
	        // handle callback in stateset
	        var stateSet = node.getStateSet();
	        if ( stateSet ) {
	            var updateCallbackList = stateSet.getUpdateCallbackList();
	
	            var numStateSetUpdateCallback = updateCallbackList.length;
	            if ( numStateSetUpdateCallback )
	                this._numUpdateCallback += numStateSetUpdateCallback;
	            for ( var i = 0, l = numStateSetUpdateCallback; i < l; i++ )
	                updateCallbackList[ i ].update( stateSet, this );
	        }
	
	        // handle callback in nodes
	        var ncs = node.getUpdateCallbackList();
	        var numUpdateCallback = ncs.length;
	        if ( numUpdateCallback )
	            for ( var j = 0, m = numUpdateCallback; j < m; j++ ) {
	                this._numUpdateCallback++;
	                if ( !ncs[ j ].update( node, this ) ) {
	                    return;
	                }
	            }
	
	        this.traverse( node );
	    }
	} );
	
	module.exports = UpdateVisitor;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	var Matrix = __webpack_require__( 23 );
	
	
	var Viewport = function ( x, y, w, h ) {
	    StateAttribute.call( this );
	
	    this._x = x !== undefined ? x : 0;
	    this._y = y !== undefined ? y : 0;
	    this._width = w !== undefined ? w : 800;
	    this._height = h !== undefined ? h : 600;
	};
	
	Viewport.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'Viewport',
	
	    cloneType: function () {
	        return new Viewport();
	    },
	
	    apply: function ( state ) {
	        var gl = state.getGraphicContext();
	        gl.viewport( this._x, this._y, this._width, this._height );
	    },
	
	    setViewport: function ( x, y, width, height ) {
	        this._x = x;
	        this._y = y;
	        this._width = width;
	        this._height = height;
	    },
	
	    x: function () {
	        return this._x;
	    },
	
	    y: function () {
	        return this._y;
	    },
	
	    width: function () {
	        return this._width;
	    },
	
	    height: function () {
	        return this._height;
	    },
	
	    computeWindowMatrix: ( function () {
	        var translate = Matrix.create();
	        var scale = Matrix.create();
	        return function ( destination ) {
	            // res = Matrix offset * Matrix scale * Matrix translate
	            Matrix.makeTranslate( 1.0, 1.0, 1.0, translate );
	            Matrix.makeScale( 0.5 * this._width, 0.5 * this._height, 0.5, scale );
	            var offset = Matrix.makeTranslate( this._x, this._y, 0.0, destination );
	            //return Matrix.mult(Matrix.mult(translate, scale, translate), offset, offset);
	
	            return Matrix.preMult( offset, Matrix.preMult( scale, translate ) );
	
	        };
	    } )()
	
	} ), 'osg', 'Viewport' );
	
	module.exports = Viewport;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	
	// use EXT_disjoint_timer_query
	// to time webgl calls GPU side
	// average over multiple frames
	// for consistent results
	// use double buffer queries for that.
	// see http://www.reedbeta.com/blog/2011/10/12/gpu-profiling-101/
	var TimerGPU = function ( gl ) {
	
	    this._enabled = false;
	
	    if ( gl ) {
	
	        var ext = gl.getExtension( 'EXT_disjoint_timer_query' );
	        if ( !ext ) return this;
	
	        // https://github.com/KhronosGroup/WebGL/blob/master/sdk/tests/conformance/extensions/ext-disjoint-timer-query.html#L102
	        // run the page if strange results
	        // to validate you gpu/browser has correct gpu queries support
	        this._hasTimeElapsed = ext.getQueryEXT( ext.TIME_ELAPSED_EXT, ext.QUERY_COUNTER_BITS_EXT ) >= 30;
	        this._hasTimeStamp = ext.getQueryEXT( ext.TIMESTAMP_EXT, ext.QUERY_COUNTER_BITS_EXT ) >= 30;
	
	        if ( !this._hasTimeElapsed && !this._hasTimeStamp ) {
	            return this;
	        }
	
	        // no timestamp means not start/end absolute time
	        // which means each start must be followed by a end
	        // BEFORE any other start (of other queryID)
	        if ( !this._hasTimeStamp ) {
	            Notify.warn( 'Warning: do not use interleaved GPU query' );
	        }
	
	        this._gl = gl;
	        this._glTimer = ext;
	        this._enabled = true;
	
	    }
	
	    // those we seek results of
	    // (all query per frame)
	    // double Buffered
	    this._pollingStartQueries = {};
	    this._pollingEndQueries = {};
	    // query list currently recording
	    // between a start and a end query
	    this._runningQueries = {};
	    // number of query asked (current index query per queryID)
	    this._timingCountQuery = {};
	    // number of query answered with results
	    this._resultCountQuery = {};
	    // cumulative average
	    this._averageTimerQuery = {};
	    // query waiting async results from GPU
	    this._waitingQueries = {};
	    // cumulative average on N frame
	    // reset & restart every N frames
	    this._frameAverageCount = 30;
	};
	
	TimerGPU.instance = function ( gl ) {
	
	    if ( !TimerGPU._instance ) {
	        TimerGPU._instance = new TimerGPU( gl );
	    } else if ( gl && TimerGPU._instance.getContext() !== gl ) {
	        TimerGPU._instance.setContext( gl );
	    }
	    return TimerGPU._instance;
	
	};
	
	TimerGPU.prototype = {
	
	    getContext: function () {
	        return this._gl;
	    },
	    setContext: function ( gl ) {
	        this._gl = gl;
	    },
	    setFrameAverageCount: function ( val ) {
	        this._frameAverageCount = val;
	    },
	
	    // when timing same thing
	    // but under new conditions
	    reset: function ( queryID ) {
	
	        this._timingCountQuery[ queryID ] = 0;
	        this._averageTimerQuery[ queryID ] = 0.0;
	        this._resultCountQuery[ queryID ] = 0;
	
	    },
	
	    supportInterleaveQuery: function () {
	        return this._hasTimeStamp;
	    },
	
	    // many browser doesn't yet have
	    // the marvellous gpu timers
	    enable: function () {
	        // enable only if we have the extension
	        this._enabled = this._glTimer;
	    },
	
	    disable: function () {
	        this._enabled = false;
	    },
	    isEnabled: function () {
	        return this._enabled;
	    },
	
	    setCallback: function ( cb ) {
	        this._callback = cb;
	    },
	
	    // start recording time
	    // if query already exist, don't recreate
	    start: function ( queryID ) {
	
	        // If timing currently disabled or glTimer does not exist, exit early.
	        if ( !this._enabled ) {
	            return undefined;
	        }
	
	
	        if ( !this._timingCountQuery[ queryID ] ) {
	
	            this._resultCountQuery[ queryID ] = 0;
	            this._timingCountQuery[ queryID ] = 0;
	            this._averageTimerQuery[ queryID ] = 0.0;
	            this._pollingStartQueries[ queryID ] = {};
	            this._pollingEndQueries[ queryID ] = {};
	            this._waitingQueries[ queryID ] = [];
	
	        } else {
	
	            // poll glTimer for data for last frames queries
	            this.pollQueriesData( queryID );
	        }
	
	        var pollIndex = this._timingCountQuery[ queryID ];
	
	        var startQuery = this._glTimer.createQueryEXT();
	        this._pollingStartQueries[ queryID ][ pollIndex ] = startQuery;
	
	        if ( this._hasTimeStamp ) {
	
	            var endQuery = this._glTimer.createQueryEXT();
	            this._pollingEndQueries[ queryID ][ pollIndex ] = endQuery;
	
	            this._glTimer.queryCounterEXT( startQuery, this._glTimer.TIMESTAMP_EXT );
	
	        } else {
	
	            this._glTimer.beginQueryEXT( this._glTimer.TIME_ELAPSED_EXT, startQuery );
	        }
	
	        this._runningQueries[ queryID ] = startQuery;
	
	        return startQuery;
	
	    },
	    /*
	     * stop query recording   (if running)
	     * polls for results
	     */
	    end: function ( queryID ) {
	
	        if ( !this._enabled ) {
	            return;
	        }
	
	
	
	        var query = this._runningQueries[ queryID ];
	
	        // End currently running query
	        if ( query ) {
	
	            var pollIndex = this._timingCountQuery[ queryID ];
	
	            if ( this._hasTimeStamp ) {
	
	                var endQuery = this._pollingEndQueries[ queryID ][ pollIndex ];
	                this._glTimer.queryCounterEXT( endQuery, this._glTimer.TIMESTAMP_EXT );
	
	            } else {
	
	                this._glTimer.endQueryEXT( this._glTimer.TIME_ELAPSED_EXT );
	
	            }
	            this._runningQueries[ queryID ] = undefined;
	
	            // number of finished queries per ID increments.
	            this._timingCountQuery[ queryID ]++;
	
	            this._waitingQueries[ queryID ].push( pollIndex );
	
	        }
	
	    },
	
	
	    // results are async
	    pollQueryData: function ( queryID, pollIndex ) {
	
	        // last to be queried
	        var lastQuery = this._hasTimeStamp ? this._pollingEndQueries[ queryID ][ pollIndex ] : this._pollingStartQueries[ queryID ][ pollIndex ];
	
	        // wait till results are ready
	        var available = this._glTimer.getQueryObjectEXT( lastQuery, this._glTimer.QUERY_RESULT_AVAILABLE_EXT );
	
	        if ( !available ) return null;
	
	        var disjoint = this._gl.getParameter( this._glTimer.GPU_DISJOINT_EXT );
	
	        if ( disjoint ) return null;
	
	
	        var timeElapsed;
	
	        if ( this._hasTimeStamp ) {
	
	            var startQuery = this._pollingStartQueries[ queryID ][ pollIndex ];
	
	            var startTime = this._glTimer.getQueryObjectEXT( startQuery, this._glTimer.QUERY_RESULT_EXT );
	            var endTime = this._glTimer.getQueryObjectEXT( lastQuery, this._glTimer.QUERY_RESULT_EXT );
	            timeElapsed = endTime - startTime;
	
	            //free slots
	            this._glTimer.deleteQueryEXT( lastQuery );
	            this._pollingEndQueries[ queryID ][ pollIndex ] = undefined;
	            this._glTimer.deleteQueryEXT( startQuery );
	            this._pollingStartQueries[ queryID ][ pollIndex ] = undefined;
	
	        } else {
	
	            timeElapsed = this._glTimer.getQueryObjectEXT( lastQuery, this._glTimer.QUERY_RESULT_EXT );
	
	            //free slots
	            this._glTimer.deleteQueryEXT( lastQuery );
	            this._pollingStartQueries[ queryID ][ pollIndex ] = undefined;
	
	        }
	
	
	        if ( timeElapsed === 0 ) return undefined;
	
	
	        this._resultCountQuery[ queryID ]++;
	
	        // store results
	        var lastTime = this._averageTimerQuery[ queryID ];
	        var resultCount = this._resultCountQuery[ queryID ];
	
	        // restart cumulative average every frameAveragecount frames
	        if ( resultCount > this._frameAverageCount ) {
	
	            this.reset( queryID );
	            // we have one result
	            this._resultCountQuery[ queryID ]++;
	            lastTime = 0;
	
	        }
	
	
	        var cumulativeAverage;
	        if ( lastTime === 0 ) {
	            cumulativeAverage = timeElapsed;
	        } else {
	            // https://en.wikipedia.org/wiki/Moving_average#Cumulative_moving_average
	            cumulativeAverage = lastTime + ( ( timeElapsed - lastTime ) / ( resultCount ) );
	        }
	        this._averageTimerQuery[ queryID ] = cumulativeAverage;
	
	        return cumulativeAverage;
	
	    },
	
	    // results are async
	    pollQueriesData: function ( queryID ) {
	
	        var average;
	        var self = this;
	        var queries = this._waitingQueries[ queryID ];
	
	        queries = queries.filter( function ( pollIndex ) {
	
	            // check if result ready
	            var res = self.pollQueryData( queryID, pollIndex );
	
	            // not ready we keep it in waiting queue
	            if ( res === null ) return true;
	            // ready, but discarded
	            if ( res === undefined ) return false;
	
	            average = res;
	            // remove from waiting queue
	            return false;
	
	        } );
	        this._waitingQueries[ queryID ] = queries;
	
	        // only bother client side if we have results
	        if ( average !== undefined && this._callback ) {
	            this._callback( average, queryID );
	        }
	    }
	
	};
	
	
	module.exports = TimerGPU;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Animation = __webpack_require__( 110 );
	var SkinningAttribute = __webpack_require__( 84 );
	var AnimationUpdateCallback = __webpack_require__( 77 );
	var BasicAnimationManager = __webpack_require__( 114 );
	var Bone = __webpack_require__( 74 );
	var Channel = __webpack_require__( 111 );
	var CollectAnimationUpdateCallbackVisitor = __webpack_require__( 116 );
	var Easing = __webpack_require__( 118 );
	var Interpolator = __webpack_require__( 115 );
	var MorphAttribute = __webpack_require__( 80 );
	var MorphGeometry = __webpack_require__( 79 );
	var RigGeometry = __webpack_require__( 78 );
	var Skeleton = __webpack_require__( 72 );
	var StackedMatrix = __webpack_require__( 119 );
	var StackedQuaternion = __webpack_require__( 120 );
	var StackedRotateAxis = __webpack_require__( 121 );
	var StackedScale = __webpack_require__( 122 );
	var StackedTranslate = __webpack_require__( 123 );
	var UpdateBone = __webpack_require__( 75 );
	var UpdateMatrixTransform = __webpack_require__( 76 );
	var UpdateMorph = __webpack_require__( 117 );
	var UpdateSkeleton = __webpack_require__( 73 );
	
	
	var osgAnimation = {};
	
	MACROUTILS.objectMix( osgAnimation, Easing );
	MACROUTILS.objectMix( osgAnimation, Interpolator );
	osgAnimation.Animation = Animation;
	osgAnimation.SkinningAttribute = SkinningAttribute;
	osgAnimation.AnimationUpdateCallback = AnimationUpdateCallback;
	osgAnimation.BasicAnimationManager = BasicAnimationManager;
	osgAnimation.Bone = Bone;
	osgAnimation.Channel = Channel;
	osgAnimation.CollectAnimationUpdateCallbackVisitor = CollectAnimationUpdateCallbackVisitor;
	osgAnimation.MorphAttribute = MorphAttribute;
	osgAnimation.MorphGeometry = MorphGeometry;
	osgAnimation.RigGeometry = RigGeometry;
	osgAnimation.Skeleton = Skeleton;
	osgAnimation.StackedMatrix = StackedMatrix;
	osgAnimation.StackedQuaternion = StackedQuaternion;
	osgAnimation.StackedRotateAxis = StackedRotateAxis;
	osgAnimation.StackedScale = StackedScale;
	osgAnimation.StackedTranslate = StackedTranslate;
	osgAnimation.UpdateBone = UpdateBone;
	osgAnimation.UpdateMatrixTransform = UpdateMatrixTransform;
	osgAnimation.UpdateMorph = UpdateMorph;
	osgAnimation.UpdateSkeleton = UpdateSkeleton;
	
	module.exports = osgAnimation;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Channel = __webpack_require__( 111 );
	
	
	// create Animation data
	// Animation {
	//     channels: [],
	//     duration: 0.0;
	//     name: string
	// },
	
	var animationCount = 0;
	
	// assume that iniChannel has been called
	// on each channel
	var createAnimation = function ( channels, name ) {
	
	    var min = Infinity;
	    var max = -Infinity;
	    for ( var i = 0; i < channels.length; i++ ) {
	        min = Math.min( min, channels[ i ].start );
	        max = Math.max( max, channels[ i ].end );
	    }
	
	    var duration = max - min;
	    var animationName = name || ( 'animation' + animationCount.toString() );
	    animationCount++;
	    return {
	        channels: channels,
	        duration: duration,
	        name: animationName,
	        start: min
	    };
	};
	
	// create instance Animation data. An instance animation
	// contains instance channels instead of original channels
	// Animation {
	//     channels: [],
	//     duration: 0.0;
	//     start: 0.0, // used to know when an animation has been started
	//     name: string
	// },
	var createInstanceAnimation = function ( animation ) {
	
	    var channels = [];
	    for ( var i = 0; i < animation.channels.length; i++ ) {
	        var channel = Channel.createInstanceChannel( animation.channels[ i ] );
	        channels.push( channel );
	    }
	
	    return {
	        channels: channels,
	        duration: animation.duration,
	        start: 0.0,
	        name: animation.name,
	        firstKeyTime: animation.start
	    };
	};
	
	
	var Animation = function () {};
	
	Animation.createAnimation = createAnimation;
	Animation.createInstanceAnimation = createInstanceAnimation;
	
	module.exports = Animation;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var Quat = __webpack_require__( 26 );
	var Target = __webpack_require__( 112 );
	var channelType = __webpack_require__( 113 );
	
	
	var Channel = {};
	
	// channel {
	//     keys: [],
	//     times: [],
	//     type: enum,
	//     target: targetName
	// }
	// init a channel with extra field
	// start, end, duration
	var initChannel = function ( type, keys, times, targetName, channelName, channel ) {
	    var start = times[ 0 ];
	    var end = times[ times.length - 1 ];
	    channel.start = start;
	    channel.keys = keys;
	    channel.end = end;
	    channel.times = times;
	    channel.type = type;
	    channel.duration = end - start;
	    channel.target = targetName;
	    channel.name = channelName;
	    return channel;
	};
	
	var createVec3Channel = function ( keys, times, targetName, channelName, chan ) {
	    return initChannel( channelType.Vec3, keys, times, targetName, channelName, chan || {} );
	};
	
	var createFloatChannel = function ( keys, times, targetName, channelName, chan ) {
	    return initChannel( channelType.Float, keys, times, targetName, channelName, chan || {} );
	};
	
	var createQuatChannel = function ( keys, times, targetName, channelName, chan ) {
	    return initChannel( channelType.Quat, keys, times, targetName, channelName, chan || {} );
	};
	
	var createQuatSlerpChannel = function ( keys, times, targetName, channelName, chan ) {
	    return initChannel( channelType.QuatSlerp, keys, times, targetName, channelName, chan || {} );
	};
	
	var createFloatCubicBezierChannel = function ( keys, times, targetName, channelName, chan ) {
	    return initChannel( channelType.FloatCubicBezier, keys, times, targetName, channelName, chan || {} );
	};
	
	var createVec3CubicBezierChannel = function ( keys, times, targetName, channelName, chan ) {
	    return initChannel( channelType.Vec3CubicBezier, keys, times, targetName, channelName, chan || {} );
	};
	
	
	
	// channel contains {
	//     keys: [],
	//     times: [],
	//     start: 0.0,
	//     end: 1.0,
	// }
	// return {
	//     channel: channel,
	//     value: Vec3.create(),
	//     targetID: int,
	//     key: 0,
	//     t: 0, //global start time
	// }
	
	var Float = {
	    create: function () {
	        return 0;
	    }
	};
	
	var createInstanceChannelType = function ( operator, channel ) {
	    return {
	        channel: channel,
	        value: operator.create(),
	        targetID: Target.InvalidTargetID,
	        weight: 1.0,
	        key: 0,
	        start: 0.0,
	        end: 0.0
	    };
	};
	
	var createInstanceVec3Channel = function ( channel ) {
	    return createInstanceChannelType( Vec3, channel );
	};
	
	var createInstanceQuatChannel = function ( channel ) {
	    return createInstanceChannelType( Quat, channel );
	};
	
	var createInstanceFloatChannel = function ( channel ) {
	    return createInstanceChannelType( Float, channel );
	};
	
	var createInstanceFloatCubicBezierChannel = function ( channel ) {
	    return createInstanceChannelType( Float, channel );
	};
	
	var createInstanceVec3CubicBezierChannel = function ( channel ) {
	    return createInstanceChannelType( Vec3, channel );
	};
	
	
	// create an instance channel from type
	var createInstanceChannel = function ( channel ) {
	    return Channel[ channel.type ]( channel );
	};
	
	// animations instances
	/*
	
	 |-----------------| anim0 (channel0_0, channel0_1 )
	           |--------------| anim1 (channel1_0, channel1_1, channel1_2 )
	
	 // si triage a cause de la priorit√©
	 // iterate on priority
	 // and for animations of the same priority
	
	
	 // init d'une animation
	
	 // init du manager
	 //   createInstanceAnimation pour chaque animations
	 //      createInstanceChannels pour chaque animation
	
	 //   initChannelTargetID pour toute les animations du manager
	 //      id -> targetName
	
	
	
	
	 // get target for an animation to push on target list ( to blend )
	 var targets = {};
	 for ( var i = 0 ; i < channels.length; i++ ) {
	    var target = channels[i].target;
	    targets[target].push( channels[i] );
	 }
	
	
	 // pour l'instant on ignore les pb d'organisation de priorit√©
	 //
	 // target X : [
	 //      ChannelAnima0_0
	 //      ChannelAnima1_0
	 // ]
	
	 // target Y : [
	 //      ChannelAnima0_1
	 //      ChannelAnima1_1
	 // ]
	
	
	 */
	
	
	// for a target compute each channel contribution
	// channel0, value0, w, priority0
	// channel1, value1, w, priority0
	// channel2, value2, w, priority0
	
	
	// channel0, value0, w, priority1
	// channel1, value1, w, priority1
	// channel2, value2, w, priority1
	
	/*
	
	 var value;
	 Copy( channels[0].value, value );
	 var weight = 0.0;
	 var priority = channels[0].priority;
	 var priorityWeight = channels[0].weight;
	
	 for ( var i = 1; i < channels.length; i++ ) {
	
	     if ( priority !== channels[i].priority ) {
	          weight += priorityWeight * ( 1.0 - weight );
	          priorityWeight = 0.0;
	          priority = channels[i].priority;
	     }
	
	     priorityWeight += weight;
	     t = ( 1.0 - weight ) * channels[i].weight / priorityWeight;
	     lerp( t, value, channels[i].value );
	 }
	
	
	 // second version
	
	 var value;
	 Copy( channels[0].value, value );
	 var weight = 0; //channels[0].weight;
	 //var priority = channels[0].priority;
	 var priorityWeight = 0;
	
	 for ( var i = 0; i < channels.length; i++ ) {
	
	     if ( priority !== channels[i].priority ) {
	          weight += priorityWeight * ( 1.0 - weight );
	          priorityWeight = 0.0;
	          priority = channels[i].priority;
	     }
	
	     priorityWeight += weight;
	     t = ( 1.0 - weight ) * channels[i].weight / priorityWeight;
	     lerp( t, value, channels[i].value );
	 }
	
	
	
	 */
	
	Channel.createInstanceChannel = createInstanceChannel;
	Channel.createInstanceVec3Channel = createInstanceVec3Channel;
	Channel.createInstanceQuatChannel = createInstanceQuatChannel;
	Channel.createInstanceQuatSlerpChannel = createInstanceQuatChannel;
	Channel.createInstanceFloatChannel = createInstanceFloatChannel;
	Channel.createInstanceFloatCubicBezierChannel = createInstanceFloatCubicBezierChannel;
	Channel.createInstanceVec3CubicBezierChannel = createInstanceVec3CubicBezierChannel;
	
	Channel.createVec3Channel = createVec3Channel;
	Channel.createQuatChannel = createQuatChannel;
	Channel.createQuatSlerpChannel = createQuatSlerpChannel;
	Channel.createFloatChannel = createFloatChannel;
	Channel.createFloatCubicBezierChannel = createFloatCubicBezierChannel;
	Channel.createVec3CubicBezierChannel = createVec3CubicBezierChannel;
	
	Channel[ channelType.Vec3 ] = createInstanceVec3Channel;
	Channel[ channelType.Quat ] = createInstanceQuatChannel;
	Channel[ channelType.QuatSlerp ] = createInstanceQuatChannel;
	Channel[ channelType.Float ] = createInstanceFloatChannel;
	Channel[ channelType.FloatCubicBezier ] = createInstanceFloatCubicBezierChannel;
	Channel[ channelType.Vec3CubicBezier ] = createInstanceVec3CubicBezierChannel;
	
	Channel.ChannelType = channelType;
	
	
	module.exports = Channel;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Matrix = __webpack_require__( 23 );
	var Quat = __webpack_require__( 26 );
	var Vec3 = __webpack_require__( 15 );
	var channelType = __webpack_require__( 113 );
	
	
	var target = {};
	target.InvalidTargetID = -1;
	
	// defaultValue is used when no channels affect the value
	var createTarget = function ( type, value, defaultValue ) {
	    return {
	        type: type,
	        id: target.InvalidTargetID, // -1 means no id assigned yet
	        channels: [],
	        value: value,
	        defaultValue: defaultValue
	    };
	};
	
	var createQuatTarget = function ( defaultValue ) {
	    return createTarget( channelType.Quat,
	        Quat.copy( defaultValue, Quat.create() ),
	        Quat.copy( defaultValue, Quat.create() ) );
	};
	
	var createMatrixTarget = function ( defaultValue ) {
	    return createTarget( channelType.Matrix,
	        Matrix.copy( defaultValue, Matrix.create() ),
	        Matrix.copy( defaultValue, Matrix.create() ) );
	};
	
	var createVec3Target = function ( defaultValue ) {
	    return createTarget( channelType.Vec3,
	        Vec3.copy( defaultValue, Vec3.create() ),
	        Vec3.copy( defaultValue, Vec3.create() ) );
	};
	
	var createFloatTarget = function ( defaultValue ) {
	    return createTarget( channelType.Float,
	        defaultValue,
	        defaultValue );
	};
	
	target.createQuatTarget = createQuatTarget;
	target.createVec3Target = createVec3Target;
	target.createFloatTarget = createFloatTarget;
	target.createMatrixTarget = createMatrixTarget;
	
	module.exports = target;


/***/ }),
/* 113 */
/***/ (function(module, exports) {

	'use strict';
	
	// must be sync wiht Interpolator Type
	module.exports = {
	    Vec3: 0,
	    Quat: 1,
	    Float: 2,
	    FloatCubicBezier: 3,
	    Vec3CubicBezier: 4,
	    QuatSlerp: 5,
	    Matrix: 6,
	    Count: 7
	};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var BaseObject = __webpack_require__( 13 );
	var Quat = __webpack_require__( 26 );
	var Vec3 = __webpack_require__( 15 );
	var Matrix = __webpack_require__( 23 );
	var Channel = __webpack_require__( 111 );
	var Animation = __webpack_require__( 110 );
	var Interpolator = __webpack_require__( 115 );
	var CollectAnimationUpdateCallbackVisitor = __webpack_require__( 116 );
	var Target = __webpack_require__( 112 );
	var UpdateMorph = __webpack_require__( 117 );
	
	
	var Float = {
	    lerp: function ( t, a, b ) {
	        return a + ( b - a ) * t;
	    },
	    init: function () {
	        return 0.0;
	    },
	    copy: function ( src ) {
	        return src;
	    },
	    create: function () {
	        return 0.0;
	    }
	};
	
	var TypeToSize = [];
	TypeToSize[ Channel.ChannelType.Float ] = 1;
	TypeToSize[ Channel.ChannelType.FloatCubicBezier ] = 1;
	TypeToSize[ Channel.ChannelType.Vec3 ] = 3;
	TypeToSize[ Channel.ChannelType.Vec3CubicBezier ] = 3;
	TypeToSize[ Channel.ChannelType.Quat ] = 4;
	TypeToSize[ Channel.ChannelType.QuatSlerp ] = 4;
	TypeToSize[ Channel.ChannelType.Matrix ] = 16;
	
	
	var ResultType = [];
	ResultType.length = Channel.ChannelType.Count;
	ResultType[ Channel.ChannelType.Vec3 ] = Vec3;
	ResultType[ Channel.ChannelType.Quat ] = Quat;
	ResultType[ Channel.ChannelType.QuatSlerp ] = Quat;
	ResultType[ Channel.ChannelType.Float ] = Float;
	ResultType[ Channel.ChannelType.FloatCubicBezier ] = Float;
	ResultType[ Channel.ChannelType.Vec3CubicBezier ] = Vec3;
	ResultType[ Channel.ChannelType.Matrix ] = Matrix;
	
	/**
	 *  BasicAnimationManager
	 *  @class BasicAnimationManager
	 */
	var BasicAnimationManager = function () {
	    BaseObject.call( this );
	
	    this._simulationTime = 0.0;
	    this._pauseTime = 0.0;
	    this._timeFactor = 1.0;
	    this._startTime = 0.0;
	
	    // contains a map with instance animations
	    this._instanceAnimations = {};
	
	    // animations to start
	    this._startAnimations = {};
	
	    // target contains an array of all target for this manager
	    // index in the array is used as ID
	    // see Animation.createTarget
	    // [
	    //     { id: 0,
	    //       channels: [],
	    //       value: 0.0,
	    //       defaultValue: 0.0,
	    //       type
	    //     },
	    //     ...
	    // ];
	    this._targets = [];
	    this._targetsMap = {};
	
	    // target id with active lists
	    // [
	    //   Vec3: [ targetID0, targetID1 ]
	    //   Quat: [ targetID2, targetID3,  ... ]
	    //   Float: [ ... ]
	    // ]
	    this._targetsByTypes = [];
	    this._targetsByTypes.length = Channel.ChannelType.Count;
	    for ( var i = 0, ni = this._targetsByTypes.length; i < ni; i++ ) {
	        this._targetsByTypes[ i ] = [];
	    }
	
	    // current playing animations
	    this._activeAnimations = {};
	    this._activeAnimationList = [];
	
	    // current actives channels by types
	    //   [ chanel0, channel1, ... ] // Vec3 type
	    //   [ chanel2, channel3, ... ] // Quat type
	    //   [ chanel5, channel6, ... ] // Float type
	    this._activeChannelsByTypes = [];
	    this._activeChannelsByTypes.length = Channel.ChannelType.Count;
	    for ( var j = 0, nj = this._activeChannelsByTypes.length; j < nj; j++ ) {
	        this._activeChannelsByTypes[ j ] = [];
	    }
	
	    // assign all target/channel in animationCallback
	    // then they can read it directly
	    // animation callback to update
	    this._animationsUpdateCallback = {};
	    this._animationsUpdateCallbackArray = [];
	
	    // queue of animations to register
	    this._animationsToRegister = [];
	
	    //Pause status (true / false)
	    this._pause = false;
	
	    this._dirty = false;
	
	    this._seekTime = -1;
	};
	
	BasicAnimationManager.prototype = MACROUTILS.objectInherit( BaseObject.prototype, {
	
	    init: function ( animations ) {
	
	        // reset all
	        this._simulationTime = 0.0;
	        this._pauseTime = 0.0;
	        this._timeFactor = 1.0;
	        this._startTime = 0.0;
	
	        // contains a map with instance animations
	        this._instanceAnimations = {};
	
	        // animations to start
	        this._startAnimations = {};
	
	        this._resetTargets();
	
	        this._activeAnimations = {};
	        this._activeAnimationList.length = 0;
	
	        for ( var i = 0, ni = this._activeChannelsByTypes.length; i < ni; i++ )
	            this._activeChannelsByTypes[ i ].length = 0;
	
	        this._animationsUpdateCallback = {};
	        this._animationsUpdateCallbackArray.length = 0;
	
	        this._pause = false;
	        this._seekTime = -1;
	
	        // add animations
	        this.addAnimations( animations );
	    },
	
	
	    // push all animations into the queue
	    addAnimations: function ( animations ) {
	
	        var instanceAnimationList = this._addAnimation( animations );
	
	        // qeue them to assign target
	        Array.prototype.push.apply( this._animationsToRegister, instanceAnimationList );
	        this._dirty = true;
	        this._registerAnimations();
	    },
	
	
	    update: function ( node, nv ) {
	
	        if ( this._dirty ) {
	            this._findAnimationUpdateCallback( node );
	            this._registerTargetFoundInAnimationCallback();
	            this._registerAnimations();
	        }
	
	        var t = nv.getFrameStamp().getSimulationTime();
	
	        if ( this._seekTime !== -1 )
	            this._pauseTime = -this._seekTime + this._startTime + t;
	        this._seekTime = -1;
	
	        if ( !this._pause ) { // Not in pause
	            this._simulationTime = this._startTime + ( t - this._pauseTime );
	        } else {
	            this._pauseTime = ( t - this._simulationTime + this._startTime );
	        }
	
	        this.updateManager( this._simulationTime * this._timeFactor );
	        return true;
	    },
	
	    updateManager: function ( t ) {
	
	
	        // adds active animations / channels requested
	        //
	        this._processStartAnimation( t );
	
	        var l = Channel.ChannelType.Count;
	        // update all actives channels by type
	        //
	        for ( var i = 0; i < l; i++ ) {
	            var activeChannelType = this._activeChannelsByTypes[ i ];
	            this._updateChannelsType( t, activeChannelType, Interpolator[ i ] );
	        }
	
	        // update targets
	        //
	        for ( var j = 0; j < l; j++ ) {
	            var targetType = this._targetsByTypes[ j ];
	            this._updateTargetType( targetType, ResultType[ j ] );
	        }
	
	
	        // update all animation callback
	        // expect to have UpdateMatrixTransform
	        for ( var k = 0, nk = this._animationsUpdateCallbackArray.length; k < nk; k++ ) {
	            var animCallback = this._animationsUpdateCallbackArray[ k ];
	            animCallback.computeChannels();
	        }
	
	        // check animation finished
	        this._removeFinishedAnimation( t );
	    },
	
	    togglePause: function () { //Pause the manager's time
	        this._pause = !this._pause;
	        // if we resume an animation we don't want to move forward the animation
	        if ( !this._pause )
	            this._seekTime = this._simulationTime;
	    },
	
	    getSimulationTime: function () {
	        return this._simulationTime;
	    },
	
	    setSimulationTime: function ( t ) {
	        this._simulationTime = t;
	    },
	
	    setSeekTime: function ( t ) {
	        this._simulationTime = t;
	        this._seekTime = t;
	    },
	
	    stopAnimation: function ( name ) {
	        var activeAnimationList = this._activeAnimationList;
	        for ( var i = 0, nbAnim = activeAnimationList.length; i < nbAnim; ++i ) {
	            if ( activeAnimationList[ i ].name === name ) {
	                this._removeActiveChannels( this._instanceAnimations[ name ] );
	                this._activeAnimations[ name ] = undefined;
	                activeAnimationList.splice( i, 1 );
	                return;
	            }
	        }
	    },
	
	    stopAllAnimation: function () {
	        var activeAnimationList = this._activeAnimationList;
	        for ( var i = 0, nbAnim = activeAnimationList.length; i < nbAnim; ++i ) {
	            var name = activeAnimationList[ i ].name;
	            this._removeActiveChannels( this._instanceAnimations[ name ] );
	            this._activeAnimations[ name ] = undefined;
	        }
	        activeAnimationList.length = 0;
	    },
	
	    setTimeFactor: function ( timeFactor ) {
	        var tf = timeFactor / this._timeFactor;
	        this._startTime += ( this._simulationTime - this._simulationTime * tf ) / tf;
	
	        this._timeFactor = timeFactor;
	
	        if ( this._pause )
	            this._simulationTime += ( this._simulationTime - this._simulationTime * tf ) / tf;
	    },
	
	    getTimeFactor: function () {
	        return this._timeFactor;
	    },
	
	    isPlaying: function ( name ) {
	        if ( this._activeAnimations[ name ] ) return true;
	        return false;
	    },
	
	    // play animation using object as config
	    // {
	    //     name: string,
	    //     priority: 0,
	    //     weight: 1.0,
	    //     loop: true / false
	    // }
	    playAnimationObject: function ( obj ) {
	
	        var anim = this._instanceAnimations[ obj.name ];
	        if ( !anim ) {
	            Notify.info( 'no animation ' + obj.name + ' found' );
	            return;
	        }
	
	        if ( this.isPlaying( obj.name ) ) return;
	
	        anim.priority = ( obj.priority === undefined ) ? 0 : obj.priority;
	        anim.weight = ( obj.weight === undefined ) ? 1.0 : obj.weight;
	        anim.loop = ( obj.loop === undefined ) ? true : obj.loop;
	
	        this._startAnimations[ anim.name ] = anim;
	    },
	
	    // if first argument is an object
	    // playAnimationObject is called instead
	    playAnimation: function ( name, loop, priority, weight ) {
	
	        var animationObject;
	        if ( typeof name === 'object' )
	            animationObject = name;
	        else {
	            animationObject = {
	                name: name,
	                priority: priority,
	                weight: weight,
	                loop: loop
	            };
	        }
	
	        return this.playAnimationObject( animationObject );
	    },
	
	    getAnimations: function () {
	        return this._instanceAnimations;
	    },
	
	
	    _registerAnimations: function () {
	
	        if ( !this._targets.length ) return;
	
	        for ( var i = 0, ni = this._animationsToRegister.length; i < ni; i++ ) {
	            var instanceAnimation = this._animationsToRegister[ i ];
	            this._registerInstanceAnimation( instanceAnimation );
	        }
	
	        this._animationsToRegister.length = 0;
	        this._dirty = false;
	    },
	
	    // Register animation
	    //
	    // Register animation list all target from channel in the animations and associate
	    // target found in the scenegraph. If no target are registered animation cant be
	    // registered. In this case animation will be pending and resolved after a visitor
	    // extract target.
	    _registerInstanceAnimation: function ( instanceAnimation ) {
	
	        var instanceChannels = instanceAnimation.channels;
	        for ( var i = 0, ni = instanceChannels.length; i < ni; i++ ) {
	            var instanceChannel = instanceChannels[ i ];
	            var targetName = instanceChannel.channel.target;
	            var name = instanceChannel.channel.name;
	            var uniqueTargetName = targetName + '.' + name;
	
	            // disply a warning if animation has a channel but not target found in the
	            // scene graph. We could probably optimize and removes those channels, but
	            // it must be a user decision in case the user plugin different scene
	            // graph together and target would appear later in the scenegraph
	            if ( !this._targetMap[ uniqueTargetName ] ) {
	                Notify.warn( 'registerInstanceAnimation did not find targetName (' + uniqueTargetName + ') in the scene graph' );
	                continue;
	            }
	
	            instanceChannel.targetID = this._targetMap[ uniqueTargetName ].id;
	        }
	        return true;
	    },
	
	    _findAnimationUpdateCallback: function ( node ) {
	        var collector = new CollectAnimationUpdateCallbackVisitor();
	        node.accept( collector );
	        this._animationsUpdateCallback = collector.getAnimationUpdateCallbackMap();
	    },
	
	    // assignTargetToAnimationCallback
	    //
	    // check all animationUpdateCallback collected and try to
	    // assign the channel instance registered in the manager. If a
	    // animationUpdateCallback contains channels not known by the
	    // manager we skip it.  It means that it should be called
	    // after the animations has been registered into the animation
	    // manager
	    _registerTargetFoundInAnimationCallback: function () {
	
	        this._resetTargets();
	
	        var targetID = 0;
	        var targetMap = this._targetMap;
	        var targets = this._targets;
	
	        var registerTarget = function ( uniqueTargetName, target, name ) {
	            if ( !targetMap[ uniqueTargetName ] ) {
	                targetMap[ uniqueTargetName ] = target;
	                // assign an id that will be an index into a array
	                target.id = targetID++;
	                targets.push( target );
	
	                var type = target.type; // split by type
	                this._targetsByTypes[ type ].push( target );
	            } else {
	                // detect differents target instance with same
	                // unique target name. It's a problem
	                if ( target !== targetMap[ uniqueTargetName ] )
	                    Notify.warn( 'detected differents target instance with the same name (' + name + ')' );
	            }
	        }.bind( this );
	
	
	        var target;
	        var name;
	        var uniqueTargetName;
	
	        var animationCallbackMap = this._animationsUpdateCallback;
	        var keys = window.Object.keys( animationCallbackMap );
	        for ( var i = 0, ni = keys.length; i < ni; i++ ) {
	            var key = keys[ i ];
	            var animationCallback = animationCallbackMap[ key ];
	
	            // handle UpdateBone and UpdateMatrixTransform but not stateSet
	            if ( animationCallback.getStackedTransforms && animationCallback.getStackedTransforms().length ) {
	                this._animationsUpdateCallbackArray.push( animationCallback );
	
	                var stackedTransforms = animationCallback.getStackedTransforms();
	                for ( var j = 0, nj = stackedTransforms.length; j < nj; j++ ) {
	                    var stackedTransform = stackedTransforms[ j ];
	                    target = stackedTransform.getTarget();
	                    name = stackedTransform.getName();
	                    uniqueTargetName = animationCallback.getName() + '.' + name;
	
	                    registerTarget( uniqueTargetName, target, name );
	                }
	            } else if ( animationCallback instanceof UpdateMorph ) {
	                for ( var t = 0, numTarget = animationCallback.getNumTarget(); t < numTarget; t++ ) {
	                    name = animationCallback.getTargetName( t );
	                    uniqueTargetName = name + '.' + t;
	                    target = animationCallback.getTarget( t );
	
	                    registerTarget( uniqueTargetName, target, name );
	                }
	            }
	        }
	    },
	
	    _addAnimation: function ( animations ) {
	
	        var instanceAnimationList = [];
	        for ( var i = 0, ni = animations.length; i < ni; i++ ) {
	
	            var animation = animations[ i ];
	            var animationName = animation.name;
	
	            if ( this._instanceAnimations[ animationName ] )
	                continue;
	
	            var instanceAnimation = Animation.createInstanceAnimation( animation );
	            this._instanceAnimations[ animationName ] = instanceAnimation;
	            instanceAnimationList.push( instanceAnimation );
	        }
	
	        return instanceAnimationList;
	    },
	
	    // add channels from instance animation to the active channels list
	    _addActiveChannels: function ( t, instanceAnimation ) {
	
	        var instanceChannels = instanceAnimation.channels;
	        for ( var i = 0, ni = instanceChannels.length; i < ni; i++ ) {
	            var instanceChannel = instanceChannels[ i ];
	            var type = instanceChannel.channel.type;
	            instanceChannel.t = t; // reset time
	            instanceChannel.instanceAnimation = instanceAnimation; // link with parent animation
	            var targetID = instanceChannel.targetID;
	
	            if ( targetID === Target.InvalidTargetID ) continue;
	
	            this._activeChannelsByTypes[ type ].push( instanceChannel );
	            this._targets[ targetID ].channels.push( instanceChannel );
	        }
	
	    },
	
	    _removeActiveChannels: function ( instanceAnimation ) {
	
	        var instanceChannels = instanceAnimation.channels;
	        for ( var i = 0, ni = instanceChannels.length; i < ni; i++ ) {
	            var instanceChannel = instanceChannels[ i ];
	            var type = instanceChannel.channel.type;
	            var targetID = instanceChannel.targetID;
	
	            if ( targetID === Target.InvalidTargetID ) continue;
	
	            // remove channel instance from targetID channel list
	            var targetChannelsList = this._targets[ targetID ].channels;
	            var index = targetChannelsList.indexOf( instanceChannel );
	            targetChannelsList.splice( index, 1 );
	
	            // remove channel from active channels
	            var channelTypeList = this._activeChannelsByTypes[ type ];
	            var channelIndex = channelTypeList.indexOf( instanceChannel );
	            channelTypeList.splice( channelIndex, 1 );
	        }
	
	    },
	
	    // blend value from each channels for each target
	    // or copy default value if not updated by an active animation
	    _updateTargetType: function ( targetList, operatorType ) {
	
	        for ( var i = 0, ni = targetList.length; i < ni; i++ ) {
	
	            var target = targetList[ i ];
	            var affectedChannels = target.channels;
	            var nbChannels = affectedChannels.length;
	            // note operatorType operations doesn't always operate on arrays (float)
	            // so we can't simply assume that target.value is an array so we need
	            // to write "target.value = ..."
	
	            if ( nbChannels === 0 ) { // no blending ?
	                target.value = operatorType.copy( target.defaultValue, target.value );
	
	            } else if ( nbChannels === 1 ) {
	                target.value = operatorType.copy( affectedChannels[ 0 ].value, target.value );
	
	            } else {
	
	                // blend between multiple channels
	                target.value = operatorType.init( target.value );
	                var accumulatedWeight = 0.0;
	
	                // it's the same as targetOut = (v0 * w0 + v1 * w1 + ...) / (w0 + w1 + ...)
	                for ( var j = 0, nj = affectedChannels.length; j < nj; j++ ) {
	
	                    var achannel = affectedChannels[ j ];
	                    var weight = achannel.weight;
	                    accumulatedWeight += weight;
	                    // avoid divide by zero and useless lerp
	                    if ( accumulatedWeight === 0.0 || weight === 0.0 )
	                        continue;
	
	                    var ratio = weight / accumulatedWeight;
	                    target.value = operatorType.lerp( ratio, target.value, achannel.value, target.value );
	                }
	            }
	        }
	    },
	
	    _updateChannelsType: function ( t, channels, interpolator ) {
	
	        for ( var i = 0, ni = channels.length; i < ni; i++ ) {
	            var channel = channels[ i ];
	            var instanceAnimation = channel.instanceAnimation;
	            var loop = instanceAnimation.loop;
	
	            var tLocal = t - channel.t;
	
	            // handle loop, careful in case animation is one frame
	            if ( loop && instanceAnimation.duration > 0.0 ) tLocal = tLocal % instanceAnimation.duration;
	
	            interpolator( tLocal + instanceAnimation.firstKeyTime, channel );
	        }
	    },
	
	    _removeFinishedAnimation: function ( t ) {
	
	        var activeAnimationList = this._activeAnimationList;
	
	        var i = 0;
	        while ( i < activeAnimationList.length ) {
	            var instanceAnimation = activeAnimationList[ i ];
	            var name = instanceAnimation.name;
	
	            if ( t > instanceAnimation.end && instanceAnimation.loop === false ) {
	                this._removeActiveChannels( instanceAnimation );
	                this._activeAnimations[ name ] = undefined;
	                activeAnimationList.splice( i, 1 );
	            } else {
	                i++;
	            }
	        }
	    },
	
	    _addActiveAnimation: function ( t, cmd ) {
	
	        this._activeAnimations[ cmd.name ] = cmd; // set animation in the list of active one
	
	        var instanceAnimation = this._instanceAnimations[ cmd.name ];
	        instanceAnimation.start = t;
	        instanceAnimation.end = t + instanceAnimation.duration;
	        this._addActiveChannels( t, instanceAnimation );
	
	        // keep track of instance animation active in a list
	        this._activeAnimationList.push( instanceAnimation );
	    },
	
	    // execute start animations events
	    // during the updateManager
	    _processStartAnimation: function ( t ) {
	
	        // dont really start animation if we dont have yet targets
	        if ( !this._targets.length ) return;
	
	        var animations = this._startAnimations;
	        var keys = window.Object.keys( animations );
	        for ( var i = 0, ni = keys.length; i < ni; i++ ) {
	            var key = keys[ i ];
	            var cmd = animations[ key ];
	            var name = cmd.name;
	
	            if ( this.isPlaying( name ) )
	                continue;
	
	            this._addActiveAnimation( t, cmd );
	        }
	
	        if ( keys.length ) this._startAnimations = {};
	    },
	
	    _resetTargets: function () {
	
	        this._targetMap = {};
	        this._targets.length = 0;
	
	        for ( var i = 0, ni = this._targetsByTypes.length; i < ni; i++ ) {
	            this._targetsByTypes[ i ].length = 0;
	        }
	
	    },
	
	    setAnimationLerpEndStart: function ( anim, lerpDuration ) {
	        var channels = anim.channels;
	        if ( anim.originalDuration === undefined )
	            anim.originalDuration = anim.duration;
	
	        anim.duration = anim.originalDuration + lerpDuration;
	
	        var firstKey = anim.firstKeyTime;
	        var animDuration = anim.originalDuration;
	
	        for ( var i = 0, nbChannels = channels.length; i < nbChannels; ++i ) {
	            var ch = channels[ i ].channel;
	
	            // compare first and last key and detect if we can loop the channel or not
	            // it uses an arbitrary epsilon
	            if ( Math.abs( ch.start - firstKey ) > 0.01 || Math.abs( ch.duration - animDuration ) > 0.01 )
	                continue;
	
	            // update channel end time
	            if ( ch.originalEnd === undefined )
	                ch.originalEnd = ch.end;
	
	            ch.end = ch.originalEnd + lerpDuration;
	
	            // add or remove additonal key and time
	
	            var sizeElt = TypeToSize[ ch.type ];
	            var size = ch.times.buffer.byteLength / 4;
	
	            // no lerp between end and start
	            if ( lerpDuration === 0.0 ) {
	
	                ch.keys = new Float32Array( ch.keys.buffer, 0, ( size - 1 ) * sizeElt );
	                ch.times = new Float32Array( ch.times.buffer, 0, size - 1 );
	
	            } else {
	
	                // take full size of buffer (with additional keys)
	                ch.keys = new Float32Array( ch.keys.buffer, 0, size * sizeElt );
	                // copy first key
	                var idLast = ( size - 1 ) * sizeElt;
	                for ( var j = 0; j < sizeElt; ++j )
	                    ch.keys[ idLast + j ] = ch.keys[ j ];
	
	                ch.times = new Float32Array( ch.times.buffer, 0, size );
	                ch.times[ size - 1 ] = ch.times[ size - 2 ] + lerpDuration;
	            }
	        }
	    }
	
	} );
	
	BasicAnimationManager.TypeToSize = TypeToSize;
	
	module.exports = BasicAnimationManager;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var Quat = __webpack_require__( 26 );
	var Channel = __webpack_require__( 111 );
	
	
	var Vec3CopyKeyFrame = function ( i, keys, result ) {
	    result[ 0 ] = keys[ i++ ];
	    result[ 1 ] = keys[ i++ ];
	    result[ 2 ] = keys[ i++ ];
	};
	
	var Vec4CopyKeyFrame = function ( i, keys, result ) {
	    result[ 0 ] = keys[ i++ ];
	    result[ 1 ] = keys[ i++ ];
	    result[ 2 ] = keys[ i++ ];
	    result[ 3 ] = keys[ i++ ];
	};
	
	var Vec3LerpInterpolator = function ( t, channelInstance ) {
	
	    var channel = channelInstance.channel;
	    var value = channelInstance.value;
	    var start = channel.start;
	    var end = channel.end;
	    var keys = channel.keys;
	    var times = channel.times;
	
	    if ( t >= end ) {
	        channelInstance.key = 0;
	        Vec3CopyKeyFrame( keys.length - 3, keys, value );
	        return;
	
	    } else if ( t <= start ) {
	        channelInstance.key = 0;
	        Vec3CopyKeyFrame( 0, keys, value );
	        return;
	    }
	
	    var i1 = channelInstance.key;
	    if ( t > times[ i1 ] )
	        while ( times[ i1 + 1 ] < t ) i1++;
	    else if ( t < times[ i1 ] )
	        while ( times[ i1 ] > t ) i1--;
	
	    var t1 = times[ i1 ];
	    var t2 = times[ i1 + 1 ];
	
	    var index = i1 * 3;
	    var x1 = keys[ index++ ];
	    var y1 = keys[ index++ ];
	    var z1 = keys[ index++ ];
	
	    var x2 = keys[ index++ ];
	    var y2 = keys[ index++ ];
	    var z2 = keys[ index++ ];
	
	    var r = ( t - t1 ) / ( t2 - t1 );
	
	    value[ 0 ] = x1 + ( x2 - x1 ) * r;
	    value[ 1 ] = y1 + ( y2 - y1 ) * r;
	    value[ 2 ] = z1 + ( z2 - z1 ) * r;
	    channelInstance.key = i1;
	};
	
	
	var QuatLerpInterpolator = ( function () {
	
	    var q0 = Quat.create();
	    var q1 = Quat.create();
	
	    return function ( t, channelInstance ) {
	
	        var channel = channelInstance.channel;
	        var value = channelInstance.value;
	        var start = channel.start;
	        var end = channel.end;
	        var keys = channel.keys;
	        var times = channel.times;
	
	        if ( t >= end ) {
	            channelInstance.key = 0;
	            Vec4CopyKeyFrame( keys.length - 4, keys, value );
	            return;
	
	        } else if ( t <= start ) {
	            channelInstance.key = 0;
	            Vec4CopyKeyFrame( 0, keys, value );
	            return;
	        }
	
	        var i1 = channelInstance.key;
	        if ( t > times[ i1 ] )
	            while ( times[ i1 + 1 ] < t ) i1++;
	        else if ( t < times[ i1 ] )
	            while ( times[ i1 ] > t ) i1--;
	
	        var t1 = times[ i1 ];
	        var t2 = times[ i1 + 1 ];
	
	        var index = i1 * 4;
	        q0[ 0 ] = keys[ index++ ];
	        q0[ 1 ] = keys[ index++ ];
	        q0[ 2 ] = keys[ index++ ];
	        q0[ 3 ] = keys[ index++ ];
	
	        q1[ 0 ] = keys[ index++ ];
	        q1[ 1 ] = keys[ index++ ];
	        q1[ 2 ] = keys[ index++ ];
	        q1[ 3 ] = keys[ index++ ];
	
	        var r = ( t - t1 ) / ( t2 - t1 );
	
	        Quat.nlerp( r, q0, q1, value );
	        channelInstance.key = i1;
	    };
	
	} )();
	
	var QuatSlerpInterpolator = ( function () {
	
	    var q0 = Quat.create();
	    var q1 = Quat.create();
	
	    return function ( t, channelInstance ) {
	
	        var channel = channelInstance.channel;
	        var value = channelInstance.value;
	        var start = channel.start;
	        var end = channel.end;
	        var keys = channel.keys;
	        var times = channel.times;
	
	        if ( t >= end ) {
	            channelInstance.key = 0;
	            Vec4CopyKeyFrame( keys.length - 4, keys, value );
	            return;
	
	        } else if ( t <= start ) {
	            channelInstance.key = 0;
	            Vec4CopyKeyFrame( 0, keys, value );
	            return;
	        }
	
	        var i1 = channelInstance.key;
	        if ( t > times[ i1 ] )
	            while ( times[ i1 + 1 ] < t ) i1++;
	        else if ( t < times[ i1 ] )
	            while ( times[ i1 ] > t ) i1--;
	
	        var t1 = times[ i1 ];
	        var t2 = times[ i1 + 1 ];
	
	        var index = i1 * 4;
	        q0[ 0 ] = keys[ index++ ];
	        q0[ 1 ] = keys[ index++ ];
	        q0[ 2 ] = keys[ index++ ];
	        q0[ 3 ] = keys[ index++ ];
	
	        q1[ 0 ] = keys[ index++ ];
	        q1[ 1 ] = keys[ index++ ];
	        q1[ 2 ] = keys[ index++ ];
	        q1[ 3 ] = keys[ index++ ];
	
	        var r = ( t - t1 ) / ( t2 - t1 );
	
	        Quat.slerp( r, q0, q1, value );
	
	        channelInstance.key = i1;
	    };
	} )();
	
	
	var FloatLerpInterpolator = function ( t, channelInstance ) {
	
	    var channel = channelInstance.channel;
	    var value = channelInstance.value;
	    var start = channel.start;
	    var end = channel.end;
	    var keys = channel.keys;
	    var times = channel.times;
	
	    if ( t >= end ) {
	        channelInstance.key = 0;
	        channelInstance.value = keys[ keys.length - 1 ];
	        return;
	
	    } else if ( t <= start ) {
	        channelInstance.key = 0;
	        channelInstance.value = keys[ 0 ];
	        return;
	    }
	
	    var i1 = channelInstance.key;
	    if ( t > times[ i1 ] )
	        while ( times[ i1 + 1 ] < t ) i1++;
	    else if ( t < times[ i1 ] )
	        while ( times[ i1 ] > t ) i1--;
	
	
	    var t1 = times[ i1 ];
	    var t2 = times[ i1 + 1 ];
	
	    var index = i1;
	    var x1 = keys[ index++ ];
	    var x2 = keys[ index++ ];
	
	    var r = ( t - t1 ) / ( t2 - t1 );
	
	    value = x1 + ( x2 - x1 ) * r;
	    channelInstance.key = i1;
	    channelInstance.value = value;
	};
	
	var FloatCubicBezierInterpolator = function ( t, channelInstance ) {
	    var channel = channelInstance.channel;
	    var value = channelInstance.value;
	    var start = channel.start;
	    var end = channel.end;
	    var keys = channel.keys;
	    var times = channel.times;
	
	    if ( t >= end ) {
	        channelInstance.key = 0;
	        channelInstance.value = keys[ keys.length - 3 ];
	        return;
	
	    } else if ( t <= start ) {
	        channelInstance.key = 0;
	        channelInstance.value = keys[ 0 ];
	        return;
	    }
	
	    var i = channelInstance.key;
	    if ( t > times[ i ] )
	        while ( times[ i + 1 ] < t ) i++;
	    else if ( t < times[ i ] )
	        while ( times[ i ] > t ) i--;
	
	    var tt = ( t - times[ i ] ) / ( times[ i + 1 ] - times[ i ] );
	    var oneMinusT = 1.0 - tt;
	    var oneMinusT2 = oneMinusT * oneMinusT;
	    var oneMinusT3 = oneMinusT2 * oneMinusT;
	    var t2 = tt * tt;
	
	    var id = i * 3;
	    var v0 = keys[ id ] * oneMinusT3;
	    var v1 = keys[ id + 1 ] * ( 3.0 * tt * oneMinusT2 );
	    var v2 = keys[ id + 2 ] * ( 3.0 * t2 * oneMinusT );
	    var v3 = keys[ id + 3 ] * ( t2 * tt );
	
	    value = v0 + v1 + v2 + v3;
	    channelInstance.key = i;
	    channelInstance.value = value;
	};
	
	var Vec3CubicBezierInterpolator = ( function () {
	    var v0 = Vec3.create();
	    var v1 = Vec3.create();
	    var v2 = Vec3.create();
	    var v3 = Vec3.create();
	
	    return function ( t, channelInstance ) {
	        var channel = channelInstance.channel;
	        var value = channelInstance.value;
	        var start = channel.start;
	        var end = channel.end;
	        var keys = channel.keys;
	        var times = channel.times;
	
	        if ( t >= end ) {
	            channelInstance.key = 0;
	            Vec3CopyKeyFrame( keys.length - 9, keys, value );
	            return;
	
	        } else if ( t <= start ) {
	            channelInstance.key = 0;
	            Vec3CopyKeyFrame( 0, keys, value );
	            return;
	        }
	
	        var i = channelInstance.key;
	        if ( t > times[ i ] )
	            while ( times[ i + 1 ] < t ) i++;
	        else if ( t < times[ i ] )
	            while ( times[ i ] > t ) i--;
	
	        var tt = ( t - times[ i ] ) / ( times[ i + 1 ] - times[ i ] );
	        var oneMinusT = 1.0 - tt;
	        var oneMinusT2 = oneMinusT * oneMinusT;
	        var oneMinusT3 = oneMinusT2 * oneMinusT;
	        var t2 = tt * tt;
	
	        var id = i * 9;
	        Vec3.mult( Vec3.set( keys[ id++ ], keys[ id++ ], keys[ id++ ], v0 ), oneMinusT3, v0 );
	        Vec3.mult( Vec3.set( keys[ id++ ], keys[ id++ ], keys[ id++ ], v1 ), ( 3.0 * tt * oneMinusT2 ), v1 );
	        Vec3.mult( Vec3.set( keys[ id++ ], keys[ id++ ], keys[ id++ ], v2 ), ( 3.0 * t2 * oneMinusT ), v2 );
	        Vec3.mult( Vec3.set( keys[ id++ ], keys[ id++ ], keys[ id++ ], v3 ), ( t2 * tt ), v3 );
	
	        value[ 0 ] = v0[ 0 ] + v1[ 0 ] + v2[ 0 ] + v3[ 0 ];
	        value[ 1 ] = v0[ 1 ] + v1[ 1 ] + v2[ 1 ] + v3[ 1 ];
	        value[ 2 ] = v0[ 2 ] + v1[ 2 ] + v2[ 2 ] + v3[ 2 ];
	        channelInstance.key = i;
	    };
	
	} )();
	
	// must be sync wiht Interpolator Type
	var ChannelType = Channel.ChannelType;
	
	var moduleInterpolator = {};
	
	// refrence interpolator by channe enum id
	moduleInterpolator[ ChannelType.Vec3 ] = Vec3LerpInterpolator;
	moduleInterpolator[ ChannelType.Quat ] = QuatLerpInterpolator;
	moduleInterpolator[ ChannelType.QuatSlerp ] = QuatSlerpInterpolator;
	moduleInterpolator[ ChannelType.Float ] = FloatLerpInterpolator;
	moduleInterpolator[ ChannelType.FloatCubicBezier ] = FloatCubicBezierInterpolator;
	moduleInterpolator[ ChannelType.Vec3CubicBezier ] = Vec3CubicBezierInterpolator;
	
	moduleInterpolator.Vec3LerpInterpolator = Vec3LerpInterpolator;
	moduleInterpolator.QuatLerpInterpolator = QuatLerpInterpolator;
	moduleInterpolator.QuatSlerpInterpolator = QuatSlerpInterpolator;
	moduleInterpolator.FloatLerpInterpolator = FloatLerpInterpolator;
	moduleInterpolator.FloatCubicBezierInterpolator = FloatCubicBezierInterpolator;
	moduleInterpolator.Vec3CubicBezierInterpolator = Vec3CubicBezierInterpolator;
	
	module.exports = moduleInterpolator;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var AnimationUpdateCallback = __webpack_require__( 77 );
	
	
	// search into a subgraph all target
	var CollectAnimationUpdateCallbackVisitor = function () {
	    NodeVisitor.call( this );
	    this._animationUpdateCallback = {};
	};
	
	
	CollectAnimationUpdateCallbackVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    getAnimationUpdateCallbackMap: function () {
	        return this._animationUpdateCallback;
	    },
	
	    apply: function ( node ) {
	        var cbs = node.getUpdateCallbackList();
	
	        // collect and remove animation update callback
	        for ( var i = 0, cbsLength = cbs.length; i < cbsLength; i++ ) {
	            var cb = cbs[ i ];
	            if ( cb instanceof AnimationUpdateCallback ) {
	                this._animationUpdateCallback[ cb.getInstanceID() ] = cb;
	                //node.removeUpdateCallback( cb );
	            }
	        }
	        this.traverse( node );
	    }
	
	} );
	
	module.exports = CollectAnimationUpdateCallbackVisitor;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var BufferArray = __webpack_require__( 40 );
	var RigGeometry = __webpack_require__( 78 );
	var AnimationUpdateCallback = __webpack_require__( 77 );
	var Target = __webpack_require__( 112 );
	var MorphGeometry = __webpack_require__( 79 );
	
	var UpdateMorph = function () {
	    AnimationUpdateCallback.call( this );
	
	    this._isInitialized = false;
	    this._targets = []; // float target
	    this._targetNames = []; // names of targets
	    this._morphs = []; // the update morph can update several morphs
	
	    this._weights = new Float32Array( 4 );
	    // stuffs to handles > 4 targets
	    this._indexMap = [ 0, 0, 0, 0 ]; // we map VA to the first 4th VA targets
	    this._gpuMorphed = []; // size of this._targets, for each target a bool states if it's gpu morphed or not
	};
	
	var EFFECTIVE_EPS = MorphGeometry.EFFECTIVE_EPS; // in case we have more than 4 morphs, we can skip low effective weights
	
	// for sorting
	var funcWeights = function ( a, b ) {
	    return Math.abs( b.value ) - Math.abs( a.value );
	};
	
	UpdateMorph.prototype = MACROUTILS.objectInherit( AnimationUpdateCallback.prototype, {
	
	    init: function ( node ) {
	        //Find the morph geometry & init it
	        var children = node.getChildren();
	        for ( var i = 0, l = children.length; i < l; i++ ) {
	
	            var geom = children[ i ];
	            var morph;
	            if ( geom instanceof MorphGeometry ) {
	                morph = geom;
	            } else if ( geom instanceof RigGeometry && geom.getSourceGeometry() instanceof MorphGeometry ) {
	                morph = geom.getSourceGeometry();
	            }
	
	            if ( !morph ) continue;
	
	            if ( morph.getName() === this.getName() ) {
	                if ( !morph.isInitialized() )
	                    morph.init();
	
	                this._morphs.push( morph );
	                this._isInitialized = true;
	            }
	        }
	    },
	
	    isInitialized: function () {
	        return this._isInitialized;
	    },
	
	    getNumTarget: function () {
	        return this._targets.length;
	    },
	
	    getTarget: function ( index ) {
	        return this._targets[ index ];
	    },
	
	    getTargetName: function ( index ) {
	        return this._targetNames[ index ];
	    },
	
	    addTarget: function ( name, index ) {
	        this._targets[ index ] = Target.createFloatTarget( 0 );
	        this._targetNames[ index ] = name;
	    },
	
	    _remapBufferArrays: function () {
	
	        // basically, this function remaps all the active morphed VA to the 4th first morphTargets VA
	        var indexMap = this._indexMap;
	        var morphs = this._morphs;
	        for ( var i = 0; i < 4; ++i ) {
	            var index = indexMap[ i ];
	            var strI = '_' + i;
	            var strIndex = '_' + index;
	
	            for ( var j = 0, nbMorphs = morphs.length; j < nbMorphs; ++j ) {
	
	                var morph = morphs[ j ];
	                var vAttrs = morph.getVertexAttributeList();
	                var morphNames = morph.getMorphTargetNames();
	                for ( var k = 0, nbNames = morphNames.length; k < nbNames; ++k ) {
	
	                    var attName = morphNames[ k ];
	                    vAttrs[ attName + strI ].setBufferArray( vAttrs[ attName + strIndex ].getInitialBufferArray() );
	
	                }
	            }
	        }
	    },
	
	    _mergeExtraMorphTarget: function ( attrs, attName, extraWeightSum ) {
	
	        var i = 0;
	        // ignore the gpu morphed
	        var gpuMorphed = this._gpuMorphed;
	        var vAttr = attrs[ attName ];
	        var vertexLen = vAttr.getElements().length;
	        var nbVertex = vertexLen / vAttr.getItemSize();
	        var itemSize = vAttr.getItemSize();
	
	        vAttr._cpuMorph = vAttr._cpuMorph || new BufferArray( BufferArray.ARRAY_BUFFER, new Float32Array( vertexLen ), itemSize );
	        var morphExtraTargets = vAttr._cpuMorph.getElements();
	        for ( i = 0; i < vertexLen; ++i ) {
	            morphExtraTargets[ i ] = 0.0;
	        }
	
	        var targets = this._targets;
	        for ( var j = 0, nb = targets.length; j < nb; ++j ) {
	
	            // ignore gpu morphed targets
	            if ( gpuMorphed[ j ] === true )
	                continue;
	
	            var weight = targets[ j ].value;
	            if ( Math.abs( weight ) < EFFECTIVE_EPS )
	                continue;
	
	            weight /= extraWeightSum;
	
	            var morphElts = attrs[ attName + '_' + j ].getInitialBufferArray().getElements();
	            for ( i = 0; i < nbVertex; ++i ) {
	
	                var k = i * itemSize;
	                morphExtraTargets[ k ] += weight * morphElts[ k ];
	                morphExtraTargets[ k + 1 ] += weight * morphElts[ k + 1 ];
	                morphExtraTargets[ k + 2 ] += weight * morphElts[ k + 2 ];
	                // don't morph tangent w component
	            }
	        }
	
	        // map on last index target
	        attrs[ attName + '_3' ].setBufferArray( vAttr._cpuMorph );
	        vAttr._cpuMorph.dirty();
	    },
	
	    _computeExtraWeightsSum: function () {
	        var gpuMorphed = this._gpuMorphed;
	        var sum = 0.0;
	        var targets = this._targets;
	        for ( var i = 0, nb = targets.length; i < nb; ++i ) {
	
	            // ignore gpu morphed targets
	            if ( gpuMorphed[ i ] === true )
	                continue;
	
	            var weight = targets[ i ].value;
	            if ( Math.abs( weight ) < EFFECTIVE_EPS )
	                continue;
	
	            sum += weight;
	        }
	        // check comment in _morphBufferArrayCPU (avoid near zero value)
	        var eps = 1e-5;
	        if ( Math.abs( sum ) > eps ) return sum;
	        return sum < 0.0 ? -eps : eps;
	    },
	
	    _morphBufferArrayCPU: function () {
	
	        // the idea is... we have :
	        // v' = v * (1-w1-w2-w3) + t1*w1 + t2*w2 + t3*w3
	        // we want
	        // v' = v * (1-w1-w4) + t1*w1 + t4*w4
	        // so basically we have to compute
	        // w4 = w2+w3 // (check if ~0 !)
	        // t4 = (t2*w2+t3*w3)/w4
	        // (w4 is extraWeightSum and t4 will be computed in _mergeExtraMorphTarget)
	
	        // compute new weights for the 4th target (all the extra target will be merged inside this one)
	        var extraWeightSum = this._weights[ 3 ] = this._computeExtraWeightsSum();
	
	        var processed = {}; // handles referenced buffer array (avoid useless double morph computation the same buffer)
	        var morphs = this._morphs;
	        for ( var i = 0, nbMorphs = morphs.length; i < nbMorphs; ++i ) {
	
	            var morph = morphs[ i ];
	            var vAttrs = morph.getVertexAttributeList();
	            var morphNames = morph.getMorphTargetNames();
	
	            for ( var j = 0, nbNames = morphNames.length; j < nbNames; ++j ) {
	
	                var name = morphNames[ j ];
	                var attr = vAttrs[ name ];
	                // skip if the bufferArray is shared in another morphGeometry and has already been cpu morphed
	                if ( !attr || processed[ attr.getInstanceID() ] ) continue;
	                processed[ attr.getInstanceID() ] = true;
	
	                this._mergeExtraMorphTarget( vAttrs, name, extraWeightSum );
	            }
	        }
	    },
	
	    updateWeights: function () {
	
	        var i = 0;
	        var targets = this._targets;
	        var nbTargets = targets.length;
	        // reset weights
	        var weights = this._weights;
	        weights[ 0 ] = weights[ 1 ] = weights[ 2 ] = weights[ 3 ] = 0.0;
	
	        // no need to swap VA or to use CPU morph
	        if ( nbTargets <= 4 ) {
	            for ( i = 0; i < nbTargets; ++i ) {
	                weights[ i ] = targets[ i ].value;
	            }
	            return;
	        }
	
	        // reset indexMap
	        var indexMap = this._indexMap;
	        indexMap[ 0 ] = indexMap[ 1 ] = indexMap[ 2 ] = indexMap[ 3 ] = 0;
	
	        // reset gpu morphed array
	        var gpuMorphed = this._gpuMorphed;
	        gpuMorphed.length = nbTargets;
	        for ( i = 0; i < nbTargets; ++i ) gpuMorphed[ i ] = false;
	
	        var sortedTargets = targets.slice( 0 ).sort( funcWeights );
	
	        for ( i = 0; i < 4; ++i ) {
	            var ti = targets.indexOf( sortedTargets[ i ] );
	            gpuMorphed[ ti ] = true;
	            indexMap[ i ] = ti;
	            weights[ i ] = sortedTargets[ i ].value;
	        }
	
	        // check more than 4 targets, we compute all the extra targets influence and merge in the last 4th morphs targets
	        var extraMorphCPU = Math.abs( sortedTargets[ 4 ].value ) >= EFFECTIVE_EPS;
	        gpuMorphed[ indexMap[ 3 ] ] = !extraMorphCPU;
	
	        this._remapBufferArrays();
	        if ( extraMorphCPU ) {
	            this._morphBufferArrayCPU();
	        }
	    },
	
	    update: function ( node /*, nv*/ ) {
	        if ( !this.isInitialized() )
	            this.init( node );
	
	        this.updateWeights();
	
	        var weights = this._weights;
	        var nbTargets = Math.min( 4, this._targets.length );
	        var morphs = this._morphs;
	        for ( var i = 0, nbMorphs = morphs.length; i < nbMorphs; ++i ) {
	
	            var array = morphs[ i ].getTargetsWeight();
	            for ( var j = 0; j < nbTargets; j++ ) {
	                array[ j ] = weights[ j ];
	            }
	        }
	
	        return true;
	    }
	} );
	
	module.exports = UpdateMorph;


/***/ }),
/* 118 */
/***/ (function(module, exports) {

	'use strict';
	
	var easeOutQuad = function ( t ) {
	    return -( t * ( t - 2.0 ) );
	};
	var easeInQuad = function ( t ) {
	    return ( t * t );
	};
	var easeOutCubic = function ( t ) {
	    t = t - 1.0;
	    return ( t * t * t + 1 );
	};
	var easeInCubic = function ( t ) {
	    return ( t * t * t );
	};
	var easeOutQuart = function ( t ) {
	    t = t - 1;
	    return -( t * t * t * t - 1 );
	};
	var easeInQuart = function ( t ) {
	    return ( t * t * t * t );
	};
	var easeOutElastic = function ( t ) {
	    return Math.pow( 2.0, -10.0 * t ) * Math.sin( ( t - 0.3 / 4.0 ) * ( 2.0 * Math.PI ) / 0.3 ) + 1.0;
	};
	//osgAnimation.EaseInElastic = function(t) { return ; };
	var easeOutBounce = function ( t ) {
	    if ( t < ( 1 / 2.75 ) ) {
	        return ( 7.5625 * t * t );
	    } else if ( t < ( 2 / 2.75 ) ) {
	        return ( 7.5625 * ( t -= ( 1.5 / 2.75 ) ) * t + 0.75 );
	    } else if ( t < ( 2.5 / 2.75 ) ) {
	        return ( 7.5625 * ( t -= ( 2.25 / 2.75 ) ) * t + 0.9375 );
	    } else {
	        return ( 7.5625 * ( t -= ( 2.625 / 2.75 ) ) * t + 0.984375 );
	    }
	};
	
	module.exports = {
	    easeOutQuad: easeOutQuad,
	    easeInQuad: easeInQuad,
	    easeOutCubic: easeOutCubic,
	    easeInCubic: easeInCubic,
	    easeOutQuart: easeOutQuart,
	    easeInQuart: easeInQuart,
	    easeOutElastic: easeOutElastic,
	    easeOutBounce: easeOutBounce,
	    EaseOutQuad: easeOutQuad,
	    EaseInQuad: easeInQuad,
	    EaseOutCubic: easeOutCubic,
	    EaseInCubic: easeInCubic,
	    EaseOutQuart: easeOutQuart,
	    EaseInQuart: easeInQuart,
	    EaseOutElastic: easeOutElastic,
	    EaseOutBounce: easeOutBounce
	};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var Matrix = __webpack_require__( 23 );
	var Target = __webpack_require__( 112 );
	
	
	var StackedMatrix = function ( name, matrix ) {
	    Object.call( this );
	    this._target = Target.createMatrixTarget( matrix || Matrix.identity );
	    if ( name ) this.setName( name );
	};
	
	StackedMatrix.prototype = MACROUTILS.objectInherit( Object.prototype, {
	
	    init: function ( matrix ) {
	        this.setMatrix( matrix );
	        Matrix.copy( matrix, this._target.defaultValue );
	    },
	
	    getTarget: function () {
	        return this._target;
	    },
	
	    getMatrix: function () {
	        return this._target.value;
	    },
	
	    setMatrix: function ( m ) {
	        Matrix.copy( m, this._target.value );
	    },
	
	    resetToDefaultValue: function () {
	        this.setMatrix( this._target.defaultValue );
	    },
	
	    applyToMatrix: function ( m ) {
	        Matrix.preMult( m, this._target.value );
	    }
	
	} );
	
	module.exports = StackedMatrix;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var Matrix = __webpack_require__( 23 );
	var Quat = __webpack_require__( 26 );
	var Target = __webpack_require__( 112 );
	
	
	var StackedQuaternion = function ( name, quat ) {
	    Object.call( this );
	    this._target = Target.createQuatTarget( quat || Quat.identity );
	    if ( name ) this.setName( name );
	};
	
	StackedQuaternion.prototype = MACROUTILS.objectInherit( Object.prototype, {
	
	    init: function ( q ) {
	        this.setQuaternion( q );
	        Quat.copy( q, this._target.defaultValue );
	    },
	
	    setQuaternion: function ( q ) {
	        Quat.copy( q, this._target.value );
	    },
	
	    getTarget: function () {
	        return this._target;
	    },
	
	    resetToDefaultValue: function () {
	        this.setQuaternion( this._target.defaultValue );
	    },
	
	    applyToMatrix: ( function () {
	        var matrixTmp = Matrix.create();
	
	        return function applyToMatrix( m ) {
	            var mtmp = matrixTmp;
	            Matrix.setRotateFromQuat( mtmp, this._target.value );
	            Matrix.preMult( m, mtmp );
	        };
	    } )()
	
	} );
	
	module.exports = StackedQuaternion;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var Matrix = __webpack_require__( 23 );
	var Vec3 = __webpack_require__( 15 );
	var Quat = __webpack_require__( 26 );
	var Target = __webpack_require__( 112 );
	
	
	var StackedRotateAxis = function ( name, axis, angle ) {
	    Object.call( this );
	    this._axis = Vec3.set( 0, 0, 1, Vec3.create() );
	    if ( axis ) Vec3.copy( axis, this._axis );
	    this._target = Target.createFloatTarget( typeof angle === 'number' ? angle : 0.0 );
	    if ( name ) this.setName( name );
	};
	
	StackedRotateAxis.prototype = MACROUTILS.objectInherit( Object.prototype, {
	
	    init: function ( axis, angle ) {
	        this.setAxis( axis );
	        this.setAngle( angle );
	        this._target.defaultValue = angle;
	    },
	
	    setAxis: function ( axis ) {
	        Vec3.copy( axis, this._axis );
	    },
	
	    setAngle: function ( angle ) {
	        this._target.value = angle;
	    },
	
	    getTarget: function () {
	        return this._target;
	    },
	
	    resetToDefaultValue: function () {
	        this.setAngle( this._target.defaultValue );
	    },
	
	    applyToMatrix: ( function () {
	        var matrixTmp = Matrix.create();
	        var quatTmp = Quat.create();
	
	        return function ( m ) {
	            var axis = this._axis;
	            var qtmp = quatTmp;
	            var mtmp = matrixTmp;
	            var angle = this._target.value;
	
	            Quat.makeRotate( angle, axis[ 0 ], axis[ 1 ], axis[ 2 ], qtmp );
	            Matrix.setRotateFromQuat( mtmp, qtmp );
	            Matrix.preMult( m, mtmp );
	        };
	    } )()
	
	} );
	
	module.exports = StackedRotateAxis;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var Matrix = __webpack_require__( 23 );
	var Vec3 = __webpack_require__( 15 );
	var Target = __webpack_require__( 112 );
	
	
	var StackedScale = function ( name, scale ) {
	    Object.call( this );
	    this._target = Target.createVec3Target( scale || Vec3.one );
	    if ( name ) this.setName( name );
	};
	
	
	StackedScale.prototype = MACROUTILS.objectInherit( Object.prototype, {
	
	    init: function ( scale ) {
	        this.setScale( scale );
	        Vec3.copy( scale, this._target.defaultValue );
	    },
	
	    setScale: function ( scale ) {
	        Vec3.copy( scale, this._target.value );
	    },
	
	    getTarget: function () {
	        return this._target;
	    },
	
	    resetToDefaultValue: function () {
	        this.setScale( this._target.defaultValue );
	    },
	
	    // must be optimized
	    applyToMatrix: function ( m ) {
	
	        var scale = this._target.value;
	
	        Matrix.preMultScale( m, scale );
	
	    }
	
	} );
	
	module.exports = StackedScale;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var Matrix = __webpack_require__( 23 );
	var Vec3 = __webpack_require__( 15 );
	var Target = __webpack_require__( 112 );
	
	
	/**
	 *  StackedTranslate
	 */
	var StackedTranslate = function ( name, translate ) {
	    Object.call( this );
	    this._target = Target.createVec3Target( translate || Vec3.zero );
	    if ( name ) this.setName( name );
	};
	
	
	StackedTranslate.prototype = MACROUTILS.objectInherit( Object.prototype, {
	
	    init: function ( translate ) {
	        this.setTranslate( translate );
	        Vec3.copy( translate, this._target.defaultValue );
	    },
	
	    setTranslate: function ( translate ) {
	        Vec3.copy( translate, this._target.value );
	    },
	
	    getTarget: function () {
	        return this._target;
	    },
	
	    resetToDefaultValue: function () {
	        this.setTranslate( this._target.defaultValue );
	    },
	
	    applyToMatrix: function ( m ) {
	        Matrix.preMultTranslate( m, this._target.value );
	    }
	} );
	
	module.exports = StackedTranslate;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Input = __webpack_require__( 46 );
	var ReaderParser = __webpack_require__( 38 );
	var DatabasePager = __webpack_require__( 125 );
	var osgWrappers = __webpack_require__( 126 );
	var osgAnimationWrappers = __webpack_require__( 127 );
	var osgTextWrappers = __webpack_require__( 128 );
	
	var osgDB = {};
	osgDB.Input = Input;
	MACROUTILS.objectMix( osgDB, ReaderParser );
	osgDB.DatabasePager = DatabasePager;
	osgDB.ObjectWrapper.serializers.osg = osgWrappers;
	osgDB.ObjectWrapper.serializers.osgAnimation = osgAnimationWrappers;
	osgDB.ObjectWrapper.serializers.osgText = osgTextWrappers;
	
	module.exports = osgDB;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var P = __webpack_require__( 47 );
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var PagedLOD = __webpack_require__( 71 );
	var Timer = __webpack_require__( 9 );
	
	/**
	 * Database paging class which manages the loading of files
	 * and synchronizing of loaded models with the main scene graph.
	 *  @class DatabasePager
	 */
	var DatabasePager = function () {
	    this._pendingRequests = [];
	    this._pendingNodes = [];
	    this._loading = false;
	    this._progressCallback = undefined;
	    this._lastCB = true;
	    this._activePagedLODList = new Set();
	    this._childrenToRemoveList = new Set();
	    this._downloadingRequestsNumber = 0;
	    this._maxRequestsPerFrame = 10;
	    this._acceptNewRequests = true;
	    // In OSG the targetMaximumNumberOfPagedLOD is 300 by default
	    // here we set 75 as we need to be more strict with memory in a browser
	    // This value can be setted using setTargetMaximumNumberOfPageLOD method.
	    this._targetMaximumNumberOfPagedLOD = 75;
	};
	
	var DatabaseRequest = function () {
	    this._loadedModel = undefined;
	    this._group = undefined;
	    this._url = undefined;
	    this._function = undefined;
	    this._timeStamp = 0.0;
	    this._groupExpired = false;
	    this._priority = 0.0;
	};
	
	var FindPagedLODsVisitor = function ( pagedLODList, frameNumber ) {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );
	    this._activePagedLODList = pagedLODList;
	    this._frameNumber = frameNumber;
	};
	FindPagedLODsVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    apply: function ( node ) {
	        if ( node.getTypeID() === PagedLOD.getTypeID() ) {
	            node.setFrameNumberOfLastTraversal( this._frameNumber );
	            this._activePagedLODList.add( node );
	        }
	        this.traverse( node );
	    }
	} );
	
	var ReleaseVisitor = function () {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );
	};
	ReleaseVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    apply: function ( node ) {
	        // mark GLResources in nodes to be released
	        node.releaseGLObjects();
	        this.traverse( node );
	    }
	} );
	
	var ExpirePagedLODVisitor = function () {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );
	    this._childrenList = [];
	};
	
	ExpirePagedLODVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	
	    apply: function ( node ) {
	        if ( node.getTypeID() === PagedLOD.getTypeID() ) {
	            this._childrenList.push( node );
	            this._markRequestsExpired( node );
	        }
	        this.traverse( node );
	    },
	
	    removeExpiredChildrenAndFindPagedLODs: function ( plod, expiryTime, expiryFrame, removedChildren ) {
	        if ( !plod.children.length ) return false;
	
	        var sizeBefore = removedChildren.length;
	        plod.removeExpiredChildren( expiryTime, expiryFrame, removedChildren );
	        for ( var i = sizeBefore; i < removedChildren.length; i++ ) {
	            removedChildren[ i ].accept( this );
	        }
	        return sizeBefore !== removedChildren.length;
	    },
	
	    _markRequestsExpired: function ( plod ) {
	        var numRanges = plod._perRangeDataList.length;
	        var request;
	        for ( var i = 0; i < numRanges; i++ ) {
	            request = plod.getDatabaseRequest( i );
	            if ( request !== undefined ) {
	                request._groupExpired = true;
	                request._loadedModel = null;
	            }
	        }
	    }
	} );
	
	DatabasePager.prototype = MACROUTILS.objectLibraryClass( {
	
	    setTargetMaximumNumberOfPageLOD: function ( target ) {
	        this._targetMaximumNumberOfPagedLOD = target;
	    },
	
	    getTargetMaximumNumberOfPageLOD: function () {
	        return this._targetMaximumNumberOfPagedLOD;
	    },
	
	    setAcceptNewDatabaseRequests: function ( acceptNewRequests ) {
	        this._acceptNewRequests = acceptNewRequests;
	    },
	    getAcceptNewDatabaseRequests: function () {
	        return this._acceptNewRequests;
	    },
	    reset: function () {
	        this._pendingRequests = [];
	        this._pendingNodes = [];
	        this._loading = false;
	        this._lastCB = true;
	        this._activePagedLODList.clear();
	        this._childrenToRemoveList.clear();
	        this._downloadingRequestsNumber = 0;
	        this._maxRequestsPerFrame = 10;
	        this._acceptNewRequests = true;
	        this._targetMaximumNumberOfPagedLOD = 75;
	    },
	
	    updateSceneGraph: function ( frameStamp ) {
	        // Progress callback
	        if ( this._progressCallback !== undefined ) {
	            // Maybe we should encapsulate this in a promise.
	            this.executeProgressCallback();
	        }
	        // We need to control the time spent in DatabasePager tasks to
	        // avoid making the rendering slow.
	        // Probably we can have a time parameter to manage all the tasks.
	        // Now it is fixed to 0.0025 ms to remove expired childs
	        // and 0.005 ms  to add to the scene the loaded requests.
	
	        // Remove expired nodes
	        this.removeExpiredSubgraphs( frameStamp, 0.0025 );
	        // Time to do the requests.
	        this.takeRequests();
	        // Add the loaded data to the graph
	        this.addLoadedDataToSceneGraph( frameStamp, 0.005 );
	    },
	
	
	    executeProgressCallback: function () {
	        if ( this._pendingRequests.length > 0 || this._pendingNodes.length > 0 ) {
	            this._progressCallback( this._pendingRequests.length + this._downloadingRequestsNumber, this._pendingNodes.length );
	            this._lastCB = false;
	        } else {
	            if ( !this._lastCB ) {
	                this._progressCallback( this._pendingRequests.length + this._downloadingRequestsNumber, this._pendingNodes.length );
	                this._lastCB = true;
	            }
	        }
	    },
	
	    setMaxRequestsPerFrame: function ( numRequests ) {
	        this._maxRequestsPerFrame = numRequests;
	    },
	
	    getMaxRequestsPerFrame: function () {
	        return this._maxRequestsPerFrame;
	    },
	
	    getRequestListSize: function () {
	        return this._pendingRequests.length + this._downloadingRequestsNumber;
	    },
	
	    setProgressCallback: function ( cb ) {
	        this._progressCallback = cb;
	    },
	
	    addLoadedDataToSceneGraph: function ( frameStamp, availableTime ) {
	
	        if ( availableTime <= 0.0 ) return 0.0;
	
	        // Prune the list of database requests.
	        var elapsedTime = 0.0;
	        var beginTime = Timer.instance().tick();
	        this._pendingNodes.sort( function ( r1, r2 ) {
	            return r2._timeStamp - r1._timeStamp;
	        } );
	
	        for ( var i = 0; i < this._pendingNodes.length; i++ ) {
	            if ( elapsedTime > availableTime ) return 0.0;
	
	            var request = this._pendingNodes.shift();
	            var frameNumber = frameStamp.getFrameNumber();
	            var timeStamp = frameStamp.getSimulationTime();
	
	            // If the request is not expired, then add/register new childs
	            if ( request._groupExpired === false ) {
	
	                var plod = request._group;
	                plod.setTimeStamp( plod.children.length, timeStamp );
	                plod.setFrameNumber( plod.children.length, frameNumber );
	                plod.addChildNode( request._loadedModel );
	
	                // Register PagedLODs.
	                if ( !this._activePagedLODList.has( plod ) ) {
	                    this.registerPagedLODs( plod, frameNumber );
	                } else {
	                    this.registerPagedLODs( request._loadedModel, frameNumber );
	                }
	
	            } else {
	
	                // Clean the request
	                request._loadedModel = undefined;
	                request = undefined;
	
	            }
	            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	        }
	        availableTime -= elapsedTime;
	        return availableTime;
	    },
	
	    isLoading: function () {
	        return this._loading;
	    },
	
	    registerPagedLODs: function ( subgraph, frameNumber ) {
	        if ( !subgraph ) return;
	        subgraph.accept( new FindPagedLODsVisitor( this._activePagedLODList, frameNumber ) );
	    },
	
	    requestNodeFile: function ( func, url, node, timestamp, priority ) {
	        // Check if we are currently accepting requests.
	        if ( !this._acceptNewRequests ) return undefined;
	        // We don't need to determine if the dbrequest is in the queue
	        // That is already done in the PagedLOD, so we just create the request
	        var dbrequest = new DatabaseRequest();
	        dbrequest._group = node;
	        dbrequest._function = func;
	        dbrequest._url = url;
	        dbrequest._timeStamp = timestamp;
	        dbrequest._priority = priority;
	        this._pendingRequests.push( dbrequest );
	        return dbrequest;
	    },
	
	    takeRequests: function () {
	        if ( this._pendingRequests.length ) {
	            var numRequests = Math.min( this._maxRequestsPerFrame, this._pendingRequests.length );
	            this._pendingRequests.sort( function ( r1, r2 ) {
	                // Ask for newer requests first.
	                var value = r1._timeStamp - r2._timeStamp;
	                // Ask for the greater priority if the timestamp is the same.
	                if ( value === 0 ) {
	                    value = r1._priority - r2._priority;
	                }
	                return value;
	
	            } );
	            for ( var i = 0; i < numRequests; i++ ) {
	                this._downloadingRequestsNumber++;
	                this.processRequest( this._pendingRequests.shift() );
	            }
	        }
	    },
	
	    processRequest: function ( dbrequest ) {
	
	        this._loading = true;
	        var that = this;
	        // Check if the request is valid;
	        if ( dbrequest._groupExpired ) {
	            //Notify.log( 'DatabasePager::processRequest() Request expired.' );
	            that._downloadingRequestsNumber--;
	            this._loading = false;
	            return;
	        }
	
	        // Load from function
	        if ( dbrequest._function !== undefined ) {
	            this.loadNodeFromFunction( dbrequest._function, dbrequest._group ).then( function ( child ) {
	                that._downloadingRequestsNumber--;
	                dbrequest._loadedModel = child;
	                that._pendingNodes.push( dbrequest );
	                that._loading = false;
	            } );
	
	        } else if ( dbrequest._url !== '' ) { // Load from URL
	            this.loadNodeFromURL( dbrequest._url ).then( function ( child ) {
	                that._downloadingRequestsNumber--;
	                dbrequest._loadedModel = child;
	                that._pendingNodes.push( dbrequest );
	                that._loading = false;
	            } );
	        }
	    },
	
	    loadNodeFromFunction: function ( func, plod ) {
	        // Need to call with pagedLOD as parent, to be able to have multiresolution structures.
	        var promise = ( func )( plod );
	        // should func always return a promise ?
	        if ( !promise ) return P.reject();
	        if ( promise && promise.then ) return promise;
	        return P.resolve( promise );
	    },
	
	    loadNodeFromURL: function ( url ) {
	        var ReaderParser = __webpack_require__( 38 );
	        // Call to ReaderParser just in case there is a custom readNodeURL Callback
	        // See osgDB/Options.js and/or osgDB/Input.js
	        // TODO: We should study if performance can be improved if separating the XHTTP request from
	        // the parsing. This way several/many request could be done at the same time.
	        // Also we should be able to cancel requests, so there is a need to have access
	        // to the HTTPRequest Object
	        return ReaderParser.readNodeURL( url );
	    },
	
	    releaseGLExpiredSubgraphs: function ( availableTime ) {
	
	        if ( availableTime <= 0.0 ) return 0.0;
	        // We need to test if we have time to flush
	        var elapsedTime = 0.0;
	        var beginTime = Timer.instance().tick();
	        var that = this;
	
	        this._childrenToRemoveList.forEach( function ( node ) {
	            // If we don't have more time, break the loop.
	            if ( elapsedTime > availableTime ) return;
	            that._childrenToRemoveList.delete( node );
	            node.accept( new ReleaseVisitor() );
	            node.removeChildren();
	            node = null;
	            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	        } );
	
	        availableTime -= elapsedTime;
	        return availableTime;
	    },
	
	    removeExpiredSubgraphs: function ( frameStamp, availableTime ) {
	
	        if ( frameStamp.getFrameNumber() === 0 ) return 0.0;
	
	        var numToPrune = this._activePagedLODList.size - this._targetMaximumNumberOfPagedLOD;
	        var expiryTime = frameStamp.getSimulationTime() - 0.1;
	        var expiryFrame = frameStamp.getFrameNumber() - 1;
	        // First traverse and remove inactive PagedLODs, as their children will
	        // certainly have expired.
	        // TODO: Then traverse active nodes if we still need to prune.
	        if ( numToPrune > 0 ) {
	            availableTime = this.removeExpiredChildren( numToPrune, expiryTime, expiryFrame, availableTime );
	        }
	        return availableTime;
	    },
	
	    removeExpiredChildren: function ( numToPrune, expiryTime, expiryFrame, availableTime ) {
	        // Iterate over the activePagedLODList to remove expired children
	        // We need to control the time spent in remove childs.
	        var elapsedTime = 0.0;
	        var beginTime = Timer.instance().tick();
	        var that = this;
	        var removedChildren = [];
	        var expiredPagedLODVisitor = new ExpirePagedLODVisitor();
	
	        this._activePagedLODList.forEach( function ( plod ) {
	            // Check if we have time, else return 0
	            if ( elapsedTime > availableTime ) return 0.0;
	            if ( numToPrune < 0 ) return availableTime;
	            // See if plod is still active, so we don't have to prune
	            if ( expiryFrame < plod.getFrameNumberOfLastTraversal() ) return availableTime;
	            expiredPagedLODVisitor.removeExpiredChildrenAndFindPagedLODs( plod, expiryTime, expiryFrame, removedChildren );
	            for ( var i = 0; i < expiredPagedLODVisitor._childrenList.length; i++ ) {
	                that._activePagedLODList.delete( expiredPagedLODVisitor._childrenList[ i ] );
	                numToPrune--;
	            }
	            // Add to the remove list all the childs deleted
	            for ( i = 0; i < removedChildren.length; i++ ) {
	                that._childrenToRemoveList.add( removedChildren[ i ] );
	            }
	            expiredPagedLODVisitor._childrenList.length = 0;
	            removedChildren.length = 0;
	            elapsedTime = Timer.instance().deltaS( beginTime, Timer.instance().tick() );
	        } );
	        availableTime -= elapsedTime;
	        return availableTime;
	    }
	}, 'osgDB', 'DatabasePager' );
	
	module.exports = DatabasePager;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var P = __webpack_require__( 47 );
	var TransformEnums = __webpack_require__( 29 );
	
	var osgWrapper = {};
	
	osgWrapper.Object = function ( input, obj ) {
	    var jsonObj = input.getJSON();
	
	    if ( jsonObj.Name ) obj.setName( jsonObj.Name );
	
	    if ( jsonObj.UserDataContainer ) {
	        var userdata = input.setJSON( jsonObj.UserDataContainer ).readUserDataContainer();
	        if ( userdata !== undefined ) {
	            obj.setUserData( userdata );
	        }
	    }
	
	    return obj;
	};
	/* jshint newcap: false */
	osgWrapper.Node = function ( input, node ) {
	    var jsonObj = input.getJSON();
	
	    osgWrapper.Object( input, node );
	
	    var promiseArray = [];
	
	    if ( jsonObj.UpdateCallbacks ) {
	        var cbAddCallback = node.addUpdateCallback.bind( node );
	        for ( var j = 0, l = jsonObj.UpdateCallbacks.length; j < l; j++ ) {
	            var promise = input.setJSON( jsonObj.UpdateCallbacks[ j ] ).readObject();
	            promiseArray.push( promise );
	            promise.then( cbAddCallback );
	        }
	    }
	
	    if ( jsonObj.StateSet ) {
	        var pp = input.setJSON( jsonObj.StateSet ).readObject();
	        promiseArray.push( pp );
	        pp.then( node.setStateSet.bind( node ) );
	    }
	
	    var queue = [];
	    // For each url, create a function call and add it to the queue
	    if ( jsonObj.Children ) {
	        for ( var i = 0, k = jsonObj.Children.length; i < k; i++ ) {
	            queue.push( input.setJSON( jsonObj.Children[ i ] ).readObject() );
	        }
	    }
	    // Resolve first updateCallbacks and stateset.
	    return P.all( promiseArray ).then( function () {
	        // Need to wait until the stateset and the all the callbacks are resolved
	        return P.all( queue ).then( function ( queueNodes ) {
	            // All the results from P.all are on the argument as an array
	            // Now insert children in the right order
	            var len = queueNodes.length;
	            for ( var i = 0; i < len; i++ )
	                node.addChild( queueNodes[ i ] );
	            return node;
	        } );
	    } );
	};
	
	osgWrapper.StateSet = function ( input, stateSet ) {
	    var jsonObj = input.getJSON();
	
	    osgWrapper.Object( input, stateSet );
	
	    if ( jsonObj.RenderingHint !== undefined ) {
	        stateSet.setRenderingHint( jsonObj.RenderingHint );
	    }
	
	    var promiseArray = [];
	
	    var createAttribute = function ( jsonAttribute ) {
	        var promise = input.setJSON( jsonAttribute ).readObject();
	        if ( promise.isRejected() ) // sometimes we have some empty objects
	            return;
	        promiseArray.push( promise );
	        promise.then( stateSet.setAttributeAndModes.bind( stateSet ) );
	    };
	
	    if ( jsonObj.AttributeList !== undefined ) {
	        for ( var i = 0, l = jsonObj.AttributeList.length; i < l; i++ ) {
	            createAttribute( jsonObj.AttributeList[ i ] );
	        }
	    }
	
	    var createTextureAttribute = function ( unit, textureAttribute ) {
	        var promise = input.setJSON( textureAttribute ).readObject();
	        if ( promise.isRejected() ) // sometimes we have some empty objects
	            return;
	        promiseArray.push( promise );
	        promise.then( stateSet.setTextureAttributeAndModes.bind( stateSet, unit ) );
	    };
	
	    if ( jsonObj.TextureAttributeList ) {
	        var textures = jsonObj.TextureAttributeList;
	        for ( var t = 0, lt = textures.length; t < lt; t++ ) {
	            var textureAttributes = textures[ t ];
	            for ( var a = 0, al = textureAttributes.length; a < al; a++ ) {
	                createTextureAttribute( t, textureAttributes[ a ] );
	            }
	        }
	    }
	
	    return P.all( promiseArray ).then( function () {
	        return stateSet;
	    } );
	};
	
	osgWrapper.Material = function ( input, material ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Diffuse || !jsonObj.Emission || !jsonObj.Specular || jsonObj.Shininess === undefined )
	        return P.reject();
	
	    osgWrapper.Object( input, material );
	
	    material.setAmbient( jsonObj.Ambient );
	    material.setDiffuse( jsonObj.Diffuse );
	    material.setEmission( jsonObj.Emission );
	    material.setSpecular( jsonObj.Specular );
	    material.setShininess( jsonObj.Shininess );
	    return P.resolve( material );
	};
	
	osgWrapper.BlendFunc = function ( input, blend ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.SourceRGB || !jsonObj.SourceAlpha || !jsonObj.DestinationRGB || !jsonObj.DestinationAlpha )
	        return P.reject();
	
	    osgWrapper.Object( input, blend );
	
	    blend.setSourceRGB( jsonObj.SourceRGB );
	    blend.setSourceAlpha( jsonObj.SourceAlpha );
	    blend.setDestinationRGB( jsonObj.DestinationRGB );
	    blend.setDestinationAlpha( jsonObj.DestinationAlpha );
	    return P.resolve( blend );
	};
	
	osgWrapper.CullFace = function ( input, attr ) {
	    var jsonObj = input.getJSON();
	    if ( jsonObj.Mode === undefined )
	        return P.reject();
	
	    osgWrapper.Object( input, attr );
	    attr.setMode( jsonObj.Mode );
	    return P.resolve( attr );
	};
	
	osgWrapper.BlendColor = function ( input, attr ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.ConstantColor )
	        return P.reject();
	
	    osgWrapper.Object( input, attr );
	    attr.setConstantColor( jsonObj.ConstantColor );
	    return P.resolve( attr );
	};
	
	osgWrapper.Light = function ( input, light ) {
	    var jsonObj = input.getJSON();
	
	    if ( !jsonObj.Ambient ||
	        !jsonObj.Diffuse ||
	        !jsonObj.Direction ||
	        !jsonObj.Position ||
	        !jsonObj.Specular ||
	        jsonObj.LightNum === undefined ||
	        jsonObj.SpotCutoff === undefined ||
	        jsonObj.LinearAttenuation === undefined ||
	        jsonObj.ConstantAttenuation === undefined ||
	        jsonObj.QuadraticAttenuation === undefined )
	        return P.reject();
	
	    osgWrapper.Object( input, light );
	    light.setAmbient( jsonObj.Ambient );
	    light.setConstantAttenuation( jsonObj.ConstantAttenuation );
	    light.setDiffuse( jsonObj.Diffuse );
	    light.setDirection( jsonObj.Direction );
	    light.setLightNumber( jsonObj.LightNum );
	    light.setLinearAttenuation( jsonObj.LinearAttenuation );
	    light.setPosition( jsonObj.Position );
	    light.setQuadraticAttenuation( jsonObj.QuadraticAttenuation );
	    light.setSpecular( jsonObj.Specular );
	    light.setSpotCutoff( jsonObj.SpotCutoff );
	    light.setSpotBlend( 0.01 );
	    if ( jsonObj.SpotExponent !== undefined ) {
	        light.setSpotBlend( jsonObj.SpotExponent / 128.0 );
	    }
	    return P.resolve( light );
	};
	
	osgWrapper.Texture = function ( input, texture ) {
	    var jsonObj = input.getJSON();
	
	    osgWrapper.Object( input, texture );
	
	    if ( jsonObj.MinFilter ) texture.setMinFilter( jsonObj.MinFilter );
	    if ( jsonObj.MagFilter ) texture.setMagFilter( jsonObj.MagFilter );
	    if ( jsonObj.WrapT ) texture.setWrapT( jsonObj.WrapT );
	    if ( jsonObj.WrapS ) texture.setWrapS( jsonObj.WrapS );
	
	    // no file return dummy texture
	    var file = jsonObj.File;
	    if ( file === undefined ) {
	        file = 'no-image-provided';
	    }
	
	    return input.readImageURL( file ).then( function ( img ) {
	        texture.setImage( img );
	        return texture;
	    } );
	};
	
	osgWrapper.Projection = function ( input, node ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Matrix )
	        return P.reject();
	
	    var promise = osgWrapper.Node( input, node );
	    node.setMatrix( jsonObj.Matrix );
	    return promise;
	};
	
	osgWrapper.MatrixTransform = function ( input, node ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Matrix )
	        return P.reject();
	
	    var promise = osgWrapper.Node( input, node );
	    node.setMatrix( jsonObj.Matrix );
	    return promise;
	};
	
	osgWrapper.LightSource = function ( input, node ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Light )
	        return P.reject();
	
	    var promise = osgWrapper.Node( input, node );
	    return P.all( [ input.setJSON( jsonObj.Light ).readObject(), promise ] ).then( function ( args ) {
	        var light = args[ 0 ];
	        //var lightsource = args[ 1 ];
	        node.setLight( light );
	        if ( jsonObj.ReferenceFrame === 'ABSOLUTE_RF' )
	            node.setReferenceFrame( TransformEnums.ABSOLUTE_RF );
	        return node;
	    } );
	};
	
	osgWrapper.Geometry = function ( input, node ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.VertexAttributeList )
	        return P.reject();
	
	    jsonObj.PrimitiveSetList = jsonObj.PrimitiveSetList || [];
	
	    var arraysPromise = [];
	    arraysPromise.push( osgWrapper.Node( input, node ) );
	
	    var prims = node.getPrimitives();
	    var cbAddPrimitives = prims.push.bind( prims );
	    var i = 0;
	    var l = jsonObj.PrimitiveSetList.length;
	    for ( i = 0; i < l; i++ ) {
	        var promisePrimitive = input.setJSON( jsonObj.PrimitiveSetList[ i ] ).readPrimitiveSet();
	        arraysPromise.push( promisePrimitive );
	        promisePrimitive.then( cbAddPrimitives );
	    }
	
	    var cbSetBuffer = function ( name, buffer ) {
	        this.getVertexAttributeList()[ name ] = buffer;
	    };
	
	    var vList = jsonObj.VertexAttributeList;
	    var keys = window.Object.keys( vList );
	    l = keys.length;
	    for ( i = 0; i < l; i++ ) {
	        var name = keys[ i ];
	        var promiseBuffer = input.setJSON( vList[ name ] ).readBufferArray();
	        arraysPromise.push( promiseBuffer );
	        promiseBuffer.then( cbSetBuffer.bind( node, name ) );
	    }
	
	    return P.all( arraysPromise ).then( function () {
	        return node;
	    } );
	};
	
	osgWrapper.PagedLOD = function ( input, plod ) {
	    var jsonObj = input.getJSON();
	
	    osgWrapper.Object( input, plod );
	    // Parse center Mode
	    if ( jsonObj.CenterMode === 'USE_BOUNDING_SPHERE_CENTER' )
	        plod.setCenterMode( 0 );
	    else if ( jsonObj.CenterMode === 'UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED' )
	        plod.setCenterMode( 2 );
	
	    // Parse center and radius
	    plod.setCenter( [ jsonObj.UserCenter[ 0 ], jsonObj.UserCenter[ 1 ], jsonObj.UserCenter[ 2 ] ] );
	    plod.setRadius( jsonObj.UserCenter[ 3 ] );
	
	    // Parse RangeMode
	    if ( jsonObj.RangeMode === 'PIXEL_SIZE_ON_SCREEN' )
	        plod.setRangeMode( 1 );
	
	    var str;
	
	    // Parse Ranges
	    var o = jsonObj.RangeList;
	
	    for ( var i = 0; i < window.Object.keys( o ).length; i++ ) {
	        str = 'Range ' + i;
	        var v = o[ str ];
	        plod.setRange( i, v[ 0 ], v[ 1 ] );
	    }
	    // Parse Files
	    o = jsonObj.RangeDataList;
	    for ( i = 0; i < window.Object.keys( o ).length; i++ ) {
	        str = 'File ' + i;
	        plod.setFileName( i, o[ str ] );
	    }
	    // Set database path from options
	    // TODO: Check also if we have a path from json
	    plod.setDatabasePath( input.getDatabasePath() );
	
	    var queue = [];
	    // For each url, create a function call and add it to the queue
	    if ( jsonObj.Children ) {
	        for ( var j = 0, k = jsonObj.Children.length; j < k; j++ ) {
	            queue.push( input.setJSON( jsonObj.Children[ j ] ).readObject() );
	        }
	    }
	
	    return P.all( queue ).then( function ( queueNodes ) {
	        // All the results from P.all are on the argument as an array
	        var len = queueNodes.length;
	        for ( i = 0; i < len; i++ )
	            plod.addChildNode( queueNodes[ i ] );
	        return plod;
	    } );
	};
	module.exports = osgWrapper;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var P = __webpack_require__( 47 );
	var Notify = __webpack_require__( 10 );
	var osgWrapper = __webpack_require__( 126 );
	var Channel = __webpack_require__( 111 );
	var Animation = __webpack_require__( 110 );
	var ReaderParser = __webpack_require__( 38 );
	var StackedMatrix = __webpack_require__( 119 );
	var StackedScale = __webpack_require__( 122 );
	var MorphGeometry = __webpack_require__( 79 );
	var Geometry = __webpack_require__( 31 );
	
	
	/*eslint new-cap: [2, {"capIsNewExceptions": ["Geometry", "MatrixTransform", "StandardVec3Channel", "StandardQuatChannel", "StandardFloatChannel", "MorphGeometry"]}]*/
	
	var osgAnimationWrapper = {};
	
	var channelCtor = function () {};
	
	var registry = ReaderParser.registry();
	registry.registerObject( 'osgAnimation.Vec3LerpChannel', channelCtor );
	registry.registerObject( 'osgAnimation.FloatLerpChannel', channelCtor );
	registry.registerObject( 'osgAnimation.QuatSlerpChannel', channelCtor );
	registry.registerObject( 'osgAnimation.QuatLerpChannel', channelCtor );
	registry.registerObject( 'osgAnimation.FloatCubicBezierChannel', channelCtor );
	registry.registerObject( 'osgAnimation.Vec3CubicBezierChannel', channelCtor );
	// needs to be cleaned in c++
	registry.registerObject( 'osgAnimation.StackedMatrixElement', StackedMatrix );
	registry.registerObject( 'osgAnimation.StackedScaleElement', StackedScale );
	
	osgAnimationWrapper.Animation = function ( input ) {
	    var jsonObj = input.getJSON();
	    if ( jsonObj.Name === undefined || !jsonObj.Channels || jsonObj.Channels.length === 0 )
	        return P.reject();
	
	    var arrayChannelsPromise = [];
	
	    // channels
	    for ( var i = 0, l = jsonObj.Channels.length; i < l; i++ ) {
	        var promise = input.setJSON( jsonObj.Channels[ i ] ).readObject();
	        arrayChannelsPromise.push( promise );
	    }
	
	    return P.all( arrayChannelsPromise ).then( function ( channels ) {
	        return Animation.createAnimation( channels, jsonObj.Name );
	    } );
	};
	
	osgAnimationWrapper.StandardVec3Channel = function ( input, channel, creator ) {
	    var jsonObj = input.getJSON();
	    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Key || jsonObj.KeyFrames.Key.length !== 3 )
	        return P.reject();
	
	    var jsTime = input.setJSON( jsonObj.KeyFrames.Time ).readBufferArray();
	    var jsKeyX = input.setJSON( jsonObj.KeyFrames.Key[ 0 ] ).readBufferArray();
	    var jsKeyY = input.setJSON( jsonObj.KeyFrames.Key[ 1 ] ).readBufferArray();
	    var jsKeyZ = input.setJSON( jsonObj.KeyFrames.Key[ 2 ] ).readBufferArray();
	
	    return P.all( [ jsTime, jsKeyX, jsKeyY, jsKeyZ ] ).then( function ( pArray ) {
	        var eTime = pArray[ 0 ].getElements();
	        var eKeyX = pArray[ 1 ].getElements();
	        var eKeyY = pArray[ 2 ].getElements();
	        var eKeyZ = pArray[ 3 ].getElements();
	
	        // the keys and time array are always create with a slightly biffer array buffer
	        // (one additional element) in case we want to lerp between end and start
	        var size = eTime.length;
	        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 3 ), 0, size * 3 );
	        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );
	
	        for ( var i = 0; i < size; i++ ) {
	            var id = i * 3;
	            times[ i ] = eTime[ i ];
	            keys[ id++ ] = eKeyX[ i ];
	            keys[ id++ ] = eKeyY[ i ];
	            keys[ id ] = eKeyZ[ i ];
	        }
	
	        creator( keys, times, jsonObj.TargetName, jsonObj.Name, channel );
	        return channel;
	    } );
	};
	
	osgAnimationWrapper.StandardQuatChannel = function ( input, channel, creator ) {
	    var jsonObj = input.getJSON();
	    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Key || jsonObj.KeyFrames.Key.length !== 4 )
	        return P.reject();
	
	    var jsTime = input.setJSON( jsonObj.KeyFrames.Time ).readBufferArray();
	    var jsKeyX = input.setJSON( jsonObj.KeyFrames.Key[ 0 ] ).readBufferArray();
	    var jsKeyY = input.setJSON( jsonObj.KeyFrames.Key[ 1 ] ).readBufferArray();
	    var jsKeyZ = input.setJSON( jsonObj.KeyFrames.Key[ 2 ] ).readBufferArray();
	    var jsKeyW = input.setJSON( jsonObj.KeyFrames.Key[ 3 ] ).readBufferArray();
	
	    return P.all( [ jsTime, jsKeyX, jsKeyY, jsKeyZ, jsKeyW ] ).then( function ( pArray ) {
	        var eTime = pArray[ 0 ].getElements();
	        var eKeyX = pArray[ 1 ].getElements();
	        var eKeyY = pArray[ 2 ].getElements();
	        var eKeyZ = pArray[ 3 ].getElements();
	        var eKeyW = pArray[ 4 ].getElements();
	
	        var size = eTime.length;
	        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 4 ), 0, size * 4 );
	        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );
	
	        for ( var i = 0; i < size; i++ ) {
	            var id = i * 4;
	            times[ i ] = eTime[ i ];
	            keys[ id++ ] = eKeyX[ i ];
	            keys[ id++ ] = eKeyY[ i ];
	            keys[ id++ ] = eKeyZ[ i ];
	            keys[ id ] = eKeyW[ i ];
	        }
	        creator( keys, times, jsonObj.TargetName, jsonObj.Name, channel );
	        return channel;
	    } );
	};
	
	osgAnimationWrapper.StandardFloatChannel = function ( input, channel, creator ) {
	    var jsonObj = input.getJSON();
	    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Key )
	        return P.reject();
	
	    var jsTime = input.setJSON( jsonObj.KeyFrames.Time ).readBufferArray();
	    var jsKey = input.setJSON( jsonObj.KeyFrames.Key ).readBufferArray();
	
	    return P.all( [ jsTime, jsKey ] ).then( function ( pArray ) {
	        var eTime = pArray[ 0 ].getElements();
	        var eKey = pArray[ 1 ].getElements();
	
	        var size = eTime.length;
	        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );
	        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );
	
	        for ( var i = 0; i < size; i++ ) {
	            times[ i ] = eTime[ i ];
	            keys[ i ] = eKey[ i ];
	        }
	
	        creator( keys, times, jsonObj.TargetName, jsonObj.Name, channel );
	        return channel;
	    } );
	};
	
	osgAnimationWrapper.Vec3LerpChannel = function ( input, channel ) {
	    return osgAnimationWrapper.StandardVec3Channel( input, channel, Channel.createVec3Channel );
	};
	
	osgAnimationWrapper.QuatLerpChannel = function ( input, channel ) {
	    return osgAnimationWrapper.StandardQuatChannel( input, channel, Channel.createQuatChannel );
	};
	
	osgAnimationWrapper.QuatSlerpChannel = function ( input, channel ) {
	    // nlerp is less expensive than slerp
	    return osgAnimationWrapper.StandardQuatChannel( input, channel, Channel.createQuatChannel );
	    // return osgAnimationWrapper.StandardQuatChannel( input, channel, Channel.createQuatSlerpChannel );
	};
	
	osgAnimationWrapper.FloatLerpChannel = function ( input, channel ) {
	    return osgAnimationWrapper.StandardFloatChannel( input, channel, Channel.createFloatChannel );
	};
	
	osgAnimationWrapper.FloatCubicBezierChannel = function ( input, channel ) {
	    var jsonObj = input.getJSON();
	
	    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name ||
	        !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Position ||
	        !jsonObj.KeyFrames.ControlPointOut || !jsonObj.KeyFrames.ControlPointIn )
	        return P.reject();
	
	    var arrayPromise = [];
	    var keyFrames = window.Object.keys( jsonObj.KeyFrames );
	    for ( var i = 0; i < keyFrames.length; i++ )
	        arrayPromise.push( input.setJSON( jsonObj.KeyFrames[ keyFrames[ i ] ] ).readBufferArray() );
	
	    return P.all( arrayPromise ).then( function ( pArray ) {
	        var controlPointIn = pArray[ 0 ].getElements();
	        var controlPointOut = pArray[ 1 ].getElements();
	        var position = pArray[ 2 ].getElements();
	        var time = pArray[ 3 ].getElements();
	
	        var size = time.length;
	        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 3 ), 0, size * 3 );
	        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );
	
	        for ( var i = 0; i < size; i++ ) {
	            var id = i * 3;
	
	            times[ i ] = time[ i ];
	            keys[ id++ ] = position[ i ];
	            keys[ id++ ] = controlPointIn[ i ];
	            keys[ id ] = controlPointOut[ i ];
	        }
	        Channel.createFloatCubicBezierChannel( keys, times, jsonObj.TargetName, jsonObj.Name, channel );
	        return channel;
	    } );
	};
	
	osgAnimationWrapper.Vec3CubicBezierChannel = function ( input, channel ) {
	    var jsonObj = input.getJSON();
	
	    if ( jsonObj.TargetName === undefined || !jsonObj.KeyFrames || !jsonObj.Name || !jsonObj.KeyFrames.Time || !jsonObj.KeyFrames.Position || !jsonObj.KeyFrames.ControlPointOut || !jsonObj.KeyFrames.ControlPointIn || jsonObj.KeyFrames.Position.length !== 3 || jsonObj.KeyFrames.ControlPointIn.length !== 3 || jsonObj.KeyFrames.ControlPointOut.length !== 3 )
	        return P.reject();
	
	    var arrayPromise = [];
	
	    //Reads all keyframes
	    var keyFrames = window.Object.keys( jsonObj.KeyFrames );
	    for ( var i = 0; i < keyFrames.length; i++ ) {
	        var key = keyFrames[ i ];
	        var jsonAttribute = jsonObj.KeyFrames[ key ];
	        if ( key !== 'Time' ) {
	            arrayPromise.push( input.setJSON( jsonAttribute[ 0 ] ).readBufferArray() );
	            arrayPromise.push( input.setJSON( jsonAttribute[ 1 ] ).readBufferArray() );
	            arrayPromise.push( input.setJSON( jsonAttribute[ 2 ] ).readBufferArray() );
	        } else
	            arrayPromise.push( input.setJSON( jsonAttribute ).readBufferArray() );
	    }
	
	    return P.all( arrayPromise ).then( function ( pArray ) {
	        var cpi0 = pArray[ 0 ].getElements();
	        var cpi1 = pArray[ 1 ].getElements();
	        var cpi2 = pArray[ 2 ].getElements();
	        var cpo0 = pArray[ 3 ].getElements();
	        var cpo1 = pArray[ 4 ].getElements();
	        var cpo2 = pArray[ 5 ].getElements();
	        var p0 = pArray[ 6 ].getElements();
	        var p1 = pArray[ 7 ].getElements();
	        var p2 = pArray[ 8 ].getElements();
	        var time = pArray[ 9 ].getElements();
	
	        var size = time.length;
	        var keys = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) * 9 ), 0, size * 9 );
	        var times = new Float32Array( new ArrayBuffer( 4 * ( size + 1 ) ), 0, size );
	
	        for ( var i = 0; i < size; i++ ) {
	            var id = i * 9;
	
	            times[ i ] = time[ i ];
	            keys[ id++ ] = p0[ i ];
	            keys[ id++ ] = p1[ i ];
	            keys[ id++ ] = p2[ i ];
	
	            keys[ id++ ] = cpi0[ i ];
	            keys[ id++ ] = cpi1[ i ];
	            keys[ id++ ] = cpi2[ i ];
	
	            keys[ id++ ] = cpo0[ i ];
	            keys[ id++ ] = cpo1[ i ];
	            keys[ id ] = cpo2[ i ];
	        }
	        Channel.createVec3CubicBezierChannel( keys, times, jsonObj.TargetName, jsonObj.Name, channel );
	        return channel;
	    } );
	};
	
	osgAnimationWrapper.BasicAnimationManager = function ( input, manager ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Animations )
	        return P.reject();
	
	    osgWrapper.Object( input, manager );
	
	    var animPromises = [];
	
	    for ( var i = 0, l = jsonObj.Animations.length; i < l; i++ ) {
	        var prim = input.setJSON( jsonObj.Animations[ i ] ).readObject();
	        if ( prim.isRejected() ) {
	            Notify.warn( 'An Animation failed on the parsing!' );
	            continue;
	        }
	        animPromises.push( prim );
	    }
	
	    return P.all( animPromises ).then( function ( animations ) {
	        manager.init( animations );
	        return manager;
	    } );
	};
	
	osgAnimationWrapper.UpdateMatrixTransform = function ( input, umt ) {
	    var jsonObj = input.getJSON();
	    //  some stackedTransform on bones has no name but the transform is usefull
	    if ( /*!jsonObj.Name ||*/ !jsonObj.StackedTransforms )
	        return P.reject();
	
	    osgWrapper.Object( input, umt );
	
	    var promiseArray = [];
	    for ( var i = 0, l = jsonObj.StackedTransforms.length; i < l; i++ ) {
	        promiseArray.push( input.setJSON( jsonObj.StackedTransforms[ i ] ).readObject() );
	    }
	
	    // when UpdateMatrixTransform is ready
	    // compute the default value data
	    return P.all( promiseArray ).then( function ( array ) {
	        var stack = umt.getStackedTransforms();
	        for ( var i = 0, l = array.length; i < l; i++ ) stack.push( array[ i ] );
	        umt.computeChannels();
	        return umt;
	    } );
	};
	
	osgAnimationWrapper.StackedTranslate = function ( input, st ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Name || !jsonObj.Translate )
	        return P.reject();
	
	    osgWrapper.Object( input, st );
	
	    st.init( jsonObj.Translate );
	
	    return P.resolve( st );
	};
	
	osgAnimationWrapper.StackedQuaternion = function ( input, st ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Name || !jsonObj.Quaternion )
	        return P.reject();
	
	    osgWrapper.Object( input, st );
	
	    st.init( jsonObj.Quaternion );
	
	    return P.resolve( st );
	};
	
	osgAnimationWrapper.StackedRotateAxis = function ( input, st ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Axis || jsonObj.Angle === undefined )
	        return P.reject();
	
	    osgWrapper.Object( input, st );
	
	    st.init( jsonObj.Axis, jsonObj.Angle );
	
	    return P.resolve( st );
	};
	
	osgAnimationWrapper.StackedMatrix = function ( input, sme ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Name || !jsonObj.Matrix )
	        return P.reject();
	
	    osgWrapper.Object( input, sme );
	
	    sme.init( jsonObj.Matrix );
	
	    return P.resolve( sme );
	};
	
	osgAnimationWrapper.StackedScale = function ( input, stc ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Name || !jsonObj.Scale )
	        return P.reject();
	
	    osgWrapper.Object( input, stc );
	
	    stc.init( jsonObj.Scale );
	
	    return P.resolve( stc );
	};
	
	osgAnimationWrapper.Bone = function ( input, bone ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.InvBindMatrixInSkeletonSpace )
	        return P.reject();
	
	    var promise = osgWrapper.MatrixTransform( input, bone );
	
	    bone.setInvBindMatrixInSkeletonSpace( jsonObj.InvBindMatrixInSkeletonSpace );
	
	    if ( jsonObj.BoundingBox ) {
	        // It is mandatory because we need it for shadows and culling
	        var bbox = bone.getBoneBoundingBox();
	        bbox.setMax( jsonObj.BoundingBox.max );
	        bbox.setMin( jsonObj.BoundingBox.min );
	    }
	
	    return promise;
	};
	
	osgAnimationWrapper.UpdateBone = osgAnimationWrapper.UpdateMatrixTransform;
	
	osgAnimationWrapper.UpdateSkeleton = function ( input, upSkl ) {
	    osgWrapper.Object( input, upSkl );
	    return P.resolve( upSkl );
	};
	
	osgAnimationWrapper.Skeleton = osgWrapper.MatrixTransform;
	
	osgAnimationWrapper.RigGeometry = function ( input, rigGeom ) {
	    var jsonObj = input.getJSON();
	
	    if ( !jsonObj.SourceGeometry ) // check boneMap
	        return P.reject();
	
	    if ( !jsonObj.BoneMap )
	        Notify.warn( 'No boneMap found in a RigGeometry !' );
	
	    //Import rigGeometry as Geometry + BoneMap
	    var rigPromise = osgWrapper.Geometry( input, rigGeom );
	    rigGeom._boneNameID = jsonObj.BoneMap;
	
	    //Import source geometry and merge it with the rigGeometry
	    var sourceGeometry = jsonObj.SourceGeometry[ 'osg.Geometry' ];
	    var geomPromise;
	    if ( sourceGeometry ) {
	        input.setJSON( sourceGeometry );
	        rigGeom.setSourceGeometry( new Geometry() );
	        geomPromise = osgWrapper.Geometry( input, rigGeom.getSourceGeometry() );
	    } else {
	        sourceGeometry = jsonObj.SourceGeometry[ 'osgAnimation.MorphGeometry' ];
	        if ( sourceGeometry ) {
	            input.setJSON( sourceGeometry );
	            rigGeom.setSourceGeometry( new MorphGeometry() );
	            geomPromise = osgAnimationWrapper.MorphGeometry( input, rigGeom.getSourceGeometry() );
	        } else {
	            Notify.warn( 'SourceGeometry type no recognized' );
	        }
	    }
	
	    // not sure if it's normal but rig geometry don't have UniqueID
	    if ( rigGeom._uniqueID === undefined )
	        rigGeom._uniqueID = sourceGeometry.UniqueID;
	
	    return P.all( [ rigPromise, geomPromise ] ).then( function () {
	
	        rigGeom.mergeChildrenData();
	        return rigGeom;
	
	    } );
	
	};
	
	osgAnimationWrapper.MorphGeometry = function ( input, morphGeometry ) {
	
	    var jsonObj = input.getJSON();
	
	    if ( !jsonObj.MorphTargets )
	        return P.reject();
	
	    var morphTargets = jsonObj.MorphTargets;
	    var arrayPromise = [];
	
	    // arrayPromise[0] is the morphGeometry
	    arrayPromise.push( osgWrapper.Geometry( input, morphGeometry ) );
	
	    for ( var i = 0, l = morphTargets.length; i < l; i++ )
	        arrayPromise.push( input.setJSON( morphTargets[ i ] ).readObject() );
	
	    return P.all( arrayPromise ).then( function ( promiseResultArray ) {
	
	        var morphGeometryResolved = promiseResultArray[ 0 ];
	
	        var targets = morphGeometryResolved.getMorphTargets();
	        for ( var j = 1, jn = promiseResultArray.length; j < jn; j++ )
	            targets.push( promiseResultArray[ j ] );
	
	        morphGeometryResolved.mergeChildrenVertexAttributeList();
	        return morphGeometryResolved;
	
	    } );
	};
	
	osgAnimationWrapper.UpdateMorph = function ( input, updateMorph ) {
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.TargetMap )
	        return P.reject();
	
	    osgWrapper.Object( input, updateMorph );
	
	    var keys = window.Object.keys( jsonObj.TargetMap );
	    for ( var i = 0, l = keys.length; i < l; i++ ) {
	        var key = keys[ i ];
	        updateMorph.addTarget( jsonObj.TargetMap[ key ], parseInt( key, 10 ) );
	    }
	
	    return P.resolve( updateMorph );
	};
	
	osgAnimationWrapper.StackedMatrixElement = osgAnimationWrapper.StackedMatrix;
	osgAnimationWrapper.StackedScaleElement = osgAnimationWrapper.StackedScale;
	
	module.exports = osgAnimationWrapper;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var P = __webpack_require__( 47 );
	var osgWrapper = __webpack_require__( 126 );
	var Notify = __webpack_require__( 10 );
	var Text = __webpack_require__( 129 );
	
	var osgTextWrapper = {};
	
	osgTextWrapper.Text = function ( input, node ) {
	
	    var jsonObj = input.getJSON();
	    if ( !jsonObj.Text )
	        return P.reject();
	
	    var promise = osgWrapper.Node( input, node );
	    node.setColor( jsonObj.Color );
	    node.setText( jsonObj.Text );
	    node.setAutoRotateToScreen( jsonObj.AutoRotateToScreen );
	    node.setPosition( jsonObj.Position );
	    node.setCharacterSize( jsonObj.CharacterSize );
	
	    if ( jsonObj.Layout === 'VERTICAL' ) {
	        Notify.error( 'Vertical Alignment not supported' );
	        return P.reject();
	    }
	    var alignment = jsonObj.Alignment;
	    if ( jsonObj.Alignment.indexOf( 'BASE_LINE' ) > -1 ) {
	        if ( jsonObj.Alignment === 'LEFT_BASE_LINE' ) {
	            alignment = Text.LEFT_CENTER;
	        } else if ( jsonObj.Alignment === 'CENTER_BASE_LINE' ) {
	            alignment = Text.CENTER_CENTER;
	        } else if ( jsonObj.Alignment === 'RIGHT_BASE_LINE' ) {
	            alignment = Text.RIGHT_CENTER;
	        } else if ( jsonObj.Alignment === 'LEFT_BOTTOM_BASE_LINE' ) {
	            alignment = Text.LEFT_BOTTOM;
	        } else if ( jsonObj.Alignment === 'CENTER_BOTTOM_BASE_LINE' ) {
	            alignment = Text.CENTER_BOTTOM;
	        } else if ( jsonObj.Alignment === 'RIGHT_BOTTOM_BASE_LINE' ) {
	            alignment = Text.RIGHT_BOTTOM;
	        }
	    }
	    node.setAlignment( alignment );
	    node.setLayout( jsonObj.Layout );
	
	    return promise;
	};
	
	
	module.exports = osgTextWrapper;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var Vec4 = __webpack_require__( 25 );
	var Matrix = __webpack_require__( 23 );
	var AutoTransform = __webpack_require__( 5 );
	var MatrixTransform = __webpack_require__( 44 );
	var Shape = __webpack_require__( 102 );
	var Texture = __webpack_require__( 34 );
	var BlendFunc = __webpack_require__( 39 );
	
	
	/**
	 *  @class Text: Text 2D using a Canvas2D as a texture for a textured quad.
	 *  Notes: The OSGjs Text has been implemented like OSG osgText::Text as much as possible. However there are some
	 *  things that should be noted:
	 *  - This Text is far more simple than OSG ones, it only supports basic functionality.
	 *  - In contrast to OSG, Text inherits from AutoTransform in osgjs.
	 *  - Supported fonts are not the same in HTML than in OSG/C++.
	 *  - Vertical layout is not supported right now.
	 *  - BaseLine alignments are not supported, instead they are converted to supported ones if parsing a osgjs file.
	 *  - Set the color in the range [ 0 - 1 ], as if you were working with OSG.
	 *  - Texts are generated as a canvas 2D texture sticked in a quad. The size of the texture is the next power of two of the current size of the
	 *    text so the bigger is your characterSize, the more memory it will consume.
	 */
	var Text = function ( text ) {
	    AutoTransform.call( this );
	    // create a canvas element
	    this._canvas = document.createElement( 'canvas' );
	    this._context = this._canvas.getContext( '2d' );
	    this._matrixTransform = new MatrixTransform();
	    this.addChild( this._matrixTransform );
	    this._text = '';
	    if ( text !== undefined ) this._text = text;
	    this._font = 'monospace';
	    // Vec4 value to load/return
	    this._color = Vec4.createAndSet( 0.0, 0.0, 0.0, 1.0 );
	    // This determines the text color, it can take a hex value or rgba value (e.g. rgba(255,0,0,0.5))
	    this._fillStyle = 'rgba( 0, 0, 0, 1 )';
	    // This determines the alignment of text, e.g. left, center, right
	    this._context.textAlign = 'center';
	    this._textX = undefined;
	    // This determines the baseline of the text, e.g. top, middle, bottom
	    this._context.baseLine = 'middle';
	    this._textY = undefined;
	    // Size of the textured quad in meters.
	    this._charactherSize = 1;
	    this._charactherSizeMode = Text.OBJECT_COORDS;
	    // Font resolution
	    this._fontSize = 32;
	    this._geometry = undefined;
	    this._autoRotateToScreen = false;
	    this._position = Vec3.create();
	    this._layout = Text.LEFT_TO_RIGHT;
	    this._alignment = Text.CENTER_CENTER;
	    // NPOT textures
	    this._forcePowerOfTwo = false;
	    // Lazy initialization
	    this.drawText();
	    this._dirty = false;
	};
	
	// CharacterSizeMode
	Text.OBJECT_COORDS = 0;
	Text.SCREEN_COORDS = 1;
	Text.OBJECT_COORDS_WITH_MAXIMUM_SCREEN_SIZE_CAPPED_BY_FONT_HEIGHT = 2;
	
	// Layout enum
	Text.LEFT_TO_RIGHT = 'ltr';
	Text.RIGHT_TO_LEFT = 'rtl';
	
	// Alignment enum
	Text.LEFT_TOP = 0;
	Text.LEFT_CENTER = 1;
	Text.LEFT_BOTTOM = 2;
	
	Text.CENTER_TOP = 3;
	Text.CENTER_CENTER = 4;
	Text.CENTER_BOTTOM = 5;
	
	Text.RIGHT_TOP = 6;
	Text.RIGHT_CENTER = 7;
	Text.RIGHT_BOTTOM = 8;
	
	/** @lends Text.prototype */
	Text.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( AutoTransform.prototype, {
	
	    drawText: function () {
	        if ( this._geometry !== undefined ) {
	            this._matrixTransform.removeChild( this._geometry );
	            // The text could be dynamic, so we need to remove GL objects
	            this._geometry.releaseGLObjects();
	        }
	        if ( !this._text ) return;
	        this.setTextProperties();
	        this._canvas.width = this._context.measureText( this._text ).width;
	        this._canvas.height = this._fontSize * 2;
	        // For devices not supporting NPOT textures
	        if ( this._forcePowerOfTwo ) {
	            this._canvas.width = this._nextPowerOfTwo( this._canvas.width );
	            this._canvas.height = this._nextPowerOfTwo( this._canvas.height );
	        }
	        // We need to set the text properties again, as the canvas size cold change.
	        this.setTextProperties();
	        this._context.clearRect( 0, 0, this._canvas.width, this._canvas.height );
	        this._context.fillText( this._text, this._textX, this._textY );
	        // Right now we set the pivot point to center, to assure the bounding box is correct when rendering billboards.
	        // TODO: Possibility to set different pivot point so we can have missing alignments.
	        var aspectRatio = this._canvas.width / this._canvas.height;
	        var quadWidth = this._charactherSize * aspectRatio;
	        this._geometry = Shape.createTexturedQuadGeometry( -quadWidth / 2, -this._charactherSize / 2, 0, quadWidth, 0, 0, 0, this._charactherSize, 0 );
	        // create a texture to attach the canvas2D
	        var texture = new Texture();
	        texture.setTextureSize( this._canvas.width, this._canvas.height );
	        texture.setMinFilter( 'LINEAR' );
	        texture.setMagFilter( 'LINEAR' );
	        texture.setImage( this._canvas );
	        // Transparency stuff
	        var stateset = this._geometry.getOrCreateStateSet();
	        stateset.setTextureAttributeAndModes( 0, texture );
	        stateset.setRenderingHint( 'TRANSPARENT_BIN' );
	        stateset.setAttributeAndModes( new BlendFunc( BlendFunc.ONE, BlendFunc.ONE_MINUS_SRC_ALPHA ) );
	        this._matrixTransform.addChild( this._geometry );
	        this.dirtyBound();
	    },
	
	    setText: function ( text ) {
	        this._text = text;
	        // Canvas size could change so we need to make it dirty.
	        this._dirty = true;
	    },
	
	    getText: function () {
	        return this._text;
	    },
	
	    setFont: function ( font ) {
	        this._font = font;
	        this._dirty = true;
	    },
	
	    setColor: function ( color ) {
	        this._color = color;
	        // Convert color to html range
	        this._fillStyle = 'rgba(' + Math.round( color[ 0 ] * 255 ) + ',' + Math.round( color[ 1 ] * 255 ) + ',' + Math.round( color[ 2 ] * 255 ) + ',' + color[ 3 ] + ')';
	        this._context.fillStyle = this._fillStyle;
	        // Canvas size does not change so we don't need to redo the quad.
	        this._context.fillText( this._text, this._textX, this._textY );
	    },
	
	    getColor: function () {
	        return this._color;
	    },
	
	    setCharacterSize: function ( size ) {
	        this._charactherSize = size;
	        if ( this._charactherSizeMode !== Text.OBJECT_COORDS ) {
	            Matrix.makeScale( this._charactherSize, this._charactherSize, this._charactherSize, this._matrixTransform.getMatrix() );
	            if ( this._charactherSizeMode === Text.OBJECT_COORDS_WITH_MAXIMUM_SCREEN_SIZE_CAPPED_BY_FONT_HEIGHT )
	                this.setMaximumScale( this._charactherSize );
	        }
	        this._dirty = true;
	    },
	
	    getCharacterSize: function () {
	        return this._charactherSize;
	    },
	
	    setCharacterSizeMode: function ( mode ) {
	        this._charactherSizeMode = mode;
	        if ( this._charactherSizeMode !== Text.OBJECT_COORDS ) {
	            Matrix.makeScale( this._charactherSize, this._charactherSize, this._charactherSize, this._matrixTransform.getMatrix() );
	            this.setAutoScaleToScreen( true );
	            this.setMaximumScale( Number.MAX_VALUE );
	            if ( this._charactherSizeMode === Text.OBJECT_COORDS_WITH_MAXIMUM_SCREEN_SIZE_CAPPED_BY_FONT_HEIGHT )
	                this.setMaximumScale( this._charactherSize );
	        } else {
	            this._matrixTransform.setMatrix( Matrix.create() );
	            this.setAutoScaleToScreen( false );
	        }
	        this._dirty = true;
	    },
	
	    getCharacterSizeMode: function () {
	        return this._charactherSizeMode;
	    },
	
	    setFontResolution: function ( resolution ) {
	        this._fontSize = resolution;
	        this._dirty = true;
	    },
	
	    getFontResolution: function () {
	        return this._fontSize;
	    },
	
	    setPosition: function ( position ) {
	        this._position = position;
	        Matrix.makeTranslate( position[ 0 ], position[ 1 ], position[ 2 ], this.getMatrix() );
	    },
	
	    getPosition: function () {
	        return this._position;
	    },
	
	    setTextProperties: function () {
	        this._context.fillStyle = this._fillStyle;
	        this._setAlignmentValues( this._alignment );
	        this._context.font = this._fontSize + 'px ' + this._font;
	        this._context.direction = this._layout;
	    },
	
	    setAutoRotateToScreen: function ( value ) {
	        AutoTransform.prototype.setAutoRotateToScreen.call( this, value );
	        this._dirty = true;
	    },
	
	    getAutoRotateToScreen: function () {
	        return this._autoRotateToScreen;
	    },
	
	    setLayout: function ( layout ) {
	        if ( typeof layout === 'string' ) {
	            this._layout = Text[ layout ];
	        } else {
	            this._layout = layout;
	        }
	        this._dirty = true;
	    },
	    getLayout: function () {
	        return this._layout;
	    },
	    setAlignment: function ( alignment ) {
	        if ( typeof alignment === 'string' ) {
	            this._alignment = Text[ alignment ];
	        } else {
	            this._alignment = alignment;
	        }
	        this._dirty = true;
	    },
	    getAlignment: function () {
	        return this._alignment;
	    },
	
	
	    traverse: function ( visitor ) {
	        if ( this._dirty ) {
	            this.drawText();
	            this._dirty = false;
	        }
	        AutoTransform.prototype.traverse.call( this, visitor );
	    },
	
	    _setAlignmentValues: function ( alignment ) {
	        // Convert the OSG Api to js API
	        switch ( alignment ) {
	        case Text.LEFT_TOP:
	            this._context.textAlign = 'left';
	            this._textX = 0;
	            this._context.textBaseline = 'top';
	            this._textY = 0;
	            break;
	        case Text.LEFT_CENTER:
	            this._context.textAlign = 'left';
	            this._textX = 0;
	            this._context.textBaseline = 'middle';
	            this._textY = this._canvas.height / 2;
	            break;
	        case Text.LEFT_BOTTOM:
	            this._context.textAlign = 'left';
	            this._textX = 0;
	            this._context.textBaseline = 'bottom';
	            this._textY = this._canvas.height;
	            break;
	        case Text.CENTER_TOP:
	            this._context.textAlign = 'center';
	            this._textX = this._canvas.width / 2;
	            this._context.textBaseline = 'top';
	            this._textY = 0;
	            break;
	        case Text.CENTER_CENTER:
	            this._context.textAlign = 'center';
	            this._textX = this._canvas.width / 2;
	            this._context.textBaseline = 'middle';
	            this._textY = this._canvas.height / 2;
	            break;
	        case Text.CENTER_BOTTOM:
	            this._context.textAlign = 'center';
	            this._textX = this._canvas.width / 2;
	            this._context.textBaseline = 'bottom';
	            this._textY = this._canvas.height;
	            break;
	        case Text.RIGHT_TOP:
	            this._context.textAlign = 'right';
	            this._textX = this._canvas.width;
	            this._context.textBaseline = 'top';
	            this._textY = 0;
	            break;
	        case Text.RIGHT_CENTER:
	            this._context.textAlign = 'right';
	            this._textX = this._canvas.width;
	            this._context.textBaseline = 'middle';
	            this._textY = this._canvas.height / 2;
	            break;
	        case Text.RIGHT_BOTTOM:
	            this._context.textAlign = 'right';
	            this._textX = this._canvas.width;
	            this._context.textBaseline = 'bottom';
	            this._textY = this._canvas.height;
	            break;
	        }
	    },
	    setForcePowerOfTwo: function ( value ) {
	        this._forcePowerOfTwo = value;
	    },
	    getForcePowerOfTwo: function () {
	        return this._forcePowerOfTwo;
	    },
	    _nextPowerOfTwo: function ( value ) {
	        var v = value;
	        v--;
	        v |= v >> 1;
	        v |= v >> 2;
	        v |= v >> 4;
	        v |= v >> 8;
	        v |= v >> 16;
	        v++;
	        return v;
	    }
	} ), 'osgText', 'Text' );
	
	module.exports = Text;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Hammer = __webpack_require__( 131 );
	var CADManipulator = __webpack_require__( 132 );
	var CADManipulatorStandardMouseKeyboardController = __webpack_require__( 147 );
	var CADManipulatorHammerController = __webpack_require__( 148 );
	var FirstPersonManipulator = __webpack_require__( 149 );
	var FirstPersonManipulatorDeviceOrientationController = __webpack_require__( 136 );
	var FirstPersonManipulatorHammerController = __webpack_require__( 150 );
	var FirstPersonManipulatorStandardMouseKeyboardController = __webpack_require__( 152 );
	var FirstPersonManipulatorWebVRController = __webpack_require__( 151 );
	var Manipulator = __webpack_require__( 133 );
	var OrbitManipulator = __webpack_require__( 134 );
	var OrbitManipulatorDeviceOrientationController = __webpack_require__( 135 );
	var OrbitManipulatorGamePadController = __webpack_require__( 137 );
	var OrbitManipulatorHammerController = __webpack_require__( 138 );
	var OrbitManipulatorLeapMotionController = __webpack_require__( 139 );
	var OrbitManipulatorStandardMouseKeyboardController = __webpack_require__( 140 );
	var OrbitManipulatorWebVRController = __webpack_require__( 142 );
	var SwitchManipulator = __webpack_require__( 153 );
	var OrbitManipulatorEnums = __webpack_require__( 141 );
	
	
	var osgGA = {};
	
	Hammer.NO_MOUSEEVENTS = true; // disable hammer js mouse events
	
	osgGA.CADManipulator = CADManipulator;
	osgGA.getCADManipulatorStandardMouseKeyboardController = function () {
	    return CADManipulatorStandardMouseKeyboardController;
	};
	osgGA.getCADManipulatorHammerController = function () {
	    return CADManipulatorHammerController;
	};
	osgGA.FirstPersonManipulator = FirstPersonManipulator;
	osgGA.getFirstPersonDeviceOrientationController = function () {
	    return FirstPersonManipulatorDeviceOrientationController;
	};
	osgGA.getFirstPersonManipulatorHammerController = function () {
	    return FirstPersonManipulatorHammerController;
	};
	osgGA.getFirstPersonStandardMouseKeyboardControllerClass = function () {
	    return FirstPersonManipulatorStandardMouseKeyboardController;
	};
	osgGA.getFirstPersonWebVRControllerClass = function () {
	    return FirstPersonManipulatorWebVRController;
	};
	osgGA.Manipulator = Manipulator;
	osgGA.OrbitManipulator = OrbitManipulator;
	osgGA.getOrbitManipulatorDeviceOrientationController = function () {
	    return OrbitManipulatorDeviceOrientationController;
	};
	osgGA.getOrbitManipulatorGamePadController = function () {
	    return OrbitManipulatorGamePadController;
	};
	osgGA.getOrbitManipulatorHammerController = function () {
	    return OrbitManipulatorHammerController;
	};
	osgGA.getOrbitManipulatorLeapMotionController = function () {
	    return OrbitManipulatorLeapMotionController;
	};
	osgGA.getOrbitManipulatorStandardMouseKeyboardController = function () {
	    return OrbitManipulatorStandardMouseKeyboardController;
	};
	osgGA.getOrbitManipulatorWebVRController = function () {
	    return OrbitManipulatorWebVRController;
	};
	
	osgGA.SwitchManipulator = SwitchManipulator;
	
	osgGA.OrbitManipulator.Rotate = OrbitManipulatorEnums.ROTATE;
	osgGA.OrbitManipulator.Pan = OrbitManipulatorEnums.PAN;
	osgGA.OrbitManipulator.Zoom = OrbitManipulatorEnums.ZOOM;
	
	module.exports = osgGA;


/***/ }),
/* 131 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_131__;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Manipulator = __webpack_require__( 133 );
	var OrbitManipulator = __webpack_require__( 134 );
	var IntersectionVisitor = __webpack_require__( 143 );
	var LineSegmentIntersector = __webpack_require__( 144 );
	var PolytopeIntersector = __webpack_require__( 145 );
	var ComputeMatrixFromNodePath = __webpack_require__( 28 );
	var Matrix = __webpack_require__( 23 );
	var Vec2 = __webpack_require__( 70 );
	var Vec3 = __webpack_require__( 15 );
	var Quat = __webpack_require__( 26 );
	var CADManipulatorStandardMouseKeyboardController = __webpack_require__( 147 );
	var CADManipulatorHammerController = __webpack_require__( 148 );
	
	/**
	 *  CADManipulator
	 *  @class Provides a manipulator with rotation and zoom capacities around a pivot point.
	 *  The pivot point is computed through intersections. If no intersection is computed
	 *  the manipulator uses the last computed pivot point.
	 *  - Mousewheel/Pinch zooms in and out on the pivot point.
	 *  - Double click/tap zooms in on the pivot point.
	 *  - Left click/pan rotates around the pivot point.
	 *  - Center/Right click or two-finger drag moves the view.
	 *  - Spacebar resets the view.
	 */
	
	var CADManipulator = function () {
	    Manipulator.call( this );
	    this._tmpHomePosition = Vec3.create();
	    this._intersectionVisitor = new IntersectionVisitor();
	    this._lineSegmentIntersector = new LineSegmentIntersector();
	    this._polytopeIntersector = undefined;
	    this._usePolytopeIntersector = false;
	    this._dimensionMask = ( 1 << 2 );
	    this.init();
	};
	
	CADManipulator.Interpolator = function () {
	    this._current = Vec2.create();
	    this._target = Vec2.create();
	    this._delta = Vec2.create();
	    this._reset = false;
	    this.reset();
	    this._width = undefined;
	    this._height = undefined;
	};
	
	CADManipulator.Interpolator.prototype = {
	    setWidth: function ( width ) {
	        this._width = width;
	    },
	    setHeight: function ( height ) {
	        this._height = height;
	    },
	    reset: function () {
	        for ( var i = 0, l = this._current.length; i < l; i++ ) {
	            this._current[ i ] = this._target[ i ] = 0;
	        }
	        this._reset = true;
	    },
	    update: function () {
	        var d0;
	        var d1;
	        if ( this._width === undefined ) d0 = 0;
	        else d0 = ( this._target[ 0 ] - this._current[ 0 ] ) / this._width;
	        this._delta[ 0 ] = d0;
	        this._current[ 0 ] = this._target[ 0 ];
	        if ( this._height === undefined ) d1 = 0;
	        else d1 = ( this._target[ 1 ] - this._current[ 1 ] ) / this._height;
	        this._delta[ 1 ] = d1;
	        this._current[ 1 ] = this._target[ 1 ];
	        return this._delta;
	    },
	    set: function () {
	        for ( var i = 0, l = this._current.length; i < l; i++ ) {
	            this._current[ i ] = this._target[ i ] = arguments[ i ];
	        }
	        this._reset = false;
	    },
	    isReset: function () {
	        return this._reset;
	    },
	    getCurrent: function () {
	        return this._current;
	    },
	    setTarget: function () {
	        for ( var i = 0, l = this._target.length; i < l; i++ ) {
	            if ( this._reset ) {
	                this._target[ i ] = this._current[ i ] = arguments[ i ];
	            } else {
	                this._target[ i ] = arguments[ i ];
	            }
	        }
	        this._reset = false;
	    },
	    addTarget: function () {
	        for ( var i = 0; i < arguments.length; i++ ) {
	            this._target[ i ] += arguments[ i ];
	        }
	    },
	    getTarget: function () {
	        return this._target;
	    },
	    getDelta: function () {
	        return this._delta;
	    }
	};
	
	CADManipulator.AvailableControllerList = [ 'StandardMouseKeyboard', 'Hammer' ];
	CADManipulator.ControllerList = [ 'StandardMouseKeyboard', 'Hammer' ];
	
	/** @lends CADManipulator.prototype */
	CADManipulator.prototype = MACROUTILS.objectInherit( Manipulator.prototype, {
	    init: function () {
	        this._distance = 25.0;
	        this._target = Vec3.create();
	        this._upz = Vec3.createAndSet( 0.0, 0.0, 1.0 );
	        Vec3.init( this._target );
	
	        var rot1 = Matrix.makeRotate( -Math.PI, 0.0, 0.0, 1.0, Matrix.create() );
	        var rot2 = Matrix.makeRotate( Math.PI / 10.0, 1.0, 0.0, 0.0, Matrix.create() );
	        this._rotation = Matrix.create();
	        Matrix.mult( rot1, rot2, this._rotation );
	        this._time = 0.0;
	
	        this._rotate = new CADManipulator.Interpolator();
	        this._pan = new CADManipulator.Interpolator();
	        this._zoom = new OrbitManipulator.Interpolator( 1 );
	
	        this._panFactor = 1.5;
	        this._rotateFactor = 1;
	        this._zoomFactor = 1;
	
	        this._inverseMatrix = Matrix.create();
	
	        this._homeEye = undefined;
	        this._homeCenter = undefined;
	        this._homeUp = Vec3.createAndSet( 0.0, 0.0, 1.0 );
	
	        this._orientation = Quat.create();
	        this._pivotPoint = Vec3.create();
	
	        this._eye = Vec3.create();
	
	        this._right = Vec3.createAndSet( 1.0, 0.0, 0.0 );
	
	        this._zoomDir = Vec3.create();
	
	        // instance of controller
	        var self = this;
	
	        CADManipulator.ControllerList.forEach( function ( value ) {
	            if ( CADManipulator[ value ] !== undefined ) {
	                self._controllerList[ value ] = new CADManipulator[ value ]( self );
	            }
	        } );
	    },
	
	    setViewer: function ( viewer ) {
	        this._viewer = viewer;
	    },
	
	    reset: function () {
	        this.init();
	    },
	
	    setNode: function ( node ) {
	        this._node = node;
	    },
	
	    setPivotPoint: function ( pivotPoint ) {
	        // First calculate offset
	        Vec3.copy( pivotPoint, this._pivotPoint );
	
	    },
	
	    setTarget: ( function () {
	        var eyePos = Vec3.create();
	        return function ( target ) {
	            Vec3.copy( target, this._target );
	            this.getEyePosition( eyePos );
	            this._distance = Vec3.distance( eyePos, target );
	        };
	    } )(),
	
	    setEyePosition: function ( eye ) {
	        Vec3.copy( eye, this._eye );
	        this._distance = Vec3.distance( eye, this._target );
	    },
	
	    setHomePosition: function ( eye, center, up ) {
	        this._homeEye = eye;
	        this._homeCenter = center;
	        this._homeUp = up;
	    },
	
	    computeHomePosition: ( function () {
	        var f = Vec3.create();
	        var s = Vec3.create();
	        var u = Vec3.create();
	        var result = Matrix.create();
	        return function ( boundStrategy ) {
	
	            var bs = this.getHomeBound( boundStrategy );
	            if ( !bs ) return;
	            this.setDistance( this.getHomeDistance( bs ) );
	            this.setTarget( bs.center() );
	            this.setPivotPoint( bs.center() );
	
	            if ( this._homeEye === undefined ) {
	                this._homeEye = Vec3.create();
	                this.getEyePosition( this._homeEye );
	            }
	
	            if ( this._homeCenter === undefined ) {
	                this._homeCenter = Vec3.create();
	                Vec3.copy( bs.center(), this._homeCenter );
	            }
	            Vec3.copy( this._homeEye, this._eye );
	            Vec3.copy( this._homeCenter, this._target );
	            Vec3.copy( this._homeUp, this._upz );
	
	            Matrix.copy( this._rotation, result );
	            var center = this._target;
	            var eye = this._eye;
	
	            Vec3.sub( center, eye, f );
	            Vec3.normalize( f, f );
	
	            Vec3.cross( f, this._upz, s );
	            Vec3.normalize( s, s );
	
	            Vec3.cross( s, f, u );
	            Vec3.normalize( u, u );
	
	            // s[0], f[0], u[0], 0.0,
	            // s[1], f[1], u[1], 0.0,
	            // s[2], f[2], u[2], 0.0,
	            // 0,    0,    0,     1.0
	            result[ 0 ] = s[ 0 ];
	            result[ 1 ] = u[ 0 ];
	            result[ 2 ] = -f[ 0 ];
	            result[ 3 ] = 0.0;
	            result[ 4 ] = s[ 1 ];
	            result[ 5 ] = u[ 1 ];
	            result[ 6 ] = -f[ 1 ];
	            result[ 7 ] = 0.0;
	            result[ 8 ] = s[ 2 ];
	            result[ 9 ] = u[ 2 ];
	            result[ 10 ] = -f[ 2 ];
	            result[ 11 ] = 0.0;
	            result[ 12 ] = 0;
	            result[ 13 ] = 0;
	            result[ 14 ] = 0;
	            result[ 15 ] = 1.0;
	
	            Matrix.getRotate( result, this._orientation );
	            Quat.inverse( this._orientation, this._orientation );
	        };
	    } )(),
	
	    setZoomFactor: function ( f ) {
	        this._zoomFactor = f;
	    },
	
	    setRotateFactor: function ( f ) {
	        this._rotateFactor = f;
	    },
	
	    setPanFactor: function ( f ) {
	        this._panFactor = f;
	    },
	
	    setDistance: function ( d ) {
	        this._distance = d;
	    },
	
	    // If set to true, intersections are computed against points and lines
	    setUsePolytopeIntersector: function ( upi ) {
	        this._usePolytopeIntersector = upi;
	    },
	
	    getUsePolytopeIntersector: function () {
	        return this._usePolytopeIntersector;
	    },
	
	    getDistance: function () {
	        return this._distance;
	    },
	
	    zoom: function ( ratio ) {
	        this._distance = ratio;
	    },
	
	    getRotateInterpolator: function () {
	        return this._rotate;
	    },
	
	    getPanInterpolator: function () {
	        return this._pan;
	    },
	
	    getZoomInterpolator: function () {
	        return this._zoom;
	    },
	
	    getIntersectionVisitor: function () {
	        return this._intersectionVisitor;
	    },
	
	    getLineSegmentIntersector: function () {
	        return this._lineSegmentIntersector;
	    },
	
	    getOrCreatePolytopeIntersector: function () {
	        if ( this._polytopeIntersector === undefined ) {
	            this._polytopeIntersector = new PolytopeIntersector();
	            this._polytopeIntersector.setIntersectionLimit( PolytopeIntersector.LIMIT_ONE_PER_DRAWABLE );
	            this._polytopeIntersector.setDimensionMask( PolytopeIntersector.DimZero | PolytopeIntersector.DimOne );
	        }
	        return this._polytopeIntersector;
	    },
	
	    getTarget: function ( target ) {
	        Vec3.copy( this._target, target );
	        return target;
	    },
	
	    getEyePosition: function ( eye ) {
	        this.computeEyePosition( this._target, this._distance, eye );
	    },
	
	    computeEyePosition: ( function () {
	        var tmpDist = Vec3.create();
	        var tmpInverse = Matrix.create();
	        return function ( target, distance, eye ) {
	            Matrix.inverse( this._rotation, tmpInverse );
	            tmpDist[ 1 ] = distance;
	            Matrix.transformVec3( tmpInverse, tmpDist, eye );
	            Vec3.add( target, eye, eye );
	        };
	    } )(),
	
	    computePan: ( function () {
	        var trans = Vec3.create();
	        var rotPos = Vec3.create();
	        var speedTmp = Vec3.create();
	        return function ( dx, dy, rotMat ) {
	            var speed = Vec3.length( Vec3.sub( this._eye, this._pivotPoint, speedTmp ) ) / this._panFactor;
	            if ( speed < 10 ) speed = 10;
	            trans[ 0 ] = dx * speed / 2;
	            trans[ 1 ] = dy * speed / 2;
	            trans[ 2 ] = 0;
	            Matrix.transformVec3( rotMat, trans, rotPos );
	            Vec3.add( this._eye, rotPos, this._eye );
	        };
	    } )(),
	
	    computeZoom: ( function () {
	        var vectorDistance = Vec3.create();
	        var speedDist = Vec3.create();
	        return function ( dz ) {
	            var zoomSpeed = dz * this._zoomFactor;
	            Vec3.sub( this._pivotPoint, this._eye, vectorDistance );
	            Vec3.add( this._eye, Vec3.mult( vectorDistance, zoomSpeed, speedDist ), this._eye );
	        };
	    } )(),
	
	    computeRotation: ( function () {
	
	        var rightNormalized = Vec3.create();
	        var right = Vec3.create();
	        var dir = Vec3.create();
	        var offset = Vec3.create();
	        var pitchQuat = Quat.create();
	        var yawQuat = Quat.create();
	        var pitchyawQuat = Quat.create();
	        var tmp = Vec3.create();
	        var rightScalar = Vec3.create;
	
	        return function ( yawDelta, pitchDelta ) {
	
	            Quat.transformVec3( this._orientation, this._right, right );
	            Vec3.normalize( right, rightNormalized );
	            Vec3.sub( this._eye, this._pivotPoint, dir );
	            var scalar = Vec3.dot( rightNormalized, dir );
	            Vec3.sub( dir, Vec3.mult( rightNormalized, scalar, rightScalar ), offset );
	            var xy = Vec3.createAndSet( -offset[ 0 ], -offset[ 1 ], 0 );
	
	            var positionPitch = Math.atan2( -offset[ 2 ], Vec3.length( xy ) );
	            pitchDelta = Math.max( -Math.PI / 2 + 0.01, Math.min( Math.PI / 2 - 0.01, ( positionPitch + pitchDelta ) ) ) - positionPitch;
	
	            Quat.makeRotate( pitchDelta * this._rotateFactor, right[ 0 ], right[ 1 ], right[ 2 ], pitchQuat );
	            Quat.makeRotate( yawDelta * this._rotateFactor, this._upz[ 0 ], this._upz[ 1 ], this._upz[ 2 ], yawQuat );
	
	            Quat.mult( yawQuat, pitchQuat, pitchyawQuat );
	            Quat.transformVec3( pitchyawQuat, dir, tmp );
	            Vec3.add( tmp, this._pivotPoint, this._eye );
	
	            // Find rotation offset and target
	            Quat.mult( yawQuat, this._orientation, this._orientation );
	
	            Quat.transformVec3( this._orientation, this._right, right );
	            Quat.makeRotate( pitchDelta * this._rotateFactor, right[ 0 ], right[ 1 ], right[ 2 ], pitchQuat );
	            Quat.mult( pitchQuat, this._orientation, this._orientation );
	        };
	    } )(),
	
	
	    update: ( function () {
	        var rotMat = Matrix.create();
	        var transMat = Matrix.create();
	        return function ( nv ) {
	
	            var dt = nv.getFrameStamp().getDeltaTime();
	
	            var mouseFactor = 10;
	            //Note inverted y
	            var delta = this._rotate.update();
	            this.computeRotation( -delta[ 0 ] * mouseFactor, delta[ 1 ] * mouseFactor );
	            Matrix.makeRotateFromQuat( this._orientation, rotMat );
	
	            var deltapan = this._pan.update();
	            this.computePan( -deltapan[ 0 ] * mouseFactor, -deltapan[ 1 ] * mouseFactor, rotMat );
	
	            delta = this._zoom.update( dt );
	            this.computeZoom( -delta[ 0 ] / 10.0 );
	
	            Matrix.makeTranslate( this._eye[ 0 ], this._eye[ 1 ], this._eye[ 2 ], transMat );
	            Matrix.mult( transMat, rotMat, this._inverseMatrix );
	            Matrix.inverse( this._inverseMatrix, this._inverseMatrix );
	        };
	    } )(),
	    getInverseMatrix: function () {
	        return this._inverseMatrix;
	    },
	
	    computeIntersections: ( function () {
	        var hits = [];
	        var pTrans = Vec3.create();
	        return function ( pos ) {
	            var viewer = this._camera.getView();
	
	            var cam = this._camera;
	            var width = cam.getViewport().width();
	            var height = cam.getViewport().height();
	            this._rotate.setWidth( width );
	            this._rotate.setHeight( height );
	            this._pan.setWidth( width );
	            this._pan.setHeight( height );
	
	            var point, matrix;
	            if ( ( this._dimensionMask & ( 1 << 2 ) ) !== 0 ) {
	                hits = viewer.computeIntersections( pos[ 0 ], pos[ 1 ] );
	
	                if ( hits.length > 0 ) {
	                    point = hits[ 0 ].point;
	                    hits[ 0 ].nodepath.shift();
	                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( hits[ 0 ].nodepath );
	                    Matrix.transformVec3( matrix, point, pTrans );
	                    this.setPivotPoint( pTrans );
	                }
	            }
	
	            if ( hits.length === 0 && this._usePolytopeIntersector ) {
	                var pi = this.getOrCreatePolytopeIntersector();
	                pi.reset();
	                pi.setPolytopeFromWindowCoordinates( pos[ 0 ] - 5, pos[ 1 ] - 5, pos[ 0 ] + 5, pos[ 1 ] + 5 );
	                var iv = this._intersectionVisitor;
	                iv.setIntersector( pi );
	                viewer.getCamera().accept( iv );
	                hits = pi.getIntersections();
	                hits.sort( function ( a, b ) {
	                    return a._distance - b._distance;
	                } );
	                if ( hits.length > 0 ) {
	                    point = hits[ 0 ]._center;
	                    hits[ 0 ].nodePath.shift();
	                    matrix = ComputeMatrixFromNodePath.computeLocalToWorld( hits[ 0 ].nodePath );
	                    Matrix.transformVec3( matrix, point, pTrans );
	                    this.setPivotPoint( pTrans );
	                }
	            }
	        };
	    } )(),
	
	    getPositionRelativeToCanvas: ( function () {
	        var offset = Vec2.create();
	        var pos = Vec2.create();
	        return function ( x, y ) {
	            var canvas = this._camera._graphicContext.canvas;
	            this.getOffsetRect( canvas, offset );
	            var ratioX = canvas.width / canvas.clientWidth;
	            var ratioY = canvas.height / canvas.clientHeight;
	            pos[ 0 ] = ( x - offset[ 1 ] ) * ratioX;
	            pos[ 1 ] = ( canvas.clientHeight - ( y - offset[ 0 ] ) ) * ratioY;
	            return pos;
	        };
	    } )(),
	
	    getCanvasCenter: ( function () {
	        var offset = Vec2.create();
	        var pos = Vec2.create();
	        return function () {
	            var canvas = this._camera.getGraphicContext().canvas;
	            this.getOffsetRect( canvas, offset );
	            var ratioX = canvas.width / canvas.clientWidth;
	            var ratioY = canvas.height / canvas.clientHeight;
	            pos[ 0 ] = ( canvas.clientWidth / 2 ) * ratioX;
	            pos[ 1 ] = ( canvas.clientHeight / 2 ) * ratioY;
	            return pos;
	        };
	    } )(),
	
	    getOffsetRect: function ( elem, offset ) {
	        var box = elem.getBoundingClientRect();
	        var body = document.body;
	        var docElem = document.documentElement;
	        var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
	        var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
	        var clientTop = docElem.clientTop || body.clientTop || 0;
	        var clientLeft = docElem.clientLeft || body.clientLeft || 0;
	        var top = box.top + scrollTop - clientTop;
	        var left = box.left + scrollLeft - clientLeft;
	        offset[ 0 ] = Math.round( top );
	        offset[ 1 ] = Math.round( left );
	        return offset;
	    }
	
	} );
	
	CADManipulator.StandardMouseKeyboard = CADManipulatorStandardMouseKeyboardController;
	CADManipulator.Hammer = CADManipulatorHammerController;
	
	module.exports = CADManipulator;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BoundingSphere = __webpack_require__( 18 );
	var Matrix = __webpack_require__( 23 );
	var Notify = __webpack_require__( 10 );
	
	
	// Base class for Camera / User manipulator
	var Manipulator = function ( boundStrategy ) {
	    this._boundStrategy = boundStrategy;
	    if ( this._boundStrategy === undefined )
	        this._boundStrategy = Manipulator.COMPUTE_HOME_USING_SPHERE;
	
	    this._controllerList = {};
	    this._inverseMatrix = Matrix.create();
	    this._camera = undefined;
	    this._node = undefined;
	    this._frustum = {};
	};
	
	Manipulator.prototype = {
	    setCamera: function ( c ) {
	        this._camera = c;
	    },
	    getCamera: function () {
	        return this._camera;
	    },
	    setNode: function ( node ) {
	        this._node = node;
	    },
	    getHomeBound: function ( overrideStrat ) {
	        var node = this._node;
	        if ( !node )
	            return;
	
	        var type = overrideStrat !== undefined ? overrideStrat : this._boundStrategy;
	
	        if ( type === true || type === false ) {
	            Notify.warn( 'Manipulator.getHomeBound with boolean is deprecated, pass a type instead' );
	            type = type ? Manipulator.COMPUTE_HOME_USING_BBOX : Manipulator.COMPUTE_HOME_USING_SPHERE;
	        }
	
	        if ( type & Manipulator.COMPUTE_HOME_USING_BBOX ) {
	            var bs = new BoundingSphere();
	            var bb = node.getBoundingBox();
	            if ( bb.valid() )
	                bs.expandByBoundingBox( bb );
	
	            // minimum between sphere and box
	            if ( type & Manipulator.COMPUTE_HOME_USING_SPHERE ) {
	                var boundSphere = node.getBound();
	                if ( boundSphere.radius() < bs.radius() )
	                    return boundSphere;
	            }
	
	            return bs;
	        }
	
	        return node.getBound();
	    },
	    getHomeDistance: function ( bs ) {
	        var frustum = this._frustum;
	        var dist = bs.radius();
	        if ( this._camera && Matrix.getFrustum( this._camera.getProjectionMatrix(), frustum ) ) {
	            var vertical2 = Math.abs( frustum.right - frustum.left ) / frustum.zNear / 2;
	            var horizontal2 = Math.abs( frustum.top - frustum.bottom ) / frustum.zNear / 2;
	            dist /= Math.sin( Math.atan2( horizontal2 < vertical2 ? horizontal2 : vertical2, 1 ) );
	        } else {
	            dist *= 1.5;
	        }
	        return dist;
	    },
	    // eg: var currentTime = nv.getFrameStamp().getSimulationTime();
	    update: function ( /*nv*/) {},
	
	    getInverseMatrix: function () {
	        return this._inverseMatrix;
	    },
	
	    getControllerList: function () {
	        return this._controllerList;
	    }
	};
	
	// flags
	Manipulator.COMPUTE_HOME_USING_SPHERE = 1 << 0;
	Manipulator.COMPUTE_HOME_USING_BBOX = 1 << 1;
	
	module.exports = Manipulator;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var Matrix = __webpack_require__( 23 );
	var Manipulator = __webpack_require__( 133 );
	var OrbitManipulatorDeviceOrientationController = __webpack_require__( 135 );
	var OrbitManipulatorGamePadController = __webpack_require__( 137 );
	var OrbitManipulatorHammerController = __webpack_require__( 138 );
	var OrbitManipulatorLeapMotionController = __webpack_require__( 139 );
	var OrbitManipulatorStandardMouseKeyboardController = __webpack_require__( 140 );
	var OrbitManipulatorWebVRController = __webpack_require__( 142 );
	
	
	/**
	 *  OrbitManipulator
	 *  @class
	 */
	var OrbitManipulator = function ( boundStrategy ) {
	    Manipulator.call( this, boundStrategy );
	    this._homePosition = Vec3.create();
	    this._frustum = {};
	    this.init();
	};
	
	OrbitManipulator.Interpolator = function ( size, delay ) {
	    this._current = new Float32Array( size );
	    this._target = new Float32Array( size );
	    this._delta = new Float32Array( size );
	    this._delay = ( delay !== undefined ) ? delay : 0.15;
	    this._reset = false;
	    this._start = 0.0;
	    this.reset();
	};
	OrbitManipulator.Interpolator.prototype = {
	    setDelay: function ( delay ) {
	        this._delay = delay;
	    },
	    reset: function () {
	        for ( var i = 0, l = this._current.length; i < l; i++ ) {
	            this._current[ i ] = this._target[ i ] = 0.0;
	        }
	        this._reset = true;
	    },
	    update: function ( dt ) {
	        // assume 60 fps to be consistent with the old _delay values for backward compatibility
	        // (otherwise we'd have to adjust the _delay values by multiplying to 60 )
	        var dtDelay = Math.min( 1.0, this._delay * dt * 60.0 );
	        for ( var i = 0, l = this._current.length; i < l; i++ ) {
	            var d = ( this._target[ i ] - this._current[ i ] ) * dtDelay;
	            this._delta[ i ] = d;
	            this._current[ i ] += d;
	        }
	        return this._delta;
	    },
	    set: function () {
	        for ( var i = 0, l = this._current.length; i < l; i++ ) {
	            this._current[ i ] = this._target[ i ] = arguments[ i ];
	        }
	        this._reset = false;
	    },
	    isReset: function () {
	        return this._reset;
	    },
	    getCurrent: function () {
	        return this._current;
	    },
	    setTarget: function () {
	        for ( var i = 0, l = this._target.length; i < l; i++ ) {
	            if ( this._reset ) {
	                this._target[ i ] = this._current[ i ] = arguments[ i ];
	            } else {
	                this._target[ i ] = arguments[ i ];
	            }
	        }
	        this._reset = false;
	    },
	    addTarget: function () {
	        for ( var i = 0; i < arguments.length; i++ ) {
	            this._target[ i ] += arguments[ i ];
	        }
	    },
	    getTarget: function () {
	        return this._target;
	    },
	    getDelta: function () {
	        return this._delta;
	    },
	    getStart: function () {
	        return this._start;
	    },
	    setStart: function ( start ) {
	        this._start = start;
	    }
	};
	
	OrbitManipulator.AvailableControllerList = [ 'StandardMouseKeyboard',
	    'LeapMotion',
	    'GamePad',
	    'Hammer',
	    'DeviceOrientation',
	    'WebVR'
	];
	
	OrbitManipulator.ControllerList = [ 'StandardMouseKeyboard',
	    'LeapMotion',
	    'GamePad',
	    'Hammer',
	    'DeviceOrientation',
	    'WebVR'
	];
	
	var DOT_LIMIT = 0.99; // angle limit around the pole
	
	/** @lends OrbitManipulator.prototype */
	OrbitManipulator.prototype = MACROUTILS.objectInherit( Manipulator.prototype, {
	    init: function () {
	        this._distance = 25.0;
	        this._target = Vec3.create();
	        this._upz = Vec3.createAndSet( 0.0, 0.0, 1.0 );
	        Vec3.init( this._target );
	
	        var rot1 = Matrix.makeRotate( -Math.PI, 0.0, 0.0, 1.0, Matrix.create() );
	        var rot2 = Matrix.makeRotate( Math.PI / 10.0, 1.0, 0.0, 0.0, Matrix.create() );
	        this._rotation = Matrix.create();
	        Matrix.mult( rot1, rot2, this._rotation );
	        this._time = 0.0;
	
	        this._vrMatrix = Matrix.create();
	
	        this._rotate = new OrbitManipulator.Interpolator( 2 );
	        this._pan = new OrbitManipulator.Interpolator( 2 );
	        this._zoom = new OrbitManipulator.Interpolator( 1 );
	
	        this._maxDistance = Infinity;
	        this._minDistance = 1e-4; // min distance allowed between eye and target
	        this._minSpeed = 1e-4; // set a limit to pan/zoom speed
	        this._scaleMouseMotion = 1.0;
	
	        this._inverseMatrix = Matrix.create();
	
	        // if we hit the min distance and can't zoom anymore, maybe we still want to move on
	        // with a very low _minDistance, it's like a fps manipulator as long as you don't unzoom
	        this._autoPushTarget = true;
	
	        // instance of controller
	        var self = this;
	
	        OrbitManipulator.ControllerList.forEach( function ( value ) {
	            if ( OrbitManipulator[ value ] !== undefined ) {
	                self._controllerList[ value ] = new OrbitManipulator[ value ]( self );
	            }
	        } );
	    },
	    setDelay: function ( dt ) {
	        this._rotate.setDelay( dt );
	        this._pan.setDelay( dt );
	        this._zoom.setDelay( dt );
	    },
	    reset: function () {
	        this.init();
	    },
	    setTarget: function ( target ) {
	        Vec3.copy( target, this._target );
	        var eyePos = Vec3.create();
	        this.getEyePosition( eyePos );
	        this._distance = Vec3.distance( eyePos, target );
	    },
	    setEyePosition: ( function () {
	        var f = Vec3.create();
	        var s = Vec3.create();
	        var u = Vec3.create();
	        return function ( eye ) {
	            var result = this._rotation;
	            var center = this._target;
	
	            Vec3.sub( eye, center, f );
	            Vec3.normalize( f, f );
	
	            Vec3.cross( f, this._upz, s );
	            Vec3.normalize( s, s );
	
	            Vec3.cross( s, f, u );
	            Vec3.normalize( u, u );
	
	            // s[0], f[0], u[0], 0.0,
	            // s[1], f[1], u[1], 0.0,
	            // s[2], f[2], u[2], 0.0,
	            // 0,    0,    0,     1.0
	            result[ 0 ] = s[ 0 ];
	            result[ 1 ] = f[ 0 ];
	            result[ 2 ] = u[ 0 ];
	            result[ 3 ] = 0.0;
	            result[ 4 ] = s[ 1 ];
	            result[ 5 ] = f[ 1 ];
	            result[ 6 ] = u[ 1 ];
	            result[ 7 ] = 0.0;
	            result[ 8 ] = s[ 2 ];
	            result[ 9 ] = f[ 2 ];
	            result[ 10 ] = u[ 2 ];
	            result[ 11 ] = 0.0;
	            result[ 12 ] = 0;
	            result[ 13 ] = 0;
	            result[ 14 ] = 0;
	            result[ 15 ] = 1.0;
	
	            this._distance = Vec3.distance( eye, center );
	        };
	    } )(),
	
	    computeHomePosition: function ( boundStrategy ) {
	
	        var bs = this.getHomeBound( boundStrategy );
	        if ( !bs || !bs.valid() ) return;
	
	        this.setDistance( this.getHomeDistance( bs ) );
	        this.setTarget( bs.center() );
	
	    },
	
	    getHomePosition: function () {
	
	        if ( this._node !== undefined ) {
	
	            var target = this._target;
	            var distance = this.getDistance();
	
	            this.computeEyePosition( target, distance, this._homePosition );
	        }
	        return this._homePosition;
	    },
	
	    setMaxDistance: function ( d ) {
	        this._maxDistance = d;
	    },
	    getMaxDistance: function () {
	        return this._maxDistance;
	    },
	
	    setMinDistance: function ( d ) {
	        this._minDistance = Math.max( 1e-4, d );
	    },
	    getMinDistance: function () {
	        return this._minDistance;
	    },
	
	    setMinSpeed: function ( s ) {
	        this._minSpeed = s;
	    },
	    getMinSpeed: function () {
	        return this._minSpeed;
	    },
	
	    setDistance: function ( d ) {
	        this._distance = d;
	    },
	    getDistance: function () {
	        return this._distance;
	    },
	
	    getSpeedFactor: function () {
	        return Math.max( this._distance, this._minSpeed );
	    },
	    computePan: ( function () {
	        var inv = Matrix.create();
	        var x = Vec3.create();
	        var y = Vec3.create();
	        return function ( dx, dy ) {
	            var proj = this._camera.getProjectionMatrix();
	            // modulate panning speed with verticalFov value
	            // if it's an orthographic we don't change the panning speed
	            // TODO : manipulators in osgjs don't support well true orthographic camera anyway because they
	            // manage the view matrix (and you need to edit the projection matrix to 'zoom' for true ortho camera)
	            var vFov = proj[ 15 ] === 1 ? 1.0 : 2.00 / proj[ 5 ];
	            var speed = this.getSpeedFactor() * vFov;
	            dy *= speed;
	            dx *= speed;
	
	            Matrix.inverse( this._rotation, inv );
	            x[ 0 ] = Matrix.get( inv, 0, 0 );
	            x[ 1 ] = Matrix.get( inv, 0, 1 );
	            x[ 2 ] = Matrix.get( inv, 0, 2 );
	            Vec3.normalize( x, x );
	
	            y[ 0 ] = Matrix.get( inv, 2, 0 );
	            y[ 1 ] = Matrix.get( inv, 2, 1 );
	            y[ 2 ] = Matrix.get( inv, 2, 2 );
	            Vec3.normalize( y, y );
	
	            Vec3.mult( x, -dx, x );
	            Vec3.mult( y, dy, y );
	            Vec3.add( this._target, x, this._target );
	            Vec3.add( this._target, y, this._target );
	        };
	    } )(),
	    computeRotation: ( function () {
	        var of = Matrix.create();
	        var r = Matrix.create();
	        var r2 = Matrix.create();
	        var tmp = Vec3.create();
	        var radLimit = Math.acos( DOT_LIMIT ) * 2.0;
	        return function ( dx, dy ) {
	            Matrix.makeRotate( -dx / 10.0, 0.0, 0.0, 1.0, of );
	            Matrix.mult( this._rotation, of, r );
	
	            // limit the dy movement to the range [-radLimit, radLimit]
	            // so that we can't "jump" to the other side of the poles
	            // with a rapid mouse movement
	            dy = Math.max( Math.min( dy / 10.0, radLimit ), -radLimit );
	            Matrix.makeRotate( -dy, 1.0, 0.0, 0.0, of );
	            Matrix.mult( of, r, r2 );
	
	            // prevent going on the other side of the sphere (block y)
	            Matrix.transformVec3( r2, this._upz, tmp );
	            if ( Math.abs( tmp[ 1 ] ) > DOT_LIMIT ) {
	                Matrix.copy( r, this._rotation );
	                return;
	            }
	            Matrix.copy( r2, this._rotation );
	        };
	    } )(),
	    computeZoom: function ( dz ) {
	        this.zoom( dz );
	    },
	
	    setAutoPushTarget: function ( bool ) {
	        this._autoPushTarget = bool;
	    },
	
	    zoom: ( function () {
	        var dir = Vec3.create();
	        return function ( ratio ) {
	            var newValue = this._distance + this.getSpeedFactor() * ( ratio - 1.0 );
	
	            if ( newValue < this._minDistance ) {
	                if ( this._autoPushTarget ) {
	                    // push the target instead of zooming on it
	                    Vec3.sub( this._target, this.getEyePosition( dir ), dir );
	                    Vec3.normalize( dir, dir );
	                    Vec3.mult( dir, this._minDistance - newValue, dir );
	                    Vec3.add( this._target, dir, this._target );
	                }
	                newValue = this._minDistance;
	            }
	
	            if ( newValue > this._maxDistance )
	                newValue = this._maxDistance;
	
	            this._distance = newValue;
	        };
	    } )(),
	
	    getRotateInterpolator: function () {
	        return this._rotate;
	    },
	    getPanInterpolator: function () {
	        return this._pan;
	    },
	    getZoomInterpolator: function () {
	        return this._zoom;
	    },
	    getTarget: function ( target ) {
	        return Vec3.copy( this._target, target );
	    },
	    getEyePosition: function ( eye ) {
	        this.computeEyePosition( this._target, this._distance, eye );
	        return eye;
	    },
	
	    computeEyePosition: ( function () {
	        var tmpDist = Vec3.create();
	        var tmpInverse = Matrix.create();
	        return function ( target, distance, eye ) {
	            Matrix.inverse( this._rotation, tmpInverse );
	            tmpDist[ 1 ] = distance;
	            Matrix.transformVec3( tmpInverse, tmpDist, eye );
	            Vec3.add( target, eye, eye );
	        };
	    } )(),
	
	    update: ( function () {
	        var eye = Vec3.create();
	        return function ( nv ) {
	            var dt = nv.getFrameStamp().getDeltaTime();
	
	            var delta;
	            var mouseFactor = 0.1;
	            delta = this._rotate.update( dt );
	            this.computeRotation( -delta[ 0 ] * mouseFactor * this._scaleMouseMotion, -delta[ 1 ] * mouseFactor * this._scaleMouseMotion );
	
	            var panFactor = 0.002;
	            delta = this._pan.update( dt );
	            this.computePan( -delta[ 0 ] * panFactor, -delta[ 1 ] * panFactor );
	
	
	            delta = this._zoom.update( dt );
	            this.computeZoom( 1.0 + delta[ 0 ] / 10.0 );
	
	            var target = this._target;
	            var distance = this._distance;
	
	            /* 1. Works but bypass other manipulators */
	            // Matrix.copy( this._vrMatrix, this._inverseMatrix );
	
	            /* 2. Works but gets broken by other manipulators */
	            Matrix.inverse( this._rotation, this._inverseMatrix );
	            Matrix.postMult( this._vrMatrix, this._inverseMatrix );
	
	            /* 3. Doesnt' work */
	            // Matrix.preMult( this._vrMatrix, this._rotation );
	            // Matrix.inverse( this._vrMatrix, this._inverseMatrix );
	
	            Vec3.set( 0.0, distance, 0.0, eye );
	            Matrix.transformVec3( this._inverseMatrix, eye, eye );
	
	            Matrix.makeLookAt( Vec3.add( target, eye, eye ), target, this._upz, this._inverseMatrix );
	        };
	    } )(),
	
	    setPoseVR: function ( quat /*, pos*/ ) {
	        Matrix.makeRotateFromQuat( quat, this._vrMatrix );
	        // this._vrMatrix[ 12 ] = pos[ 0 ];
	        // this._vrMatrix[ 13 ] = pos[ 1 ];
	        // this._vrMatrix[ 14 ] = pos[ 2 ];
	    }
	} );
	
	OrbitManipulator.DeviceOrientation = OrbitManipulatorDeviceOrientationController;
	OrbitManipulator.GamePad = OrbitManipulatorGamePadController;
	OrbitManipulator.Hammer = OrbitManipulatorHammerController;
	OrbitManipulator.LeapMotion = OrbitManipulatorLeapMotionController;
	OrbitManipulator.WebVR = OrbitManipulatorWebVRController;
	OrbitManipulator.StandardMouseKeyboard = OrbitManipulatorStandardMouseKeyboardController;
	
	module.exports = OrbitManipulator;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Quat = __webpack_require__( 26 );
	var Vec3 = __webpack_require__( 15 );
	
	var FirstPersonDeviceOrientation = __webpack_require__( 136 );
	
	
	var OrbitManipulatorDeviceOrientationController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	OrbitManipulatorDeviceOrientationController.prototype = {
	
	    init: function () {
	        this._stepFactor = 1.0; // meaning radius*stepFactor to move
	        this._quat = Quat.create();
	        this._pos = Vec3.create();
	    },
	
	    update: function ( deviceOrientation, screenOrientation ) {
	
	        // for now we use the same code in first person and orbit to compute rotation
	        FirstPersonDeviceOrientation.computeQuaternion( this._quat, deviceOrientation, screenOrientation );
	        this._manipulator.setPoseVR( this._quat, this._pos );
	    }
	
	};
	
	module.exports = OrbitManipulatorDeviceOrientationController;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Quat = __webpack_require__( 26 );
	var Vec3 = __webpack_require__( 15 );
	
	var degtorad = Math.PI / 180.0; // Degree-to-Radian conversion
	
	var makeRotateFromEuler = function ( x, y, z, order, quat ) {
	
	    // http://www.mathworks.com/matlabcentral/fileexchange/
	    // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
	    // content/SpinCalc.m
	
	    var c1 = Math.cos( x / 2 );
	    var c2 = Math.cos( y / 2 );
	    var c3 = Math.cos( z / 2 );
	    var s1 = Math.sin( x / 2 );
	    var s2 = Math.sin( y / 2 );
	    var s3 = Math.sin( z / 2 );
	
	    if ( order === 'XYZ' ) {
	
	        quat[ 0 ] = s1 * c2 * c3 + c1 * s2 * s3;
	        quat[ 1 ] = c1 * s2 * c3 - s1 * c2 * s3;
	        quat[ 2 ] = c1 * c2 * s3 + s1 * s2 * c3;
	        quat[ 3 ] = c1 * c2 * c3 - s1 * s2 * s3;
	
	    } else if ( order === 'YXZ' ) {
	
	        quat[ 0 ] = s1 * c2 * c3 + c1 * s2 * s3;
	        quat[ 1 ] = c1 * s2 * c3 - s1 * c2 * s3;
	        quat[ 2 ] = c1 * c2 * s3 - s1 * s2 * c3;
	        quat[ 3 ] = c1 * c2 * c3 + s1 * s2 * s3;
	
	    } else if ( order === 'ZXY' ) {
	
	        quat[ 0 ] = s1 * c2 * c3 - c1 * s2 * s3;
	        quat[ 1 ] = c1 * s2 * c3 + s1 * c2 * s3;
	        quat[ 2 ] = c1 * c2 * s3 + s1 * s2 * c3;
	        quat[ 3 ] = c1 * c2 * c3 - s1 * s2 * s3;
	
	    } else if ( order === 'ZYX' ) {
	
	        quat[ 0 ] = s1 * c2 * c3 - c1 * s2 * s3;
	        quat[ 1 ] = c1 * s2 * c3 + s1 * c2 * s3;
	        quat[ 2 ] = c1 * c2 * s3 - s1 * s2 * c3;
	        quat[ 3 ] = c1 * c2 * c3 + s1 * s2 * s3;
	
	    } else if ( order === 'YZX' ) {
	
	        quat[ 0 ] = s1 * c2 * c3 + c1 * s2 * s3;
	        quat[ 1 ] = c1 * s2 * c3 + s1 * c2 * s3;
	        quat[ 2 ] = c1 * c2 * s3 - s1 * s2 * c3;
	        quat[ 3 ] = c1 * c2 * c3 - s1 * s2 * s3;
	
	    } else if ( order === 'XZY' ) {
	
	        quat[ 0 ] = s1 * c2 * c3 - c1 * s2 * s3;
	        quat[ 1 ] = c1 * s2 * c3 - s1 * c2 * s3;
	        quat[ 2 ] = c1 * c2 * s3 + s1 * s2 * c3;
	        quat[ 3 ] = c1 * c2 * c3 + s1 * s2 * s3;
	
	    }
	    return quat;
	};
	
	
	var FirstPersonManipulatorDeviceOrientationController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	FirstPersonManipulatorDeviceOrientationController.computeQuaternion = ( function () {
	
	    var screenTransform = Quat.create();
	    var worldTransform = Quat.createAndSet( -Math.sqrt( 0.5 ), 0.0, 0.0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis
	
	    // but on ios alpha is relative to the first question:
	    //
	    // http://www.html5rocks.com/en/tutorials/device/orientation/
	    // For most browsers, alpha returns the compass heading, so when the device is pointed
	    // north, alpha is zero. With Mobile Safari, alpha is based on the direction the
	    // device was pointing when device orientation was first requested. The compass
	    // heading is available in the webkitCompassHeading parameter.
	
	    return function ( quat, deviceOrientation, screenOrientation ) {
	
	        var alpha = deviceOrientation.alpha * degtorad;
	        var beta = deviceOrientation.beta * degtorad;
	        var gamma = deviceOrientation.gamma * degtorad;
	
	        // If the user goes in landscape mode, he rotates his device with a certain angle
	        // around the Z axis counterclockwise and the DeviceOrientation contains this
	        // rotation To compensate this, we apply a rotation of the same angle in the
	        // opposite way
	
	        var screenAngle = screenOrientation * degtorad;
	
	        // alpha is heading -> X
	        // beta             -> Z Up
	        // Gamma            -> Y view direction
	        makeRotateFromEuler( beta, alpha, -gamma, 'YXZ', quat );
	        // equivalent to
	        // var rotateX = Matrix.makeRotate( beta, 1,0,0, Matrix.create() );
	        // var rotateY = Matrix.makeRotate( alpha, 0,1,0, Matrix.create() );
	        // var rotateZ = Matrix.makeRotate( -gamma, 0,0,1, Matrix.create() );
	        // var result = Matrix.create();
	        // Matrix.mult( rotateY, rotateX, result );
	        // Matrix.mult( result, rotateZ, result );
	        // Matrix.getRotate( result, quat );
	
	        var minusHalfAngle = -screenAngle / 2.0;
	        screenTransform[ 1 ] = Math.sin( minusHalfAngle );
	        screenTransform[ 3 ] = Math.cos( minusHalfAngle );
	
	        Quat.mult( quat, screenTransform, quat );
	        Quat.mult( quat, worldTransform, quat );
	
	        var yTemp = quat[ 1 ];
	        quat[ 1 ] = -quat[ 2 ];
	        quat[ 2 ] = yTemp;
	
	        return quat;
	    };
	
	} )();
	
	FirstPersonManipulatorDeviceOrientationController.prototype = {
	
	    init: function () {
	        this._stepFactor = 1.0; // meaning radius*stepFactor to move
	        this._quat = Quat.create();
	        this._pos = Vec3.create();
	    },
	
	    update: function ( deviceOrientation, screenOrientation ) {
	
	        FirstPersonManipulatorDeviceOrientationController.computeQuaternion( this._quat, deviceOrientation, screenOrientation );
	        this._manipulator.setPoseVR( this._quat, this._pos );
	    }
	
	};
	
	module.exports = FirstPersonManipulatorDeviceOrientationController;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec2 = __webpack_require__( 70 );
	
	
	var OrbitManipulatorGamePadController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	OrbitManipulatorGamePadController.prototype = {
	    init: function () {
	        this._delay = 0.15;
	        this._threshold = 0.08;
	        this._mode = 0;
	        this._padFactor = 10.0;
	        this._zoomFactor = 0.5;
	        this._rotateFactor = 5.0;
	    },
	
	
	    addPan: function ( pan, x, y ) {
	        pan.setDelay( this._delay );
	        pan.addTarget( x * this._padFactor, y * this._padFactor );
	    },
	
	    addZoom: function ( zoom, z ) {
	        zoom.setDelay( this._delay );
	        zoom.addTarget( z * this._zoomFactor );
	    },
	
	    addRotate: function ( rotate, x, y ) {
	        rotate.setDelay( this._delay );
	        //var rotateTarget = rotate.getTarget();
	        rotate.addTarget( x * this._rotateFactor, y * this._rotateFactor );
	    },
	
	    gamepadaxes: function ( axes ) {
	
	        // Block badly balanced controllers
	        var AXIS_THRESHOLD = 0.005;
	
	        //var rotateTarget, panTarget;
	        var rotate = this._manipulator.getRotateInterpolator();
	        var zoom = this._manipulator.getZoomInterpolator();
	        var pan = this._manipulator.getPanInterpolator();
	        // Regular gamepads
	        if ( axes.length === 4 ) {
	
	            if ( Math.abs( axes[ 0 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 1 ] ) > AXIS_THRESHOLD ) {
	                this.addRotate( rotate, -axes[ 0 ], axes[ 1 ] );
	            }
	            if ( Math.abs( axes[ 3 ] ) > AXIS_THRESHOLD ) {
	                this.addZoom( zoom, -axes[ 3 ] );
	            }
	
	            //SpaceNavigator & 6-axis controllers
	        } else if ( axes.length >= 5 ) {
	            //Notify.log(axes);
	            if ( Math.abs( axes[ 0 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 1 ] ) > AXIS_THRESHOLD ) {
	                this.addPan( pan, -axes[ 0 ], axes[ 1 ] );
	            }
	
	            if ( Math.abs( axes[ 2 ] ) > AXIS_THRESHOLD ) {
	                this.addZoom( zoom, -axes[ 2 ] );
	            }
	
	            if ( Math.abs( axes[ 3 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 4 ] ) > AXIS_THRESHOLD ) {
	                this.addRotate( rotate, axes[ 4 ], axes[ 3 ] );
	            }
	        }
	
	    },
	
	    gamepadbuttondown: function ( event /*, pressed */ ) {
	        // Buttons 12 to 15 are the d-pad.
	        if ( event.button >= 12 && event.button <= 15 ) {
	            var pan = this._manipulator.getPanInterpolator();
	            var panTarget = pan.getTarget();
	            var delta = {
	                12: Vec2.createAndSet( 0, -1 ),
	                13: Vec2.createAndSet( 0, 1 ),
	                14: Vec2.createAndSet( -1, 0 ),
	                15: Vec2.createAndSet( 1, 0 )
	            }[ event.button ];
	            pan.setDelay( this._delay );
	            pan.setTarget( panTarget[ 0 ] - delta[ 0 ] * 10, panTarget[ 1 ] + delta[ 1 ] * 10 );
	        }
	    },
	
	    update: function ( gm ) {
	        if ( !gm ) {
	            return;
	        }
	
	        var axis = gm.axes;
	        var buttons = gm.buttons;
	
	        this.gamepadaxes( axis );
	
	        // Dummy event wrapper
	        var emptyFunc = function () {};
	        for ( var i = 0; i < buttons.length; i++ ) {
	            if ( buttons[ i ] ) {
	                this.gamepadbuttondown( {
	                    preventDefault: emptyFunc,
	                    gamepad: gm,
	                    button: i
	                }, !!buttons[ i ] );
	            }
	        }
	    }
	};
	module.exports = OrbitManipulatorGamePadController;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	
	
	var OrbitManipulatorHammerController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	OrbitManipulatorHammerController.prototype = {
	    init: function () {
	        this._panFactorX = 1.0;
	        this._panFactorY = -this._panFactorX;
	
	        this._rotateFactorX = 0.6;
	        this._rotateFactorY = -this._rotateFactorX;
	        this._zoomFactor = 5.0;
	
	        this._lastScale = 0;
	        this._nbPointerLast = 0; // to check if we the number of pointers has changed
	        this._delay = 0.15;
	    },
	    setEventProxy: function ( proxy ) {
	        if ( proxy === undefined || ( proxy !== undefined && proxy === this._eventProxy ) ) {
	            return;
	        }
	        this._eventProxy = proxy;
	        var self = this;
	        var hammer = proxy;
	        var computeTouches = function ( event ) {
	            if ( event.pointers !== undefined )
	                return event.pointers.length;
	            return 1; // mouse
	        };
	
	        var dragCB = function ( ev ) {
	            return 'touches ' + computeTouches( ev ) + ' distance ' + ev.distance + ' x ' + ev.deltaX + ' y ' + ev.deltaY;
	        };
	        // Set a minimal thresold on pinch event, to be detected after pan
	        hammer.get( 'pinch' ).set( {
	            threshold: 0.1
	        } );
	        // Let the pan be detected with two fingers.
	        hammer.get( 'pan' ).set( {
	            threshold: 0,
	            pointers: 0
	        } );
	        hammer.get( 'pinch' ).recognizeWith( hammer.get( 'pan' ) );
	
	        this._cbPanStart = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || self._transformStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            var gesture = event;
	            self._dragStarted = true;
	            self._nbPointerLast = computeTouches( gesture );
	
	            if ( self._nbPointerLast === 2 ) {
	                manipulator.getPanInterpolator().reset();
	                manipulator.getPanInterpolator().set( event.center.x * self._panFactorX, event.center.y * self._panFactorY );
	            } else {
	                manipulator.getRotateInterpolator().reset();
	                manipulator.getRotateInterpolator().set( event.center.x * self._rotateFactorX, event.center.y * self._rotateFactorY );
	            }
	            Notify.debug( 'drag start, ' + dragCB( gesture ) );
	        };
	
	        this._cbPanMove = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            var gesture = event;
	            var nbPointers = computeTouches( gesture );
	            // prevent sudden big changes in the event.center variables
	            if ( self._nbPointerLast !== nbPointers ) {
	                if ( nbPointers === 2 ) manipulator.getPanInterpolator().reset();
	                else manipulator.getRotateInterpolator().reset();
	                self._nbPointerLast = nbPointers;
	            }
	
	            if ( nbPointers === 2 ) {
	                manipulator.getPanInterpolator().setTarget( event.center.x * self._panFactorX, event.center.y * self._panFactorY );
	                Notify.debug( 'pan, ' + dragCB( gesture ) );
	            } else {
	                manipulator.getRotateInterpolator().setDelay( self._delay );
	                manipulator.getRotateInterpolator().setTarget( event.center.x * self._rotateFactorX, event.center.y * self._rotateFactorY );
	                Notify.debug( 'rotate, ' + dragCB( gesture ) );
	            }
	        };
	
	        this._cbPanEnd = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            self._dragStarted = false;
	            var gesture = event;
	            Notify.debug( 'drag end, ' + dragCB( gesture ) );
	        };
	
	        this._cbPinchStart = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || event.pointerType === 'mouse' ) {
	                return;
	            }
	            self._transformStarted = true;
	            var gesture = event;
	
	            self._lastScale = gesture.scale;
	            manipulator.getZoomInterpolator().reset();
	            manipulator.getZoomInterpolator().set( self._lastScale );
	            event.preventDefault();
	            Notify.debug( 'zoom start, ' + dragCB( gesture ) );
	        };
	
	        this._cbPinchEnd = function ( event ) {
	            if ( event.pointerType === 'mouse' ) {
	                return;
	            }
	            self._transformStarted = false;
	            Notify.debug( 'zoom end, ' + dragCB( event ) );
	        };
	
	        this._cbPinchInOut = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || !self._transformStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            var gesture = event;
	            // make the dezoom faster
	            var zoomFactor = gesture.scale > self._lastScale ? self._zoomFactor : self._zoomFactor * 4.0;
	            var scale = ( gesture.scale - self._lastScale ) * zoomFactor;
	            self._lastScale = gesture.scale;
	
	            manipulator.getZoomInterpolator().setTarget( manipulator.getZoomInterpolator().getTarget()[ 0 ] - scale );
	            Notify.debug( 'zoom, ' + dragCB( gesture ) );
	        };
	
	        hammer.on( 'panstart ', this._cbPanStart );
	        hammer.on( 'panmove', this._cbPanMove );
	        hammer.on( 'panend', this._cbPanEnd );
	        hammer.on( 'pinchstart', this._cbPinchStart );
	        hammer.on( 'pinchend', this._cbPinchEnd );
	        hammer.on( 'pinchin pinchout', this._cbPinchInOut );
	    },
	    removeEventProxy: function ( proxy ) {
	        if ( !proxy || !this._eventProxy )
	            return;
	        proxy.off( 'panstart ', this._cbPanStart );
	        proxy.off( 'panmove', this._cbPanMove );
	        proxy.off( 'panend', this._cbPanEnd );
	        proxy.off( 'pinchstart', this._cbPinchStart );
	        proxy.off( 'pinchend', this._cbPinchEnd );
	        proxy.off( 'pinchin pinchout', this._cbPinchInOut );
	    },
	    setManipulator: function ( manipulator ) {
	        this._manipulator = manipulator;
	    }
	};
	module.exports = OrbitManipulatorHammerController;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Vec2 = __webpack_require__( 70 );
	var Vec3 = __webpack_require__( 15 );
	
	
	var OrbitManipulatorLeapMotionController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	var ModeConfig = {
	    'rotate': {
	        dtx: -1.2 * 1.2,
	        dty: -0.9 * 1.2,
	        dtz: -0.1,
	        delay: 0.05,
	        method: 'getRotateInterpolator'
	    },
	    'pan': {
	        dtx: -1.2 * 1.2,
	        dty: -0.9 * 1.2,
	        delay: 0.05,
	        method: 'getPanInterpolator'
	    },
	    'zoom': {
	        dtx: 0.0,
	        dty: -0.5,
	        delay: 0.05,
	        method: 'getZoomInterpolator'
	    },
	    'zoom-twohands': {
	        dtx: -0.05,
	        dty: 0.0,
	        delay: 0.05,
	        method: 'getZoomInterpolator'
	    }
	};
	
	OrbitManipulatorLeapMotionController.prototype = {
	    init: function () {
	        this._virtualCursor = Vec2.createAndSet( 0.0, 0.0 );
	        this._targetPosition = Vec2.createAndSet( 0.0, 0.0 );
	        this._previousFrame = undefined;
	        this._displacement = Vec2.createAndSet( 0.0, 0.0 );
	        this._top = Vec2.createAndSet( 0.0, 1.0, 0.0 );
	        this._motion = Vec2.createAndSet( 0.0, 0.0 );
	        this._delay = 0.05;
	        this._threshold = 0.08;
	        this._directionDotThreshold = 0.5;
	        this._mode = 'rotate';
	    },
	
	    update: function ( frame ) {
	        if ( !this._previousFrame ) {
	            this._previousFrame = frame;
	        }
	
	        // no fingers ? return
	        if ( frame.fingers.length === 0 ) {
	            return;
	        }
	
	        var deltaFrame = this._previousFrame.translation( frame );
	
	        this._previousFrame = frame;
	
	        if ( frame.hands.length === 0 ) {
	            return;
	        }
	
	        // filter noise
	        if ( Math.abs( deltaFrame[ 0 ] ) < this._threshold &&
	            Math.abs( deltaFrame[ 1 ] ) < this._threshold ) {
	            return;
	        }
	
	        var mode = this._mode;
	        var dist = 0;
	
	        // scale is when there two hands with but with two hand with more than 1 fingers
	        if ( frame.gestures.length > 0 ) {
	            for ( var i = 0; i < frame.gestures.length; i++ ) {
	                var gesture = frame.gestures[ i ];
	                if ( gesture.type === 'circle' ) {
	                    this._manipulator.computeHomePosition();
	                    return;
	                }
	            }
	        }
	
	        if ( frame.hands.length === 1 ) {
	            if ( frame.hands[ 0 ].fingers.length >= 3 ) {
	                mode = 'zoom';
	                dist = frame.hands[ 0 ].palmPosition[ 1 ] / 10.0;
	                dist = Math.max( dist - 4, 0.01 );
	
	            } else if ( frame.hands[ 0 ].fingers.length > 1 ) {
	                mode = 'pan';
	            } else {
	                // by default onw hand moving means rotation
	                mode = 'rotate';
	            }
	        } else if ( frame.hands.length === 2 ) {
	            var d0 = Math.abs( Vec3.dot( frame.hands[ 0 ].palmNormal, this._top ) ),
	                d1 = Math.abs( Vec3.dot( frame.hands[ 1 ].palmNormal, this._top ) );
	
	            // two hands : zoom
	            if ( d0 < this._directionDotThreshold && d1 < this._directionDotThreshold ) {
	                mode = 'zoom-twohands';
	            } else {
	                // if hands flat do nothing
	                mode = undefined;
	                this._handsDistanceOld = undefined;
	            }
	        }
	        var zoom = this._manipulator.getZoomInterpolator();
	
	        if ( mode === undefined ) {
	            return;
	        }
	        // change mode reset counter and skip this frame
	        if ( mode !== this._mode ) {
	            Notify.info( 'Switch to mode ' + mode );
	
	            this._motion[ 0 ] = 0;
	            this._motion[ 1 ] = 0;
	            this._mode = mode;
	
	            if ( mode === 'zoom' || mode === 'zoom-twohands' ) {
	                if ( zoom.isReset() ) {
	                    zoom.setStart( 1.0 );
	                    zoom.set( 0.0 );
	                }
	            }
	            return;
	        }
	
	        var dtx, dty, dtz;
	        dtx = ModeConfig[ mode ].dtx;
	        dty = ModeConfig[ mode ].dty;
	        dtz = ModeConfig[ mode ].dtz;
	
	        this._motion[ 0 ] += deltaFrame[ 0 ] * dtx;
	        this._motion[ 1 ] += deltaFrame[ 1 ] * dty;
	
	        var delay = ModeConfig[ mode ].delay;
	
	        // we use the mode enum to get the good method
	        var method = ModeConfig[ mode ].method;
	        this._manipulator[ method ]().setDelay( delay );
	
	        if ( mode === 'zoom' ) {
	            Notify.log( dist );
	            zoom.setTarget( dist );
	        } else if ( mode === 'zoom-twohands' ) { // two hands zoom
	            // distance between two hands
	            var handsDistance = Vec3.distance( frame.hands[ 0 ].palmPosition, frame.hands[ 1 ].palmPosition );
	
	            if ( this._handsDistanceOld !== undefined ) {
	                // compare distance with lastframe and zoom if they get nearer, unzoom if they separate
	                var vel = dtx * ( handsDistance - this._handsDistanceOld );
	
	                dist = zoom._target;
	                dist[ 0 ] += vel;
	            }
	            this._handsDistanceOld = handsDistance;
	        } else {
	            if ( mode === 'rotate' ) {
	                dist = zoom._target[ 0 ];
	                dist += deltaFrame[ 2 ] * dtz;
	                dist = Math.max( dist, 0.01 );
	                zoom.setTarget( dist );
	            }
	            this._manipulator[ method ]().addTarget( this._motion[ 0 ], this._motion[ 1 ] );
	        }
	
	        this._motion[ 1 ] = this._motion[ 0 ] = 0;
	    }
	};
	module.exports = OrbitManipulatorLeapMotionController;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osgMath = __webpack_require__( 16 );
	var OrbitManipulatorEnums = __webpack_require__( 141 );
	
	
	var OrbitManipulatorStandardMouseKeyboardController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	OrbitManipulatorStandardMouseKeyboardController.prototype = {
	    init: function () {
	        this.releaseButton();
	        this._rotateKey = 65; // a
	        this._zoomKey = 83; // s
	        this._panKey = 68; // d
	
	        this._mode = undefined;
	        this._delay = 0.15;
	    },
	    getMode: function () {
	        return this._mode;
	    },
	    setMode: function ( mode ) {
	        this._mode = mode;
	    },
	    setEventProxy: function ( proxy ) {
	        this._eventProxy = proxy;
	    },
	    setManipulator: function ( manipulator ) {
	        this._manipulator = manipulator;
	    },
	    mousemove: function ( ev ) {
	        if ( this._buttonup === true ) {
	            return;
	        }
	        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );
	        var manipulator = this._manipulator;
	        if ( osgMath.isNaN( pos[ 0 ] ) === false && osgMath.isNaN( pos[ 1 ] ) === false ) {
	
	            var mode = this.getMode();
	            if ( mode === OrbitManipulatorEnums.ROTATE ) {
	                manipulator.getRotateInterpolator().setDelay( this._delay );
	                manipulator.getRotateInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );
	
	            } else if ( mode === OrbitManipulatorEnums.PAN ) {
	                manipulator.getPanInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );
	
	            } else if ( mode === OrbitManipulatorEnums.ZOOM ) {
	                var zoom = manipulator.getZoomInterpolator();
	                if ( zoom.isReset() ) {
	                    zoom.setStart( pos[ 1 ] );
	                    zoom.set( 0.0 );
	                }
	                var dy = pos[ 1 ] - zoom.getStart();
	                zoom.setStart( pos[ 1 ] );
	                var v = zoom.getTarget()[ 0 ];
	                zoom.setTarget( v - dy / 20.0 );
	            }
	        }
	
	        ev.preventDefault();
	    },
	    mousedown: function ( ev ) {
	        var manipulator = this._manipulator;
	        var mode = this.getMode();
	        if ( mode === undefined ) {
	            if ( ev.button === 0 ) {
	                if ( ev.shiftKey ) {
	                    this.setMode( OrbitManipulatorEnums.PAN );
	                } else if ( ev.ctrlKey ) {
	                    this.setMode( OrbitManipulatorEnums.ZOOM );
	                } else {
	                    this.setMode( OrbitManipulatorEnums.ROTATE );
	                }
	            } else {
	                this.setMode( OrbitManipulatorEnums.PAN );
	            }
	        }
	
	        this.pushButton();
	
	        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );
	        mode = this.getMode();
	        if ( mode === OrbitManipulatorEnums.ROTATE ) {
	            manipulator.getRotateInterpolator().reset();
	            manipulator.getRotateInterpolator().set( pos[ 0 ], pos[ 1 ] );
	        } else if ( mode === OrbitManipulatorEnums.PAN ) {
	            manipulator.getPanInterpolator().reset();
	            manipulator.getPanInterpolator().set( pos[ 0 ], pos[ 1 ] );
	        } else if ( mode === OrbitManipulatorEnums.ZOOM ) {
	            manipulator.getZoomInterpolator().setStart( pos[ 1 ] );
	            manipulator.getZoomInterpolator().set( 0.0 );
	        }
	        ev.preventDefault();
	    },
	    mouseup: function ( /*ev */) {
	        this.releaseButton();
	        this.setMode( undefined );
	    },
	    mouseout: function ( /*ev */) {
	        this.releaseButton();
	        this.setMode( undefined );
	    },
	    mousewheel: function ( ev, intDelta /*, deltaX, deltaY */ ) {
	        var manipulator = this._manipulator;
	        ev.preventDefault();
	        var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - intDelta;
	        manipulator.getZoomInterpolator().setTarget( zoomTarget );
	    },
	
	    pushButton: function () {
	        this._buttonup = false;
	    },
	    releaseButton: function () {
	        this._buttonup = true;
	    },
	
	    keydown: function ( ev ) {
	        if ( ev.keyCode === 32 ) {
	            this._manipulator.computeHomePosition();
	            ev.preventDefault();
	        } else if ( ev.keyCode === this._panKey &&
	            this.getMode() !== OrbitManipulatorEnums.PAN ) {
	            this.setMode( OrbitManipulatorEnums.PAN );
	            this._manipulator.getPanInterpolator().reset();
	            this.pushButton();
	            ev.preventDefault();
	        } else if ( ev.keyCode === this._zoomKey &&
	            this.getMode() !== OrbitManipulatorEnums.ZOOM ) {
	            this.setMode( OrbitManipulatorEnums.ZOOM );
	            this._manipulator.getZoomInterpolator().reset();
	            this.pushButton();
	            ev.preventDefault();
	        } else if ( ev.keyCode === this._rotateKey &&
	            this.getMode() !== OrbitManipulatorEnums.ROTATE ) {
	            this.setMode( OrbitManipulatorEnums.ROTATE );
	            this._manipulator.getRotateInterpolator().reset();
	            this.pushButton();
	            ev.preventDefault();
	        }
	
	    },
	
	    keyup: function ( ev ) {
	        if ( ev.keyCode === this._panKey ) {
	            this.mouseup( ev );
	        } else if ( ev.keyCode === this._rotateKey ) {
	            this.mouseup( ev );
	        } else if ( ev.keyCode === this._rotateKey ) {
	            this.mouseup( ev );
	        }
	        this.setMode( undefined );
	    }
	
	};
	module.exports = OrbitManipulatorStandardMouseKeyboardController;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

	'use strict';
	module.exports = {
	    ROTATE: 0,
	    PAN: 1,
	    ZOOM: 2
	};


/***/ }),
/* 142 */
/***/ (function(module, exports) {

	'use strict';
	
	var OrbitManipulatorWebVRController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	OrbitManipulatorWebVRController.prototype = {
	    init: function () {},
	    update: function ( quat, position ) {
	        this._manipulator.setPoseVR( quat, position );
	    }
	};
	
	module.exports = OrbitManipulatorWebVRController;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var Matrix = __webpack_require__( 23 );
	var MatrixMemoryPool = __webpack_require__( 27 );
	var TransformEnums = __webpack_require__( 29 );
	
	
	var IntersectionVisitor = function () {
	    NodeVisitor.call( this );
	    // We could need to use a stack of intersectors in case we want
	    // to use several intersectors. Right now we use only one.
	    this._intersector = undefined;
	    this._projectionStack = [ Matrix.identity ];
	    this._modelStack = [ Matrix.identity ];
	    this._viewStack = [ Matrix.identity ];
	    this._windowStack = [ Matrix.identity ];
	
	    this.reset();
	};
	
	IntersectionVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    reset: function () {
	        IntersectionVisitor._reservedMatrixStack.reset();
	    },
	    setIntersector: function ( intersector ) {
	        this._intersector = intersector;
	    },
	    getIntersector: function () {
	        return this._intersector;
	    },
	    // Model matrix
	    pushModelMatrix: function ( matrix ) {
	        this._modelStack.push( matrix );
	    },
	    getModelMatrix: function () {
	        return ( this._modelStack.length ) ? this._modelStack[ this._modelStack.length - 1 ] : undefined;
	
	    },
	    popModelMatrix: function () {
	        return this._modelStack.pop();
	    },
	    // View Matrix
	    pushViewMatrix: function ( matrix ) {
	        this._viewStack.push( matrix );
	
	    },
	    getViewMatrix: function () {
	        return ( this._viewStack.length ) ? this._viewStack[ this._viewStack.length - 1 ] : undefined;
	
	    },
	    popViewMatrix: function () {
	        return this._viewStack.pop();
	    },
	    // Projection Matrix
	    pushProjectionMatrix: function ( matrix ) {
	        this._projectionStack.push( matrix );
	    },
	    getProjectionMatrix: function () {
	        return ( this._projectionStack.length ) ? this._projectionStack[ this._projectionStack.length - 1 ] : undefined;
	
	    },
	    popProjectionMatrix: function () {
	        return this._projectionStack.pop();
	    },
	    // Window Matrix
	    pushWindowMatrix: function ( matrix ) {
	        this._windowStack.push( matrix );
	    },
	    pushWindowMatrixUsingViewport: function ( viewport ) {
	        this._windowStack.push( viewport.computeWindowMatrix( IntersectionVisitor._reservedMatrixStack.get() ) );
	    },
	    getWindowMatrix: function () {
	        return ( this._windowStack.length ) ? this._windowStack[ this._windowStack.length - 1 ] : undefined;
	    },
	    popWindowMatrix: function () {
	        return this._windowStack.pop();
	    },
	    getTransformation: ( function () {
	        // We should move this to the intersector when we need to use different coordinate frames
	        // Now we only support WINDOW coordinate frame
	
	        // /!\ 64 bit precision because the picking is jittery otherwise
	        // It's probably caused by one of the camera matrix that has too big/small values
	        // but currently it's the ony fix we have
	        var mat = new Float64Array( 16 );
	
	        return function () {
	            Matrix.copy( this.getWindowMatrix() || Matrix.identity, mat );
	            Matrix.preMult( mat, this.getProjectionMatrix() || Matrix.identity );
	            Matrix.preMult( mat, this.getViewMatrix() || Matrix.identity );
	            Matrix.preMult( mat, this.getModelMatrix() || Matrix.identity );
	
	            return mat;
	        };
	    } )(),
	
	    enter: function ( node ) {
	        // Call to each intersector
	        return this._intersector.enter( node );
	    },
	
	    apply: function ( node ) {
	        // Here we need to decide which apply method to use
	        if ( node.getViewMatrix ) {
	            // It's a Camera
	            this.applyCamera( node );
	        } else {
	            if ( node.getMatrix ) {
	                // It's a Transform Node
	                this.applyTransform( node );
	            } else {
	                // It's a leaf or an intermediate node
	                this.applyNode( node );
	            }
	        }
	    },
	
	    applyCamera: function ( camera ) {
	        // We use an absolute reference frame for simplicity
	        var vp = camera.getViewport();
	        if ( vp !== undefined ) {
	            this.pushWindowMatrixUsingViewport( vp );
	        }
	
	        var projection, view, model;
	        if ( camera.getReferenceFrame() === TransformEnums.RELATIVE_RF && this.getViewMatrix() && this.getProjectionMatrix() ) {
	            // relative
	            projection = Matrix.mult( this.getProjectionMatrix(), camera.getProjectionMatrix(), IntersectionVisitor._reservedMatrixStack.get() );
	            view = this.getViewMatrix();
	            model = Matrix.mult( this.getModelMatrix(), camera.getViewMatrix(), IntersectionVisitor._reservedMatrixStack.get() );
	        } else {
	            // absolute
	            projection = camera.getProjectionMatrix();
	            view = camera.getViewMatrix();
	            model = IntersectionVisitor._reservedMatrixStack.get();
	        }
	
	        this.pushProjectionMatrix( projection );
	        this.pushViewMatrix( view );
	        this.pushModelMatrix( model );
	
	        // TODO maybe we should do something like OSG for the transformation given
	        // to the intersector (having a stack)
	        this._intersector.setCurrentTransformation( this.getTransformation() );
	        this.traverse( camera );
	
	        this.popModelMatrix();
	        this.popViewMatrix();
	        this.popProjectionMatrix();
	        if ( vp !== undefined ) {
	            this.popWindowMatrix();
	        }
	        this._intersector.setCurrentTransformation( this.getTransformation() );
	    },
	
	    applyNode: function ( node ) {
	        if ( !this.enter( node ) ) return;
	        if ( node.primitives ) {
	            this._intersector.intersect( this, node );
	            // If it is a leaf (it has primitives) we can safely return
	            return;
	        }
	        if ( node.traverse ) {
	            this.traverse( node );
	        }
	    },
	
	    applyTransform: function ( node ) {
	        // Now only use PROJECTION coordinate frame
	        if ( !this.enter( node ) ) return;
	        // Accumulate Transform
	        if ( node.getReferenceFrame() === TransformEnums.ABSOLUTE_RF ) {
	            this.pushViewMatrix( IntersectionVisitor._reservedMatrixStack.get() );
	            this.pushModelMatrix( node.getMatrix() );
	        } else if ( this._modelStack.length > 0 ) {
	            var m = Matrix.copy( this.getModelMatrix(), IntersectionVisitor._reservedMatrixStack.get() );
	            Matrix.preMult( m, node.getMatrix() );
	            this.pushModelMatrix( m );
	        } else {
	            this.pushModelMatrix( node.getMatrix() );
	        }
	
	        // TODO see above
	        this._intersector.setCurrentTransformation( this.getTransformation() );
	        this.traverse( node );
	
	        this.popModelMatrix();
	        if ( node.getReferenceFrame() === TransformEnums.ABSOLUTE_RF )
	            this.popViewMatrix();
	        this._intersector.setCurrentTransformation( this.getTransformation() );
	    }
	} );
	
	IntersectionVisitor._reservedMatrixStack = new MatrixMemoryPool();
	
	module.exports = IntersectionVisitor;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var Matrix = __webpack_require__( 23 );
	var TriangleIntersector = __webpack_require__( 93 );
	
	
	var LineSegmentIntersector = function () {
	    this._start = Vec3.create();
	    this._end = Vec3.create();
	    this._iStart = Vec3.create();
	    this._iEnd = Vec3.create();
	    this._intersections = [];
	};
	
	LineSegmentIntersector.prototype = {
	    set: function ( start, end ) {
	        Vec3.copy( start, this._start );
	        Vec3.copy( start, this._iStart );
	        Vec3.copy( end, this._end );
	        Vec3.copy( end, this._iEnd );
	    },
	    setStart: function ( start ) {
	        Vec3.copy( start, this._start );
	        Vec3.copy( start, this._iStart );
	    },
	    setEnd: function ( end ) {
	        Vec3.copy( end, this._end );
	        Vec3.copy( end, this._iEnd );
	    },
	    reset: function () {
	        // Clear the intersections vector
	        this._intersections.length = 0;
	    },
	    enter: function ( node ) {
	        // Not working if culling disabled ??
	        return !node.isCullingActive() || this.intersects( node.getBound() );
	    },
	    // Intersection Segment/Sphere 
	    intersects: ( function () {
	        var sm = Vec3.create();
	        var se = Vec3.create();
	        return function ( bsphere ) {
	            // test for _start inside the bounding sphere
	            if ( !bsphere.valid() ) return false;
	            Vec3.sub( this._iStart, bsphere.center(), sm );
	            var c = Vec3.length2( sm ) - bsphere.radius2();
	            if ( c <= 0.0 ) {
	                return true;
	            }
	            // solve quadratic equation
	            Vec3.sub( this._iEnd, this._iStart, se );
	            var a = Vec3.length2( se );
	            var b = Vec3.dot( sm, se ) * 2.0;
	            var d = b * b - 4.0 * a * c;
	            // no intersections if d<0
	            if ( d < 0.0 ) {
	                return false;
	            }
	            // compute two solutions of quadratic equation
	            d = Math.sqrt( d );
	            var div = 0.5 / a;
	            var r1 = ( -b - d ) * div;
	            var r2 = ( -b + d ) * div;
	
	            // return false if both intersections are before the ray start
	            if ( r1 <= 0.0 && r2 <= 0.0 ) {
	                return false;
	            }
	
	            if ( r1 > 1.0 && r2 > 1.0 ) {
	                return false;
	            }
	            return true;
	        };
	    } )(),
	
	    intersect: ( function () {
	
	        var ti = new TriangleIntersector();
	
	        return function ( iv, node ) {
	
	            var kdtree = node.getShape();
	            if ( kdtree )
	                return kdtree.intersectRay( this._iStart, this._iEnd, this._intersections, iv.nodePath );
	
	            ti.reset();
	            ti.setNodePath( iv.nodePath );
	            ti.set( this._iStart, this._iEnd );
	
	            // handle rig transformed vertices
	            if ( node.computeTransformedVertices ) {
	                var vList = node.getVertexAttributeList();
	                var originVerts = vList.Vertex.getElements();
	
	                // temporarily hook vertex buffer for the tri intersections
	                // don't call setElements as it dirty some stuffs because of gl buffer 
	                vList.Vertex._elements = node.computeTransformedVertices();
	                ti.apply( node );
	                vList.Vertex._elements = originVerts;
	            } else {
	                ti.apply( node );
	            }
	
	            var l = ti._intersections.length;
	            for ( var i = 0; i < l; i++ ) {
	                this._intersections.push( ti._intersections[ i ] );
	            }
	
	            return l > 0;
	        };
	    } )(),
	
	    getIntersections: function () {
	        return this._intersections;
	    },
	    setCurrentTransformation: function ( matrix ) {
	        Matrix.inverse( matrix, matrix );
	        Matrix.transformVec3( matrix, this._start, this._iStart );
	        Matrix.transformVec3( matrix, this._end, this._iEnd );
	    }
	};
	
	module.exports = LineSegmentIntersector;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var PolytopePrimitiveIntersector = __webpack_require__( 146 );
	var Matrix = __webpack_require__( 23 );
	var Vec4 = __webpack_require__( 25 );
	var Vec3 = __webpack_require__( 15 );
	
	/** Concrete class for implementing polytope intersections with the scene graph.
	 * To be used in conjunction with IntersectionVisitor. */
	var PolytopeIntersector = function () {
	    this._intersections = [];
	    this._index = 0;
	    this._polytope = [];
	    this._iPolytope = [];
	    this._referencePlane = Vec4.create();
	    this._iReferencePlane = Vec4.create();
	    this._intersectionLimit = PolytopeIntersector.NO_LIMIT;
	    this._dimensionMask = PolytopeIntersector.AllDims;
	};
	
	
	PolytopeIntersector.NO_LIMIT = 0;
	PolytopeIntersector.LIMIT_ONE_PER_DRAWABLE = 1;
	PolytopeIntersector.LIMIT_ONE = 2;
	
	
	PolytopeIntersector.DimZero = ( 1 << 0 );
	PolytopeIntersector.DimOne = ( 1 << 1 );
	PolytopeIntersector.DimTwo = ( 1 << 2 );
	PolytopeIntersector.AllDims = ( PolytopeIntersector.DimZero | PolytopeIntersector.DimOne | PolytopeIntersector.DimTwo );
	
	
	PolytopeIntersector.prototype = {
	
	    setPolytope: function ( polytope ) {
	        this._polytope = polytope;
	        this._referencePlane[ 0 ] = polytope[ polytope.length - 1 ][ 0 ];
	        this._referencePlane[ 1 ] = polytope[ polytope.length - 1 ][ 1 ];
	        this._referencePlane[ 2 ] = polytope[ polytope.length - 1 ][ 2 ];
	        this._referencePlane[ 3 ] = polytope[ polytope.length - 1 ][ 3 ];
	        // TODO initialize _iPolytope or _iReferencePlane in case there is no transform in the graph?
	        // same as setCurrentTransformation with matrix identity
	    },
	
	    setPolytopeFromWindowCoordinates: function ( xMin, yMin, xMax, yMax ) {
	        // Note: last polytope value depends on the Coordinate frame
	        // Now we are only supporting WINDOW coordinate frame, so must change this if we decide to support
	        // other types of Coordinate Frame
	        this.setPolytope( [
	            Vec4.createAndSet( 1.0, 0.0, 0.0, -xMin ),
	            Vec4.createAndSet( -1.0, 0.0, 0.0, xMax ),
	            Vec4.createAndSet( 0.0, 1.0, 0.0, -yMin ),
	            Vec4.createAndSet( 0.0, -1.0, 0.0, yMax ),
	            Vec4.createAndSet( 0.0, 0.0, 1.0, 0.0 )
	        ] );
	    },
	
	    /** Set the dimension mask.
	     * As polytope-triangle and polytope-quad intersections are expensive to compute
	     * it is possible to turn them off by calling setDimensionMask( DimZero | DimOne )
	     */
	    setDimensionMask: function ( mask ) {
	        this._dimensionMask = mask;
	    },
	
	    reset: function () {
	        // Clear the intersections vector
	        this._intersections.length = 0;
	    },
	
	    enter: function ( node ) {
	        if ( this.reachedLimit() ) return false;
	        return ( this.intersects( node.getBound() ) );
	    },
	
	    reachedLimit: function () {
	        return this._intersectionLimit === PolytopeIntersector.LIMIT_ONE && this._intersections.length > 0;
	    },
	
	    // Intersection Polytope/Sphere
	    intersects: ( function () {
	        var position = Vec3.create();
	        return function ( bsphere ) {
	            if ( !bsphere.valid() ) return false;
	            var pos = bsphere.center();
	            var d;
	            Vec3.copy( pos, position );
	            var radius = -bsphere.radius();
	            for ( var i = 0, j = this._iPolytope.length; i < j; i++ ) {
	                d = this._iPolytope[ i ][ 0 ] * position[ 0 ] + this._iPolytope[ i ][ 1 ] * position[ 1 ] + this._iPolytope[ i ][ 2 ] * position[ 2 ] + this._iPolytope[ i ][ 3 ];
	                if ( d <= radius ) {
	                    return false;
	                }
	            }
	            return true;
	        };
	    } )(),
	
	    // Intersection Polytope/Geometry
	    intersect: function ( iv, node ) {
	        if ( this.reachedLimit() ) return false;
	        var ppi = new PolytopePrimitiveIntersector();
	        ppi.setNodePath( iv.nodePath );
	        ppi.set( this._iPolytope, this._iReferencePlane );
	        ppi.setLimitOneIntersection( this._intersectionLimit === PolytopeIntersector.LIMIT_ONE_PER_DRAWABLE || this._intersectionLimit === PolytopeIntersector.LIMIT_ONE );
	        ppi.setDimensionMask( this._dimensionMask );
	        ppi.apply( node );
	        var l = ppi._intersections.length;
	        if ( l > 0 ) {
	            // Intersection/s exists
	            for ( var i = 0; i < l; i++ ) {
	                this._intersections.push( ppi._intersections[ i ] );
	            }
	            return true;
	        }
	        // No intersection found
	        return false;
	    },
	
	    getIntersections: function () {
	        return this._intersections;
	    },
	
	    setIntersectionLimit: function ( limit ) {
	        this._intersectionLimit = limit;
	    },
	
	    setCurrentTransformation: function ( matrix ) {
	        // Transform the polytope and the referencePlane to the current Model local coordinate frame
	        var inv;
	        var iplane = Vec4.create();
	        for ( var i = 0, j = this._polytope.length; i < j; i++ ) {
	            var plane = this._polytope[ i ];
	            // PostMult
	            Matrix.transformVec4PostMult( matrix, plane, iplane );
	            // multiply the coefficients of the plane equation with a constant factor so that the equation a^2+b^2+c^2 = 1 holds.
	            inv = 1.0 / Math.sqrt( iplane[ 0 ] * iplane[ 0 ] + iplane[ 1 ] * iplane[ 1 ] + iplane[ 2 ] * iplane[ 2 ] );
	            iplane[ 0 ] *= inv;
	            iplane[ 1 ] *= inv;
	            iplane[ 2 ] *= inv;
	            iplane[ 3 ] *= inv;
	            this._iPolytope[ i ] = Vec4.copy( iplane, Vec4.create() );
	        }
	        //Post Mult
	        Matrix.transformVec4PostMult( matrix, this._referencePlane, this._iReferencePlane );
	        // multiply the coefficients of the plane equation with a constant factor so that the equation a^2+b^2+c^2 = 1 holds.
	        inv = 1.0 / Math.sqrt( this._iReferencePlane[ 0 ] * this._iReferencePlane[ 0 ] + this._iReferencePlane[ 1 ] * this._iReferencePlane[ 1 ] + this._iReferencePlane[ 2 ] * this._iReferencePlane[ 2 ] );
	        this._iReferencePlane[ 0 ] *= inv;
	        this._iReferencePlane[ 1 ] *= inv;
	        this._iReferencePlane[ 2 ] *= inv;
	        this._iReferencePlane[ 3 ] *= inv;
	    }
	};
	
	module.exports = PolytopeIntersector;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osgMath = __webpack_require__( 16 );
	var Vec3 = __webpack_require__( 15 );
	var PrimitiveFunctor = __webpack_require__( 99 );
	
	
	var PolytopeIntersection = function ( index, candidates, candidatesMasks, referencePlane, nodePath ) {
	    this._index = index - 1; ///< primitive index
	    this._distance = 0; ///< distance from reference plane
	    this._maxDistance = -1; ///< maximum distance of intersection points from reference plane
	    this._numPoints = 0;
	    this._points = [];
	    this._maxNumIntersections = 6;
	    this._center = Vec3.create();
	    for ( var i = 0, j = candidates.length; i < j; i++ ) {
	        if ( candidatesMasks[ i ] === 0 ) continue;
	        this._points[ this._numPoints++ ] = Vec3.copy( candidates[ i ], Vec3.create() );
	        Vec3.add( this._center, candidates[ i ], this._center );
	        var distance = referencePlane[ 0 ] * candidates[ i ][ 0 ] + referencePlane[ 1 ] * candidates[ i ][ 1 ] + referencePlane[ 2 ] * candidates[ i ][ 2 ] + referencePlane[ 3 ];
	        if ( distance > this._maxDistance ) this._maxDistance = distance;
	        if ( this._numPoints === this._maxNumIntesections ) break;
	    }
	    Vec3.mult( this._center, 1 / this._numPoints, this._center );
	    this._distance = referencePlane[ 0 ] * this._center[ 0 ] + referencePlane[ 1 ] * this._center[ 1 ] + referencePlane[ 2 ] * this._center[ 2 ] + referencePlane[ 3 ];
	    this.nodePath = nodePath;
	};
	
	var PlanesLine = function ( planeMask, pos, dir ) {
	    this._planeMask = planeMask;
	    this._pos = pos;
	    this._dir = dir;
	};
	var PolytopePrimitiveIntersector = function () {
	    this._intersections = [];
	    this._nodePath = [];
	    this._index = 0;
	    this._referencePlane = [];
	    this._planes = []; ///< active planes extracted from polytope
	    this._lines = []; ///< all intersection lines of two polytope planes
	    this._candidates = [];
	    this._candidatesMasks = [];
	    this._lines = [];
	    this._planesMask = 0;
	    this._limitOneIntersection = false;
	    this._dimensionMask = undefined;
	};
	
	PolytopePrimitiveIntersector.prototype = {
	
	    setNodePath: function ( np ) {
	        this._nodePath = np;
	    },
	
	    set: function ( polytope, referencePlane ) {
	        this._planes = polytope;
	        this._referencePlane = referencePlane;
	        this._planesMask = 0;
	        this._lines.length = 0;
	        for ( var i = 0; i < this._planes.length; i++ ) {
	            this._planesMask = ( this._planesMask << 1 ) | 1;
	        }
	    },
	
	    setDimensionMask: function ( mask ) {
	        this._dimensionMask = mask;
	    },
	
	    apply: function ( node ) {
	        if ( !node.getAttributes().Vertex ) {
	            return;
	        }
	        var vertices = node.getAttributes().Vertex.getElements();
	        var self = this;
	        // The callback must be defined as a closure
	        /* jshint asi: true */
	        var cb = function () {
	            return {
	                operatorPoint: function ( v ) {
	                    self.intersectPoint( v );
	                },
	                operatorLine: function ( v1, v2 ) {
	                    self.intersectLine( v1, v2 );
	                },
	                operatorTriangle: function ( v1, v2, v3 ) {
	                    self.intersectTriangle( v1, v2, v3 );
	                }
	            }
	        };
	        var pf = new PrimitiveFunctor( node, cb, vertices );
	        pf.apply();
	    },
	
	
	    checkCandidatePoints: function ( insideMask ) {
	        var selectorMask = 0x1;
	        var numCands = this._candidates.length;
	        for ( var i = 0, j = this._planes.length; i < j && numCands > 0; ++i, selectorMask <<= 1 ) {
	            if ( insideMask & selectorMask ) continue;
	            for ( var c = 0; c < this._candidates.length; ++c ) {
	                if ( this._candidatesMasks[ c ] === 0 ) continue;
	                if ( selectorMask & this._candidatesMasks[ c ] ) continue;
	                if ( this.distance( this._planes[ i ], this._candidates[ c ] ) < 0.0 ) {
	                    this._candidatesMasks[ c ] = 0;
	                    --numCands;
	                    if ( numCands === 0 ) return 0;
	                }
	            }
	        }
	        return numCands;
	    },
	
	    intersectPoint: ( function () {
	        var hit = Vec3.create();
	        return function ( v ) {
	            this._index++;
	            if ( ( this._dimensionMask & ( 1 << 0 ) ) === 0 ) return;
	            if ( this._limitOneIntersection && this._intersections.length > 0 ) return;
	            var d;
	
	            for ( var i = 0, j = this._planes.length; i < j; ++i ) {
	                d = this.distance( this._planes[ i ], v );
	                if ( d < 0.0 ) {
	                    // point is outside the polytope
	                    return;
	                }
	            }
	            this._candidates = [];
	            this._candidatesMasks = [];
	            // Intersection found: Copy the value and push it
	            Vec3.copy( v, hit );
	            this._candidates.push( hit );
	            this._candidatesMasks.push( this._planesMask );
	            this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );
	        };
	    } )(),
	
	
	    intersectLine: ( function () {
	
	        var hit = Vec3.create();
	        return function ( v1, v2 ) {
	            this._index++;
	            if ( ( this._dimensionMask & ( 1 << 1 ) ) === 0 ) return;
	            if ( this._limitOneIntersection && this._intersections.length > 0 ) return;
	            var v1Inside = true;
	            var v2Inside = true;
	            var selectorMask = 0x1;
	            var insideMask = 0x0;
	            this._candidates = [];
	            this._candidatesMasks = [];
	            var d1, d2, d1IsNegative, d2IsNegative;
	            for ( var i = 0, j = this._planes.length; i < j; ++i, selectorMask <<= 1 ) {
	                d1 = this.distance( this._planes[ i ], v1 );
	                d2 = this.distance( this._planes[ i ], v2 );
	                d1IsNegative = ( d1 < 0.0 );
	                d2IsNegative = ( d2 < 0.0 );
	                if ( d1IsNegative && d2IsNegative ) return; // line outside
	                if ( !d1IsNegative && !d2IsNegative ) {
	                    // completly inside this plane
	                    insideMask |= selectorMask;
	                    continue;
	                }
	                if ( d1IsNegative ) v1Inside = false;
	                if ( d2IsNegative ) v2Inside = false;
	                if ( d1 === 0.0 ) {
	                    Vec3.copy( v1, hit );
	                    this._candidates.push( hit );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( d2 === 0.0 ) {
	                    Vec3.copy( v2, hit );
	                    this._candidates.push( hit );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( d1IsNegative && !d2IsNegative ) {
	                    //v1-(v2-v1)*(d1/(-d1+d2))) )
	                    Vec3.sub( v2, v1, hit );
	                    Vec3.mult( hit, d1 / ( -d1 + d2 ), hit );
	                    Vec3.sub( v1, hit, hit );
	                    this._candidates.push( hit );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( !d1IsNegative && d2IsNegative ) {
	                    //(v1+(v2-v1)*(d1/(d1-d2)))
	                    Vec3.sub( v2, v1, hit );
	                    Vec3.mult( hit, d1 / ( d1 - d2 ), hit );
	                    Vec3.add( v1, hit, hit );
	                    this._candidates.push( hit );
	                    this._candidatesMasks.push( selectorMask );
	                }
	            }
	
	            if ( insideMask === this._planesMask ) {
	                this._candidates.push( Vec3.copy( v1, Vec3.create() ) );
	                this._candidatesMasks.push( this._planesMask );
	                this._candidates.push( Vec3.copy( v2, Vec3.create() ) );
	                this._candidatesMasks.push( this._planesMask );
	                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );
	                return;
	            }
	
	            var numCands = this.checkCandidatePoints( insideMask );
	            if ( numCands > 0 ) {
	                if ( v1Inside ) {
	                    this._candidatesMasks.push( this._planesMask );
	                    this._candidates.push( Vec3.copy( v1, Vec3.create() ) );
	                }
	                if ( v2Inside ) {
	                    this._candidatesMasks.push( this._planesMask );
	                    this._candidates.push( Vec3.copy( v2, Vec3.create() ) );
	                }
	                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );
	            }
	        };
	    } )(),
	
	    intersectTriangle: ( function () {
	
	        var tmpHit = Vec3.create();
	        // Only needed for special case, should we move it to a new function?
	        var e1 = Vec3.create();
	        var e2 = Vec3.create();
	        var point = Vec3.create();
	        var p = Vec3.create();
	        var s = Vec3.create();
	        var q = Vec3.create();
	        return function ( v1, v2, v3 ) {
	            this._index++;
	            if ( ( this._dimensionMask & ( 1 << 2 ) ) === 0 ) return;
	            if ( this._limitOneIntersection && this._intersections.length > 0 ) return;
	            var selectorMask = 0x1;
	            var insideMask = 0x0;
	            this._candidates = [];
	            this._candidatesMasks = [];
	            var d1, d2, d3, d1IsNegative, d2IsNegative, d3IsNegative;
	            for ( var i = 0, j = this._planes.length; i < j; ++i, selectorMask <<= 1 ) {
	                d1 = this.distance( this._planes[ i ], v1 );
	                d2 = this.distance( this._planes[ i ], v2 );
	                d3 = this.distance( this._planes[ i ], v3 );
	                d1IsNegative = ( d1 < 0.0 );
	                d2IsNegative = ( d2 < 0.0 );
	                d3IsNegative = ( d3 < 0.0 );
	
	                if ( d1IsNegative && d2IsNegative && d3IsNegative ) return; // Triangle outside
	                if ( !d1IsNegative && !d2IsNegative && !d3IsNegative ) {
	                    // completly inside this plane
	                    insideMask |= selectorMask;
	                    continue;
	                }
	                // edge v1-v2 intersects
	                if ( d1 === 0.0 ) {
	                    Vec3.copy( v1, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( d2 === 0.0 ) {
	                    Vec3.copy( v2, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( d1IsNegative && !d2IsNegative ) {
	                    //v1-(v2-v1)*(d1/(-d1+d2))) )
	                    Vec3.sub( v2, v1, tmpHit );
	                    Vec3.mult( tmpHit, d1 / ( -d1 + d2 ), tmpHit );
	                    Vec3.sub( v1, tmpHit, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( !d1IsNegative && d2IsNegative ) {
	                    //(v1+(v2-v1)*(d1/(d1-d2)))
	                    Vec3.sub( v2, v1, tmpHit );
	                    Vec3.mult( tmpHit, d1 / ( d1 - d2 ), tmpHit );
	                    Vec3.add( v1, tmpHit, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                }
	                // edge v1-v3 intersects
	                if ( d3 === 0.0 ) {
	                    Vec3.copy( v3, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( d1IsNegative && !d3IsNegative ) {
	                    // v1-(v3-v1)*(d1/(-d1+d3))
	                    Vec3.sub( v3, v1, tmpHit );
	                    Vec3.mult( tmpHit, d1 / ( -d1 + d3 ), tmpHit );
	                    Vec3.sub( v1, tmpHit, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( !d1IsNegative && d3IsNegative ) {
	                    // v1+(v3-v1)*(d1/(d1-d3))
	                    Vec3.sub( v3, v1, tmpHit );
	                    Vec3.mult( tmpHit, d1 / ( d1 - d3 ), tmpHit );
	                    Vec3.add( v1, tmpHit, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                }
	                // edge v2-v3 intersects
	                if ( d2IsNegative && !d3IsNegative ) {
	                    // v2-(v3-v2)*(d2/(-d2+d3))
	                    Vec3.sub( v3, v2, tmpHit );
	                    Vec3.mult( tmpHit, d2 / ( -d2 + d3 ), tmpHit );
	                    Vec3.sub( v2, tmpHit, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                } else if ( !d2IsNegative && d3IsNegative ) {
	                    //v2+(v3-v2)*(d2/(d2-d3))
	                    Vec3.sub( v3, v2, tmpHit );
	                    Vec3.mult( tmpHit, d2 / ( d2 - d3 ), tmpHit );
	                    Vec3.add( v2, tmpHit, tmpHit );
	                    this._candidates.push( Vec3.copy( tmpHit, Vec3.create() ) );
	                    this._candidatesMasks.push( selectorMask );
	                }
	            }
	            if ( insideMask === this._planesMask ) {
	                // triangle lies inside of all planes
	                this._candidates.push( Vec3.copy( v1, Vec3.create() ) );
	                this._candidatesMasks.push( this._planesMask );
	                this._candidates.push( Vec3.copy( v2, Vec3.create() ) );
	                this._candidatesMasks.push( this._planesMask );
	                this._candidates.push( Vec3.copy( v3, Vec3.create() ) );
	                this._candidatesMasks.push( this._planesMask );
	                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );
	                return;
	            }
	            var numCands = this.checkCandidatePoints( insideMask );
	            if ( numCands > 0 ) {
	                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );
	                return;
	            }
	            // handle case where the polytope goes through the triangle
	            // without containing any point of it
	            // Probably it can be moved to other function and do the relevant closures.
	
	            var lines = this.getPolytopeLines();
	            this._candidates = [];
	            // check all polytope lines against the triangle
	            // use algorithm from "Real-time rendering" (second edition) pp.580
	            //var e1= Vec3.create();
	            //var e2= Vec3.create();
	
	            Vec3.sub( v2, v1, e1 );
	            Vec3.sub( v3, v1, e2 );
	            for ( i = 0; i < lines.length; ++i ) {
	                //var point = Vec3.create();
	                //var p = Vec3.create(); 
	                Vec3.cross( lines[ i ]._dir, e2, p );
	                var a = Vec3.dot( e1, p );
	                if ( Math.abs( a ) < 1E-6 ) continue;
	                var f = 1.0 / a;
	                //var s = Vec3.create();
	                Vec3.sub( lines[ i ]._pos, v1, s );
	                var u = f * ( Vec3.dot( s, p ) );
	                if ( u < 0.0 || u > 1.0 ) continue;
	                //var q = Vec3.create();
	                Vec3.cross( s, e1, q );
	                var v = f * ( Vec3.dot( lines[ i ]._dir, q ) );
	                if ( v < 0.0 || u + v > 1.0 ) continue;
	                var t = f * ( Vec3.dot( e2, q ) );
	                Vec3.mult( lines[ i ]._dir, t, point );
	                Vec3.add( lines[ i ]._pos, point, point );
	                this._candidates.push( Vec3.copy( point, Vec3.create() ) );
	                this._candidatesMasks.push( lines[ i ]._planeMask );
	            }
	            numCands = this.checkCandidatePoints( insideMask );
	            if ( numCands > 0 ) {
	                this._intersections.push( new PolytopeIntersection( this._index, this._candidates, this._candidatesMasks, this._referencePlane, this._nodePath.slice( 0 ) ) );
	                return;
	            }
	        };
	    } )(),
	
	    getPolytopeLines: ( function () {
	        var lineDirection = Vec3.create();
	        var searchDirection = Vec3.create();
	        var normal1 = Vec3.create();
	        var point1 = Vec3.create();
	        var normal2 = Vec3.create();
	        var linePoint = Vec3.create();
	        var epsilon = 1E-6;
	        return function () {
	            if ( this._lines.length > 0 ) return this._lines; // Polytope lines already calculated
	            var selectorMask = 0x1;
	            for ( var i = 0, j = this._planes.length; i < j; i++, selectorMask <<= 1 ) {
	                Vec3.copy( this.getNormal( this._planes[ i ] ), normal1 );
	                Vec3.mult( normal1, -this._planes[ i ][ 3 ], point1 ); // canonical point on plane[ i ]
	                var subSelectorMask = ( selectorMask << 1 );
	                for ( var jt = i + 1, k = this._planes.length; jt < k; ++jt, subSelectorMask <<= 1 ) {
	                    Vec3.copy( this.getNormal( this._planes[ jt ] ), normal2 );
	                    if ( Math.abs( Vec3.dot( normal1, normal2 ) ) > ( 1.0 - epsilon ) ) continue;
	                    Vec3.cross( normal1, normal2, lineDirection );
	                    Vec3.cross( lineDirection, normal1, searchDirection );
	                    //-plane2.distance(point1)/(searchDirection*normal2);
	                    var searchDist = -this.distance( this._planes[ jt ], point1 ) / Vec3.dot( searchDirection, normal2 );
	                    if ( osgMath.isNaN( searchDist ) ) continue;
	                    Vec3.mult( searchDirection, searchDist, linePoint );
	                    Vec3.add( point1, lineDirection, lineDirection );
	                    this._lines.push( new PlanesLine( selectorMask | subSelectorMask, Vec3.copy( linePoint, Vec3.create() ), Vec3.copy( lineDirection, Vec3.create() ) ) );
	                }
	            }
	            return this._lines;
	        };
	    } )(),
	
	    setLimitOneIntersection: function ( limit ) {
	        this._limitOneIntersection = limit;
	    },
	
	    distance: function ( plane, v ) {
	        var d = plane[ 0 ] * v[ 0 ] + plane[ 1 ] * v[ 1 ] + plane[ 2 ] * v[ 2 ] + plane[ 3 ];
	        return d;
	    },
	
	    getNormal: ( function () {
	        var normal = Vec3.create();
	        return function ( plane ) {
	            normal[ 0 ] = plane[ 0 ];
	            normal[ 1 ] = plane[ 1 ];
	            normal[ 2 ] = plane[ 2 ];
	            return normal;
	        };
	    } )()
	};
	
	module.exports = PolytopePrimitiveIntersector;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var OrbitManipulator = __webpack_require__( 134 );
	
	var CADManipulatorStandardMouseKeyboardController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this._timer = false;
	    this.init();
	};
	
	CADManipulatorStandardMouseKeyboardController.prototype = {
	    init: function () {
	        this.releaseButton();
	        this._rotateKey = 65; // a
	        this._zoomKey = 83; // s
	        this._panKey = 68; // d
	        this._mode = undefined;
	    },
	    getMode: function () {
	        return this._mode;
	    },
	    setMode: function ( mode ) {
	        this._mode = mode;
	    },
	    setEventProxy: function ( proxy ) {
	        this._eventProxy = proxy;
	    },
	    setManipulator: function ( manipulator ) {
	        this._manipulator = manipulator;
	    },
	    setDimensionMask: function ( dimMask ) {
	        this._dimensionMask = dimMask;
	    },
	
	    mousemove: function ( ev ) {
	        if ( this._buttonup === true ) {
	            return;
	        }
	
	        var manipulator = this._manipulator;
	        var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );
	
	        if ( isNaN( pos[ 0 ] ) === false && isNaN( pos[ 1 ] ) === false ) {
	
	            var mode = this.getMode();
	            if ( mode === OrbitManipulator.Rotate ) {
	                manipulator.getRotateInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );
	
	            } else if ( mode === OrbitManipulator.Pan ) {
	                manipulator.getPanInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );
	
	            } else if ( mode === OrbitManipulator.Zoom ) {
	                var zoom = manipulator.getZoomInterpolator();
	                manipulator.computeIntersections( pos );
	
	                if ( zoom.isReset() ) {
	                    zoom.setStart( pos[ 1 ] );
	                    zoom.set( 0.0 );
	                }
	                var dy = pos[ 1 ] - zoom.getStart();
	                zoom.setStart( pos[ 1 ] );
	                var v = zoom.getTarget()[ 0 ];
	                zoom.setTarget( v - dy / 20.0 );
	            }
	        }
	
	        ev.preventDefault();
	    },
	    mousedown: function ( ev ) {
	        var manipulator = this._manipulator;
	        var mode = this.getMode();
	        if ( mode === undefined ) {
	            if ( ev.button === 0 ) {
	                if ( ev.shiftKey ) {
	                    this.setMode( OrbitManipulator.Pan );
	                } else if ( ev.ctrlKey ) {
	                    this.setMode( OrbitManipulator.Zoom );
	                } else {
	                    this.setMode( OrbitManipulator.Rotate );
	                }
	            } else {
	                this.setMode( OrbitManipulator.Pan );
	            }
	        }
	
	        this.pushButton();
	
	        //var pos = this.getPositionRelativeToCanvas( ev );
	        var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );
	        manipulator.computeIntersections( pos );
	
	        mode = this.getMode();
	        if ( mode === OrbitManipulator.Rotate ) {
	            manipulator.getRotateInterpolator().reset();
	            manipulator.getRotateInterpolator().set( pos[ 0 ], pos[ 1 ] );
	        } else if ( mode === OrbitManipulator.Pan ) {
	            manipulator.getPanInterpolator().reset();
	            manipulator.getPanInterpolator().set( pos[ 0 ], pos[ 1 ] );
	        } else if ( mode === OrbitManipulator.Zoom ) {
	            manipulator.getZoomInterpolator().setStart( pos[ 1 ] );
	            manipulator.getZoomInterpolator().set( 0.0 );
	        }
	        ev.preventDefault();
	    },
	    mouseup: function ( /*ev */) {
	        this.releaseButton();
	        this.setMode( undefined );
	    },
	    mousewheel: function ( ev, intDelta /*, deltaX, deltaY */ ) {
	        var manipulator = this._manipulator;
	        ev.preventDefault();
	        var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - intDelta;
	        manipulator.getZoomInterpolator().setTarget( zoomTarget );
	        var timer;
	        if ( this._timer === false ) {
	            this._timer = true;
	            var that = this;
	            clearTimeout( timer );
	            timer = setTimeout( function () {
	                that._timer = false;
	            }, 200 );
	            //var pos = this.getPositionRelativeToCanvas( ev );
	            var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );
	            manipulator.computeIntersections( pos );
	        }
	    },
	
	    dblclick: function ( ev ) {
	        var manipulator = this._manipulator;
	        ev.preventDefault();
	
	        manipulator.getZoomInterpolator().set( 0.0 );
	        var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - 10; // Default interval 10
	        manipulator.getZoomInterpolator().setTarget( zoomTarget );
	        //var pos = this.getPositionRelativeToCanvas( ev );
	        var pos = manipulator.getPositionRelativeToCanvas( ev.clientX, ev.clientY );
	        manipulator.computeIntersections( pos );
	    },
	
	    pushButton: function () {
	        this._buttonup = false;
	    },
	    releaseButton: function () {
	        this._buttonup = true;
	    },
	
	    keydown: function ( ev ) {
	        if ( ev.keyCode === 32 ) {
	            this._manipulator.computeHomePosition();
	            ev.preventDefault();
	
	        } else if ( ev.keyCode === this._panKey &&
	            this.getMode() !== OrbitManipulator.Pan ) {
	            this.setMode( OrbitManipulator.Pan );
	            this._manipulator.getPanInterpolator().reset();
	            this.pushButton();
	            ev.preventDefault();
	        } else if ( ev.keyCode === this._zoomKey &&
	            this.getMode() !== OrbitManipulator.Zoom ) {
	            this.setMode( OrbitManipulator.Zoom );
	            this._manipulator.getZoomInterpolator().reset();
	            this.pushButton();
	            ev.preventDefault();
	        } else if ( ev.keyCode === this._rotateKey &&
	            this.getMode() !== OrbitManipulator.Rotate ) {
	            this.setMode( OrbitManipulator.Rotate );
	            this._manipulator.getRotateInterpolator().reset();
	            this.pushButton();
	            ev.preventDefault();
	        }
	
	    },
	
	    keyup: function ( ev ) {
	        if ( ev.keyCode === this._panKey ) {
	            this.mouseup( ev );
	        } else if ( ev.keyCode === this._rotateKey ) {
	            this.mouseup( ev );
	        } else if ( ev.keyCode === this._rotateKey ) {
	            this.mouseup( ev );
	        }
	        this.setMode( undefined );
	    },
	
	};
	
	module.exports = CADManipulatorStandardMouseKeyboardController;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	
	var CADManipulatorHammerController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this._timer = false;
	    this.init();
	};
	
	CADManipulatorHammerController.prototype = {
	    init: function () {
	        this._panFactorX = 1.0;
	        this._panFactorY = -this._panFactorX;
	
	        this._rotateFactorX = 0.6;
	        this._rotateFactorY = -this._rotateFactorX;
	        this._zoomFactor = 5.0;
	
	        this._lastScale = 0;
	        this._nbPointerLast = 0; // to check if we the number of pointers has changed
	
	        this._lastPos = undefined; // to set the pivot for rotation
	    },
	    setEventProxy: function ( proxy ) {
	        if ( proxy === undefined || ( proxy !== undefined && proxy === this._eventProxy ) ) {
	            return;
	        }
	        this._eventProxy = proxy;
	        var self = this;
	        var hammer = proxy;
	        var computeTouches = function ( event ) {
	            if ( event.pointers !== undefined )
	                return event.pointers.length;
	            return 1; // mouse
	        };
	
	        var dragCB = function ( ev ) {
	            return 'touches ' + computeTouches( ev ) + ' distance ' + ev.distance + ' x ' + ev.deltaX + ' y ' + ev.deltaY;
	        };
	        // Set a minimal thresold on pinch event, to be detected after pan
	        hammer.get( 'pinch' ).set( {
	            threshold: 0.1
	        } );
	        // Let the pan be detected with two fingers.
	        hammer.get( 'pan' ).set( {
	            threshold: 0,
	            pointers: 0
	        } );
	        hammer.get( 'pinch' ).recognizeWith( hammer.get( 'pan' ) );
	
	        hammer.get( 'tap' ).set( {
	            taps: 2,
	            posThreshold: 300
	        } );
	
	        this._cbPanStart = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || self._transformStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            var gesture = event;
	            self._dragStarted = true;
	            self._nbPointerLast = computeTouches( gesture );
	
	            var pos;
	            if ( self._nbPointerLast === 2 ) {
	                pos = manipulator.getPositionRelativeToCanvas( event.center.x, event.center.y );
	                self._lastPos = pos;
	            } else {
	                if ( self._lastPos === undefined ) {
	                    pos = manipulator.getCanvasCenter();
	                } else {
	                    pos = self._lastPos;
	                }
	            }
	
	            manipulator.computeIntersections( pos );
	
	            if ( self._nbPointerLast === 2 ) {
	                manipulator.getPanInterpolator().reset();
	                manipulator.getPanInterpolator().set( event.center.x * self._panFactorX, event.center.y * self._panFactorY );
	            } else {
	                manipulator.getRotateInterpolator().reset();
	            }
	            Notify.debug( 'drag start, ' + dragCB( gesture ) );
	        };
	
	        this._cbPanMove = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            var gesture = event;
	            var nbPointers = computeTouches( gesture );
	
	            // prevent sudden big changes in the event.center variables
	            if ( self._nbPointerLast !== nbPointers ) {
	                if ( nbPointers === 2 ) manipulator.getPanInterpolator().reset();
	                else manipulator.getRotateInterpolator().reset();
	                self._nbPointerLast = nbPointers;
	            }
	
	            if ( nbPointers === 2 ) {
	                manipulator.getPanInterpolator().setTarget( event.center.x * self._panFactorX, event.center.y * self._panFactorY );
	                Notify.debug( 'pan, ' + dragCB( gesture ) );
	            } else {
	                manipulator.getRotateInterpolator().setTarget( event.center.x * self._rotateFactorX, event.center.y * self._rotateFactorY );
	                Notify.debug( 'rotate, ' + dragCB( gesture ) );
	            }
	        };
	
	        this._cbPanEnd = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || !self._dragStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            self._dragStarted = false;
	            var gesture = event;
	            Notify.debug( 'drag end, ' + dragCB( gesture ) );
	        };
	
	        this._cbPinchStart = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || event.pointerType === 'mouse' ) {
	                return;
	            }
	            self._transformStarted = true;
	            var gesture = event;
	
	            self._lastScale = gesture.scale;
	            manipulator.getZoomInterpolator().reset();
	            manipulator.getZoomInterpolator().set( self._lastScale );
	            event.preventDefault();
	
	            Notify.debug( 'zoom start, ' + dragCB( gesture ) );
	        };
	
	        this._cbPinchEnd = function ( event ) {
	            if ( event.pointerType === 'mouse' ) {
	                return;
	            }
	            self._transformStarted = false;
	            Notify.debug( 'zoom end, ' + dragCB( event ) );
	        };
	
	        this._cbPinchInOut = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || !self._transformStarted || event.pointerType === 'mouse' ) {
	                return;
	            }
	            var gesture = event;
	
	            // make the dezoom faster
	            var zoomFactor = gesture.scale > self._lastScale ? self._zoomFactor : self._zoomFactor * 4.0;
	            var scale = ( gesture.scale - self._lastScale ) * zoomFactor;
	            self._lastScale = gesture.scale;
	
	            manipulator.getZoomInterpolator().setTarget( manipulator.getZoomInterpolator().getTarget()[ 0 ] - scale );
	
	            Notify.debug( 'zoom, ' + dragCB( gesture ) );
	        };
	
	        this._cbDoubleTap = function ( event ) {
	            var manipulator = self._manipulator;
	            if ( !manipulator || event.pointerType === 'mouse' ) {
	                return;
	            }
	            var gesture = event;
	
	            var pos = manipulator.getPositionRelativeToCanvas( event.center.x, event.center.y );
	            self._lastPos = pos;
	
	            manipulator.getZoomInterpolator().set( 0.0 );
	            var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - 10; // Default interval 10
	            manipulator.getZoomInterpolator().setTarget( zoomTarget );
	
	            Notify.debug( 'tap, ' + dragCB( gesture ) );
	        };
	
	        hammer.on( 'panstart ', this._cbPanStart );
	        hammer.on( 'panmove', this._cbPanMove );
	        hammer.on( 'panend', this._cbPanEnd );
	        hammer.on( 'pinchstart', this._cbPinchStart );
	        hammer.on( 'pinchend', this._cbPinchEnd );
	        hammer.on( 'pinchin pinchout', this._cbPinchInOut );
	        hammer.on( 'tap', this._cbDoubleTap );
	    },
	    removeEventProxy: function ( proxy ) {
	        if ( !proxy || !this._eventProxy )
	            return;
	        proxy.off( 'panstart ', this._cbPanStart );
	        proxy.off( 'panmove', this._cbPanMove );
	        proxy.off( 'panend', this._cbPanEnd );
	        proxy.off( 'pinchstart', this._cbPinchStart );
	        proxy.off( 'pinchend', this._cbPinchEnd );
	        proxy.off( 'pinchin pinchout', this._cbPinchInOut );
	        proxy.off( 'tap', this._cbDoubleTap );
	    },
	    setManipulator: function ( manipulator ) {
	        this._manipulator = manipulator;
	    }
	};
	
	module.exports = CADManipulatorHammerController;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Manipulator = __webpack_require__( 133 );
	var OrbitManipulator = __webpack_require__( 134 );
	var Matrix = __webpack_require__( 23 );
	var Vec2 = __webpack_require__( 70 );
	var Vec3 = __webpack_require__( 15 );
	var Quat = __webpack_require__( 26 );
	var FirstPersonManipulatorDeviceOrientationController = __webpack_require__( 136 );
	var FirstPersonManipulatorHammerController = __webpack_require__( 150 );
	var FirstPersonManipulatorWebVRController = __webpack_require__( 151 );
	var FirstPersonManipulatorStandardMouseKeyboardController = __webpack_require__( 152 );
	
	
	/**
	 * Authors:
	 *  Matt Fontaine <tehqin@gmail.com>
	 *  Cedric Pinson <trigrou@gmail.com>
	 */
	
	/**
	 *  FirstPersonManipulator
	 *  @class
	 */
	var FirstPersonManipulator = function ( boundStrategy ) {
	    Manipulator.call( this, boundStrategy );
	    this.init();
	};
	
	FirstPersonManipulator.AvailableControllerList = [ 'StandardMouseKeyboard', 'WebVR', 'DeviceOrientation', 'Hammer' ];
	FirstPersonManipulator.ControllerList = [ 'StandardMouseKeyboard', 'WebVR', 'DeviceOrientation', 'Hammer' ];
	
	FirstPersonManipulator.prototype = MACROUTILS.objectInherit( Manipulator.prototype, {
	
	    computeHomePosition: function ( boundStrategy ) {
	        var bs = this.getHomeBound( boundStrategy );
	        if ( !bs || !bs.valid() ) return;
	
	        this._distance = this.getHomeDistance( bs );
	        var cen = bs.center();
	        Vec3.mult( this._direction, -this._distance, this._eye );
	        Vec3.add( cen, this._eye, this._eye );
	        this.setTarget( cen );
	    },
	
	    init: function () {
	        this._direction = Vec3.createAndSet( 0.0, 1.0, 0.0 );
	        this._eye = Vec3.createAndSet( 0.0, 25.0, 10.0 );
	        this._up = Vec3.createAndSet( 0.0, 0.0, 1.0 );
	        this._distance = 1.0;
	        this._forward = new OrbitManipulator.Interpolator( 1 );
	        this._side = new OrbitManipulator.Interpolator( 1 );
	        this._lookPosition = new OrbitManipulator.Interpolator( 2 );
	
	        // direct pan interpolator (not based on auto-move)
	        this._pan = new OrbitManipulator.Interpolator( 2 );
	        this._zoom = new OrbitManipulator.Interpolator( 1 );
	
	        this._stepFactor = 1.0; // meaning radius*stepFactor to move
	        this._angleVertical = 0.0;
	        this._angleHorizontal = 0.0;
	
	        // tmp value use for computation
	        this._tmpGetTargetDir = Vec3.create();
	
	        // vr controls
	        this._vrEnable = false;
	        this._vrRot = Quat.create(); // absolute orientation
	        this._vrPos = Vec3.create(); // absolute position
	        this._vrTrans = Vec3.create(); // delta translation since last update
	
	        var self = this;
	
	        this._controllerList = {};
	        FirstPersonManipulator.ControllerList.forEach( function ( value ) {
	            if ( FirstPersonManipulator[ value ] !== undefined ) {
	                self._controllerList[ value ] = new FirstPersonManipulator[ value ]( self );
	            }
	        } );
	
	    },
	
	    setDelay: function ( dt ) {
	        this._forward.setDelay( dt );
	        this._side.setDelay( dt );
	        this._lookPosition.setDelay( dt );
	        this._pan.setDelay( dt );
	        this._zoom.setDelay( dt );
	    },
	
	    getEyePosition: function ( eye ) {
	        eye[ 0 ] = this._eye[ 0 ];
	        eye[ 1 ] = this._eye[ 1 ];
	        eye[ 2 ] = this._eye[ 2 ];
	        return eye;
	    },
	
	    setEyePosition: function ( eye ) {
	        this._eye[ 0 ] = eye[ 0 ];
	        this._eye[ 1 ] = eye[ 1 ];
	        this._eye[ 2 ] = eye[ 2 ];
	        return this;
	    },
	
	    getTarget: function ( pos ) {
	        var dir = Vec3.mult( this._direction, this._distance, this._tmpGetTargetDir );
	        Vec3.add( this._eye, dir, pos );
	        return pos;
	    },
	
	    setTarget: function ( pos ) {
	        var dir = this._tmpGetTargetDir;
	        Vec3.sub( pos, this._eye, dir );
	        dir[ 2 ] = 0.0;
	        Vec3.normalize( dir, dir );
	        this._angleHorizontal = Math.acos( dir[ 1 ] );
	        if ( dir[ 0 ] < 0.0 ) {
	            this._angleHorizontal = -this._angleHorizontal;
	        }
	        Vec3.sub( pos, this._eye, dir );
	        Vec3.normalize( dir, dir );
	
	        this._angleVertical = -Math.asin( dir[ 2 ] );
	        Vec3.copy( dir, this._direction );
	    },
	
	    getLookPositionInterpolator: function () {
	        return this._lookPosition;
	    },
	    getSideInterpolator: function () {
	        return this._side;
	    },
	    getForwardInterpolator: function () {
	        return this._forward;
	    },
	    getPanInterpolator: function () {
	        return this._pan;
	    },
	    getZoomInterpolator: function () {
	        return this._zoom;
	    },
	    getRotateInterpolator: function () {
	        // for compatibility with orbit hammer controllers
	        return this._lookPosition;
	    },
	
	    computeRotation: ( function () {
	        var first = Matrix.create();
	        var rotMat = Matrix.create();
	
	        var upy = Vec3.createAndSet( 0.0, 1.0, 0.0 );
	        var upz = Vec3.createAndSet( 0.0, 0.0, 1.0 );
	        var LIMIT = Math.PI * 0.5;
	        return function ( dx, dy ) {
	            this._angleVertical += dy * 0.01;
	            this._angleHorizontal -= dx * 0.01;
	            if ( this._angleVertical > LIMIT ) this._angleVertical = LIMIT;
	            else if ( this._angleVertical < -LIMIT ) this._angleVertical = -LIMIT;
	
	            if ( this._vrEnable ) {
	                Quat.transformVec3( this._vrRot, upy, this._direction );
	                Vec3.normalize( this._direction, this._direction );
	                Quat.transformVec3( this._vrRot, upz, this._up );
	
	            } else {
	                Matrix.makeRotate( -this._angleVertical, 1.0, 0.0, 0.0, first );
	                Matrix.makeRotate( -this._angleHorizontal, 0.0, 0.0, 1.0, rotMat );
	                Matrix.preMult( rotMat, first );
	
	                Matrix.transformVec3( rotMat, upy, this._direction );
	                Vec3.normalize( this._direction, this._direction );
	                Matrix.transformVec3( rotMat, upz, this._up );
	            }
	        };
	    } )(),
	    reset: function () {
	        this.init();
	    },
	    setDistance: function ( d ) {
	        this._distance = d;
	    },
	    getDistance: function () {
	        return this._distance;
	    },
	    setStepFactor: function ( t ) {
	        this._stepFactor = t;
	    },
	
	    computePosition: ( function () {
	        var vec = Vec2.create();
	
	        return function ( dt ) {
	            this._forward.update( dt );
	            this._side.update( dt );
	
	            // TDOO why check with epsilon ?
	            var factor = this._distance < 1e-3 ? 1e-3 : this._distance;
	
	            // see comment in orbitManipulator for fov modulation speed
	            var proj = this._camera.getProjectionMatrix();
	            var vFov = proj[ 15 ] === 1 ? 1.0 : 2.0 / proj[ 5 ];
	
	            // time based displacement vector
	            vec[ 0 ] = this._forward.getCurrent()[ 0 ];
	            vec[ 1 ] = this._side.getCurrent()[ 0 ];
	            var len2 = Vec2.length2( vec );
	            if ( len2 > 1.0 ) Vec2.mult( vec, 1.0 / Math.sqrt( len2 ), vec );
	
	            // direct displacement vectors
	            var pan = this._pan.update( dt );
	            var zoom = this._zoom.update( dt );
	
	            var timeFactor = this._stepFactor * factor * vFov * dt;
	            var directFactor = this._stepFactor * factor * vFov * 0.005;
	
	            this.moveForward( vec[ 0 ] * timeFactor - zoom[ 0 ] * directFactor * 20.0 );
	            this.strafe( vec[ 1 ] * timeFactor - pan[ 0 ] * directFactor );
	            this.strafeVertical( -pan[ 1 ] * directFactor );
	
	            if ( this._vrEnable ) {
	                Vec3.add( this._eye, this._vrTrans, this._eye );
	                // in case setPoseVR skips some frame (possible if tracking is lost temporarily)
	                Vec3.init( this._vrTrans );
	            }
	        };
	    } )(),
	
	
	    update: ( function () {
	        var tmpTarget = Vec3.create();
	
	        return function ( nv ) {
	
	            var dt = nv.getFrameStamp().getDeltaTime();
	
	            var delta = this._lookPosition.update( dt );
	            this.computeRotation( -delta[ 0 ] * 0.5, -delta[ 1 ] * 0.5 );
	            this.computePosition( dt );
	
	            Vec3.add( this._eye, this._direction, tmpTarget );
	            Matrix.makeLookAt( this._eye, tmpTarget, this._up, this._inverseMatrix );
	
	            this._vrEnable = false; // setPoseVR is called on each frame
	        };
	    } )(),
	
	    setPoseVR: function ( quat, pos ) {
	        this._vrEnable = true;
	        Quat.copy( quat, this._vrRot );
	        Vec3.sub( pos, this._vrPos, this._vrTrans );
	        Vec3.copy( pos, this._vrPos );
	    },
	
	    moveForward: ( function () {
	        var tmp = Vec3.create();
	        return function ( distance ) {
	            Vec3.normalize( this._direction, tmp );
	            Vec3.mult( tmp, distance, tmp );
	            Vec3.add( this._eye, tmp, this._eye );
	        };
	    } )(),
	
	    strafe: ( function () {
	        var tmp = Vec3.create();
	        return function ( distance ) {
	            Vec3.cross( this._direction, this._up, tmp );
	            Vec3.normalize( tmp, tmp );
	            Vec3.mult( tmp, distance, tmp );
	            Vec3.add( this._eye, tmp, this._eye );
	        };
	    } )(),
	
	    strafeVertical: ( function () {
	        var tmp = Vec3.create();
	        return function ( distance ) {
	            Vec3.normalize( this._up, tmp );
	            Vec3.mult( tmp, distance, tmp );
	            Vec3.add( this._eye, tmp, this._eye );
	        };
	    } )()
	
	} );
	
	FirstPersonManipulator.DeviceOrientation = FirstPersonManipulatorDeviceOrientationController;
	FirstPersonManipulator.Hammer = FirstPersonManipulatorHammerController;
	FirstPersonManipulator.WebVR = FirstPersonManipulatorWebVRController;
	FirstPersonManipulator.StandardMouseKeyboard = FirstPersonManipulatorStandardMouseKeyboardController;
	
	module.exports = FirstPersonManipulator;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var OrbitManipulatorHammerController = __webpack_require__( 138 );
	
	
	module.exports = OrbitManipulatorHammerController;


/***/ }),
/* 151 */
/***/ (function(module, exports) {

	'use strict';
	
	var FirstPersonManipulatorWebVRController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	FirstPersonManipulatorWebVRController.prototype = {
	    init: function () {},
	    update: function ( quat, position ) {
	        this._manipulator.setPoseVR( quat, position );
	    }
	};
	
	module.exports = FirstPersonManipulatorWebVRController;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

	'use strict';
	
	var FirstPersonManipulatorStandardMouseKeyboardController = function ( manipulator ) {
	    this._manipulator = manipulator;
	    this.init();
	};
	
	FirstPersonManipulatorStandardMouseKeyboardController.prototype = {
	    init: function () {
	        this.releaseButton();
	        this._delay = 0.15;
	        this._stepFactor = 1.0; // meaning radius*stepFactor to move
	    },
	    setEventProxy: function ( proxy ) {
	        this._eventProxy = proxy;
	    },
	    setManipulator: function ( manipulator ) {
	        this._manipulator = manipulator;
	
	        // we always want to sync speed of controller with manipulator
	        this._manipulator.setStepFactor( this._stepFactor );
	    },
	
	    pushButton: function () {
	        this._buttonup = false;
	    },
	    releaseButton: function () {
	        this._buttonup = true;
	    },
	
	    mousedown: function ( ev ) {
	        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );
	        var manipulator = this._manipulator;
	        manipulator.getLookPositionInterpolator().set( pos[ 0 ], pos[ 1 ] );
	        this.pushButton();
	    },
	    mouseup: function ( /*ev */) {
	        this.releaseButton();
	    },
	    mouseout: function ( /*ev */) {
	        this.releaseButton();
	    },
	    mousemove: function ( ev ) {
	        if ( this._buttonup === true ) {
	            return;
	        }
	
	        var pos = this._eventProxy.getPositionRelativeToCanvas( ev );
	        this._manipulator.getLookPositionInterpolator().setDelay( this._delay );
	        this._manipulator.getLookPositionInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );
	    },
	    mousewheel: function ( ev, intDelta /*, deltaX, deltaY */ ) {
	        ev.preventDefault();
	        this._stepFactor = Math.min( Math.max( 0.001, this._stepFactor + intDelta * 0.01 ), 4.0 );
	        this._manipulator.setStepFactor( this._stepFactor );
	    },
	
	    keydown: function ( event ) {
	        var manipulator = this._manipulator;
	        if ( event.keyCode === 32 ) {
	            manipulator.computeHomePosition();
	            event.preventDefault();
	        } else if ( event.keyCode === 87 || event.keyCode === 90 || event.keyCode === 38 ) { // w/z/up
	            manipulator.getForwardInterpolator().setDelay( this._delay );
	            manipulator.getForwardInterpolator().setTarget( 1 );
	            event.preventDefault();
	            return false;
	        } else if ( event.keyCode === 83 || event.keyCode === 40 ) { // S/down
	            manipulator.getForwardInterpolator().setDelay( this._delay );
	            manipulator.getForwardInterpolator().setTarget( -1 );
	            event.preventDefault();
	            return false;
	        } else if ( event.keyCode === 68 || event.keyCode === 39 ) { // D/right
	            manipulator.getSideInterpolator().setDelay( this._delay );
	            manipulator.getSideInterpolator().setTarget( 1 );
	            event.preventDefault();
	            return false;
	        } else if ( event.keyCode === 65 || event.keyCode === 81 || event.keyCode === 37 ) { // a/q/left
	            manipulator.getSideInterpolator().setDelay( this._delay );
	            manipulator.getSideInterpolator().setTarget( -1 );
	            event.preventDefault();
	            return false;
	        }
	        return undefined;
	    },
	
	    keyup: function ( event ) {
	        var manipulator = this._manipulator;
	        if ( event.keyCode === 87 || event.keyCode === 90 || event.keyCode === 38 || // w/z/up
	            event.keyCode === 83 || event.keyCode === 40 ) { // S/down
	            manipulator.getForwardInterpolator().setDelay( this._delay );
	            manipulator.getForwardInterpolator().setTarget( 0 );
	            return false;
	        } else if ( event.keyCode === 68 || event.keyCode === 39 || // D/right
	            event.keyCode === 65 || event.keyCode === 81 || event.keyCode === 37 ) { // a/q/left
	            manipulator.getSideInterpolator().setDelay( this._delay );
	            manipulator.getSideInterpolator().setTarget( 0 );
	            return false;
	        }
	        return undefined;
	    }
	
	};
	
	module.exports = FirstPersonManipulatorStandardMouseKeyboardController;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 *  OrbitManipulator
	 *  @class
	 */
	var SwitchManipulator = function () {
	    this._manipulatorList = [];
	    this._currentManipulator = undefined;
	};
	
	/** @lends SwitchManipulator.prototype */
	SwitchManipulator.prototype = {
	    getCamera: function () {
	        return this.getCurrentManipulator().getCamera();
	    },
	    setCamera: function ( cam ) {
	        var cbList = this.getManipulatorList();
	        for ( var i = 0, nb = cbList.length; i < nb; ++i )
	            cbList[ i ].setCamera( cam );
	    },
	    update: function ( nv ) {
	        var manipulator = this.getCurrentManipulator();
	        if ( manipulator !== undefined ) {
	            return manipulator.update( nv );
	        }
	        return undefined;
	    },
	    getNode: function () {
	        // we should add an accessor in the osgjs manipulator
	        return this.getCurrentManipulator()._node;
	    },
	    setNode: function ( node ) {
	        var cbList = this.getManipulatorList();
	        for ( var i = 0, nb = cbList.length; i < nb; ++i )
	            cbList[ i ].setNode( node );
	    },
	    getControllerList: function () {
	        return this.getCurrentManipulator().getControllerList();
	    },
	    getNumManipulator: function () {
	        return this._manipulatorList.length;
	    },
	    addManipulator: function ( manipulator ) {
	        this._manipulatorList.push( manipulator );
	        if ( this._currentManipulator === undefined ) {
	            this.setManipulatorIndex( 0 );
	        }
	    },
	    getManipulatorList: function () {
	        return this._manipulatorList;
	    },
	    setManipulatorIndex: function ( index ) {
	        this._currentManipulator = index;
	    },
	    getCurrentManipulatorIndex: function () {
	        return this._currentManipulator;
	    },
	    getCurrentManipulator: function () {
	        return this._manipulatorList[ this._currentManipulator ];
	    },
	    reset: function () {
	        this.getCurrentManipulator().reset();
	    },
	    computeHomePosition: function ( useBoundingBox ) {
	        var manipulator = this.getCurrentManipulator();
	        if ( manipulator !== undefined ) {
	            manipulator.computeHomePosition( useBoundingBox );
	        }
	    },
	    getInverseMatrix: function () {
	        var manipulator = this.getCurrentManipulator();
	        if ( manipulator !== undefined ) {
	            return manipulator.getInverseMatrix();
	        }
	    },
	    getHomeBound: function ( boundStrategy ) {
	        return this.getCurrentManipulator().getHomeBound( boundStrategy );
	    },
	    getHomeDistance: function ( bs ) {
	        return this.getCurrentManipulator().getHomeDistance( bs );
	    }
	};
	
	module.exports = SwitchManipulator;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Composer = __webpack_require__( 155 );
	var DisplayNormalVisitor = __webpack_require__( 156 );
	var DisplayGeometryVisitor = __webpack_require__( 166 );
	var DisplayGraph = __webpack_require__( 200 );
	var IntersectionVisitor = __webpack_require__( 143 );
	var LineSegmentIntersector = __webpack_require__( 144 );
	var NodeGizmo = __webpack_require__( 207 );
	var GizmoGeometry = __webpack_require__( 208 );
	var ParameterVisitor = __webpack_require__( 209 );
	var PolytopeIntersector = __webpack_require__( 145 );
	var PolytopePrimitiveIntersector = __webpack_require__( 146 );
	var SphereIntersector = __webpack_require__( 210 );
	var TangentSpaceGenerator = __webpack_require__( 211 );
	var TriangleIntersect = __webpack_require__( 93 );
	var WebVRCustom = __webpack_require__( 212 );
	var WebVR = __webpack_require__( 213 );
	
	
	var osgUtil = {};
	
	osgUtil.Composer = Composer;
	osgUtil.DisplayNormalVisitor = DisplayNormalVisitor;
	osgUtil.DisplayGeometryVisitor = DisplayGeometryVisitor;
	osgUtil.DisplayGraph = DisplayGraph;
	osgUtil.IntersectionVisitor = IntersectionVisitor;
	osgUtil.LineSegmentIntersector = LineSegmentIntersector;
	osgUtil.NodeGizmo = NodeGizmo;
	osgUtil.GizmoGeometry = GizmoGeometry;
	osgUtil.WebVRCustom = WebVRCustom;
	osgUtil.ParameterVisitor = ParameterVisitor;
	osgUtil.PolytopeIntersector = PolytopeIntersector;
	osgUtil.PolytopePrimitiveIntersector = PolytopePrimitiveIntersector;
	osgUtil.SphereIntersector = SphereIntersector;
	osgUtil.TangentSpaceGenerator = TangentSpaceGenerator;
	osgUtil.TriangleIntersect = TriangleIntersect;
	osgUtil.WebVR = WebVR;
	
	module.exports = osgUtil;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Node = __webpack_require__( 12 );
	var CullFace = __webpack_require__( 59 );
	var Depth = __webpack_require__( 86 );
	var Texture = __webpack_require__( 34 );
	var Camera = __webpack_require__( 56 );
	var FrameBufferObject = __webpack_require__( 68 );
	var Viewport = __webpack_require__( 107 );
	var Matrix = __webpack_require__( 23 );
	var Uniform = __webpack_require__( 35 );
	var StateSet = __webpack_require__( 19 );
	var Program = __webpack_require__( 100 );
	var Shader = __webpack_require__( 101 );
	var Shape = __webpack_require__( 102 );
	var TransformEnums = __webpack_require__( 29 );
	var Vec2 = __webpack_require__( 70 );
	var Vec3 = __webpack_require__( 15 );
	
	
	/*
	 Composer is an helper to create post fx. The idea is to push one or more textures into a pipe of shader filter.
	
	 how to use it:
	
	 // example how to blur a texture and render it to screen
	 var myTexture; // imagine it's your texture you want to process
	 var composer = new Composer();
	 composer.addPass(new Composer.Filter.InputTexture(myTexture));
	 composer.addPass(new Composer.Filter.HBlur(5));
	 composer.addPass(new Composer.Filter.VBlur(5));
	 composer.renderToScreen(1200, 900);
	 composer.build(); // if you dont build manually it will be done in the scenegraph while upading
	 rootnode.addChild(composer);
	
	 // now you can imagine to some process and use the result as input texture for a geometry
	 var myTexture; // imagine it's your texture you want to process
	 var myResultTexture = new Texture(); // imagine it's your texture you want to process
	 myResultTexture.setTextureSize(1200,900);
	 var composer = new Composer();
	 composer.addPass(new Composer.Filter.InputTexture(myTexture));
	 composer.addPass(new Composer.Filter.HBlur(5));
	 composer.addPass(new Composer.Filter.VBlur(5), resultTexture);
	
	 myGeometry.getStateSet().setTextureAttributeAndModes(0, resultTexture);
	 rootnode.addChild(composer);
	
	 */
	
	var Composer = function () {
	    Node.call( this );
	    this._stack = [];
	    this._renderToScreen = false;
	    this._dirty = false;
	
	    this._textureRTT = [];
	    this._cameraRTT = [];
	
	    var UpdateCallback = function () {
	
	    };
	    UpdateCallback.prototype = {
	        update: function ( node /*, nv */ ) {
	            if ( node.isDirty() ) {
	                node.build();
	            }
	            return true;
	        }
	    };
	    this.setUpdateCallback( new UpdateCallback() );
	    // disable unecessarry drawing/states/check
	    this.getOrCreateStateSet().setAttributeAndModes( new Depth( 'DISABLE' ) );
	    this.getOrCreateStateSet().setAttributeAndModes( new CullFace( 'BACK' ) );
	};
	
	Composer.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    dirty: function () {
	        for ( var i = 0, l = this._stack.length; i < l; i++ ) {
	            this._stack[ i ].filter.dirty();
	        }
	    },
	
	    // addPass support different signature
	    // addPass(filter) -> the filter will be done on a texture of the same size than the previous pass
	    // addPass(filter, textureWidth, textureHeight) -> the filter will be done on a texture width and height
	    // addPass(filter, texture) -> the filter will be done on the giver texture using its width and height
	    addPass: function ( filter, arg0, arg1 ) {
	
	        var newPass = {};
	        newPass.filter = filter;
	        // when arg0 is a texture
	        // arg1 is the target, can be TEXTURE_2D ( by default ) or
	        // a cubemape's face like TEXTURE_CUBE_MAP_POSITIVE_X, ...
	        if ( arg0 instanceof Texture ) {
	            newPass.texture = arg0;
	            newPass.textureTarget = arg1 || Texture.TEXTURE_2D;
	        } else if ( arg0 !== undefined && arg1 !== undefined ) {
	            newPass.width = Math.floor( arg0 );
	            newPass.height = Math.floor( arg1 );
	        }
	
	        this._stack.push( newPass );
	        return newPass.filter;
	    },
	    renderToScreen: function ( w, h ) {
	        this._renderToScreen = true;
	        this._renderToScreenWidth = w;
	        this._renderToScreenHeight = h;
	    },
	    getResultTexture: function () {
	        return this._resultTexture;
	    },
	    isDirty: function () {
	        for ( var i = 0, l = this._stack.length; i < l; i++ ) {
	            if ( this._stack[ i ].filter.isDirty() ) {
	                return true;
	            }
	        }
	        return false;
	    },
	
	
	    build: function () {
	
	        var self = this;
	
	        // keep some references
	        // TODO: use for reuse/cache/invalidation
	        self._textureRTT = [];
	        self._cameraRTT = [];
	
	
	        this.removeChildren();
	        var lastTextureResult;
	
	        this._stack.forEach( function ( element, i, array ) {
	
	            // update filter internal due to user change on filter
	            if ( element.filter.isDirty() ) {
	                element.filter.build();
	            }
	
	            // this filter need a special setup that composer build cannot do
	            if ( element.filter.interConnectFilters ) {
	                lastTextureResult = element.filter.interConnectFilters( self, i, array );
	                // goto next filter directly
	                return;
	            }
	
	            var stateSet = element.filter.getStateSet();
	            var w, h;
	
	            // compute filter render texture size
	            if ( element.texture !== undefined ) {
	
	                w = element.texture.getWidth();
	                h = element.texture.getHeight();
	
	            } else if ( element.width !== undefined && element.height !== undefined ) {
	
	                w = element.width;
	                h = element.height;
	
	            } else {
	
	                // get width from Texture0
	                var inputTexture = stateSet.getTextureAttribute( 0, 'Texture' );
	                if ( inputTexture === undefined ) {
	                    Notify.warn( 'Composer can\'t find any information to setup texture output size' );
	                } else {
	                    w = inputTexture.getWidth();
	                    h = inputTexture.getHeight();
	                }
	            }
	
	            // is it the last filter and we want to render to screen ?
	            var lastFilterRenderToScreen = ( i === array.length - 1 &&
	                self._renderToScreen === true );
	
	            // check if we have something to do
	            // else we will just translate stateset to the next filter
	            // this part exist to manage the Composer.Filter.InputTexture that setup the first texture unit
	            if ( !lastFilterRenderToScreen ) {
	                if ( stateSet.getAttribute( 'Program' ) === undefined ) {
	                    array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, stateSet.getTextureAttribute( 0, 'Texture' ) );
	                    return;
	                }
	            }
	
	            // build the filter into a Camera and a StateSet
	            var camera = new Camera();
	            self._cameraRTT.push( camera );
	            camera.setStateSet( stateSet );
	
	
	            var textureResult;
	            // check if we want to render on screen
	            if ( lastFilterRenderToScreen === true ) {
	                w = self._renderToScreenWidth;
	                h = self._renderToScreenHeight;
	            } else {
	                // Or in a offscreen Framebuffer
	                camera.setRenderOrder( Camera.PRE_RENDER, 0 );
	                textureResult = element.texture;
	                var textureTarget = element.textureTarget;
	                // if no user provided render target texture, create one
	                if ( textureResult === undefined ) {
	                    textureResult = new Texture();
	                    textureResult.setName( 'composer Rtt ' + element.filter.getFragmentName() );
	                    textureResult.setTextureSize( w, h );
	                    textureTarget = Texture.TEXTURE_2D;
	                    self._textureRTT.push( textureResult );
	                }
	                // Attach the render texture target as FBO
	                // Note: node depth attachment because we're in 2D
	                camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, textureResult, textureTarget );
	            }
	
	            var vp = new Viewport( 0, 0, w, h );
	            camera.setReferenceFrame( TransformEnums.ABSOLUTE_RF );
	            camera.setViewport( vp );
	
	            // FIXME: not really useful, but osgjs keep pushing projection matrix
	            // and maybe some old code still use it
	            Matrix.makeOrtho( 0, 1, 0, 1, -5, 5, camera.getProjectionMatrix() );
	
	            var quad = Shape.createTexturedFullScreenFakeQuadGeometry();
	
	            if ( element.filter.buildGeometry )
	                quad = element.filter.buildGeometry( quad );
	
	            quad.setName( 'composer layer' );
	
	            // if rendering into texture framebuffer
	            if ( textureResult ) {
	
	
	                // assign the result texture to the next stateset
	                if ( i + 1 < array.length ) {
	                    array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, textureResult );
	                }
	
	            }
	            lastTextureResult = textureResult;
	
	
	            camera.addChild( quad );
	            element.filter.getStateSet().addUniform( Uniform.createFloat2( Vec2.createAndSet( w, h ), 'RenderSize' ) );
	
	            // Optimization, no need to clear,
	            // unless we know we'll have transparent parts
	            // which is a special case rather than the default
	            camera.setClearMask( 0 );
	
	
	            camera.setName( 'Composer Pass' + i );
	            // add to composer
	            self.addChild( camera );
	        } );
	        // reference to the resulting texture
	        // undefined if rendering directly to screen
	        this._resultTexture = lastTextureResult;
	    }
	} );
	
	Composer.Filter = function () {
	    this._stateSet = new StateSet();
	    this._dirty = true;
	    this._fragmentName = 'FilterOSGJS';
	    this._vertexName = '';
	};
	
	Composer.Filter.prototype = {
	    setFragmentName: function ( fname ) {
	        this._fragmentName = fname;
	    },
	    getFragmentName: function () {
	        return this._fragmentName;
	    },
	    setVertexName: function ( vname ) {
	        this._vertexName = vname;
	    },
	    getVertexName: function () {
	        return this._vertexName;
	    },
	    getDefineFragmentName: function () {
	        return '\n#define SHADER_NAME ' + this._fragmentName + '\n';
	    },
	    getDefineVertexName: function () {
	        return '\n#define SHADER_NAME ' + ( this._vertexName || this._fragmentName ) + '\n';
	    },
	    getStateSet: function () {
	        return this._stateSet;
	    },
	    getOrCreateStateSet: function () {
	        return this._stateSet;
	    },
	    dirty: function () {
	        this._dirty = true;
	    },
	    isDirty: function () {
	        return this._dirty;
	    }
	};
	
	// default means you do use the special optimized full screen triangle
	// dubbed fakeFullscreenQuad
	// no need of modelView, projection, nor texcoord
	Composer.Filter.defaultVertexShader = [
	    'attribute vec3 Vertex;',
	    'varying vec2 FragTexCoord0;',
	    'void main(void) {',
	    '  gl_Position = vec4(Vertex*2.0 - 1.0,1.0);',
	    '  FragTexCoord0 = Vertex.xy;',
	    '}',
	    ''
	].join( '\n' );
	Composer.Filter.defaultFragmentShaderHeader = [
	    '#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp float;\n #else\n precision mediump float;\n#endif',
	    'varying vec2 FragTexCoord0;',
	    'uniform vec2 RenderSize;',
	    'uniform sampler2D Texture0;',
	    ''
	].join( '\n' );
	
	Composer.Filter.shaderUtils = [
	    'vec4 packFloatTo4x8(in float v) {',
	    'vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;',
	    'enc = fract(enc);',
	    'enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);',
	    'return enc;',
	    '}',
	
	    ' ',
	    'vec4 pack2FloatTo4x8(in vec2 val) {',
	    ' const vec2 bitSh = vec2(256.0, 1.0);',
	    ' const vec2 bitMsk = vec2(0.0, 1.0/256.0);',
	    ' vec2 res1 = fract(val.x * bitSh);',
	    ' res1 -= res1.xx * bitMsk;',
	    ' vec2 res2 = fract(val.y * bitSh);',
	    ' res2 -= res2.xx * bitMsk;',
	    ' return vec4(res1.x,res1.y,res2.x,res2.y);',
	    '}',
	    ' ',
	    'float unpack4x8ToFloat( vec4 rgba ) {',
	    ' return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );',
	    '}',
	    ' ',
	    'vec2 unpack4x8To2Float(in vec4 val) {',
	    ' const vec2 unshift = vec2(1.0/256.0, 1.0);',
	    ' return vec2(dot(val.xy, unshift), dot(val.zw, unshift));',
	    '}',
	
	    'vec2 encodeNormal (vec3 n)',
	    '{',
	    '    float f = sqrt(8.0*n.z+8.0);',
	    '    return n.xy / f + 0.5;',
	    '}',
	
	    'vec3 decodeNormal (vec2 enc)',
	    '{',
	    '    vec2 fenc = enc*4.0-2.0;',
	    '    float f = dot(fenc,fenc);',
	    '    float g = sqrt(1.0-f/4.0);',
	    '    vec3 n;',
	    '    n.xy = fenc*g;',
	    '    n.z = 1.0-f/2.0;',
	    '    return n;',
	    '}',
	    ''
	].join( '\n' );
	
	Composer.Filter.Helper = {
	    pascalCache: [
	        [ 1 ]
	    ],
	    getOrCreatePascalCoefficients: function ( kernelSize ) {
	        kernelSize = kernelSize === undefined ? 5 : Math.min( kernelSize, 128 );
	        var cache = Composer.Filter.Helper.pascalCache;
	        if ( cache[ kernelSize ] )
	            return cache[ kernelSize ];
	        for ( var j = cache.length - 1; j < kernelSize; j++ ) {
	            var currentRow = cache[ j ];
	            var currentRowSize = currentRow.length;
	
	            var nextRow = new Array( currentRowSize );
	            nextRow[ 0 ] = 1.0;
	            nextRow[ currentRowSize ] = 1.0;
	
	            // unnormalized pascal
	            var sum = j === cache.length - 1 ? Math.pow( 2, j ) : 1.0;
	            for ( var p = 0; p < currentRowSize - 1; p++ )
	                nextRow[ p + 1 ] = ( currentRow[ p ] + currentRow[ p + 1 ] ) * sum;
	            // normalized array
	            sum = Math.pow( 2, j + 1 );
	            for ( var k = 0; k < currentRowSize + 1; k++ )
	                nextRow[ k ] /= sum;
	            cache.push( nextRow );
	        }
	        return cache[ kernelSize ];
	    }
	};
	
	Composer.Filter.Custom = function ( fragmentShader, uniforms ) {
	    Composer.Filter.call( this );
	    this._fragmentShader = fragmentShader;
	    this._uniforms = uniforms;
	    this._vertexShader = Composer.Filter.defaultVertexShader;
	};
	
	Composer.Filter.Custom.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    setFragmentShader: function ( f ) {
	        this._fragmentShader = f;
	    },
	    setVertexShader: function ( v ) {
	        this._vertexShader = v;
	    },
	    autoBindFragmentUniformStateSet: function ( stateSet, fragmentShader, uniforms ) {
	
	        var unitIndex = 0;
	
	        // TODO: check if not a better place Utils
	        // and reuse (we already do this in shader)
	        // At least DEFINE the regexp somewhere somehow
	        var r = fragmentShader.match( /uniform\s+\w+\s+\w+/g );
	        if ( !r ) return;
	
	        for ( var i = 0, l = r.length; i < l; i++ ) {
	
	            var match = r[ i ].match( /uniform\s+(\w+)\s+(\w+)/ );
	            var uniformType = match[ 1 ];
	            var uniformName = match[ 2 ];
	            var uniform;
	
	            if ( !uniforms[ uniformName ] ) continue;
	
	            var uniformValue = uniforms[ uniformName ];
	
	            if ( uniformType.search( 'sampler' ) !== -1 ) {
	
	                // STRONG IMPLICIT LINKING HERE:
	                // Texture Unit Linked directly to declaration order in fragment Shader
	                stateSet.setTextureAttributeAndModes( unitIndex, uniformValue );
	                uniform = Uniform.createInt1( unitIndex, uniformName );
	                unitIndex++;
	                stateSet.addUniform( uniform );
	
	            } else {
	
	                if ( Uniform.isUniform( uniformValue ) ) {
	                    uniform = uniformValue;
	                } else {
	                    uniform = Uniform[ uniformType ]( uniforms[ uniformName ], uniformName );
	                }
	                stateSet.addUniform( uniform );
	
	            }
	
	        }
	    },
	    build: function () {
	
	        this._program = new Program(
	            new Shader( Shader.VERTEX_SHADER, this._vertexShader + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, this._fragmentShader + this.getDefineFragmentName() ) );
	
	        if ( this._uniforms ) {
	            this.autoBindFragmentUniformStateSet( this._stateSet, this._fragmentShader, this._uniforms );
	        }
	        this._stateSet.setAttributeAndModes( this._program );
	        this._dirty = false;
	
	    }
	} );
	
	
	// filter that switch its render target and its input at each frame
	// allowing to get input for last frame render.
	Composer.Filter.PingPong = function ( cameraRtt0, rtt0, cameraRtt1, rtt1, fragmentShader, uniforms ) {
	    Composer.Filter.Custom.apply( this, [ fragmentShader, uniforms ] );
	
	    this._cameraRtt0 = cameraRtt0;
	    this._rtt0 = rtt0;
	
	    this._cameraRtt1 = cameraRtt1;
	    this._rtt1 = rtt1;
	
	    this._fragmentName = 'PingPong';
	};
	
	Composer.Filter.PingPong.prototype = MACROUTILS.objectInherit( Composer.Filter.Custom.prototype, {
	
	    // Constraints:
	    // - Next Filter: texture unit 0 === rtt0 && texture unit 1 === rtt1
	    // - Previous Filter: the output of the previous filter if any
	    //      will be binded to texture unit 0 of both camera stateset
	    interConnectFilters: function ( composer, i, array ) {
	
	        var filterStateSet = this.getStateSet();
	
	        var st0 = this._cameraRtt0.getOrCreateStateSet();
	        var st1 = this._cameraRtt1.getOrCreateStateSet();
	
	        // copy filter program and uniforms on the 2 cameras
	        st0.setAttributeAndModes( this._program );
	        st1.setAttributeAndModes( this._program );
	
	        // PingPong filter is a peculiar Filter where user provides the Camera
	        // instead of compose::build creating them, and allowing user to provide
	        // them in the ctor
	        // To make sure we don't forget any uniform
	        // we make sure to get uniform from the filter itself and the uniform
	        // from the parameters
	        var k, l, keys, unif, uniforms = this.getStateSet().getUniformList();
	        if ( uniforms ) {
	            keys = window.Object.keys( uniforms );
	            for ( k = 0, l = keys.length; k < l; k++ ) {
	                unif = uniforms[ keys[ k ] ].getUniform();
	                st0.addUniform( unif );
	                st1.addUniform( unif );
	            }
	        }
	
	        uniforms = this._uniforms;
	        if ( uniforms ) {
	            keys = window.Object.keys( uniforms );
	            for ( k = 0, l = keys.length; k < l; k++ ) {
	                unif = uniforms[ keys[ k ] ];
	                st0.addUniform( unif );
	                st1.addUniform( unif );
	            }
	        }
	
	
	        var uniformTU0 = Uniform.createInt1( 0, 'Texture0' );
	        var uniformTU1 = Uniform.createInt1( 1, 'Texture1' );
	
	        st0.addUniform( uniformTU0 );
	        st0.addUniform( uniformTU1 );
	
	        st1.addUniform( uniformTU0 );
	        st1.addUniform( uniformTU1 );
	
	        // copy input on both camera
	        // Composer::Build set the last render into the current filter stateset texture unit 0
	        // we copy that into each camera as Texture unit 0
	        var inputTexture = filterStateSet.getTextureAttribute( 0, 'Texture' );
	        st0.setTextureAttributeAndModes( 0, inputTexture );
	        st1.setTextureAttributeAndModes( 0, inputTexture );
	
	        st0.setTextureAttributeAndModes( 1, this._rtt1 );
	        st1.setTextureAttributeAndModes( 1, this._rtt0 );
	
	        // if not the last filter
	        // bind both result to next filter
	        // rtt0 to texture unit 0
	        // rtt0 to texture unit 1
	        if ( i !== array.length - 1 ) {
	
	            // just translate stateset to the next filter
	            var nextSt = array[ i + 1 ].filter.getStateSet();
	
	            nextSt.setTextureAttributeAndModes( 0, this._rtt0 );
	            nextSt.setTextureAttributeAndModes( 1, this._rtt1 );
	
	            nextSt.addUniform( uniformTU0 );
	            nextSt.addUniform( uniformTU1 );
	
	        }
	
	        var quad = Shape.createTexturedFullScreenFakeQuadGeometry();
	
	        if ( this.buildGeometry )
	            quad = this.buildGeometry( quad );
	
	        quad.setName( 'composer layer' );
	
	        this._cameraRtt0.addChild( quad );
	        this._cameraRtt1.addChild( quad );
	
	        composer.addChild( this._cameraRtt0 );
	        composer.addChild( this._cameraRtt1 );
	
	        composer._textureRTT.push( this._rtt0 );
	        composer._textureRTT.push( this._rtt1 );
	
	        composer._cameraRTT.push( this._cameraRtt0 );
	        composer._cameraRTT.push( this._cameraRtt1 );
	
	        // hide one of the two pass, as we will render only one each frame
	        this._cameraRtt1.setNodeMask( 0x0 );
	
	        // last texture result, only one possible so the first will do
	        return this._rtt0;
	
	    },
	
	    // PingPong
	    switch: function () {
	
	        var nodeMask0 = this._cameraRtt0.getNodeMask();
	        var nodeMask1 = this._cameraRtt1.getNodeMask();
	
	        this._cameraRtt0.setNodeMask( nodeMask1 );
	        this._cameraRtt1.setNodeMask( nodeMask0 );
	
	    }
	
	} );
	
	Composer.Filter.AverageHBlur = function ( nbSamplesOpt, linear, unpack, pack ) {
	    Composer.Filter.call( this );
	    this._linear = linear !== false;
	    this.setBlurSize( nbSamplesOpt !== undefined ? nbSamplesOpt : 5 );
	    this._unpack = unpack;
	    this._pack = pack;
	    this._pixelSize = 1.0;
	    this._fragmentName = 'AverageHBlur' + this._nbSamples;
	};
	
	Composer.Filter.AverageHBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    setBlurSize: function ( nbSamples ) {
	        if ( nbSamples % 2 !== 1 ) {
	            nbSamples += 1;
	        }
	        this._nbSamples = nbSamples;
	        this.dirty();
	    },
	    setPixelSize: function ( value ) {
	        this._pixelSize = value;
	        this.dirty();
	    },
	
	    getUVOffset: function ( value ) {
	        return 'vec2(float(' + value + ')/RenderSize[0], 0.0);';
	    },
	    getShaderBlurKernel: function () {
	        var nbSamples = this._nbSamples;
	
	
	        var kernel = [];
	
	        kernel.push( ' pixel = unpack(Texture0, FragTexCoord0 );' );
	        kernel.push( ' if (pixel.w == 0.0) { gl_FragColor = pixel; return; }' );
	        kernel.push( ' vec2 offset;' );
	        var i;
	        var numTexBlurStep = Math.floor( nbSamples / 2 );
	        if ( numTexBlurStep % 2 !== 0 ) {
	            nbSamples += 1;
	            numTexBlurStep = Math.floor( nbSamples / 2 );
	        }
	        var numFinalSample = numTexBlurStep * 2.0 + 1.0;
	        var weight = 1.0 / numFinalSample;
	        if ( !this._linear ) {
	            for ( i = 0; i < numTexBlurStep; i++ ) {
	                kernel.push( ' offset = ' + this.getUVOffset( ( i + 1 ) * this._pixelSize ) );
	                kernel.push( ' pixel += unpack(Texture0, FragTexCoord0 + offset);' );
	                kernel.push( ' pixel += unpack(Texture0, FragTexCoord0 - offset);' );
	            }
	            kernel.push( ' pixel *= float(' + weight + ');' );
	
	            //console.log( 'N: Sum = ' + ( weight + numTexBlurStep * weight * 2 ) );
	            //console.log( 'N: nbSample = ' + nbSamples + ' texBlurStep= ' + numTexBlurStep + ' finalSample= ' + numFinalSample );
	            //console.log( 'N: w = ' + weight );
	
	        } else {
	            // using bilinear HW to divide texfetch by 2
	            var offset, offsetIdx;
	            var idx = 1;
	            var weightTwo = ( 1.0 - weight ) / ( numTexBlurStep * 2.0 );
	            // first pixel not same weight as others
	            kernel.push( ' pixel *= float(' + weight + ');' );
	            kernel.push( ' vec4 pixelLin = vec4(0.0);' );
	
	            for ( i = 0; i < numTexBlurStep; i += 2 ) {
	
	                offsetIdx = idx + 0.5; //  ((i*weight + (i+1)*weight)/(weight+weight)) ===  (2i + 1) / 2 = i + 0.5
	                idx += 2;
	                offset = this.getUVOffset( offsetIdx * this._pixelSize );
	
	                kernel.push( ' offset = ' + offset );
	
	                kernel.push( ' pixelLin += unpack(Texture0, FragTexCoord0 + offset);' );
	                kernel.push( ' pixelLin += unpack(Texture0, FragTexCoord0 - offset);' );
	            }
	            kernel.push( ' pixel += pixelLin * float(' + weightTwo * 2 + ');' );
	
	            //console.log( 'L: Sum = ' + ( weight + numTexBlurStep * weightTwo * 2 ) );
	            //console.log( 'L: nbSample = ' + nbSamples + ' texBlurStep= ' + numTexBlurStep + ' finalSample= ' + numFinalSample );
	            //console.log( 'N: w = ' + weight + ' numTexBlurStep  ' + numTexBlurStep + ' * w2 = ' + weightTwo );
	
	        }
	        return kernel;
	    },
	    build: function () {
	
	        var tex = this._stateSet.getTextureAttribute( 0, 'Texture' );
	        if ( tex && this._linear ) {
	            tex.setMinFilter( 'LINEAR' );
	            tex.setMagFilter( 'LINEAR' );
	        } else {
	            this._linear = false;
	        }
	
	        //var nbSamples = this._nbSamples;
	        var vtx = Composer.Filter.defaultVertexShader;
	        var fgt = [
	            Composer.Filter.defaultFragmentShaderHeader,
	            'uniform float width;',
	
	            this._unpack || 'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }',
	            this._pack || 'vec4 pack(vec4 pix) { return pix; }',
	
	            'void main (void)',
	            '{',
	            '  vec4 pixel;',
	            this.getShaderBlurKernel().join( '\n' ),
	            '  gl_FragColor = pack(pixel);',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );
	
	        if ( this._stateSet.getUniform( 'Texture0' ) === undefined ) {
	            this._stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );
	        }
	
	
	        this._stateSet.setAttributeAndModes( program );
	        this._dirty = false;
	    }
	} );
	
	
	Composer.Filter.AverageVBlur = function ( nbSamplesOpt, linear, unpack, pack ) {
	    Composer.Filter.AverageHBlur.call( this, nbSamplesOpt, linear, unpack, pack );
	    this._fragmentName = 'AverageVBlur' + this._nbSamples;
	};
	Composer.Filter.AverageVBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.AverageHBlur.prototype, {
	    getUVOffset: function ( value ) {
	        return 'vec2(0.0, float(' + value + ')/RenderSize[1]);';
	    }
	} );
	
	Composer.Filter.BilateralHBlur = function ( options, unpack, pack ) {
	    Composer.Filter.call( this );
	
	    if ( options === undefined ) {
	        options = {};
	    }
	
	    var nbSamplesOpt = options.nbSamples;
	    var depthTexture = options.depthTexture;
	    var radius = options.radius;
	
	    this.setBlurSize( nbSamplesOpt !== undefined ? nbSamplesOpt : 5 );
	    this._depthTexture = depthTexture;
	    this._radius = Uniform.createFloat( 1.0, 'radius' );
	    this._pixelSize = Uniform.createFloat( 1.0, 'pixelSize' );
	    this.setRadius( radius );
	
	    this._unpack = unpack;
	    this._pack = pack;
	    this._fragmentName = 'BilateralHBlur' + this._nbSamples;
	};
	
	Composer.Filter.BilateralHBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    setBlurSize: function ( nbSamples ) {
	        if ( nbSamples % 2 !== 1 ) {
	            nbSamples += 1;
	        }
	        //Notify.log('BlurSize ' + nbSamples);
	        this._nbSamples = nbSamples;
	        this.dirty();
	    },
	    setPixelSize: function ( value ) {
	        this._pixelSize.setFloat( value );
	    },
	    setRadius: function ( radius ) {
	        this._radius.setFloat( radius ); // *2.0;
	    },
	    getUVOffset: function ( value ) {
	        return 'vec2(0.0, float(' + value + ') * pixelSize )/RenderSize[1];';
	    },
	    getShaderBlurKernel: function () {
	        var nbSamples = this._nbSamples;
	        var kernel = [];
	        kernel.push( ' pixel = unpack(Texture0, FragTexCoord0 );' );
	        kernel.push( ' if (pixel.w <= 0.0001) { gl_FragColor = vec4(1.0); return; }' );
	        kernel.push( ' vec2 offset, tmpUV;' );
	        kernel.push( ' depth = getDepthValue(unpack(Texture1, FragTexCoord0 ));' );
	        for ( var i = 1; i < Math.ceil( nbSamples / 2 ); i++ ) {
	            kernel.push( ' offset = ' + this.getUVOffset( i ) );
	
	            kernel.push( ' tmpUV =  FragTexCoord0 + offset;' );
	            kernel.push( ' tmpDepth = getDepthValue(unpack(Texture1, tmpUV ));' );
	            kernel.push( ' if ( abs(depth-tmpDepth) < radius) {' );
	            kernel.push( '   pixel += unpack(Texture0, tmpUV);' );
	            kernel.push( '   nbHits += 1.0;' );
	            kernel.push( ' }' );
	
	            kernel.push( ' tmpUV =  FragTexCoord0 - offset;' );
	            kernel.push( ' tmpDepth = getDepthValue(unpack(Texture1, tmpUV ));' );
	            kernel.push( ' if ( abs(depth-tmpDepth) < radius) {' );
	            kernel.push( '   pixel += unpack(Texture0, tmpUV);' );
	            kernel.push( '   nbHits += 1.0;' );
	            kernel.push( ' }' );
	        }
	        kernel.push( ' pixel /= nbHits;' );
	        return kernel;
	    },
	    build: function () {
	        //var nbSamples = this._nbSamples;
	        var vtx = Composer.Filter.defaultVertexShader;
	        var fgt = [
	            Composer.Filter.defaultFragmentShaderHeader,
	            'uniform sampler2D Texture1;',
	            'uniform float width;',
	            'uniform mat4 projection;',
	            'uniform float radius;',
	            'uniform float pixelSize;',
	
	            this._unpack || 'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }',
	            this._pack || 'vec4 pack(vec4 pix) { return pix; }',
	
	            'float znear,zfar,zrange;',
	            '',
	            Composer.Filter.shaderUtils,
	            '',
	            'float getDepthValue(vec4 v) {',
	            '  float depth = unpack4x8ToFloat(v);',
	            '  depth = depth*zrange+znear;',
	            '  return -depth;',
	            '}',
	
	            'void main (void)',
	            '{',
	            '  vec4 pixel;',
	            '  float depth, tmpDepth;',
	            '  znear = projection[3][2] / (projection[2][2]-1.0);',
	            '  zfar = projection[3][2] / (projection[2][2]+1.0);',
	            '  zrange = zfar-znear;',
	            '  float nbHits = 1.0;',
	
	            this.getShaderBlurKernel().join( '\n' ),
	            '  gl_FragColor = pack(pixel);',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );
	
	        if ( this._stateSet.getUniform( 'Texture0' ) === undefined ) {
	            this._stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );
	        }
	        if ( this._stateSet.getUniform( 'Texture1' ) === undefined ) {
	            this._stateSet.addUniform( Uniform.createInt1( 1, 'Texture1' ) );
	        }
	        this._stateSet.addUniform( this._radius );
	        this._stateSet.addUniform( this._pixelSize );
	        this._stateSet.setTextureAttributeAndModes( 1, this._depthTexture );
	        this._stateSet.setAttributeAndModes( program );
	        this._dirty = false;
	    }
	} );
	
	Composer.Filter.BilateralVBlur = function ( options, unpack, pack ) {
	    Composer.Filter.BilateralHBlur.call( this, options, unpack, pack );
	    this._fragmentName = 'BilateralVBlur' + this._nbSamples;
	};
	
	Composer.Filter.BilateralVBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.BilateralHBlur.prototype, {
	    getUVOffset: function ( value ) {
	        return 'vec2(float(' + value + ')*pixelSize/RenderSize[0],0.0);';
	    }
	} );
	
	// InputTexture is a fake filter to setup the first texture
	// in the composer pipeline
	Composer.Filter.InputTexture = function ( texture ) {
	    Composer.Filter.call( this );
	    this._stateSet.setTextureAttributeAndModes( 0, texture );
	    this._fragmentName = 'InputTexture';
	};
	Composer.Filter.InputTexture.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    build: function () {
	        this._dirty = false;
	    }
	} );
	
	// Operate a Gaussian horizontal blur
	Composer.Filter.HBlur = function ( nbSamplesOpt, linear, unpack, pack ) {
	    Composer.Filter.call( this );
	    this._linear = linear !== false;
	    this.setBlurSize( nbSamplesOpt !== undefined ? nbSamplesOpt : 5 );
	    this._unpack = unpack;
	    this._pack = pack;
	    this._fragmentName = 'HBlur' + this._nbSamples;
	};
	
	Composer.Filter.HBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    setBlurSize: function ( nbSamples ) {
	        if ( nbSamples % 2 !== 0 ) {
	            nbSamples += 1;
	        }
	        this._nbSamples = nbSamples;
	        this.dirty();
	    },
	    getUVOffset: function ( value ) {
	        // TODO: could compute that in JS and remove 1 div per kernel step
	        return 'vec2(float(' + value + ')/ RenderSize[0], 0.0) ;';
	    },
	    build: function () {
	        var nbSamples = this._nbSamples;
	
	        // TODO: get rendersize from that and precompute
	        // offset when possible
	        var tex = this._stateSet.getTextureAttribute( 0, 'Texture' );
	        if ( tex && this._linear ) {
	            tex.setMinFilter( 'LINEAR' );
	            tex.setMagFilter( 'LINEAR' );
	        } else {
	            this._linear = false;
	        }
	
	        var vtx = Composer.Filter.defaultVertexShader;
	
	
	        // http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/
	        // outermost are near 0, so unless float buffer...
	        // at samples = 6 already it's 1/32 = 0.03
	        // so we lessen texFetch (allow higher kernel size with less texfetch)
	        var weightMin = 0.005 / nbSamples;
	        var coeffIdx = nbSamples;
	        var weights = Composer.Filter.Helper.getOrCreatePascalCoefficients( coeffIdx );
	        var start = Math.floor( coeffIdx / 2.0 );
	
	        var kernel = [];
	        kernel.push( ' pixel = float(' + weights[ start ] + ')*unpack(Texture0, FragTexCoord0 ).rgb;' );
	
	        kernel.push( ' vec2 offset;' );
	        var idx, i, weight, offset, offsetIdx;
	        if ( !this._linear ) {
	            idx = 1;
	            for ( i = start + 1; i < nbSamples; i++ ) {
	                weight = weights[ i ];
	
	                if ( weight < weightMin ) break;
	
	                offsetIdx = idx++;
	                offset = this.getUVOffset( offsetIdx );
	
	                kernel.push( ' offset = ' + offset );
	                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (FragTexCoord0.xy + offset.xy)).rgb;' );
	                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (FragTexCoord0.xy - offset.xy)).rgb;' );
	            }
	        } else {
	
	            // using bilinear HW to divide texfetch by 2
	            // http://www.rastergrid.com/blog/wp-content/uploads/2010/09/equation.png
	            idx = 1;
	            for ( i = start + 1; i < nbSamples; i += 2 ) {
	                var weightT1 = weights[ i ];
	                var weightT2 = weights[ i + 1 ];
	
	                weight = weightT1 + weightT2;
	
	                if ( weight < weightMin ) break;
	
	                var offsetT1 = idx;
	                var offsetT2 = idx + 1;
	                idx += 2;
	
	                offsetIdx = ( offsetT1 * weightT1 + offsetT2 * weightT2 ) / weight;
	                offset = this.getUVOffset( offsetIdx );
	
	                kernel.push( ' offset = ' + offset );
	                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (FragTexCoord0.xy + offset.xy)).rgb;' );
	                kernel.push( ' pixel += ' + weight + '* unpack(Texture0, (FragTexCoord0.xy - offset.xy)).rgb;' );
	            }
	        }
	        var fgt = [
	            Composer.Filter.defaultFragmentShaderHeader,
	            'uniform float width;',
	
	            this._unpack || 'vec4 unpack(const in sampler2D tex, const in vec2 uv) { return texture2D(tex, uv); }',
	            this._pack || 'vec4 pack(vec4 pix) { return pix; }',
	
	            'void main (void)',
	            '{',
	            '  vec3 pixel;',
	            kernel.join( '\n' ),
	            '  gl_FragColor = pack(vec4(pixel, 1.0));',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );
	
	        if ( this._stateSet.getUniform( 'Texture0' ) === undefined ) {
	            this._stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );
	        }
	        this._stateSet.setAttributeAndModes( program );
	        this._dirty = false;
	    }
	} );
	
	// Operate a Gaussian vertical blur
	Composer.Filter.VBlur = function ( nbSamplesOpt, linear, unpack, pack ) {
	    Composer.Filter.HBlur.call( this, nbSamplesOpt, linear, unpack, pack );
	    this._fragmentName = 'VBlur' + this._nbSamples;
	};
	
	Composer.Filter.VBlur.prototype = MACROUTILS.objectInherit( Composer.Filter.HBlur.prototype, {
	    getUVOffset: function ( value ) {
	        return 'vec2(0.0, float(' + value + ')/RenderSize[1]) ;';
	    }
	} );
	
	// Sobel filter
	// http://en.wikipedia.org/wiki/Sobel_operator
	Composer.Filter.SobelFilter = function () {
	    Composer.Filter.call( this );
	    this._color = Uniform.createFloat3( Vec3.createAndSet( 1.0, 1.0, 1.0 ), 'color' );
	    this._factor = Uniform.createFloat( 1.0, 'factor' );
	    this._fragmentName = 'SobelFilter';
	};
	
	Composer.Filter.SobelFilter.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    setColor: function ( color ) {
	        this._color.setVec3( color );
	    },
	    setFactor: function ( f ) {
	        this._factor.setFloat( f );
	    },
	    build: function () {
	        var stateSet = this._stateSet;
	        var vtx = Composer.Filter.defaultVertexShader;
	        var fgt = [
	            '',
	            Composer.Filter.defaultFragmentShaderHeader,
	            'uniform vec3 color;',
	            'uniform float factor;',
	            'void main (void)',
	            '{',
	            '  float fac0 = 2.0;',
	            '  float fac1 = 1.0;',
	            '  float offsetx = 1.0/RenderSize[0];',
	            '  float offsety = 1.0/RenderSize[1];',
	            '  vec4 texel0 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, offsety));',
	            '  vec4 texel1 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, 0.0));',
	            '  vec4 texel2 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, -offsety));',
	            '  vec4 texel3 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, -offsety));',
	            '  vec4 texel4 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, -offsety));',
	            '  vec4 texel5 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, 0.0));',
	            '  vec4 texel6 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, offsety));',
	            '  vec4 texel7 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, offsety));',
	            '  vec4 rowx = -fac0*texel5 + fac0*texel1 +  -fac1*texel6 + fac1*texel0 + -fac1*texel4 + fac1*texel2;',
	            '  vec4 rowy = -fac0*texel3 + fac0*texel7 +  -fac1*texel4 + fac1*texel6 + -fac1*texel2 + fac1*texel0;',
	            '  float mag = sqrt(dot(rowy,rowy)+dot(rowx,rowx));',
	            '  if (mag < 1.0/255.0) discard;',
	            '  mag *= factor;',
	            '  mag = min(1.0, mag);',
	            '  gl_FragColor = vec4(color*mag,mag);',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );
	
	        stateSet.setAttributeAndModes( program );
	        stateSet.addUniform( this._color );
	        stateSet.addUniform( this._factor );
	        stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );
	        this._dirty = false;
	    }
	} );
	
	Composer.Filter.BlendMix = function () {
	    Composer.Filter.call( this );
	    var texture0, texture1, mixValue;
	    var unit0 = 0;
	    var unit1 = 1;
	    var stateSet = this._stateSet;
	    if ( arguments.length === 3 ) {
	        texture0 = arguments[ 0 ];
	        texture1 = arguments[ 1 ];
	        mixValue = arguments[ 2 ];
	        unit0 = 1;
	        unit1 = 2;
	        stateSet.setTextureAttributeAndModes( unit0, texture0 );
	    } else if ( arguments.length === 2 ) {
	        texture1 = arguments[ 0 ];
	        mixValue = arguments[ 1 ];
	    } else if ( arguments.length === 1 ) {
	        texture1 = arguments[ 0 ];
	        mixValue = 0.5;
	    }
	    stateSet.setTextureAttributeAndModes( unit1, texture1 );
	    stateSet.addUniform( Uniform.createInt1( unit0, 'Texture0' ) );
	    stateSet.addUniform( Uniform.createInt1( unit1, 'Texture1' ) );
	    this._mixValueUniform = Uniform.createFloat1( mixValue, 'MixValue' );
	    stateSet.addUniform( this._mixValueUniform );
	    this._fragmentName = 'BlendMix';
	};
	
	Composer.Filter.BlendMix.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    getBlendFactorUniform: function () {
	        return this._mixValueUniform;
	    },
	
	    build: function () {
	        var stateSet = this._stateSet;
	        var vtx = Composer.Filter.defaultVertexShader;
	        var fgt = [
	            '',
	            Composer.Filter.defaultFragmentShaderHeader,
	            'uniform sampler2D Texture1;',
	            'uniform float MixValue;',
	
	            'void main (void)',
	            '{',
	            '  gl_FragColor = mix(texture2D(Texture0,FragTexCoord0), texture2D(Texture1,FragTexCoord0),MixValue);',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );
	
	        stateSet.setAttributeAndModes( program );
	        this._dirty = false;
	    }
	} );
	
	
	Composer.Filter.BlendMultiply = function () {
	    Composer.Filter.call( this );
	    var stateSet = this._stateSet;
	    var texture0, texture1;
	    var unit0 = 0;
	    var unit1 = 1;
	    if ( arguments.length === 2 ) {
	        texture0 = arguments[ 0 ];
	        texture1 = arguments[ 1 ];
	        unit0 = 1;
	        unit0 = 2;
	        stateSet.setTextureAttributeAndModes( unit0, texture0 );
	    } else if ( arguments.length === 1 ) {
	        texture1 = arguments[ 0 ];
	    }
	    stateSet.setTextureAttributeAndModes( unit1, texture1 );
	    stateSet.addUniform( Uniform.createInt1( unit0, 'Texture0' ) );
	    stateSet.addUniform( Uniform.createInt1( unit1, 'Texture1' ) );
	    this._fragmentName = 'BlendMultiply';
	};
	
	Composer.Filter.BlendMultiply.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	    build: function () {
	        var vtx = Composer.Filter.defaultVertexShader;
	        var fgt = [
	            '',
	            Composer.Filter.defaultFragmentShaderHeader,
	            'uniform sampler2D Texture1;',
	            'uniform float MixValue;',
	
	            'void main (void)',
	            '{',
	            '  gl_FragColor = texture2D(Texture0,FragTexCoord0)*texture2D(Texture1,FragTexCoord0);',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vtx + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fgt + this.getDefineFragmentName() ) );
	
	        this._stateSet.setAttributeAndModes( program );
	        this._dirty = false;
	    }
	} );
	
	Composer.Filter.SSAO = function ( options ) {
	    Composer.Filter.call( this );
	
	    var stateSet = this._stateSet;
	    var nbSamples = 16;
	    var radius = 0.05;
	    if ( options !== undefined ) {
	        if ( options.nbSamples !== undefined )
	            nbSamples = options.nbSamples;
	
	        if ( options.radius !== undefined )
	            radius = options.radius;
	        var textureNormal = options.normal;
	        var texturePosition = options.position;
	        var w = textureNormal.getWidth();
	        var h = textureNormal.getHeight();
	        this._size = Vec2.createAndSet( w, h );
	
	        stateSet.setTextureAttributeAndModes( 0, textureNormal );
	        stateSet.setTextureAttributeAndModes( 1, texturePosition );
	    }
	
	    this._radius = radius;
	    this._nbSamples = nbSamples;
	    this._noiseTextureSize = 16;
	    this._sceneRadius = 2.0;
	
	    stateSet.addUniform( Uniform.createFloat1( 1.0, 'Power' ) );
	    stateSet.addUniform( Uniform.createFloat1( radius, 'Radius' ) );
	    stateSet.addUniform( Uniform.createInt1( 0, 'Texture0' ) );
	    stateSet.addUniform( Uniform.createInt1( 1, 'Texture1' ) );
	    stateSet.addUniform( Uniform.createInt1( 2, 'Texture2' ) );
	    stateSet.addUniform( Uniform.createFloat1( 0.1, 'AngleLimit' ) );
	
	    this.initNoise();
	    this._fragmentName = 'SSAO';
	};
	
	Composer.Filter.SSAO.prototype = MACROUTILS.objectInherit( Composer.Filter.prototype, {
	
	    initNoise: function () {
	        var sizeNoise = this._noiseTextureSize;
	        var noise = new Array( sizeNoise * sizeNoise * 3 );
	        ( function ( array ) {
	            var n = Vec2.createAndSet( 0.0, 0.0 );
	            for ( var i = 0; i < sizeNoise * sizeNoise; i++ ) {
	                n[ 0 ] = 2.0 * ( Math.random() - 0.5 );
	                n[ 1 ] = 2.0 * ( Math.random() - 0.5 );
	
	                Vec2.normalize( n, n );
	                array[ i * 3 + 0 ] = 255 * ( n[ 0 ] * 0.5 + 0.5 );
	                array[ i * 3 + 1 ] = 255 * ( n[ 1 ] * 0.5 + 0.5 );
	                array[ i * 3 + 2 ] = 255 * 0.5;
	            }
	        } )( noise );
	
	        var noiseTexture = new Texture();
	        noiseTexture.setWrapS( 'REPEAT' );
	        noiseTexture.setWrapT( 'REPEAT' );
	        noiseTexture.setMinFilter( 'NEAREST' );
	        noiseTexture.setMagFilter( 'NEAREST' );
	
	        noiseTexture.setTextureSize( sizeNoise, sizeNoise );
	        noiseTexture.setImage( new Uint8Array( noise ), 'RGB' );
	        this._noiseTexture = noiseTexture;
	    },
	    setSceneRadius: function ( value ) {
	        this._sceneRadius = value;
	        this.dirty();
	    },
	    setAngleLimit: function ( value ) {
	        var uniform = this._stateSet.getUniform( 'AngleLimit' );
	        uniform.setFloat( value );
	    },
	    setNbSamples: function ( value ) {
	        if ( value === this._nbSamples ) {
	            return;
	        }
	        this._nbSamples = Math.floor( value );
	        this.dirty();
	    },
	    setRadius: function ( value ) {
	        var uniform = this._stateSet.getUniform( 'Radius' );
	        uniform.setFloat( value );
	    },
	    setPower: function ( value ) {
	        var uniform = this._stateSet.getUniform( 'Power' );
	        uniform.setFloat( value );
	    },
	    build: function () {
	        var stateSet = this._stateSet;
	        var nbSamples = this._nbSamples;
	        var kernel = new Array( nbSamples * 4 );
	        ( function ( array ) {
	            var v = Vec3.create();
	            for ( var i = 0; i < nbSamples; i++ ) {
	                v[ 0 ] = 2.0 * ( Math.random() - 0.5 );
	                v[ 1 ] = 2.0 * ( Math.random() - 0.5 );
	                v[ 2 ] = Math.random();
	
	                Vec3.normalize( v, v );
	                var scale = Math.max( i / nbSamples, 0.1 );
	                scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );
	                array[ i * 3 + 0 ] = v[ 0 ];
	                array[ i * 3 + 1 ] = v[ 1 ];
	                array[ i * 3 + 2 ] = v[ 2 ];
	                array[ i * 3 + 3 ] = scale;
	            }
	        } )( kernel );
	
	
	        stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );
	        var uniform = stateSet.getUniform( 'noiseSampling' );
	        if ( uniform === undefined ) {
	            uniform = Uniform.createFloat2( Vec2.createAndSet( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ), 'noiseSampling' );
	            stateSet.addUniform( uniform );
	        } else {
	            uniform.setVec2( Vec2.createAndSet( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ) );
	        }
	        var vertexShader = [
	            '',
	            'attribute vec3 Vertex;',
	            'attribute vec2 TexCoord0;',
	            'varying vec2 FragTexCoord0;',
	            'uniform mat4 ModelViewMatrix;',
	            'uniform mat4 ProjectionMatrix;',
	            'void main(void) {',
	            '  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);',
	            '  FragTexCoord0 = TexCoord0;',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var kernelglsl = [];
	        for ( var i = 0; i < nbSamples; i++ ) {
	            kernelglsl.push( 'kernel[' + i + '] = vec4(' + kernel[ i * 3 ] + ',' + kernel[ i * 3 + 1 ] + ', ' + kernel[ i * 3 + 2 ] + ', ' + kernel[ i * 3 + 3 ] + ');' );
	        }
	        kernelglsl = kernelglsl.join( '\n' );
	
	        //var ssaoRadiusMin = this._sceneRadius * 0.002;
	        //var ssaoRadiusMax = this._sceneRadius * 0.05;
	        //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;
	
	        var fragmentShader = [
	            '',
	            Composer.Filter.defaultFragmentShaderHeader,
	            'uniform sampler2D Texture1;',
	            'uniform sampler2D Texture2;',
	            'uniform mat4 projection;',
	            'uniform vec2 noiseSampling;',
	            'uniform float Power;', //'+ '{ 'min': 0.1, 'max': 16.0, 'step': 0.1, 'value': 1.0 }',
	            'uniform float Radius;', //'+ '{ 'min': ' + ssaoRadiusMin +', 'max': ' + ssaoRadiusMax + ', 'step': '+ ssaoRadiusStep + ', 'value': 0.01 }',
	            'uniform float AngleLimit;',
	            '#define NB_SAMPLES ' + this._nbSamples,
	            'float depth;',
	            'vec3 normal;',
	            'vec4 position;',
	            'vec4 kernel[' + nbSamples + '];',
	
	
	            'mat3 computeBasis()',
	            '{',
	            '  vec2 uvrand = FragTexCoord0*noiseSampling;',
	            '  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);',
	            '  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));',
	            '  vec3 bitangent = cross(normal, tangent);',
	            '  mat3 tbn = mat3(tangent, bitangent, normal);',
	            '  return tbn;',
	            '}',
	
	            'void main (void)',
	            '{',
	            kernelglsl,
	            '  position = texture2D(Texture1, FragTexCoord0);',
	            '  vec4 p = texture2D(Texture0, FragTexCoord0);',
	            '  depth = p.w;',
	            '  normal = vec3(p);',
	            '  if ( position.w == 0.0) {',
	            '     gl_FragColor = vec4(1.0,1.0,1.0,0.0);',
	            '     return;',
	            '  }',
	            '',
	            ' mat3 tbn = computeBasis();',
	            ' float occlusion = 0.0;',
	            ' for (int i = 0; i < NB_SAMPLES; i++) {',
	            '    vec3 vecKernel = vec3(kernel[i]);',
	            '    vecKernel[2] = max(AngleLimit,vecKernel[2]);',
	            '    vec3 sample = tbn * vecKernel;',
	            '    vec3 dir = sample;',
	            '    float w = dot(dir, normal);',
	            '    float dist = 1.0-kernel[i].w;',
	            '    w *= dist*dist*Power;',
	            '    sample = dir * float(Radius) + position.xyz;',
	
	            '    vec4 offset = projection * vec4(sample,1.0);',
	            '    offset.xy /= offset.w;',
	            '    offset.xy = offset.xy * 0.5 + 0.5;',
	
	            '    float sample_depth = texture2D(Texture1, offset.xy).z;',
	            '    float range_check = abs(sample.z - sample_depth) < float(Radius) ? 1.0 : 0.0;',
	            '    occlusion += (sample_depth > sample.z ? 1.0 : 0.0) * range_check*w;',
	
	            ' }',
	            ' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));',
	            ' gl_FragColor = vec4(vec3(occlusion),1.0);',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vertexShader + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fragmentShader + this.getDefineFragmentName() ) );
	
	        stateSet.setAttributeAndModes( program );
	        this._dirty = false;
	    }
	} );
	
	Composer.Filter.SSAO8 = function ( options ) {
	    Composer.Filter.SSAO.call( this, options );
	    this._fragmentName = 'SSAO8';
	};
	
	Composer.Filter.SSAO8.prototype = MACROUTILS.objectInherit( Composer.Filter.SSAO.prototype, {
	    buildGeometry: function ( quad ) {
	        quad.getAttributes().TexCoord1 = this._texCoord1;
	        return quad;
	    },
	    build: function () {
	        var stateSet = this._stateSet;
	        var nbSamples = this._nbSamples;
	        var kernel = new Array( nbSamples * 4 );
	        //var angleLimit = this._angleLimit;
	        ( function ( array ) {
	            var v = Vec3.create();
	            for ( var i = 0; i < nbSamples; i++ ) {
	                v[ 0 ] = 2.0 * ( Math.random() - 0.5 );
	                v[ 1 ] = 2.0 * ( Math.random() - 0.5 );
	                v[ 2 ] = Math.random();
	
	                Vec3.normalize( v, v );
	                var scale = Math.max( i / nbSamples, 0.1 );
	                scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );
	                array[ i * 3 + 0 ] = v[ 0 ];
	                array[ i * 3 + 1 ] = v[ 1 ];
	                array[ i * 3 + 2 ] = v[ 2 ];
	                array[ i * 3 + 3 ] = scale;
	            }
	        } )( kernel );
	
	        //var sizeNoise = this._noiseTextureSize;
	        stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );
	        var uniform = stateSet.getUniform( 'noiseSampling' );
	        if ( uniform === undefined ) {
	            uniform = Uniform.createFloat2( Vec2.createAndSet( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ), 'noiseSampling' );
	            stateSet.addUniform( uniform );
	        } else {
	            uniform.setVec2( Vec2.createAndSet( this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ) );
	        }
	        var vertexShader = [
	            '',
	            'attribute vec3 Vertex;',
	            'attribute vec2 TexCoord0;',
	            'attribute vec3 TexCoord1;',
	            'varying vec2 FragTexCoord0;',
	            'varying vec3 FragTexCoord1;',
	            'uniform mat4 ModelViewMatrix;',
	            'uniform mat4 ProjectionMatrix;',
	            'void main(void) {',
	            '  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);',
	            '  FragTexCoord0 = TexCoord0;',
	            '  FragTexCoord1 = TexCoord1;',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var kernelglsl = [];
	        for ( var i = 0; i < nbSamples; i++ ) {
	            kernelglsl.push( 'kernel[' + i + '] = vec4(' + kernel[ i * 3 ] + ',' + kernel[ i * 3 + 1 ] + ', ' + kernel[ i * 3 + 2 ] + ', ' + kernel[ i * 3 + 3 ] + ');' );
	        }
	        kernelglsl = kernelglsl.join( '\n' );
	
	        //var ssaoRadiusMin = this._sceneRadius * 0.002;
	        //var ssaoRadiusMax = this._sceneRadius * 0.05;
	        //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;
	
	        var fragmentShader = [
	            '',
	            Composer.Filter.defaultFragmentShaderHeader,
	            'varying vec3 FragTexCoord1;',
	            'uniform sampler2D Texture1;',
	            'uniform sampler2D Texture2;',
	            'uniform mat4 projection;',
	            'uniform vec2 noiseSampling;',
	            'uniform float Power;', //'+ '{ 'min': 0.1, 'max': 16.0, 'step': 0.1, 'value': 1.0 }',
	            'uniform float Radius;', //'+ '{ 'min': ' + ssaoRadiusMin +', 'max': ' + ssaoRadiusMax + ', 'step': '+ ssaoRadiusStep + ', 'value': 0.01 }',
	            'uniform float AngleLimit;',
	            '#define NB_SAMPLES ' + this._nbSamples,
	            'float depth;',
	            'float znear, zfar, zrange;',
	            'vec3 normal;',
	            'vec3 position;',
	            'vec4 kernel[' + nbSamples + '];',
	
	            Composer.Filter.shaderUtils,
	
	            'mat3 computeBasis()',
	            '{',
	            '  vec2 uvrand = FragTexCoord0*noiseSampling;',
	            '  //uvrand = rand(gl_FragCoord.xy);',
	            '  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);',
	            '  //vec3 rvec = normalize(vec3(uvrand,0.0));',
	            '  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));',
	            '  vec3 bitangent = cross(normal, tangent);',
	            '  mat3 tbn = mat3(tangent, bitangent, normal);',
	            '  return tbn;',
	            '}',
	
	            'float getDepthValue(vec4 v) {',
	            '  float depth = unpack4x8ToFloat(v);',
	            '  depth = depth*zrange+znear;',
	            '  //depth = depth*zrange;',
	            '  return -depth;',
	            '}',
	
	            'void main (void)',
	            '{',
	            kernelglsl,
	            '  vec4 p = texture2D(Texture0, FragTexCoord0);',
	            '  if (dot(p,p) < 0.001) { ',
	            '     gl_FragColor = vec4(1.0,1.0,1.0,0.0);',
	            '     return;',
	            '  }',
	            '  znear = projection[3][2] / (projection[2][2]-1.0);',
	            '  zfar = projection[3][2] / (projection[2][2]+1.0);',
	            '  zrange = zfar-znear;',
	            '  depth = getDepthValue(texture2D(Texture1, FragTexCoord0));',
	            //B = (A - znear)/(zfar-znear);',
	            //B = A/(zfar-znear) - znear/(zfar-znear);',
	            //B+ znear/(zfar-znear) = A/(zfar-znear) ;',
	            //(zfar-znear)*(B+ znear/(zfar-znear)) = A ;',
	            //(zfar-znear)*B+ znear = A ;',
	
	            '  if ( -depth < znear) {',
	            '     gl_FragColor = vec4(1.0,1.0,1.0,0.0);',
	            '     return;',
	            '  }',
	
	            '  normal = decodeNormal(unpack4x8To2Float(p));',
	
	            '  position = -FragTexCoord1*depth;',
	            '  position.z = -position.z;',
	
	            '',
	            ' mat3 tbn = computeBasis();',
	            ' float occlusion = 0.0;',
	            ' for (int i = 0; i < NB_SAMPLES; i++) {',
	            '    vec3 vecKernel = vec3(kernel[i]);',
	            '    vecKernel[2] = max(AngleLimit,vecKernel[2]);',
	            '    vec3 sample = tbn * vec3(vecKernel);',
	            '    vec3 dir = sample;',
	            '    float w = dot(dir, normal);',
	            '    float dist = 1.0-kernel[i].w;',
	            '    w *= dist*dist*Power;',
	            '    sample = dir * float(Radius) + position.xyz;',
	
	            '    vec4 offset = projection * vec4(sample,1.0);',
	            '    offset.xy /= offset.w;',
	            '    offset.xy = offset.xy * 0.5 + 0.5;',
	
	            '    float sample_depth = getDepthValue(texture2D(Texture1, offset.xy));',
	            '    float range_check = abs(sample.z - sample_depth) < float(Radius) ? 1.0 : 0.0;',
	            '    occlusion += (sample_depth > sample.z ? 1.0 : 0.0) * range_check*w;',
	
	            ' }',
	            ' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));',
	            ' gl_FragColor = vec4(vec3(occlusion),1.0);',
	            '}',
	            ''
	        ].join( '\n' );
	
	        var program = new Program(
	            new Shader( Shader.VERTEX_SHADER, vertexShader + this.getDefineVertexName() ),
	            new Shader( Shader.FRAGMENT_SHADER, fragmentShader + this.getDefineFragmentName() ) );
	
	        stateSet.setAttributeAndModes( program );
	        this._dirty = false;
	    }
	} );
	
	module.exports = Composer;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var Geometry = __webpack_require__( 31 );
	var BufferArray = __webpack_require__( 40 );
	var DrawArrays = __webpack_require__( 42 );
	var PrimitiveSet = __webpack_require__( 41 );
	var StateSet = __webpack_require__( 19 );
	var Uniform = __webpack_require__( 35 );
	var Depth = __webpack_require__( 86 );
	var Vec3 = __webpack_require__( 15 );
	var ShaderGenerator = __webpack_require__( 157 );
	var Compiler = __webpack_require__( 158 );
	var RigGeometry = __webpack_require__( 78 );
	var MorphGeometry = __webpack_require__( 79 );
	var UpdateMorph = __webpack_require__( 117 );
	
	
	////////////////////////
	// COMPILER OFFSET NORMAL
	////////////////////////
	var CompilerOffsetNormal = function () {
	    Compiler.apply( this, arguments );
	    this._isVertexColored = false;
	};
	
	CompilerOffsetNormal.prototype = MACROUTILS.objectInherit( Compiler.prototype, {
	    getFragmentShaderName: function () {
	        return 'CompilerOffsetNormal';
	    },
	    initTextureAttributes: function () {},
	    createFragmentShaderGraph: function () {
	        var frag = this.getNode( 'glFragColor' );
	
	        this.getNode( 'SetAlpha' ).inputs( {
	            color: this.getOrCreateUniform( 'vec3', 'uColorDebug' ),
	            alpha: this.createVariable( 'float' ).setValue( '1.0' )
	        } ).outputs( {
	            color: frag
	        } );
	
	        return [ frag ];
	    },
	    _getDirectionVec: function () {
	        return this.getOrCreateNormalAttribute();
	    },
	    getOrCreateVertexAttribute: function () {
	        var vertexOffset = this.getVariable( 'vertexOffset' );
	        if ( vertexOffset ) return vertexOffset;
	
	        vertexOffset = this.createVariable( 'vec3', 'vertexOffset' );
	
	        // normalize len (divide scale of worldmat, don't work for non uniform scale, but work enough for debug)
	        var str = '%out = %offset == 1.0 ? %vertex + normalize(%direction.xyz) * %scale / length(%world[0].xyz) : %vertex;';
	        this.getNode( 'InlineCode' ).code( str ).inputs( {
	            offset: this.getOrCreateAttribute( 'float', 'Offset' ),
	            direction: this._getDirectionVec(),
	            vertex: Compiler.prototype.getOrCreateVertexAttribute.call( this ),
	            scale: this.getOrCreateUniform( 'float', 'uScale' ),
	            world: this.getOrCreateUniform( 'mat4', 'ModelWorldMatrix' )
	        } ).outputs( {
	            out: vertexOffset
	        } );
	
	        return vertexOffset;
	    },
	    declareVertexTransforms: Compiler.prototype.declareVertexTransformShadeless
	} );
	
	var ShaderGeneratorCompilerOffsetNormal = function () {
	    ShaderGenerator.apply( this, arguments );
	    this.setShaderCompiler( CompilerOffsetNormal );
	};
	ShaderGeneratorCompilerOffsetNormal.prototype = ShaderGenerator.prototype;
	
	////////////////////////
	// COMPILER OFFSET TANGENT
	////////////////////////
	var CompilerOffsetTangent = function () {
	    CompilerOffsetNormal.apply( this, arguments );
	};
	
	CompilerOffsetTangent.prototype = MACROUTILS.objectInherit( CompilerOffsetNormal.prototype, {
	    getFragmentShaderName: function () {
	        return 'CompilerOffsetTangent';
	    },
	    _getDirectionVec: function () {
	        return this.getOrCreateTangentAttribute();
	    }
	} );
	
	var ShaderGeneratorCompilerOffsetTangent = function () {
	    ShaderGenerator.apply( this, arguments );
	    this.setShaderCompiler( CompilerOffsetTangent );
	};
	ShaderGeneratorCompilerOffsetTangent.prototype = ShaderGenerator.prototype;
	
	////////////////////////
	// DISPLAY NORMAL VISITOR
	////////////////////////
	
	var DisplayNormalVisitor = function () {
	    NodeVisitor.call( this );
	
	    this._unifScale = Uniform.createFloat( 1.0, 'uScale' );
	
	    var ns = this._normalStateSet = new StateSet();
	    ns.addUniform( Uniform.createFloat3( Vec3.createAndSet( 1.0, 0.0, 0.0 ), 'uColorDebug' ) );
	    ns.addUniform( this._unifScale );
	    ns.setAttributeAndModes( new Depth( Depth.NEVER ) );
	    ns.setShaderGeneratorName( 'debugNormal' );
	
	    var ts = this._tangentStateSet = new StateSet();
	    ts.addUniform( Uniform.createFloat3( Vec3.createAndSet( 0.0, 1.0, 0.0 ), 'uColorDebug' ) );
	    ts.addUniform( this._unifScale );
	    ts.setAttributeAndModes( new Depth( Depth.NEVER ) );
	    ts.setShaderGeneratorName( 'debugTangent' );
	};
	
	DisplayNormalVisitor.CompilerOffsetNormal = CompilerOffsetNormal;
	DisplayNormalVisitor.CompilerOffsetTangent = CompilerOffsetTangent;
	DisplayNormalVisitor.ShaderGeneratorCompilerOffsetNormal = ShaderGeneratorCompilerOffsetNormal;
	DisplayNormalVisitor.ShaderGeneratorCompilerOffsetTangent = ShaderGeneratorCompilerOffsetTangent;
	
	DisplayNormalVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    setScale: function ( scale ) {
	        this._unifScale.setFloat( scale );
	    },
	    setTangentVisibility: function ( bool ) {
	        this._tangentStateSet.setAttributeAndModes( new Depth( bool ? Depth.LESS : Depth.NEVER ) );
	    },
	    setNormalVisibility: function ( bool ) {
	        this._normalStateSet.setAttributeAndModes( new Depth( bool ? Depth.LESS : Depth.NEVER ) );
	    },
	    apply: function ( node ) {
	        var list = node.getUpdateCallbackList();
	        // dirty the UpdateMorph so that they detect the normal/tangent geometry and update the target/weights correctly
	        for ( var i = 0, nbCB = list.length; i < nbCB; ++i ) {
	            if ( list[ i ] instanceof UpdateMorph ) {
	                list[ i ]._isInitialized = false;
	            }
	        }
	
	        if ( node._isVisitedNormalDebug )
	            return;
	
	        node._isVisitedNormalDebug = true;
	
	        if ( node instanceof Geometry === false )
	            return this.traverse( node );
	
	        this._createDebugGeom( node, 'Normal', this._normalStateSet );
	        this._createDebugGeom( node, 'Tangent', this._tangentStateSet );
	    },
	    _createDoubleOffsetArray: function ( nbVertices ) {
	        // 0 means original vertex pos
	        // 1 means offseted vertex
	        var elts = new Float32Array( nbVertices * 2 );
	        for ( var i = 0; i < nbVertices; ++i ) {
	            elts[ i * 2 ] = 1.0;
	        }
	        return new BufferArray( BufferArray.ARRAY_BUFFER, elts, 1 );
	    },
	    _createDoubledBufferArray: function ( bufferArray ) {
	        // in case of morphs
	        if ( bufferArray.getInitialBufferArray )
	            bufferArray = bufferArray.getInitialBufferArray();
	
	        var itemSize = bufferArray.getItemSize();
	        var elements = bufferArray.getElements();
	        var nbElements = elements.length / itemSize;
	
	        var ctor = elements.constructor;
	        var elementsDouble = new ctor( elements.length * 2 );
	        for ( var i = 0; i < nbElements; ++i ) {
	            var iSize = i * itemSize;
	            var iSize2 = iSize * 2;
	
	            for ( var j = 0; j < itemSize; ++j ) {
	                elementsDouble[ iSize2 + j ] = elementsDouble[ iSize2 + j + itemSize ] = elements[ iSize + j ];
	            }
	        }
	
	        return new BufferArray( BufferArray.ARRAY_BUFFER, elementsDouble, itemSize );
	    },
	    _addMorphTargets: function ( originMorph, morph, vecName ) {
	        var targets = morph.getMorphTargets();
	        morph.setName( originMorph.getName() ); // for the UpdateMorph
	
	        var originTargets = originMorph.getMorphTargets();
	        for ( var i = 0, nbTarget = originTargets.length; i < nbTarget; ++i ) {
	            var origTarget = originTargets[ i ];
	            var origAttrs = origTarget.getVertexAttributeList();
	
	            var newTarget = new Geometry();
	            newTarget.setName( origTarget.getName() ); // for the UpdateMorph
	            var newAttrs = newTarget.getVertexAttributeList();
	
	            newAttrs.Vertex = this._createDoubledBufferArray( origAttrs.Vertex );
	            if ( origAttrs[ vecName ] ) newAttrs[ vecName ] = this._createDoubledBufferArray( origAttrs[ vecName ] );
	
	            targets.push( newTarget );
	        }
	
	        morph.mergeChildrenVertexAttributeList();
	        return morph;
	    },
	    _createDebugGeom: function ( node, vecName, stateSet ) {
	        var attrs = node.getAttributes();
	        var dispVec = attrs[ vecName ];
	        if ( !dispVec )
	            return;
	
	        var vertices = attrs.Vertex;
	        if ( !vertices )
	            return;
	
	        var originMorph;
	        if ( node instanceof MorphGeometry ) originMorph = node;
	        else if ( node.getSourceGeometry && node.getSourceGeometry() instanceof MorphGeometry ) originMorph = node.getSourceGeometry();
	
	        var nbVertices = vertices.getElements().length / vertices.getItemSize();
	
	        // vertex and normals
	        var source = originMorph ? new MorphGeometry() : new Geometry();
	        source.getAttributes().Vertex = this._createDoubledBufferArray( vertices );
	        source.getAttributes().Offset = this._createDoubleOffsetArray( nbVertices );
	        source.getAttributes()[ vecName ] = this._createDoubledBufferArray( dispVec );
	
	        // primitive
	        source.getPrimitives().push( new DrawArrays( PrimitiveSet.LINES, 0, nbVertices * 2 ) );
	
	        if ( originMorph )
	            this._addMorphTargets( originMorph, source, vecName );
	
	        var geom;
	        if ( node instanceof RigGeometry ) {
	
	            var rig = new RigGeometry();
	            rig.setSourceGeometry( source );
	
	            rig.getVertexAttributeList().Bones = this._createDoubledBufferArray( attrs.Bones );
	            rig.getVertexAttributeList().Weights = this._createDoubledBufferArray( attrs.Weights );
	
	            // we can simply share the rig-animated stateSet attributes
	            // (unlike morph, the stateSet and update animation doesn't operate at per vertex level)
	            rig._rigTransformImplementation = node._rigTransformImplementation;
	            rig._stateSetAnimation = node._stateSetAnimation;
	
	            rig.mergeChildrenData();
	            geom = rig;
	
	        } else {
	            geom = source;
	        }
	
	
	        // add geom to the graph
	        var parents = node.getParents();
	        var nbParents = parents.length;
	        geom._isVisitedNormalDebug = true;
	        geom._isNormalDebug = true;
	        geom.setStateSet( stateSet );
	        for ( var i = 0; i < nbParents; ++i )
	            parents[ i ].addChild( geom );
	
	        return geom;
	    }
	} );
	
	
	module.exports = DisplayNormalVisitor;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Program = __webpack_require__( 100 );
	var Shader = __webpack_require__( 101 );
	var Map = __webpack_require__( 20 );
	var Compiler = __webpack_require__( 158 );
	var ShaderProcessor = __webpack_require__( 167 );
	
	// this is the list of attributes type we support by default to generate shader
	// if you need to adjust for your need provide or modify this list
	// if you still need more fine tuning to the filter, override the filterAttributeTypes
	var DefaultsAcceptAttributeTypes = [
	    'ShadowReceive',
	    'Skinning',
	    'Morph',
	    'ShadowTexture',
	    'Texture',
	    'Light',
	    'Material',
	    'Billboard'
	];
	
	var ShaderGenerator = function () {
	    this._cache = new window.Map();
	
	    // ShaderProcessor singleton used by ShaderGenerator
	    // but user can replace it if needed
	    this._shaderProcessor = new ShaderProcessor();
	    this._acceptAttributeTypes = new window.Set( DefaultsAcceptAttributeTypes );
	
	    // ShaderCompiler Object to instanciate
	    this._ShaderCompiler = Compiler;
	};
	
	ShaderGenerator.prototype = {
	
	    // setShaderCompiler that will be used to createShader
	    setShaderCompiler: function ( compiler ) {
	        this._ShaderCompiler = compiler;
	    },
	
	    getShaderCompiler: function () {
	        return this._ShaderCompiler;
	    },
	
	
	    // return a Set of accepted attribtues to generate shader
	    getAcceptAttributeTypes: function () {
	        return this._acceptAttributeTypes;
	    },
	
	
	    getShaderProcessor: function () {
	        return this._shaderProcessor;
	    },
	
	    setShaderProcessor: function ( shaderProcessor ) {
	        this._shaderProcessor = shaderProcessor;
	    },
	
	    // filter input types and write the result in the outputs array
	    filterAttributeTypes: function ( attribute ) {
	
	        // TODO: use same mechanism as acceptAttributesTypes ?
	        // with a default set in a var and use overwrittable Set
	        // when inheriting the class
	        // Faster && Flexiblier
	        if ( attribute.libraryName() !== 'osg' && attribute.libraryName() !== 'osgShadow' && attribute.libraryName() !== 'osgAnimation' )
	            return true;
	
	        var attributeType = attribute.getType();
	
	        // accept only attribute listed in the container
	        if ( !this._acceptAttributeTypes.has( attributeType ) )
	            return true;
	
	        // works for attribute that contains isEnabled
	        // Light, Shadow. It let us to filter them to build a shader if not enabled
	        if ( attribute.isEnabled && !attribute.isEnabled() )
	            return true;
	        // // if it's a light and it's not enable we filter it
	        // if ( attribute.typeID === Light.typeID && !attribute.isEnabled() ) {
	        //     return true;
	        // }
	
	        return false;
	    },
	
	    // get actives attribute that comes from state
	    getActiveAttributeList: function ( state, list ) {
	
	        var hash = '';
	        var attributeMap = state.attributeMap;
	        var attributeMapKeys = attributeMap.getKeys();
	
	        for ( var j = 0, k = attributeMapKeys.length; j < k; j++ ) {
	
	            var keya = attributeMapKeys[ j ];
	            var attributeStack = attributeMap[ keya ];
	            var attr = attributeStack.lastApplied;
	
	            if ( this.filterAttributeTypes( attr ) )
	                continue;
	
	            if ( attr.getHash ) {
	                hash += attr.getHash();
	            } else {
	                hash += attr.getType();
	            }
	            list.push( attr );
	        }
	        return hash;
	    },
	
	    // get actives texture attribute that comes from state
	    getActiveTextureAttributeList: function ( state, list ) {
	        var hash = '';
	        var attributeMapList = state.textureAttributeMapList;
	        var i, l;
	
	        for ( i = 0, l = attributeMapList.length; i < l; i++ ) {
	            var attributeMapForUnit = attributeMapList[ i ];
	            if ( !attributeMapForUnit ) {
	                continue;
	            }
	            list[ i ] = [];
	
	            var attributeMapForUnitKeys = attributeMapForUnit.getKeys();
	
	            for ( var j = 0, m = attributeMapForUnitKeys.length; j < m; j++ ) {
	
	                var key = attributeMapForUnitKeys[ j ];
	                var attributeStack = attributeMapForUnit[ key ];
	                if ( attributeStack.values().length === 0 ) {
	                    continue;
	                }
	
	                var attr = attributeStack.lastApplied;
	                if ( this.filterAttributeTypes( attr ) )
	                    continue;
	
	                if ( attr.isTextureNull() )
	                    continue;
	
	                if ( attr.getHash ) {
	                    hash += attr.getHash();
	                } else {
	                    hash += attr.getType();
	                }
	                list[ i ].push( attr );
	            }
	        }
	        return hash;
	    },
	
	    getActiveUniforms: function ( state, attributeList, textureAttributeList ) {
	
	        var uniforms = {};
	
	        for ( var i = 0, l = attributeList.length; i < l; i++ ) {
	
	            var at = attributeList[ i ];
	            if ( at.getOrCreateUniforms ) {
	                var attributeUniformMap = at.getOrCreateUniforms();
	                // It could happen that uniforms are declared conditionally
	                if ( attributeUniformMap !== undefined ) {
	                    var attributeUniformMapKeys = attributeUniformMap.getKeys();
	
	                    for ( var j = 0, m = attributeUniformMapKeys.length; j < m; j++ ) {
	                        var name = attributeUniformMapKeys[ j ];
	                        var uniform = attributeUniformMap[ name ];
	                        uniforms[ uniform.getName() ] = uniform;
	                    }
	                }
	            }
	        }
	
	        for ( var a = 0, n = textureAttributeList.length; a < n; a++ ) {
	            var tat = textureAttributeList[ a ];
	            if ( tat ) {
	                for ( var b = 0, o = tat.length; b < o; b++ ) {
	                    var attr = tat[ b ];
	
	                    var texUniformMap = attr.getOrCreateUniforms( a );
	                    var texUniformMapKeys = texUniformMap.getKeys();
	
	                    for ( var t = 0, tl = texUniformMapKeys.length; t < tl; t++ ) {
	                        var tname = texUniformMapKeys[ t ];
	                        var tuniform = texUniformMap[ tname ];
	                        uniforms[ tuniform.getName() ] = tuniform;
	                    }
	                }
	            }
	        }
	
	        return new Map( uniforms );
	    },
	
	    getOrCreateProgram: ( function () {
	        // TODO: double check GC impact of this stack
	        // TODO: find a way to get a hash dirty/cache on stateAttribute
	        var textureAttributes = [];
	        var attributes = [];
	
	        return function ( state ) {
	            // extract valid attributes
	            var hash = '';
	            attributes.length = 0;
	            textureAttributes.length = 0;
	            hash += this.getActiveAttributeList( state, attributes );
	            hash += this.getActiveTextureAttributeList( state, textureAttributes );
	
	            var cache = this._cache.get( hash );
	            if ( cache !== undefined ) {
	                return cache;
	            }
	
	
	            // use ShaderCompiler, it can be overrided by a custom one
	            var ShaderCompiler = this._ShaderCompiler;
	            var shaderGen = new ShaderCompiler( attributes, textureAttributes, this._shaderProcessor );
	
	
	            var vertexshader = shaderGen.createVertexShader();
	            var fragmentshader = shaderGen.createFragmentShader();
	
	            var program = new Program(
	                new Shader( Shader.VERTEX_SHADER, vertexshader ),
	                new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );
	
	            program.hash = hash;
	            program.setActiveUniforms( this.getActiveUniforms( state, attributes, textureAttributes ) );
	            program.generated = true;
	
	            this._cache.set( hash, program );
	            return program;
	        };
	    } )()
	};
	
	module.exports = ShaderGenerator;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Light = __webpack_require__( 97 );
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Uniform = __webpack_require__( 35 );
	var factory = __webpack_require__( 159 );
	
	var Compiler = function ( attributes, textureAttributes, shaderProcessor ) {
	    this._attributes = attributes;
	    this._textureAttributes = textureAttributes;
	
	    this._activeNodeList = {};
	    this._compiledNodeList = {};
	    this._traversedNodeList = {};
	
	    this._variables = {};
	    this._varyings = {};
	    this._vertexShader = [];
	    this._fragmentShader = [];
	
	    // global stuffs
	    this._shaderProcessor = shaderProcessor;
	    this._texturesByName = {};
	
	    // TODO: Have to handle better textures
	    // 4 separate loop over texture list: one here, one for declareTexture, 2 for vertexShader (varying decl + varying store)
	    // (not counting loops done above in shader generator)
	
	    this._shadowsTextures = [];
	    this._lights = [];
	    this._shadows = [];
	    this._textures = [];
	    this._material = null;
	
	
	    // LOW-LEVEL info
	    // shared between VS and FS pass
	    //
	    // List what we'll use
	    // allowing not to try
	    // to compute varying for nothing
	    // and interpolate varying for nothing
	    // default is nearly all disabled until proven otherwise
	    // but for texcoord.
	    // this._shaderAttributes = {
	    //     'Vertex': true,
	    //     'VertexColor': true,
	    //     'Normal': true
	    // };
	    this._shaderAttributes = {
	        'Vertex': true,
	        'VertexColor': false,
	        'Normal': false,
	        'Tangent': false
	    };
	
	    // High-Level Info, maybe specific
	    // to Material "light/ilb" Compilation
	    // shared between VS and FS pass
	    //
	    // This hints at current compiler is already too specialized
	    // and we should make a more abstract One the Parent class
	    // and this one one that inherits and add light, shadow, etc.
	    // (material?)
	    this._isLighted = false; // either shadeless, or no light (beware ibl)
	    this._isShadeless = false;
	    this._isBillboard = false;
	    // from Attributes to variables
	    // to build shader nodes graph from
	    this.initAttributes();
	    this.initTextureAttributes();
	
	    // no need to test light
	    var hasMaterial = !!this._material;
	    this._isLighted = hasMaterial && this._lights.length > 0;
	
	    // backup shader, FS just output 'fofd'
	    this._isVertexColored = hasMaterial;
	
	    // Important: if not using Compiler for Both VS and FS
	    // Check either of those
	    // it allow override by custom Processor of some check
	    // between the VS & FS pass (varying mostly)
	    this._customVertexShader = false;
	    this._customFragmentShader = false;
	};
	
	Compiler.prototype = {
	
	    initAttributes: function () {
	        var attributes = this._attributes;
	        // separate Material / Light / Texture
	        // because this shader generator is specific for this
	        var lights = this._lights;
	        var shadows = this._shadows;
	        for ( var i = 0, l = attributes.length; i < l; i++ ) {
	
	            var type = attributes[ i ].className();
	
	            // Test one light at a time
	            if ( type === 'Light' ) { // && lights.length === 0) {
	
	                lights.push( attributes[ i ] );
	
	
	            } else if ( type === 'Material' ) {
	                this._material = attributes[ i ];
	            } else if ( type === 'ShadowReceiveAttribute' ) {
	                shadows.push( attributes[ i ] );
	            } else if ( type === 'Billboard' ) {
	                this._isBillboard = !!attributes[ i ];
	            } else if ( type === 'SkinningAttribute' ) {
	                this._skinningAttribute = attributes[ i ];
	            } else if ( type === 'MorphAttribute' ) {
	                this._morphAttribute = attributes[ i ];
	            }
	        }
	    },
	
	    initTextureAttributes: function () {
	
	        var textureAttributes = this._textureAttributes;
	        var texturesNum = textureAttributes.length;
	        this._textures.length = this._shadowsTextures.length = texturesNum;
	
	        for ( var j = 0; j < texturesNum; j++ ) {
	            var tu = textureAttributes[ j ];
	            if ( tu === undefined )
	                continue;
	            for ( var t = 0, tl = tu.length; t < tl; t++ ) {
	                this.registerTextureAttributes( tu[ t ], j );
	            }
	        }
	    },
	
	    registerTextureAttributes: function ( tuTarget, tunit ) {
	        var tType = tuTarget.className();
	        if ( tType === 'Texture' ) return this.registerTexture( tuTarget, tunit );
	        if ( tType === 'ShadowTexture' ) return this.registerTextureShadow( tuTarget, tunit );
	    },
	
	    registerTexture: function ( tuTarget, texUnit ) {
	        var tName = tuTarget.getName();
	        if ( !tName ) {
	            tName = 'Texture' + texUnit;
	            tuTarget.setName( tName );
	        }
	        this._textures[ texUnit ] = tuTarget;
	
	        this._texturesByName[ tName ] = {
	            texture: tuTarget,
	            variable: undefined,
	            textureUnit: texUnit
	        };
	    },
	
	    registerTextureShadow: function ( tuTarget, texUnit ) {
	        var tName = tuTarget.getName();
	        if ( !tName ) {
	            tName = 'Texture' + texUnit;
	            tuTarget.setName( tName );
	        }
	        this._shadowsTextures[ texUnit ] = tuTarget;
	
	        this._texturesByName[ tName ] = {
	            texture: tuTarget,
	            variable: undefined,
	            textureUnit: texUnit,
	            shadow: true
	        };
	    },
	
	    // cache all requested node, so that we can list
	    // and log unused Node that where called
	    // or/cache unique or predefined node
	    // thus avoid mutiple getNode of a
	    // Node that HAS to be unique
	    getNode: function ( /*name, arg1, etc*/) {
	
	        // check unique Node
	        // for predefined GL variables
	        // gl_FragCoord, gl_Position, etc
	        // Extend to Varying
	        var n = factory.getNode.apply( factory, arguments );
	        var cacheID = n.getID();
	        this._activeNodeList[ cacheID ] = n;
	        return n;
	    },
	
	    // during compilation we pop
	    // all node we do encounter
	    // so that we can warn about
	    // "leftover" once compilation
	    // is finished
	    // Note: same node may be marked multiple time
	    // do not use it as a "once and for all mark thing"
	    markNodeAsVisited: function ( n ) {
	        var cacheID = n.getID();
	        if ( this._activeNodeList[ cacheID ] === n ) {
	            this._compiledNodeList[ cacheID ] = n;
	        } else {
	            Notify.warn( 'Node not requested by using Compiler getNode and/or not registered in nodeFactory ' + n.toString() );
	        }
	    },
	
	    // make sure we traverse once per evaluation of graph
	    checkOrMarkNodeAsTraversed: function ( n ) {
	        var cacheID = n.getID();
	        if ( this._traversedNodeList[ cacheID ] ) {
	            return true;
	        }
	        this._traversedNodeList[ cacheID ] = n;
	        return false;
	    },
	
	    getVariable: function ( nameID ) {
	        return this._variables[ nameID ];
	    },
	
	    getAttributeType: function ( type ) {
	
	        for ( var i = 0; i < this._attributes.length; i++ ) {
	            if ( this._attributes[ i ].getType() === type )
	                return this._attributes[ i ];
	        }
	        return undefined;
	
	    },
	
	
	    // TODO: add Precision qualifier
	    // if doesn't exist create a new on
	    // if nameID given and var already exist, create a varname +
	    createVariable: function ( type, varname, deepness ) {
	
	        var nameID = varname;
	
	        if ( nameID === undefined ) {
	
	            var len = window.Object.keys( this._variables ).length;
	            nameID = 'tmp_' + len;
	
	        } else if ( this._variables[ nameID ] ) {
	            // create a new variable
	            // if we want to reuse a variable we should NOT
	            // call this function in the first place and do the
	            // test before...
	            // however for uniform, varying and sampler, we return
	            // the variable if it already exists, because they are
	            // meant to be read only
	            nameID = nameID + deepness;
	            if ( deepness === undefined ) {
	                return this.createVariable( type, varname, 1 );
	            } else if ( this._variables[ nameID ] ) {
	                deepness++;
	                return this.createVariable( type, varname, deepness );
	            }
	
	        }
	
	        var v = this.getNode( 'Variable', type, nameID );
	        this._variables[ nameID ] = v;
	        return v;
	    },
	
	    // Map of uniform from a StateAttribute or TextureStateAttribute
	    getOrCreateUniformFromUniformMap: function ( uniforms, prefix ) {
	        var keys = window.Object.keys( uniforms );
	        var object = {};
	
	        var prefixUniform = prefix ? prefix : '';
	
	        for ( var i = 0; i < keys.length; i++ ) {
	            var k = prefixUniform + keys[ i ];
	            object[ k ] = this.getOrCreateUniform( uniforms[ keys[ i ] ] );
	        }
	
	        return object;
	    },
	
	    // specialized for texture, enforcing last parameter usage.
	    getOrCreateTextureStateAttributeUniforms: function ( stateAttribute, prefix, unit ) {
	
	        var uniforms = stateAttribute.getOrCreateUniforms( unit );
	        return this.getOrCreateUniformFromUniformMap( uniforms, prefix );
	    },
	
	    getOrCreateStateAttributeUniforms: function ( stateAttribute, prefix ) {
	
	        var uniforms = stateAttribute.getOrCreateUniforms();
	        return this.getOrCreateUniformFromUniformMap( uniforms, prefix );
	    },
	
	    getOrCreateUniform: function ( type, varname, size ) {
	
	        var nameID = varname;
	
	        // accept uniform as parameter to simplify code
	        if ( type instanceof Uniform ) {
	
	            var uniform = type;
	            type = uniform.getType();
	            nameID = uniform.getName();
	
	        } else if ( nameID === undefined ) {
	            Notify.error( 'Cannot create unamed Uniform' );
	        }
	
	
	        var exist = this._variables[ nameID ];
	        if ( exist ) {
	            // see comment in Variable function
	            if ( exist.getType() === type ) {
	                return exist;
	            }
	        }
	
	
	        var v = this.getNode( 'Uniform', type, nameID, size );
	        this._variables[ nameID ] = v;
	        return v;
	    },
	
	    // make sure we get correct Node
	    getOrCreateAttribute: function ( type, nameID ) {
	
	        if ( this._fragmentShaderMode ) {
	            Notify.error( 'No Vertex Attribute in Fragment Shader' );
	        }
	
	        var exist = this._variables[ nameID ];
	        if ( exist ) {
	
	
	            return exist;
	        }
	
	        // adds the reference for Fragment Shader
	        // aknowledging data binded
	        // and that varying data will be available accordingly
	        this._shaderAttributes[ nameID ] = true;
	
	        var v = this.getNode( 'Attribute', type, nameID );
	        this._variables[ nameID ] = v;
	        return v;
	    },
	
	    getOrCreateConstant: function ( type, varname ) {
	        var nameID = varname;
	        if ( nameID === undefined ) {
	            // TODO: temp constant ? or enforcing reuse ?
	            // maybe could parse variable to find other constant
	            // but would need having scope info
	            var len = window.Object.keys( this._variables ).length;
	            nameID = 'tmp_' + len;
	
	        } else {
	
	            var exist = this._variables[ nameID ];
	            if ( exist ) {
	
	
	                // see comment in Variable function
	                return exist;
	            }
	
	        }
	        var v = this.getNode( 'Constant', type, nameID );
	        this._variables[ nameID ] = v;
	        return v;
	    },
	
	    // make sure we get correct Node
	    getOrCreateVarying: function ( type, nameID ) {
	
	        // make sure you don't create varying out of thin air
	        if ( nameID === undefined ) {
	            Notify.error( 'Error: Mandatory to name varying (as you need to retrieve them)' );
	        }
	
	        var exist = this._variables[ nameID ];
	        if ( exist ) {
	
	
	            // see comment in Variable function
	            return exist;
	        } else {
	            exist = this._varyings[ nameID ];
	            if ( exist ) {
	
	                // varying was declared in Vertex Shader
	                // just add it to variables cache.
	                // as that cache is not shared between VS and PS
	                this._variables[ nameID ] = exist;
	
	                // ensure we have it in active node list, could come from VS varying list
	                if ( this._fragmentShaderMode && !this._customVertexShader && ( !this._activeNodeList[ exist.getID() ] || this._activeNodeList[ exist.getID() ] !== exist ) ) {
	
	                    Notify.error( 'Error: Varying in Fragment not declared in Vertex shader: ' + nameID + ' ' + type );
	                }
	                return exist;
	            }
	        }
	
	
	        var v = this.getNode( 'Varying', type, nameID );
	        this._variables[ nameID ] = v;
	        this._varyings[ nameID ] = v;
	
	        return v;
	    },
	
	    // make sure we get correct Node
	    getOrCreateSampler: function ( type, varname ) {
	
	        if ( varname === undefined ) {
	            Notify.error( 'No name given for sampler type : ' + type );
	        }
	
	        var exist = this._variables[ varname ];
	        if ( exist ) {
	            return exist; // see comment in Variable function
	        }
	
	        var v = this.getNode( 'Sampler', type, varname );
	        this._variables[ varname ] = v;
	
	        return v;
	    },
	
	    getOrCreateInputTangent: function () {
	        return this.getOrCreateVarying( 'vec4', 'FragTangent' );
	    },
	
	    getOrCreateFrontTangent: function () {
	        var frontTangent = this.createVariable( 'vec4', 'frontTangent' );
	
	        this.getNode( 'FrontNormal' ).inputs( {
	            normal: this.getOrCreateInputTangent()
	        } ).outputs( {
	            normal: frontTangent
	        } );
	
	        return frontTangent;
	    },
	
	    getOrCreateInputNormal: function () {
	        return this.getOrCreateVarying( 'vec3', 'FragNormal' );
	    },
	
	    getOrCreateFrontNormal: function () {
	        var inputNormal = this.getOrCreateInputNormal();
	        var frontNormal = this.createVariable( 'vec3', 'frontNormal' );
	
	        this.getNode( 'FrontNormal' ).inputs( {
	            normal: inputNormal
	        } ).outputs( {
	            normal: frontNormal
	        } );
	
	        return frontNormal;
	    },
	
	
	    // return a Vec4 so that we have the .w
	    // Allowing to know homogenous/ndc transfor
	    // (help linearizing depth casting for example)
	    getOrCreateInputPosition: function () {
	        return this.getOrCreateVarying( 'vec4', 'FragEyeVector' );
	    },
	
	
	    getOrCreateNormalizedNormal: function () {
	        var normal = this._variables[ 'normal' ];
	        if ( normal )
	            return normal;
	        var out = this.createVariable( 'vec3', 'normal' );
	        this.getNode( 'Normalize' ).inputs( {
	            vec: this.getOrCreateFrontNormal()
	        } ).outputs( {
	            vec: out
	        } );
	        return out;
	    },
	    getOrCreateNormalizedPosition: function () {
	        var eye = this._variables[ 'eyeVector' ];
	        if ( eye )
	            return eye;
	        var nor = this.createVariable( 'vec3' );
	        var castEye = this.createVariable( 'vec3' );
	        this.getNode( 'SetFromNode' ).inputs( this.getOrCreateInputPosition() ).outputs( castEye );
	        this.getNode( 'Normalize' ).inputs( {
	            vec: castEye
	        } ).outputs( {
	            vec: nor
	        } );
	        var out = this.createVariable( 'vec3', 'eyeVector' );
	        this.getNode( 'Mult' ).inputs( nor, this.createVariable( 'float' ).setValue( '-1.0' ) ).outputs( out );
	        return out;
	    },
	
	    getPremultAlpha: function ( finalColor, alpha ) {
	
	        if ( alpha === undefined )
	            return finalColor;
	
	        var premultAlpha = this.createVariable( 'vec4' );
	
	        this.getNode( 'PreMultAlpha' ).inputs( {
	            color: finalColor,
	            alpha: alpha
	        } ).outputs( {
	            color: premultAlpha
	        } );
	
	        return premultAlpha;
	    },
	
	
	    getColorsRGB: function ( finalColor ) {
	        var finalSrgbColor = this.createVariable( 'vec3' );
	        this.getNode( 'LinearTosRGB' ).inputs( {
	            color: finalColor
	        } ).outputs( {
	            color: finalSrgbColor
	        } );
	
	        return finalSrgbColor;
	    },
	
	
	    // Declare variable / varying to handle vertex color
	    // return a variable that contains the following operation
	    // newDiffuseColor = diffuseColor * vertexColor
	    // TODO: this code should move in the shader instead
	    getVertexColor: function ( diffuseColor ) {
	
	        if ( diffuseColor === undefined )
	            return undefined;
	
	        var vertexColor = this.getOrCreateVarying( 'vec4', 'VertexColor' );
	        var vertexColorUniform = this.getOrCreateUniform( 'float', 'ArrayColorEnabled' );
	        var tmp = this.createVariable( 'vec4' );
	
	        var str = [ '',
	            '%color.rgb = %diffuse.rgb;',
	            'if ( %hasVertexColor == 1.0)',
	            '  %color *= %vertexColor.rgba;'
	        ].join( '\n' );
	
	        this.getNode( 'InlineCode' ).code( str ).inputs( {
	            diffuse: diffuseColor,
	            hasVertexColor: vertexColorUniform,
	            vertexColor: vertexColor
	        } ).outputs( {
	            color: tmp
	        } ).comment( 'diffuse color = diffuse color * vertex color' );
	
	        return tmp;
	    },
	
	
	    getDiffuseColorFromTextures: function () {
	
	        var texturesInput = [];
	        var textures = this._texturesByName;
	
	        var keys = window.Object.keys( textures );
	        for ( var i = 0; i < keys.length; i++ ) {
	            var texture = textures[ keys[ i ] ];
	
	            if ( !texture )
	                continue;
	
	            if ( texture.shadow )
	                continue;
	
	            texturesInput.push( texture.variable );
	        }
	
	        // if multi texture multiply them all with diffuse
	        // but if only one, return the first
	        if ( texturesInput.length > 1 ) {
	
	            var texAccum = this.createVariable( 'vec3', 'texDiffuseAccum' );
	
	            this.getNode( 'Mult' ).inputs( texturesInput ).outputs( texAccum );
	            return texAccum;
	
	        } else if ( texturesInput.length === 1 ) {
	
	            return texturesInput[ 0 ];
	        }
	
	        return undefined;
	    },
	
	
	    // return the first texture valid in texture unit
	    getFirstValidTexture: function () {
	
	        var keys = window.Object.keys( this._texturesByName );
	        if ( !keys.length )
	            return undefined;
	
	        return this._texturesByName[ keys[ 0 ] ].variable;
	
	    },
	
	
	
	    // declare sampler2D or samplerCube
	    // declare varying FragTexCoordX corresponding to the texture unit
	    // create a textureNode that could be referenced later by the compiler
	    declareTexture: function ( unit, texture ) {
	
	        var samplerName = 'Texture' + unit.toString();
	        var textureSampler = this.getVariable( samplerName );
	        if ( !textureSampler ) {
	            if ( texture.className() === 'Texture' ) {
	                textureSampler = this.getOrCreateSampler( 'sampler2D', samplerName );
	            } else if ( texture.className() === 'TextureCubeMap' ) {
	                textureSampler = this.getOrCreateSampler( 'samplerCube', samplerName );
	            } else if ( texture.className() === 'ShadowTexture' ) {
	                // don't pre-declare texture for shadow
	                // as it's uniform node caching/get/compilation must not
	                // get the dual int/sampler2D thing.
	
	                //textureSampler = this.getOrCreateSampler( 'sampler2D', samplerName );
	                // return;
	
	                return;
	            }
	        }
	
	        // texture coordinates are automatically mapped to unit texture number
	        // it means that for Texture0 we will search for FragTexCoord0,
	        // Texture1 -> FragTexCoord1 ...
	        var texCoordUnit = unit;
	        var texCoord = this.getVariable( 'FragTexCoord' + texCoordUnit );
	        if ( texCoord === undefined ) {
	            texCoord = this.getOrCreateVarying( 'vec2', 'FragTexCoord' + texCoordUnit );
	        }
	
	        // instanciate and reference a texture node
	        var output = this.createTextureRGBA( texture, textureSampler, texCoord );
	
	        // this part would need to be checked/updated
	        // not sure texturesByName makes sense
	        var nameID = texture.getName();
	        if ( nameID === undefined ) {
	            nameID = 'Texture' + texCoordUnit;
	        }
	
	        // create/update texture entry (texture, textureUnit)
	        var textureMaterial = this._texturesByName[ nameID ];
	        if ( textureMaterial === undefined ) {
	
	            this._texturesByName[ nameID ] = {
	                variable: output,
	                textureUnit: unit
	            };
	
	        } else {
	
	            textureMaterial.variable = output;
	            textureMaterial.textureUnit = unit;
	
	        }
	
	    },
	
	    // check for all textures found in the State
	    // and reference sampler associated to texture and uv channels
	    declareTextures: function () {
	
	        var textures = this._textures;
	        var nbTextures = textures.length;
	
	        for ( var t = 0, tl = nbTextures; t < tl; t++ ) {
	
	            var texture = textures[ t ];
	            if ( !texture )
	                continue;
	
	            if ( texture.getType() === 'Texture' ) {
	
	                var texCoordUnit = this.getTexCoordUnit( t );
	                if ( texCoordUnit !== undefined )
	                    this.declareTexture( texCoordUnit, texture );
	            }
	
	        }
	    },
	    createShadowingLight: function ( light, inputs, lightedOutput ) {
	
	        var k;
	        var shadow;
	        var shadowTexture;
	        var hasShadows = false;
	        var shadowTextures = new Array( this._shadowsTextures.length );
	        var lightIndex = -1;
	
	        // seach current light its corresponding shadow and shadowTextures.
	        // if none, no shadow, hop we go.
	        // TODO: harder Link shadowTexture and shadowAttribute ?
	        // TODO: multi shadow textures for 1 light
	        var lightNum = light.getLightNumber();
	        for ( k = 0; k < this._shadows.length; k++ ) {
	            shadow = this._shadows[ k ];
	            if ( shadow.getLightNumber() !== lightNum ) continue;
	
	            lightIndex = k;
	            for ( var p = 0; p < this._shadowsTextures.length; p++ ) {
	                shadowTexture = this._shadowsTextures[ p ];
	                if ( shadowTexture && shadowTexture.getLightUnit() === lightNum ) {
	                    shadowTextures[ p ] = shadowTexture;
	                    hasShadows = true;
	                }
	            }
	        }
	        if ( !hasShadows ) return undefined;
	
	        // Varyings
	        var vertexWorld = this.getOrCreateVarying( 'vec3', 'WorldPosition' );
	
	        // asserted we have a shadow we do the shadow node allocation
	        // and mult with lighted output
	        var shadowedOutput = this.createVariable( 'float' );
	
	        // shadow Attribute uniforms
	        var shadowUniforms = this.getOrCreateStateAttributeUniforms( this._shadows[ lightIndex ], 'shadow' );
	        var shadowInputs = MACROUTILS.objectMix( inputs, shadowUniforms );
	
	        // shadowTexture  Attribute uniforms AND varying
	        // TODO: better handle multi texture shadow (CSM/PSM/etc.)
	        for ( k = 0; k < shadowTextures.length; k++ ) {
	            shadowTexture = shadowTextures[ k ];
	            if ( shadowTexture ) {
	                shadowInputs = this.createShadowTextureInputVarying( shadowTexture, shadowInputs, vertexWorld, k );
	            }
	
	        }
	        // TODO: shadow Attributes in node, is this the legit way
	        this.getNode( 'ShadowReceive' ).inputs( inputs ).outputs( {
	            float: shadowedOutput
	        } ).setShadowAttribute( shadow );
	
	        // allow overwrite by inheriting compiler
	        // where shadow inputs ( NDotL notably)
	        // can be used for non standard shadows
	        return this.connectShadowLightNode( light, lightedOutput, shadowedOutput, shadowInputs );
	
	    },
	
	    connectShadowLightNode: function ( light, lightedOutput, shadowedOutput ) {
	
	        var lightAndShadowTempOutput = this.createVariable( 'vec3', 'lightAndShadowTempOutput' );
	
	        this.getNode( 'Mult' ).inputs( lightedOutput, shadowedOutput ).outputs( lightAndShadowTempOutput );
	
	        return lightAndShadowTempOutput;
	
	    },
	
	    createShadowTextureInputVarying: function ( shadowTexture, inputs, vertexWorld, tUnit ) {
	        var shadowTexSamplerName = 'Texture' + tUnit;
	
	        // we declare first this uniform so that the Int one 
	        var tex = this.getOrCreateSampler( 'sampler2D', shadowTexSamplerName );
	
	        // per texture uniforms
	        var shadowTextureUniforms = this.getOrCreateTextureStateAttributeUniforms( shadowTexture, 'shadowTexture', tUnit );
	
	        // UGLY REMOVAL: special case of the sampler texture as method above create
	        // unforms for all shadow texture uniform,
	        // including texture unit Int 'Texture0' which becomes
	        // 'shadowTextureTexture0' which we won't use
	        // so we remove it from adding it here
	        var id = shadowTextureUniforms[ 'shadowTexture' + shadowTexSamplerName ].getID();
	        shadowTextureUniforms[ 'shadowTexture' + shadowTexSamplerName ] = undefined;
	        this._variables[ shadowTexSamplerName ] = tex; // the uniform Int overrided our sampler2D, so we add it back
	        delete this._activeNodeList[ id ];
	        // end UGLY REMOVAL
	
	        var inputsShadow = MACROUTILS.objectMix( inputs, shadowTextureUniforms );
	
	        inputsShadow.shadowTexture = tex;
	
	        var shadowVarying = {
	            vertexWorld: vertexWorld,
	            lightEyeDir: inputsShadow.lightEyeDir,
	            lightNDL: inputsShadow.lightNDL
	        };
	        inputsShadow = MACROUTILS.objectMix( inputsShadow, shadowVarying );
	        return inputsShadow;
	    },
	
	    // Shared var between all lights and shadows
	    // useful for compilers overriding default compiler
	    /*jshint -W098*/
	    createCommonLightingVars: function ( materials, enumLights ) {
	        return {};
	    },
	    /*jshint +W098*/
	
	    // Shared var between each light and its respective shadow
	    createLightAndShadowVars: function ( materials, enumLights, lightNum ) {
	
	        var type = this._lights[ lightNum ].getLightType();
	
	        var lighted = this.createVariable( 'bool', 'lighted' + lightNum );
	        var lightPos;
	        if ( type === Light.SPOT || type === Light.POINT ) {
	            lightPos = this.createVariable( 'vec3', 'lightEyePos' + lightNum );
	        }
	        var lightDir = this.createVariable( 'vec3', 'lightEyeDir' + lightNum );
	        var lightNDL = this.createVariable( 'float', 'lightNDL' + lightNum );
	
	
	        return {
	            lighted: lighted,
	            lightEyePos: lightPos,
	            lightEyeDir: lightDir,
	            lightNDL: lightNDL
	        };
	
	    },
	
	    createLighting: function ( materials, overrideNodeName ) {
	
	        var output = this.createVariable( 'vec3' );
	        var lightOutputVarList = [];
	
	        var enumToNodeName = overrideNodeName || {
	            DIRECTION: 'SunLight',
	            SPOT: 'SpotLight',
	            POINT: 'PointLight',
	            HEMI: 'HemiLight'
	        };
	
	
	        var materialUniforms = this.getOrCreateStateAttributeUniforms( this._material, 'material' );
	        var sharedLightingVars = this.createCommonLightingVars( materials, enumToNodeName );
	
	        for ( var i = 0; i < this._lights.length; i++ ) {
	
	            var light = this._lights[ i ];
	
	            var lightedOutput = this.createVariable( 'vec3' );
	            var nodeName = enumToNodeName[ light.getLightType() ];
	
	            // create uniforms from stateAttribute and mix them with materials
	            // to pass the result as input for light node
	            var lightUniforms = this.getOrCreateStateAttributeUniforms( this._lights[ i ], 'light' );
	            var lightOutShadowIn = this.createLightAndShadowVars( materials, enumToNodeName, i );
	
	            var inputs = MACROUTILS.objectMix( {}, lightUniforms );
	            inputs = MACROUTILS.objectMix( inputs, materialUniforms );
	            inputs = MACROUTILS.objectMix( inputs, materials );
	            inputs = MACROUTILS.objectMix( inputs, sharedLightingVars );
	            inputs = MACROUTILS.objectMix( inputs, lightOutShadowIn );
	
	            if ( !inputs.normal )
	                inputs.normal = this.getOrCreateNormalizedNormal();
	            if ( !inputs.eyeVector )
	                inputs.eyeVector = this.getOrCreateNormalizedPosition();
	
	            this.getNode( nodeName ).inputs( inputs ).outputs( {
	                color: lightedOutput,
	                lightEyePos: inputs.lightEyePos, // spot and point only
	                lightEyeDir: inputs.lightEyeDir,
	                ndl: inputs.lightNDL,
	                lighted: inputs.lighted
	            } );
	
	            var shadowedOutput = this.createShadowingLight( light, inputs, lightedOutput );
	            if ( shadowedOutput ) {
	                lightOutputVarList.push( shadowedOutput );
	            } else {
	                lightOutputVarList.push( lightedOutput );
	            }
	
	            var lightMatAmbientOutput = this.createVariable( 'vec3', 'lightMatAmbientOutput' );
	
	            this.getNode( 'Mult' ).inputs( inputs.materialambient, lightUniforms.lightambient ).outputs( lightMatAmbientOutput );
	
	
	            lightOutputVarList.push( lightMatAmbientOutput );
	        }
	
	        // do not delete on the assumption that light list is always filled
	        // in case CreateLighting is called with a empty lightList
	        // when Compiler is overriden.
	        if ( lightOutputVarList.length === 0 )
	            lightOutputVarList.push( this.createVariable( 'vec3' ).setValue( 'vec3(0.0)' ) );
	
	        this.getNode( 'Add' ).inputs( lightOutputVarList ).outputs( output );
	
	        return output;
	    },
	
	
	    // but we could later implement srgb inside and read differents flag
	    // as read only in the texture
	    createTextureRGBA: function ( texture, textureSampler, texCoord ) {
	
	        var texel = this.createVariable( 'vec4' );
	        this.getNode( 'TextureRGBA' ).inputs( {
	            sampler: textureSampler,
	            uv: texCoord
	        } ).outputs( {
	            color: texel
	        } );
	
	        return texel;
	    },
	
	
	    // TODO: add a visitor to debug the graph
	    traverse: function ( functor, node ) {
	
	        if ( this.checkOrMarkNodeAsTraversed( node ) ) return;
	
	        var inputs = node.getInputs();
	        if ( !Array.isArray( inputs ) ) {
	            var keys = window.Object.keys( inputs );
	            var objectToArray = [];
	            for ( var j = 0; j < keys.length; j++ )
	                objectToArray.push( inputs[ keys[ j ] ] );
	            inputs = objectToArray;
	        }
	
	        for ( var i = 0, l = inputs.length; i < l; i++ ) {
	            node.checkInputsOutputs();
	
	            var child = inputs[ i ];
	
	            if ( child !== undefined &&
	                child !== node ) {
	                this.traverse( functor, child );
	            }
	        }
	        functor.call( functor, node );
	
	        // keep trace we visited
	        this.markNodeAsVisited( node );
	
	    },
	
	    // clean necessary bits before traversing
	    // called in each evaluate func belows
	    preTraverse: function ( visitor ) {
	
	        // store traversed list to prevent double traverse
	        this._traversedNodeList = {};
	
	        visitor._map = {};
	        visitor._text = [];
	
	        return visitor;
	    },
	    // Gather a particular output field
	    // for now one of
	    // ['define', 'extensions']
	    //
	    // from a nodeGraph
	    //
	    // In case a node of same Type
	    // have different outputs (shadow with different defines)
	    // it use ID rather than Type as map index
	    // UNIQUE PER TYPE
	    // TODO: adds includes so that we can remove it from
	    // the eval Global Functions ?
	    evaluateAndGatherField: function ( nodes, field ) {
	
	        var func = function ( node ) {
	
	            var idx = node.getType();
	            if ( idx === undefined || idx === '' ) {
	                Notify.error( 'Your node ' + node + ' has no type' );
	            }
	            if ( node[ field ] && this._map[ idx ] === undefined ) {
	
	                this._map[ idx ] = true;
	                var c = node[ field ]();
	                // push all elements of the array on text array
	                // node[field]()  must return an array
	                Array.prototype.push.apply( this._text, c );
	
	            }
	
	        };
	
	        this.preTraverse( func );
	
	        for ( var j = 0, jl = nodes.length; j < jl; j++ ) {
	            this.traverse( func, nodes[ j ] );
	        }
	
	        return func._text;
	    },
	
	    // Gather a functions declartions of nodes
	    // from a nodeGraph
	    // (for now pragma include done here too. could be done with define/etc...)
	    // Node of same Type has to share
	    // exact same "node.globalFunctionDeclaration" output
	    // as it use Type rather than ID as map index
	    evaluateGlobalFunctionDeclaration: function ( nodes ) {
	
	        var func = function ( node ) {
	
	            // UNIQUE PER TYPE
	            var idx = node.getType();
	
	            if ( idx === undefined || idx === '' ) {
	                Notify.error( 'Your node ' + node + ' has no type' );
	            }
	            if ( node.globalFunctionDeclaration &&
	                this._map[ idx ] === undefined ) {
	
	                this._map[ idx ] = true;
	                var c = node.globalFunctionDeclaration();
	                if ( c !== undefined ) {
	                    this._text.push( c );
	                }
	
	            }
	
	        };
	
	        this.preTraverse( func );
	
	        for ( var j = 0, jl = nodes.length; j < jl; j++ ) {
	            this.traverse( func, nodes[ j ] );
	        }
	
	        return func._text.join( '\n' );
	    },
	
	    // Gather a Variables declarations of nodes
	    // from a nodeGraph to be outputted
	    // outside the VOID MAIN code
	    // ( Uniforms, Varying )
	    // Node of same Type has different output
	    // as it use Type rather than ID as map index
	    evaluateGlobalVariableDeclaration: function ( nodes ) {
	
	        var func = function ( node ) {
	
	            // UNIQUE PER NODE
	            var idx = node.getID();
	
	            if ( node.globalDeclaration &&
	                this._map[ idx ] === undefined ) {
	
	                this._map[ idx ] = true;
	                var c = node.globalDeclaration();
	                if ( c !== undefined ) {
	                    this._text.push( c );
	                }
	            }
	        };
	
	
	        this.preTraverse( func );
	
	        for ( var j = 0, jl = nodes.length; j < jl; j++ ) {
	            this.traverse( func, nodes[ j ] );
	        }
	
	
	        // Attribute 0 Must Be vertex
	        // perf warning in console otherwiser in opengl Desktop
	        if ( func._text.length ) {
	            // sort in alphabetical order
	            // attr, unif, sample, varying
	            func._text.sort();
	            // now sort Attributes
	            // making sure Vertex is always coming first
	            var toShift = [];
	            for ( j = 0; j < func._text.length; j++ ) {
	                // found vertex, break
	                if ( func._text[ 0 ].indexOf( 'Vertex' ) !== -1 ) break;
	                // not yet, keep referenc to push after vertex
	                toShift.push( func._text.shift() ); // remove
	            }
	            // Add after vertex all the  found attributes
	            func._text.splice( 1, 0, toShift.join( '\n' ) );
	
	            // beautify/formatting with empty line between type of var
	            var type = func._text[ 0 ][ 0 ];
	            var len = func._text.length;
	            for ( j = 0; j < len; j++ ) {
	                if ( func._text[ j ][ 0 ] !== type ) {
	                    type = func._text[ j ][ 0 ];
	                    func._text.splice( j, 0, '' );
	                    len++;
	                }
	            }
	        }
	        return func._text.join( '\n' );
	    },
	
	
	    evaluate: function ( nodes ) {
	
	
	        var func = function ( node ) {
	
	            var id = node.getID();
	            if ( this._map[ id ] !== undefined ) {
	                return;
	            }
	
	            var c = node.computeShader();
	            if ( c !== undefined ) {
	
	                if ( node.getComment !== undefined ) {
	
	                    var comment = node.getComment();
	                    if ( comment !== undefined ) {
	                        this._text.push( comment );
	                    }
	
	                }
	
	                this._text.push( c );
	            }
	
	            this._map[ id ] = true;
	        };
	
	        this.preTraverse( func );
	
	        for ( var j = 0, jl = nodes.length; j < jl; j++ ) {
	            this.traverse( func, nodes[ j ] );
	        }
	        return func._text.join( '\n' );
	    },
	
	    getTexCoordUnit: function ( id ) {
	        var texture = this._textures[ id ];
	        if ( texture === undefined )
	            return undefined;
	
	        var textureMaterial = this._texturesByName[ texture.getName() ];
	        if ( !textureMaterial )
	            return undefined;
	
	        var texCoordUnit = textureMaterial.textureUnit;
	        if ( texCoordUnit === undefined )
	            textureMaterial.textureUnit = texCoordUnit = id;
	        return texCoordUnit;
	    },
	
	
	    getOrCreateProjectionMatrix: function () {
	        return this.getOrCreateUniform( 'mat4', 'ProjectionMatrix' );
	    },
	
	    // reusable BoneMatrix between Vertex, Normal, Tangent
	    // Manadatory: scale animations must be uniform scale
	    getOrCreateBoneMatrix: function () {
	        var boneMatrix = this._variables[ 'boneMatrix' ];
	        if ( boneMatrix )
	            return boneMatrix;
	
	        boneMatrix = this.createVariable( 'mat4', 'boneMatrix' );
	
	        var inputWeights = this.getOrCreateAttribute( 'vec4', 'Weights' );
	        var inputBones = this.getOrCreateAttribute( 'vec4', 'Bones' );
	        var matrixPalette = this.getOrCreateUniform( 'vec4', 'uBones', this._skinningAttribute.getBoneUniformSize() );
	
	        this.getNode( 'Skinning' ).inputs( {
	            weights: inputWeights,
	            bonesIndex: inputBones,
	            matrixPalette: matrixPalette
	        } ).outputs( {
	            mat4: boneMatrix
	        } );
	
	        return boneMatrix;
	    },
	    getTarget: function ( name, i ) {
	        var type = name.indexOf( 'Tangent' ) !== -1 ? 'vec4' : 'vec3';
	        return this.getOrCreateAttribute( type, name + '_' + i );
	    },
	    morphTangentApproximation: function ( inputVertex, outputVertex ) {
	        var normalizedMorph;
	        // kind of tricky, here we retrieve the normalized normal after morphing
	        // if there is no rigging we do not recompute it
	        if ( this._skinningAttribute ) {
	
	            normalizedMorph = this.createVariable( 'vec3' );
	            this.getNode( 'Normalize' ).inputs( {
	                vec: this.getVariable( 'normalMorph' )
	            } ).outputs( {
	                vec: normalizedMorph
	            } );
	
	        } else {
	            normalizedMorph = this.getVariable( 'normalAttribute' );
	        }
	
	        this.getNode( 'InlineCode' ).code( '%out = %tangent.rgb - dot(%tangent.rgb, %normal) * %normal;' ).inputs( {
	            tangent: inputVertex,
	            normal: normalizedMorph
	        } ).outputs( {
	            out: outputVertex
	        } );
	
	        return outputVertex;
	    },
	    morphTransformVec3: function ( inputVertex, outputVertex, targetName ) {
	        // Comented as this code is not reachable
	        // var approx = false; // on mobile ?
	        // var morph = this._morphAttribute;
	        // compute morph tangent (getOrCreateNormalAttribute will create the 'normalMorph' variable)
	        // if ( approx && targetName === 'Tangent' && this.getOrCreateNormalAttribute() && morph && morph.hasTarget( 'Normal' ) ) {
	        //     return this.morphTangentApproximation( inputVertex, outputVertex );
	        // }
	
	        var inputs = {
	            vertex: inputVertex,
	            weights: this.getOrCreateUniform( 'vec4', 'uTargetWeights' )
	        };
	
	        var numTargets = this._morphAttribute.getNumTargets();
	        for ( var i = 0; i < numTargets; i++ )
	            inputs[ 'target' + i ] = this.getTarget( targetName || inputVertex.getVariable(), i );
	
	        this.getNode( 'Morph' ).inputs( inputs ).outputs( {
	            out: outputVertex
	        } );
	
	        return outputVertex;
	    },
	    skinTransformVertex: function ( inputVertex, outputVertex ) {
	        this.getNode( 'MatrixMultPosition' ).setInverse( true ).inputs( {
	            matrix: this.getOrCreateBoneMatrix(),
	            vec: inputVertex
	        } ).outputs( {
	            vec: outputVertex
	        } );
	        return outputVertex;
	    },
	    skinTransformNormal: function ( inputVertex, outputVertex ) {
	        this.getNode( 'MatrixMultDirection' ).setInverse( true ).inputs( {
	            matrix: this.getOrCreateBoneMatrix(),
	            vec: inputVertex
	        } ).outputs( {
	            vec: outputVertex
	        } );
	        return outputVertex;
	    },
	    getOrCreateVertexAttribute: function () {
	        var vecOut = this.getVariable( 'vertexAttribute' );
	        if ( vecOut ) return vecOut;
	
	        var hasMorph = this._morphAttribute && this._morphAttribute.hasTarget( 'Vertex' );
	
	        var inputVertex = this.getOrCreateAttribute( 'vec3', 'Vertex' );
	        if ( !this._skinningAttribute && !hasMorph ) return inputVertex;
	
	        vecOut = this.createVariable( 'vec3', 'vertexAttribute' );
	
	        if ( hasMorph && !this._skinningAttribute ) return this.morphTransformVec3( inputVertex, vecOut );
	        else if ( !hasMorph && this._skinningAttribute ) return this.skinTransformVertex( inputVertex, vecOut );
	
	        var tmpMorph = this.createVariable( 'vec3' );
	        this.morphTransformVec3( inputVertex, tmpMorph );
	        return this.skinTransformVertex( tmpMorph, vecOut );
	    },
	    getOrCreateNormalAttribute: function () {
	        var vecOut = this.getVariable( 'normalAttribute' );
	        if ( vecOut ) return vecOut;
	
	        var hasMorph = this._morphAttribute && this._morphAttribute.hasTarget( 'Normal' );
	
	        var inputNormal = this.getOrCreateAttribute( 'vec3', 'Normal' );
	        if ( !this._skinningAttribute && !hasMorph ) return inputNormal;
	
	        var tmpAnim;
	
	        // we name the morph variable in case we want to infer the tangent from the morph normal
	        if ( hasMorph && !this._skinningAttribute ) {
	            tmpAnim = this.morphTransformVec3( inputNormal, this.createVariable( 'vec3', 'normalMorph' ) );
	        } else if ( !hasMorph && this._skinningAttribute ) {
	            tmpAnim = this.skinTransformNormal( inputNormal, this.createVariable( 'vec3', 'normalSkin' ) );
	        } else {
	
	            tmpAnim = this.morphTransformVec3( inputNormal, this.createVariable( 'vec3', 'normalMorph' ) );
	            tmpAnim = this.skinTransformNormal( tmpAnim, this.createVariable( 'vec3', 'normalSkin' ) );
	
	        }
	
	        vecOut = this.createVariable( 'vec3', 'normalAttribute' );
	        this.getNode( 'Normalize' ).inputs( {
	            vec: tmpAnim
	        } ).outputs( {
	            vec: vecOut
	        } );
	
	        return vecOut;
	    },
	    getOrCreateTangentAttribute: function () {
	        var vecOut = this.getVariable( 'tangentAttribute' );
	        if ( vecOut ) return vecOut;
	
	        var hasMorph = this._morphAttribute && this._morphAttribute.hasTarget( 'Tangent' );
	
	        var inputTangent = this.getOrCreateAttribute( 'vec4', 'Tangent' );
	        if ( !this._skinningAttribute && !hasMorph ) return inputTangent;
	
	        var tmpAnim;
	
	        if ( hasMorph && !this._skinningAttribute ) {
	            tmpAnim = this.morphTransformVec3( inputTangent, this.createVariable( 'vec3', 'tangentMorph' ) );
	        } else if ( !hasMorph && this._skinningAttribute ) {
	            tmpAnim = this.skinTransformNormal( inputTangent, this.createVariable( 'vec3', 'tangentSkin' ) );
	        } else {
	
	            tmpAnim = this.morphTransformVec3( inputTangent, this.createVariable( 'vec3', 'tangentMorph' ), 'Tangent' );
	            tmpAnim = this.skinTransformNormal( tmpAnim, this.createVariable( 'vec3', 'tangentSkin' ) );
	
	        }
	
	        // normalize
	        var tangNorm = this.createVariable( 'vec3' );
	        this.getNode( 'Normalize' ).inputs( {
	            vec: tmpAnim
	        } ).outputs( {
	            vec: tangNorm
	        } );
	
	        // apply back the alpha
	        vecOut = this.createVariable( 'vec4', 'tangentAttribute' );
	        this.getNode( 'SetAlpha' ).inputs( {
	            color: tangNorm,
	            alpha: inputTangent
	        } ).outputs( {
	            color: vecOut
	        } );
	
	        return vecOut;
	    },
	    declareVertexTransformShadeless: function ( glPosition ) {
	        // No light
	        var tempViewSpace = this.createVariable( 'vec4' );
	
	        //viewSpace
	        this.getNode( 'MatrixMultPosition' ).inputs( {
	            matrix: this.getOrCreateUniform( 'mat4', 'ModelViewMatrix' ),
	            vec: this.getOrCreateVertexAttribute()
	        } ).outputs( {
	            vec: tempViewSpace
	        } );
	
	        //glpos
	        this.getNode( 'MatrixMultPosition' ).inputs( {
	            matrix: this.getOrCreateProjectionMatrix(),
	            vec: tempViewSpace
	        } ).outputs( {
	            vec: glPosition
	        } );
	    },
	
	    declareVertexTransformBillboard: function ( glPosition ) {
	        this.getOrCreateInputPosition();
	        this.getNode( 'Billboard' ).inputs( {
	            Vertex: this.getOrCreateAttribute( 'vec3', 'Vertex' ),
	            ModelViewMatrix: this.getOrCreateUniform( 'mat4', 'ModelViewMatrix' ),
	            ProjectionMatrix: this.getOrCreateUniform( 'mat4', 'ProjectionMatrix' )
	        } ).outputs( {
	            vec: glPosition
	        } );
	    },
	
	    needTangent: function () {
	        // the application choose whether or not to use tangent
	        return false;
	    },
	    declareVertexTransformLighted: function ( glPosition ) {
	        // FragNormal
	        this.getNode( 'MatrixMultDirection' ).inputs( {
	            matrix: this.getOrCreateUniform( 'mat4', 'NormalMatrix' ),
	            vec: this.getOrCreateNormalAttribute()
	        } ).outputs( {
	            vec: this.getOrCreateInputNormal()
	        } );
	
	        if ( this.needTangent() ) {
	            this.getNode( 'MatrixMultDirection' ).setForceComplement( false ).inputs( {
	                matrix: this.getOrCreateUniform( 'mat4', 'NormalMatrix' ),
	                vec: this.getOrCreateTangentAttribute()
	            } ).outputs( {
	                vec: this.getOrCreateVarying( 'vec4', 'FragTangent' )
	            } );
	        }
	
	        if ( this._isBillboard )
	            this.declareVertexTransformBillboard( glPosition );
	        else
	            this.declareTransformWithEyeSpace( glPosition );
	
	    },
	    // Transform Position into NDC
	    // but keep intermediary result
	    // FragEye which is in Camera/Eye space
	    // (most light computation is in eye space)
	    // (better precision, particulary if camera is far from World 0.0.0)
	    declareTransformWithEyeSpace: function ( glPosition ) {
	
	        // FragEye
	        // need vec4 for linearization of depth
	        var tempViewSpace = this.getOrCreateInputPosition();
	        this.getNode( 'MatrixMultPosition' ).inputs( {
	            matrix: this.getOrCreateUniform( 'mat4', 'ModelViewMatrix' ),
	            vec: this.getOrCreateVertexAttribute()
	        } ).outputs( {
	            vec: tempViewSpace
	        } );
	
	
	        //glpos
	        this.getNode( 'MatrixMultPosition' ).inputs( {
	            matrix: this.getOrCreateProjectionMatrix(),
	            vec: tempViewSpace
	        } ).outputs( {
	            vec: glPosition
	        } );
	    },
	
	    declareVertexTransformShadowed: function ( /*glPosition*/) {
	
	        // worldpos
	        this.getNode( 'MatrixMultPosition' ).inputs( {
	            matrix: this.getOrCreateUniform( 'mat4', 'ModelWorldMatrix' ),
	            vec: this.getOrCreateVertexAttribute()
	        } ).outputs( {
	            vec: this.getOrCreateVarying( 'vec3', 'WorldPosition' )
	        } );
	
	    },
	
	    isShadowed: function () {
	        // if no light, no shadow
	        if ( !this._isLighted )
	            return false;
	        for ( var i = 0, ll = this._shadowsTextures.length; i < ll; i++ ) {
	
	            if ( this._shadowsTextures[ i ] !== undefined )
	                return true;
	        }
	        return false;
	    },
	    // - check Precision qualifier on vertex Attributes
	    // - check Precision qualifier on vertex Attributes Varying
	    declareVertexTransforms: function ( glPosition ) {
	
	        // Make only necessary operation and varying
	        if ( this._isLighted || this._shaderAttributes[ 'Normal' ] ) {
	            if ( this.isShadowed() ) {
	                this.declareVertexTransformShadowed( glPosition );
	            }
	            this.declareVertexTransformLighted( glPosition );
	
	        } else {
	            if ( this._isBillboard )
	                this.declareVertexTransformBillboard( glPosition );
	            else
	                this.declareVertexTransformShadeless( glPosition );
	        }
	    },
	
	    declareVertexTextureCoords: function ( /*glPosition*/) {
	
	        var texCoordMap = {};
	        for ( var tt = 0; tt < this._textures.length; tt++ ) {
	            var texCoordUnit = this.getTexCoordUnit( tt );
	            if ( texCoordUnit === undefined || texCoordMap[ texCoordUnit ] !== undefined )
	                continue;
	
	            this.getNode( 'SetFromNode' ).inputs( this.getOrCreateAttribute( 'vec2', 'TexCoord' + texCoordUnit ) ).outputs(
	                this.getOrCreateVarying( 'vec2', 'FragTexCoord' + texCoordUnit )
	            );
	
	            texCoordMap[ texCoordUnit ] = true;
	        }
	    },
	
	    declareVertexMain: function () {
	
	        // the mandatory output is glPosition
	        var glPosition = this.getNode( 'glPosition' );
	
	        // shader graph can have multiple output (glPointsize, varyings)
	        // here named roots
	        // all outputs must be pushed inside
	        var roots = [];
	
	
	        // roots is
	        this.declareVertexTransforms( glPosition, roots );
	        this.declareVertexTextureCoords( glPosition, roots );
	
	
	        if ( this._isVertexColored ) {
	            var vertexDynamicColoring = [ '',
	                'if ( %ArrayColorEnabled == 1.0 ) ',
	                '    %VertexColor = %Color;',
	                '  else',
	                '    %VertexColor = vec4(1.0,1.0,1.0,1.0);'
	            ];
	
	            this.getNode( 'InlineCode' ).code( vertexDynamicColoring.join( '\n' ) ).inputs( {
	                ArrayColorEnabled: this.getOrCreateUniform( 'float', 'ArrayColorEnabled' ),
	                Color: this.getOrCreateAttribute( 'vec4', 'Color' )
	            } ).outputs( {
	                VertexColor: this.getOrCreateVarying( 'vec4', 'VertexColor' )
	            } );
	        }
	
	
	
	        // TODO: add this for POINT RENDERING ONLY
	        var str = '%out = %input;';
	        var glPointSize = this.getNode( 'glPointSize' );
	        this.getNode( 'InlineCode' ).code( str ).inputs( {
	            input: this.getOrCreateConstant( 'float', 'unitFloat' ).setValue( '1.0' )
	        } ).outputs( {
	            out: glPointSize
	        } );
	        roots.push( glPointSize );
	
	        // Because of a weird bug on iOS
	        // glPosition should be computed in the vertex shader before some varyings
	        roots.push( glPosition );
	
	        var vars = window.Object.keys( this._varyings );
	        for ( var j = 0, jl = vars.length; j < jl; j++ ) {
	            var varying = this._varyings[ vars[ j ] ];
	            if ( varying !== undefined ) {
	                // make sure we link all vertex shader output
	                // to the finale Node
	                roots.push( varying );
	            }
	        }
	
	        return roots;
	
	    },
	    // Meanwhile, here it is.
	    createVertexShaderGraph: function () {
	        return this.declareVertexMain();
	    },
	
	    // The Compiler Main Code
	    // called on Vertex or Fragment Shader Graph
	    createShaderFromGraphs: function ( roots, type ) {
	        this._compiledNodeList = {};
	
	        // list all vars
	        var vars = window.Object.keys( this._variables );
	        var variables = [];
	        for ( var j = 0, jl = vars.length; j < jl; j++ ) {
	
	            var varNode = this._variables[ vars[ j ] ];
	            var d = varNode.declare();
	            if ( d ) {
	                variables.push( d );
	            }
	        }
	
	        // defines and extensions are added by process shader
	        var extensions = this.evaluateExtensions( roots );
	        var defines = this.evaluateDefines( roots );
	
	        var shaderStack = [];
	        shaderStack.push( '\n' );
	        shaderStack.push( this.evaluateGlobalVariableDeclaration( roots ) );
	        shaderStack.push( '\n' );
	        shaderStack.push( this.evaluateGlobalFunctionDeclaration( roots ) );
	
	
	        shaderStack.push( 'void main() {' );
	
	        // declare variables in main
	        if ( variables.length !== 0 ) {
	            shaderStack.push( '// vars\n' );
	            shaderStack.push( variables.join( ' ' ) );
	            shaderStack.push( '\n// end vars\n' );
	        }
	        // make sure we have at least one output
	        if ( roots.length === 0 ) {
	            Notify.error( 'shader without any final Node output (need at least one)' );
	        }
	        shaderStack.push( this.evaluate( roots ) );
	
	        shaderStack.push( '}' );
	
	        // Shader Graph has been outputed an array of string
	        // we concatenate it to a shader string program
	        var shaderStr = shaderStack.join( '\n' );
	
	        // Process defines, add precision, resolve include pragma
	        var shader = this._shaderProcessor.processShader( shaderStr, defines, extensions, type );
	
	
	        // return the complete shader string.
	        // now is compilable by gl driver
	        return shader;
	    },
	    createVertexShader: function () {
	
	
	        // start with clean slate
	        this._variables = {};
	        this._activeNodeList = {};
	        this._fragmentShaderMode = false;
	
	        // Call to specialised inhenrited shader Compiler
	        var roots = this.createVertexShaderGraph();
	        var vname = this.getVertexShaderName();
	        if ( vname )
	            roots.push( this.getNode( 'Define', 'SHADER_NAME' ).setValue( vname ) );
	
	        // call the graph compiler itself
	        var shader = this.createShaderFromGraphs( roots, 'vertex' );
	
	        Notify.debug( shader );
	
	        // reset for next, but not empty, keep varyings
	        this._variables = {};
	        this._activeNodeList = {};
	        this._fragmentShaderMode = true;
	        // we want to keep list of varying
	        // to be able to validate fragment shader
	        // requiring varyings
	        var vars = window.Object.keys( this._varyings );
	        for ( var j = 0, jl = vars.length; j < jl; j++ ) {
	            var varying = this._varyings[ vars[ j ] ];
	            if ( varying !== undefined ) {
	                // make sure we clean input/output
	                // of varying for fragment shader graph
	                varying.reset();
	                // add it back to variables list
	                // so that we can detect
	                // when varing is computed in VS but not in FS
	                this._activeNodeList[ varying.getID() ] = varying;
	                this._variables[ varying.getID() ] = varying;
	            }
	        }
	
	
	        return shader;
	    },
	    evaluateDefines: function ( roots ) {
	        return this.evaluateAndGatherField( roots, 'getDefines' );
	    },
	    evaluateExtensions: function ( roots ) {
	        return this.evaluateAndGatherField( roots, 'getExtensions' );
	    },
	    createFragmentShader: function () {
	
	        // start with clean slate
	        if ( this._customVertexShader ) {
	            this._variables = {};
	            this._activeNodeList = {};
	        }
	        this._fragmentShaderMode = true;
	
	        this.declareTextures();
	
	        // Call to specialised inhenrited shader Compiler
	        var roots = this.createFragmentShaderGraph();
	        var fname = this.getFragmentShaderName();
	        if ( fname )
	            roots.push( this.getNode( 'Define', 'SHADER_NAME' ).setValue( fname ) );
	
	        var shader = this.createShaderFromGraphs( roots, 'fragment' );
	        Notify.debug( shader );
	
	        // reset for next
	        this._variables = {};
	        this._fragmentShaderMode = false;
	        this._activeNodeList = {};
	
	        return shader;
	    },
	
	
	    // This function is used when no material
	    // is present. If you inherit from this Compiler
	    // you could change the default behavior
	    createDefaultFragmentShaderGraph: function () {
	        var fofd = this.getOrCreateConstant( 'vec4', 'fofd' ).setValue( 'vec4(1.0, 0.0, 1.0, 0.7)' );
	        var fragCol = this.getNode( 'glFragColor' );
	        this.getNode( 'SetFromNode' ).inputs( fofd ).outputs( fragCol );
	        return fragCol;
	    },
	
	    // this is the main function that will generate the
	    // fragment shader. If you need to improve / add your own
	    // you could inherit and override this function
	    createFragmentShaderGraph: function () {
	
	        // shader graph can have multiple output (glPointsize, varyings)
	        // here named roots
	        // all outputs must be pushed inside
	        var roots = [];
	
	        // no material then return a default shader
	        if ( !this._material ) {
	            roots.push( this.createDefaultFragmentShaderGraph() );
	            return roots;
	        }
	
	        var materialUniforms = this.getOrCreateStateAttributeUniforms( this._material );
	
	        // vertex color needs to be computed to diffuse
	        var diffuseColor = this.getVertexColor( materialUniforms.diffuse );
	
	        // 2 codes path
	        // if we have light we compute a subgraph that will generate
	        // color from lights contribution...
	        // if we dont have light we will use the diffuse color found as default
	        // fallback
	        var finalColor;
	
	        if ( this._lights.length > 0 ) {
	
	            // creates lights nodes
	            var lightedOutput = this.createLighting( {
	                materialdiffuse: diffuseColor
	            } );
	            finalColor = lightedOutput;
	
	        } else {
	            // no light, no emssion use diffuse color
	            finalColor = diffuseColor;
	        }
	
	        if ( materialUniforms.emission ) {
	            // add emission if any
	            var outputDiffEm = this.createVariable( 'vec3' ).setValue( 'vec3(0.0)' );
	            this.getNode( 'Add' ).inputs( finalColor, materialUniforms.emission ).outputs( outputDiffEm );
	            finalColor = outputDiffEm;
	        }
	        // finalColor = primary color * texture color
	        var textureColor = this.getDiffuseColorFromTextures();
	        if ( textureColor !== undefined ) {
	            this.getNode( 'InlineCode' ).code( '%color.rgb *= %texture.rgb;' ).inputs( {
	                texture: textureColor
	            } ).outputs( {
	                color: finalColor
	            } );
	        }
	
	        // compute alpha
	        var alpha = this.createVariable( 'float' );
	        var textureTexel = this.getFirstValidTexture();
	        var alphaCompute;
	        if ( textureTexel ) // use alpha of the first valid texture if has texture
	            alphaCompute = '%alpha = %color.a * %texelAlpha.a;';
	        else
	            alphaCompute = '%alpha = %color.a;';
	
	        // Discard fragments totally transparents when rendering billboards
	        if ( this._isBillboard )
	            alphaCompute += 'if ( %alpha == 0.0) discard;';
	
	        this.getNode( 'InlineCode' ).code( alphaCompute ).inputs( {
	            color: materialUniforms.diffuse,
	            texelAlpha: textureTexel
	        } ).outputs( {
	            alpha: alpha
	        } );
	        // premult alpha
	        finalColor = this.getPremultAlpha( finalColor, alpha );
	
	        var fragColor = this.getNode( 'glFragColor' );
	
	        // todo add gamma corrected color, but it would also
	        // mean to handle correctly srgb texture. So it should be done
	        // at the same time. see osg.Tetxure to implement srgb
	        this.getNode( 'SetAlpha' ).inputs( {
	            color: finalColor,
	            alpha: alpha
	        } ).outputs( {
	            color: fragColor
	        } );
	
	        roots.push( fragColor );
	
	        return roots;
	    },
	    getFragmentShaderName: function () {
	        return this._material ? 'CompilerOSGJS' : 'NoMaterialCompilerOSGJS';
	    },
	    getVertexShaderName: function () {
	        return this.getFragmentShaderName();
	    }
	};
	
	module.exports = Compiler;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var skinning = __webpack_require__( 160 );
	var data = __webpack_require__( 193 );
	var functions = __webpack_require__( 195 );
	var lights = __webpack_require__( 196 );
	var shadows = __webpack_require__( 198 );
	var operations = __webpack_require__( 197 );
	var textures = __webpack_require__( 194 );
	var morph = __webpack_require__( 191 );
	var billboard = __webpack_require__( 199 );
	
	var Factory = function () {
	
	    this._nodes = new window.Map();
	
	    this.registerNodes( skinning );
	    this.registerNodes( data );
	    this.registerNodes( textures );
	    this.registerNodes( functions );
	    this.registerNodes( lights );
	    this.registerNodes( morph );
	    this.registerNodes( shadows );
	    this.registerNodes( operations );
	    this.registerNodes( billboard );
	};
	
	Factory.prototype = {
	
	    registerNodes: function ( obj ) {
	        var self = this;
	        window.Object.keys( obj ).forEach( function ( key ) {
	            self.registerNode( key, obj[ key ] );
	        } );
	    },
	
	    registerNode: function ( name, constructor ) {
	
	        if ( this._nodes.has( name ) ) {
	            Notify.warn( 'Node ' + name + ' already registered' );
	        }
	        this._nodes.set( name, constructor );
	
	    },
	    // extra argument are passed to the constructor of the node
	    getNode: function ( name ) {
	
	        var Constructor = this._nodes.get( name );
	        if ( !Constructor ) {
	            // Means either:
	            // - the node isn't registered by methods above
	            // - you mistyped the name
	            // - Core Node has changed its Name
	            Notify.warn( 'Node ' + name + ' does not exist' );
	            return undefined;
	        }
	
	        // call a constructor with array arguments
	        // http://www.ecma-international.org/ecma-262/5.1/#sec-13.2.2
	        var instance = window.Object.create( Constructor.prototype );
	        Constructor.apply( instance, Array.prototype.slice.call( arguments, 1 ) );
	
	        return instance;
	    }
	
	};
	
	var instance = new Factory();
	
	module.exports = instance;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var ShaderUtils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	var Skinning = function () {
	    Node.call( this );
	};
	
	Skinning.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    type: 'Skinning',
	    validInputs: [ 'weights', 'bonesIndex', 'matrixPalette' ],
	    validOutputs: [ 'mat4' ],
	
	    globalFunctionDeclaration: function () {
	        return '#pragma include "skinning.glsl"';
	    },
	
	    computeShader: function () {
	        // For now matrixPalette is used as a global (uBones) because an array means a dynamic function signature in the glsl...
	        return ShaderUtils.callFunction( 'skeletalTransform', this._outputs.mat4, [ this._inputs.weights, this._inputs.bonesIndex ] );
	    }
	} );
	
	module.exports = {
	    Skinning: Skinning
	};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var sprintf = function ( string, args ) {
	    if ( !string || !args ) {
	        return '';
	    }
	
	    var arg;
	
	    for ( var index in args ) {
	        arg = args[ index ];
	
	        if ( arg === undefined )
	            continue;
	
	        if ( arg.getVariable ) {
	            arg = arg.getVariable();
	        }
	        string = string.replace( '%s', arg );
	    }
	    return string;
	};
	
	
	var checkVariableType = function ( vars, optionalPrefix ) {
	
	    var inputs = vars;
	    var varsList = [];
	    var prefix = optionalPrefix;
	    if ( optionalPrefix === undefined ) {
	        prefix = '';
	    }
	
	    for ( var i = 0, l = inputs.length; i < l; i++ ) {
	
	        var variable = inputs[ i ];
	        var output;
	
	        if ( variable === undefined ) {
	            output = 'undefined';
	        } else if ( typeof variable === 'string' ) {
	            output = variable;
	        } else if ( variable.getType ) {
	            output = variable.getType() + ' ' + variable.getVariable();
	        } else {
	            output = variable.getVariable();
	        }
	
	        varsList.push( prefix + output );
	    }
	
	    return varsList;
	
	};
	
	
	// call glsl function
	// generate a string with output = funcName ( inputs )
	// useful when debuging to print inputs / outputs
	// TODO check type of arguments with regexp in glsl
	// shader function regex
	// [\r\n]\s[(vec4)|(vec3)|(vec2)|(float)|(bool)|(int)].*\(.*[.|\r\n]*\).*[\r\n]*{
	// doesn't handle multiline
	// then split(',')
	// then substring (out,in)
	// then type matching
	// (works by hand here.)
	// for instance, gather types from input and compare themt to glsl decl
	// var inputTypes = [
	//             'vec4',
	//             'vec4',
	//             'sampler2D',
	//             'vec4',
	//             'vec4',
	//             'vec3',
	//             'float',
	//             'vec3',
	//             'float',
	//             'float',
	//             'float',
	//             'float',
	//             'float'
	//         ];
	//         console.assert( inputs.length === inputTypes.length );
	//         var i = inputs.length;
	//         while ( i-- ) {
	//             console.assert( inputs[ i ]._type === inputTypes[ i ], inputs[ i ]._prefix );
	//         }
	var callFunction = function ( funcName, output, inputs ) {
	
	    var osgShader = __webpack_require__( 162 );
	
	    var debug = [];
	    var callString = '';
	
	    // debug
	    if ( osgShader.debugShaderNode ) {
	        debug.push( '\n// output' );
	        Array.prototype.push.apply( debug, checkVariableType( [ output ], '// ' ) );
	    }
	
	    if ( output ) {
	        if ( output.getVariable )
	            output = output.getVariable();
	        callString = output + ' = ';
	    }
	
	    callString = callString + funcName + '( ';
	
	    if ( inputs && inputs.length > 0 ) {
	
	        // debug
	        if ( osgShader.debugShaderNode ) {
	            debug.push( '// inputs' );
	            Array.prototype.push.apply( debug, checkVariableType( inputs, '// ' ) );
	        }
	
	        for ( var i = 0, l = inputs.length; i < l; i++ ) {
	
	            // check if it's a variable and not a constant
	            if ( inputs[ i ].getVariable )
	                callString += inputs[ i ].getVariable();
	            else
	                callString += inputs[ i ];
	
	            if ( i !== l - 1 )
	                callString += ', ';
	        }
	    }
	
	    callString += ' );\n';
	
	    if ( osgShader.debugShaderNode )
	        return debug.join( '\n' ) + '\n' + callString;
	
	    return callString;
	};
	
	
	module.exports = {
	    callFunction: callFunction,
	    checkVariableType: checkVariableType,
	    sprintf: sprintf
	};


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Compiler = __webpack_require__( 158 );
	var ShaderGenerator = __webpack_require__( 157 );
	var ShaderGeneratorProxy = __webpack_require__( 163 );
	var ShaderProcessor = __webpack_require__( 167 );
	var nodeFactory = __webpack_require__( 159 );
	var node = __webpack_require__( 190 );
	var utils = __webpack_require__( 161 );
	
	
	var lib = {};
	
	lib.Compiler = Compiler;
	lib.ShaderGenerator = ShaderGenerator;
	lib.ShaderGeneratorProxy = ShaderGeneratorProxy;
	lib.ShaderProcessor = ShaderProcessor;
	lib.nodeFactory = nodeFactory;
	lib.node = node;
	
	lib.utils = utils;
	
	
	// debug utility: set it to one to have verbose in shaders
	lib.debugShaderNode = false;
	
	module.exports = lib;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ShaderGenerator = __webpack_require__( 157 );
	var ShadowCastShaderGenerator = __webpack_require__( 164 );
	var DisplayNormalVisitor = __webpack_require__( 156 );
	var DisplayGeometryVisitor = __webpack_require__( 166 );
	
	var ShaderGeneratorProxy = function () {
	
	    // object of shader generators
	    this._generators = new window.Map();
	    this.addShaderGenerator( 'default', new ShaderGenerator() );
	    this.addShaderGenerator( 'ShadowCast', new ShadowCastShaderGenerator() );
	    this.addShaderGenerator( 'debugNormal', new DisplayNormalVisitor.ShaderGeneratorCompilerOffsetNormal() );
	    this.addShaderGenerator( 'debugTangent', new DisplayNormalVisitor.ShaderGeneratorCompilerOffsetTangent() );
	    this.addShaderGenerator( 'debugGeometry', new DisplayGeometryVisitor.ShaderGeneratorCompilerColorGeometry() );
	    this.addShaderGenerator( 'debugSkinning', new DisplayGeometryVisitor.ShaderGeneratorCompilerColorSkinning() );
	
	    return this;
	};
	
	ShaderGeneratorProxy.prototype = {
	
	    getShaderGenerator: function ( name ) {
	
	        if ( !name )
	            return this._generators.get( 'default' );
	
	        return this._generators.get( name );
	    },
	
	    // user-space facility to provide its own
	    addShaderGenerator: function ( name, sg ) {
	
	        this._generators.set( name, sg );
	
	    }
	
	};
	
	module.exports = ShaderGeneratorProxy;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ShaderGenerator = __webpack_require__( 157 );
	var ShadowCompiler = __webpack_require__( 165 );
	
	var ShaderGeneratorShadowCast = function () {
	
	    ShaderGenerator.apply( this, arguments );
	    this.setShaderCompiler( ShadowCompiler );
	    // only one attribute makes change to the compilation
	    // ignore all others
	    this._acceptAttributeTypes = new window.Set( [ 'ShadowCast', 'Skinning', 'Morph' ] );
	
	};
	
	ShaderGeneratorShadowCast.prototype = ShaderGenerator.prototype;
	
	module.exports = ShaderGeneratorShadowCast;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Compiler = __webpack_require__( 158 );
	
	
	var CompilerShadowCast = function () {
	    Compiler.apply( this, arguments );
	    this._isVertexColored = false;
	    this._isLighted = false;
	};
	
	CompilerShadowCast.prototype = MACROUTILS.objectInherit( Compiler.prototype, {
	    getCompilerName: function () {
	        return 'ShadowCast';
	    },
	    getFragmentShaderName: function () {
	        return this.getCompilerName();
	    },
	    initAttributes: function () {
	        var attributes = this._attributes;
	
	        for ( var i = 0, l = attributes.length; i < l; i++ ) {
	
	            var type = attributes[ i ].className();
	
	            if ( type === 'ShadowCastAttribute' ) {
	                this._shadowCastAttribute = attributes[ i ];
	            } else if ( type === 'Billboard' ) {
	                this._isBillboard = !!attributes[ i ];
	            } else if ( type === 'SkinningAttribute' ) {
	                this._skinningAttribute = attributes[ i ];
	            } else if ( type === 'MorphAttribute' ) {
	                this._morphAttribute = attributes[ i ];
	            }
	        }
	    },
	    registerTextureAttributes: function () {},
	    registerTextureShadow: function () {},
	
	    // Fast Path, only Depth
	    declareVertexTransforms: function ( glPosition ) {
	        this.declareTransformWithEyeSpace( glPosition );
	    },
	
	    // Depth Shadow Map Casted from Light POV
	    // Depth encoded in color buffer
	    createShadowCastDepth: function () {
	
	        var frag = this.createVariable( 'vec4' );
	
	        this.getNode( 'ShadowCast' ).setShadowCastAttribute( this._shadowCastAttribute ).inputs( {
	
	            exponent0: this.getOrCreateUniform( 'float', 'exponent0' ),
	            exponent1: this.getOrCreateUniform( 'float', 'exponent1' ),
	            shadowDepthRange: this.getOrCreateUniform( 'vec4', 'Shadow_DepthRange' ),
	            fragEye: this.getOrCreateInputPosition()
	
	        } ).outputs( {
	
	            color: frag
	
	        } );
	
	        return frag;
	    },
	
	    // encapsulate for easier overwrite by user defined compiler
	    // that would inherint from this compiler
	    // Do not merge with above method
	    createFragmentShaderGraph: function () {
	
	        var depthFrag = this.createShadowCastDepth();
	        var frag = this.getNode( 'glFragColor' );
	        this.getNode( 'SetFromNode' ).inputs( depthFrag ).outputs( frag );
	        return [ frag ];
	    }
	
	} );
	
	module.exports = CompilerShadowCast;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var Geometry = __webpack_require__( 31 );
	var RigGeometry = __webpack_require__( 78 );
	var Uniform = __webpack_require__( 35 );
	var StateSet = __webpack_require__( 19 );
	var Vec3 = __webpack_require__( 15 );
	var ShaderGenerator = __webpack_require__( 157 );
	var Compiler = __webpack_require__( 158 );
	var BufferArray = __webpack_require__( 40 );
	var DrawArrays = __webpack_require__( 42 );
	var PrimitiveSet = __webpack_require__( 41 );
	var MatrixTransform = __webpack_require__( 44 );
	var Depth = __webpack_require__( 86 );
	
	
	////////////////////////
	// COMPILER DEBUG GEOMETRY
	////////////////////////
	var CompilerColorGeometry = function () {
	    Compiler.apply( this, arguments );
	    this._isVertexColored = false;
	};
	
	CompilerColorGeometry.prototype = MACROUTILS.objectInherit( Compiler.prototype, {
	    getFragmentShaderName: function () {
	        return 'CompilerDebugGeometry';
	    },
	    initTextureAttributes: function () {},
	    createFragmentShaderGraph: function () {
	        var frag = this.getNode( 'glFragColor' );
	
	        this.getNode( 'SetAlpha' ).inputs( {
	            color: this.getOrCreateUniform( 'vec3', 'uColorDebug' ),
	            alpha: this.createVariable( 'float' ).setValue( '1.0' )
	        } ).outputs( {
	            color: frag
	        } );
	
	        return [ frag ];
	    },
	    declareVertexTransforms: Compiler.prototype.declareVertexTransformShadeless
	} );
	
	var ShaderGeneratorCompilerColorGeometry = function () {
	    ShaderGenerator.apply( this, arguments );
	    this.setShaderCompiler( CompilerColorGeometry );
	};
	ShaderGeneratorCompilerColorGeometry.prototype = ShaderGenerator.prototype;
	
	
	////////////////////////
	// COMPILER SKINNING DEBUG
	////////////////////////
	var CompilerColorSkinning = function () {
	    Compiler.apply( this, arguments );
	    this._isVertexColored = false;
	};
	
	CompilerColorSkinning.prototype = MACROUTILS.objectInherit( Compiler.prototype, {
	    getFragmentShaderName: function () {
	        return 'CompilerDebugSkinning';
	    },
	    initTextureAttributes: function () {},
	    createFragmentShaderGraph: function () {
	        var frag = this.getNode( 'glFragColor' );
	
	        this.getNode( 'SetAlpha' ).inputs( {
	            color: this.getOrCreateVarying( 'vec3', 'vBonesColor' ),
	            alpha: this.createVariable( 'float' ).setValue( '1.0' )
	        } ).outputs( {
	            color: frag
	        } );
	
	        return [ frag ];
	    },
	    declareVertexTransforms: function ( glPosition ) {
	
	        var color = this.getOrCreateVarying( 'vec3', 'vBonesColor' );
	        this.getNode( 'SetFromNode' ).inputs( this.getOrCreateAttribute( 'vec3', 'BonesColor' ) ).outputs( color );
	
	        return Compiler.prototype.declareVertexTransformShadeless.call( this, glPosition );
	    }
	} );
	
	var ShaderGeneratorCompilerColorSkinning = function () {
	    ShaderGenerator.apply( this, arguments );
	    this.setShaderCompiler( CompilerColorSkinning );
	};
	ShaderGeneratorCompilerColorSkinning.prototype = ShaderGenerator.prototype;
	
	///////////////////////////
	// DISPLAY GEOMETRY VISITOR
	///////////////////////////
	
	var GeometryColorDebugVisitor = function () {
	    NodeVisitor.call( this );
	    this._debugColor = true;
	    this._debugSkinning = false;
	
	    this._stCenter = new StateSet(); // state set of center crosses
	    this._stCenter.setShaderGeneratorName( 'debugGeometry' );
	};
	
	GeometryColorDebugVisitor.CompilerColorGeometry = CompilerColorGeometry;
	GeometryColorDebugVisitor.ShaderGeneratorCompilerColorGeometry = ShaderGeneratorCompilerColorGeometry;
	
	GeometryColorDebugVisitor.CompilerSkinningGeometry = CompilerColorSkinning;
	GeometryColorDebugVisitor.ShaderGeneratorCompilerColorSkinning = ShaderGeneratorCompilerColorSkinning;
	
	GeometryColorDebugVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    setGeometryDebug: function ( node ) {
	        this._stCenter.setAttributeAndModes( new Depth( Depth.ALWAYS ) );
	        this._debugColor = true;
	        this._debugSkinning = false;
	        this.apply( node );
	    },
	    setSkinningDebug: function ( node ) {
	        this._stCenter.setAttributeAndModes( new Depth( Depth.NEVER ) );
	        this._debugColor = false;
	        this._debugSkinning = true;
	        this.apply( node );
	    },
	    disableDebug: function ( node ) {
	        this._stCenter.setAttributeAndModes( new Depth( Depth.NEVER ) );
	        this._debugColor = false;
	        this._debugSkinning = false;
	        this.apply( node );
	    },
	    apply: function ( node ) {
	        if ( node._isNormalDebug || node._isCenterDebug )
	            return;
	
	        if ( node instanceof Geometry ) {
	
	            if ( this._debugColor || ( this._debugSkinning && node instanceof RigGeometry ) ) {
	
	                if ( node._originalStateSet === undefined )
	                    node._originalStateSet = node.getStateSet() || null;
	
	                var st = new StateSet();
	                node.setStateSet( st );
	
	                if ( this._debugSkinning ) {
	                    st.setShaderGeneratorName( 'debugSkinning' );
	
	                    // a bone can be shared between several rigs so we use the instanceID to get unique color
	                    var vList = node.getVertexAttributeList();
	                    if ( !vList.BonesColor ) {
	                        var eltBones = vList.Bones.getElements();
	                        var eltWeights = vList.Weights.getElements();
	
	                        var bones = node._rigTransformImplementation._bones;
	                        var nbBones = eltBones.length / 4;
	
	                        var bonesColor = new Float32Array( nbBones * 3 );
	
	                        for ( var i = 0; i < nbBones; ++i ) {
	                            var idb = i * 4;
	                            var c0 = bones[ eltBones[ idb ] ].getOrCreateDebugColor();
	                            var c1 = bones[ eltBones[ idb + 1 ] ].getOrCreateDebugColor();
	                            var c2 = bones[ eltBones[ idb + 2 ] ].getOrCreateDebugColor();
	                            var c3 = bones[ eltBones[ idb + 3 ] ].getOrCreateDebugColor();
	
	                            var w0 = eltWeights[ idb ];
	                            var w1 = eltWeights[ idb + 1 ];
	                            var w2 = eltWeights[ idb + 2 ];
	                            var w3 = eltWeights[ idb + 3 ];
	
	                            var idc = i * 3;
	                            bonesColor[ idc ] = w0 * c0[ 0 ] + w1 * c1[ 0 ] + w2 * c2[ 0 ] + w3 * c3[ 0 ];
	                            bonesColor[ idc + 1 ] = w0 * c0[ 1 ] + w1 * c1[ 1 ] + w2 * c2[ 1 ] + w3 * c3[ 1 ];
	                            bonesColor[ idc + 2 ] = w0 * c0[ 2 ] + w1 * c1[ 2 ] + w2 * c2[ 2 ] + w3 * c3[ 2 ];
	                        }
	
	                        vList.BonesColor = new BufferArray( BufferArray.ARRAY_BUFFER, bonesColor, 3 );
	                    }
	
	                } else {
	
	                    var color = Vec3.createAndSet( Math.random(), Math.random(), Math.random() );
	                    st.addUniform( Uniform.createFloat3( color, 'uColorDebug' ) );
	                    st.setShaderGeneratorName( 'debugGeometry' );
	
	                    // draw crosses
	                    var bb = node.getBound();
	
	                    var verts = new Float32Array( 18 );
	                    var off = bb.radius() * 0.1;
	                    verts[ 0 ] = off;
	                    verts[ 3 ] = -off;
	
	                    verts[ 7 ] = off;
	                    verts[ 10 ] = -off;
	
	                    verts[ 14 ] = off;
	                    verts[ 17 ] = -off;
	
	                    var geo = new Geometry();
	                    geo.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, verts, 3 );
	                    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, 6 );
	                    geo.getPrimitives().push( primitive );
	
	                    var mt = new MatrixTransform();
	                    var center = bb.center();
	                    mt.getMatrix()[ 12 ] = center[ 0 ];
	                    mt.getMatrix()[ 13 ] = center[ 1 ];
	                    mt.getMatrix()[ 14 ] = center[ 2 ];
	
	                    mt.addChild( geo );
	                    this.nodePath[ this.nodePath.length - 2 ].addChild( mt );
	                    color = Vec3.createAndSet( color[ 0 ] * 0.8, color[ 1 ] * 0.8, color[ 2 ] * 0.8 );
	                    geo.getOrCreateStateSet().addUniform( Uniform.createFloat3( color, 'uColorDebug' ) );
	                    mt.setStateSet( this._stCenter );
	
	                    mt._isCenterDebug = true;
	                }
	
	            } else if ( node._originalStateSet !== undefined ) {
	                node.setStateSet( node._originalStateSet || undefined );
	            }
	
	        }
	
	        this.traverse( node );
	    }
	} );
	
	module.exports = GeometryColorDebugVisitor;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var shaderLib = __webpack_require__( 168 );
	var shadowShaderLib = __webpack_require__( 176 );
	
	
	//     Shader as vert/frag/glsl files Using requirejs text plugin
	//     Preprocess features like:    //
	//     - Handle (recursive) include, avoiding code repeat and help code factorization
	//     - Handle per shader and global define/precision
	
	
	var ShaderProcessor = function ( createInstance ) {
	
	    if ( !createInstance ) {
	        if ( ShaderProcessor.instance ) {
	            return ShaderProcessor.instance;
	        }
	        ShaderProcessor.instance = this;
	    }
	
	    this.addShaders( shaderLib );
	    this.addShaders( shadowShaderLib );
	    return this;
	};
	
	ShaderProcessor.prototype = {
	    _shadersText: {},
	    _shadersList: {},
	    _globalDefaultprecision: '#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp float;\n #else\n precision mediump float;\n#endif',
	    _debugLines: false,
	    _includeR: /#pragma include "([^"]+)"/g,
	    _includeCondR: /#pragma include (["^+"]?["\ "[a-zA-Z_0-9](.*)"]*?)/g,
	    _defineR: /\#define\s+([a-zA-Z_0-9]+)/,
	    _precisionR: /precision\s+(high|low|medium)p\s+float/,
	
	
	    // {
	    //     'functions.glsl': textShaderFunctions,
	    //     'lights.glsl': textShaderFunctions,
	    //     'textures.glsl': textShaderFunctions
	    // };
	    addShaders: function ( shaders ) {
	
	        var keys = window.Object.keys( shaders );
	
	        keys.forEach( function ( key ) {
	
	            this._shadersList[ key ] = key;
	            this._shadersText[ key ] = shaders[ key ];
	
	        }, this );
	
	    },
	
	
	    instrumentShaderlines: function ( content, sourceID ) {
	        // TODO instrumentShaderlines
	        // http://immersedcode.org/2012/1/12/random-notes-on-webgl/
	        // one ID per "file"
	        // Each file has its line number starting at 0
	        //   handle include, the do that numbering also in preprocess...
	        // Then on shader error using sourceID and line you can point the correct line...
	        // has to attach that info to osg.shader object.
	        /*
	          var allLines = content.split('\n');
	          var i = 0;
	          for (var k = 0; k _< allLines.length; k++) {
	          if (!this._includeR.test(allLines[k])) {
	          allLines[k] = "#line " + (i++) + " " + sourceID + '\n' + allLines[k] ;
	          }
	          }
	          content = allLines.join('\n');
	        */
	
	        // seems just  prefixing first line seems ok to help renumbering error mesg
	        return '\n#line ' + 0 + ' ' + sourceID + '\n' + content;
	    },
	
	    getShaderTextPure: function ( shaderName ) {
	
	        var preShader = this._shadersText[ shaderName ];
	
	        if ( !preShader ) {
	            Notify.error( 'shader file/text: ' + shaderName + ' not registered' );
	            preShader = '';
	        }
	
	        return preShader;
	    },
	
	    getShader: function ( shaderName, defines, extensions, type ) {
	        var shader = this.getShaderTextPure( shaderName );
	        return this.processShader( shader, defines, extensions, type );
	    },
	
	    // recursively  handle #include external glsl
	    // files (for now in the same folder.)
	    preprocess: function ( content, sourceID, includeList, inputsDefines ) {
	        var self = this;
	        return content.replace( this._includeCondR, function ( _, name ) {
	            var includeOpt = name.split( ' ' );
	            var includeName = includeOpt[ 0 ].replace( /"/g, '' );
	
	            // pure include is
	            // \#pragma include "name";
	
	            // conditionnal include is name included if _PCF defined
	            // \#pragma include "name" "_PCF";
	            if ( includeOpt.length > 1 && inputsDefines ) {
	
	                // some conditions here.
	                // if not defined we do not include
	                var found = false;
	                var defines = inputsDefines.map( function ( defineString ) {
	                    // find '#define', remove duplicate whitespace, split on space and return the define Text
	                    return self._defineR.test( defineString ) && defineString.replace( /\s+/g, ' ' ).split( ' ' )[ 1 ];
	                } );
	
	                for ( var i = 1; i < includeOpt.length && !found; i++ ) {
	                    var key = includeOpt[ i ].replace( /"/g, '' );
	                    for ( var k = 0; k < defines.length && !found; k++ ) {
	
	                        if ( defines[ k ] !== false && defines[ k ] === key ) {
	                            found = true;
	                            break;
	                        }
	
	                    }
	                }
	                if ( !found )
	                    return '';
	            }
	
	            // already included
	            if ( includeList.indexOf( includeName ) !== -1 ) return '';
	            // avoid endless loop, not calling the impure
	            var txt = this.getShaderTextPure( includeName );
	            // make sure it's not included twice
	            includeList.push( includeName );
	            if ( this._debugLines ) {
	                txt = this.instrumentShaderlines( txt, sourceID );
	            }
	            sourceID++;
	            // to the infinite and beyond !
	            txt = this.preprocess( txt, sourceID, includeList, inputsDefines );
	            return txt;
	        }.bind( this ) );
	
	    },
	
	    //  process a shader and define
	    //  get a full expanded single shader source code
	    //  resolving include dependencies
	    //  adding defines
	    //  adding line instrumenting.
	    processShader: function ( shader, defines, extensions /*, type*/ ) {
	
	        var includeList = [];
	        var preShader = shader;
	        var sourceID = 0;
	        if ( this._debugLines ) {
	            preShader = this.instrumentShaderlines( preShader, sourceID );
	            sourceID++;
	        }
	
	        // removes duplicates
	        if ( defines !== undefined ) {
	            defines = defines.sort().filter( function ( item, pos ) {
	                return !pos || item !== defines[ pos - 1 ];
	            } );
	        }
	        if ( extensions !== undefined ) {
	            extensions = extensions.sort().filter( function ( item, pos ) {
	                return !pos || item !== extensions[ pos - 1 ];
	            } );
	        }
	
	        var postShader = this.preprocess( preShader, sourceID, includeList, defines );
	
	        var prePrend = '';
	        prePrend += '#version 100\n'; // webgl1  (webgl2 #version 130 ?)
	
	        // then
	        // it's extensions first
	        // See https://khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
	        // p14-15: before any non-processor token
	        // add them
	        if ( extensions !== undefined ) {
	            // could add an extension check support warning there...
	            prePrend += extensions.join( '\n' ) + '\n';
	        }
	
	        // vertex shader doesn't need precision, it's highp per default, enforced per spec
	        // but then not giving precision on uniform/varying might make conflicts arise
	        // between both FS and VS if FS default is mediump !
	        // && type !== 'vertex'
	        if ( this._globalDefaultprecision ) {
	            if ( !this._precisionR.test( postShader ) ) {
	                // use the shaderhighprecision flag at shaderloader start
	                //var highp = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
	                //var highpSupported = highp.precision != 0;
	                prePrend += this._globalDefaultprecision + '\n';
	            }
	        }
	
	        // if defines
	        // add them
	        if ( defines !== undefined ) {
	            prePrend += defines.join( '\n' ) + '\n';
	        }
	        postShader = prePrend + postShader;
	
	        return postShader;
	    }
	};
	module.exports = ShaderProcessor;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var functions = __webpack_require__( 169 );
	var lights = __webpack_require__( 170 );
	var skinning = __webpack_require__( 171 );
	var textures = __webpack_require__( 172 );
	var colorEncode = __webpack_require__( 173 );
	var noise = __webpack_require__( 174 );
	var billboard = __webpack_require__( 175 );
	module.exports = {
	    'functions.glsl': functions,
	    'lights.glsl': lights,
	    'skinning.glsl': skinning,
	    'textures.glsl': textures,
	    'colorEncode.glsl': colorEncode,
	    'noise.glsl': noise,
	    'billboard.glsl': billboard
	};


/***/ }),
/* 169 */
/***/ (function(module, exports) {

	module.exports = "// the approximation :\n// http://chilliant.blogspot.fr/2012/08/srgb-approximations-for-hlsl.html\n// introduced slightly darker colors and more slight banding in the darks.\n// The reference implementation (or even a single pow approx) did not introduced these effects.\n\n// so for now we stick with the reference implementation :\n// https://www.khronos.org/registry/gles/extensions/EXT/EXT_sRGB.txt\n// with the slight changes :\n// - we always assume the color is >= 0.0 (so no check)\n// - unlike the previous approximation, linear to srgb is monotonic so we don't need to check if the color is > 1\n\n#define LIN_SRGB(x) x < 0.0031308 ? x * 12.92 : 1.055 * pow(x, 1.0/2.4) - 0.055\nfloat linearTosRGB(const in float c) {\n    return LIN_SRGB(c);\n}\nvec3 linearTosRGB(const in vec3 c) {\n    return vec3(LIN_SRGB(c.r), LIN_SRGB(c.g), LIN_SRGB(c.b));\n}\nvec4 linearTosRGB(const in vec4 c) {\n    return vec4(LIN_SRGB(c.r), LIN_SRGB(c.g), LIN_SRGB(c.b), c.a);\n}\n\n#define SRGB_LIN(x) x < 0.04045 ? x * (1.0 / 12.92) : pow((x + 0.055) * (1.0 / 1.055), 2.4)\nfloat sRGBToLinear(const in float c) {\n    return SRGB_LIN(c);\n}\nvec3 sRGBToLinear(const in vec3 c) {\n    return vec3(SRGB_LIN(c.r), SRGB_LIN(c.g), SRGB_LIN(c.b));\n}\nvec4 sRGBToLinear(const in vec4 c) {\n    return vec4(SRGB_LIN(c.r), SRGB_LIN(c.g), SRGB_LIN(c.b), c.a);\n}\n\n//http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html\nvec3 RGBMToRGB( const in vec4 rgba ) {\n    const float maxRange = 8.0;\n    return rgba.rgb * maxRange * rgba.a;\n}\n\nconst mat3 LUVInverse = mat3( 6.0013,    -2.700,   -1.7995,\n                              -1.332,    3.1029,   -5.7720,\n                              0.3007,    -1.088,    5.6268 );\n\nvec3 LUVToRGB( const in vec4 vLogLuv ) {\n    float Le = vLogLuv.z * 255.0 + vLogLuv.w;\n    vec3 Xp_Y_XYZp;\n    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;\n    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;\n    vec3 vRGB = LUVInverse * Xp_Y_XYZp;\n    return max(vRGB, 0.0);\n}\n\n// http://graphicrants.blogspot.fr/2009/04/rgbm-color-encoding.html\nvec4 encodeRGBM(const in vec3 col, const in float range) {\n    if(range <= 0.0)\n        return vec4(col, 1.0);\n    vec4 rgbm;\n    vec3 color = col / range;\n    rgbm.a = clamp( max( max( color.r, color.g ), max( color.b, 1e-6 ) ), 0.0, 1.0 );\n    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;\n    rgbm.rgb = color / rgbm.a;\n    return rgbm;\n}\n\nvec3 decodeRGBM(const in vec4 col, const in float range) {\n    if(range <= 0.0)\n        return col.rgb;\n    return range * col.rgb * col.a;\n}"

/***/ }),
/* 170 */
/***/ (function(module, exports) {

	module.exports = "////////////////\n// ATTENUATION\n/////////////\nfloat getLightAttenuation(const in float dist, const in vec4 lightAttenuation)\n{\n    // lightAttenuation(constantEnabled, linearEnabled, quadraticEnabled)\n    // TODO find a vector alu instead of 4 scalar\n    float constant = lightAttenuation.x;\n    float linear = lightAttenuation.y*dist;\n    float quadratic = lightAttenuation.z*dist*dist;\n    return 1.0 / ( constant + linear + quadratic );\n}\n//\n// LIGHTING EQUATION TERMS\n///\nvoid specularCookTorrance(const in vec3 n, const in vec3 l, const in vec3 v, const in float hard, const in vec3 materialSpecular, const in vec3 lightSpecular, out vec3 specularContrib)\n{\n    vec3 h = normalize(v + l);\n    float nh = dot(n, h);\n    float specfac = 0.0;\n\n    if(nh > 0.0) {\n        float nv = max( dot(n, v), 0.0 );\n        float i = pow(nh, hard);\n        i = i / (0.1 + nv);\n        specfac = i;\n    }\n    // ugly way to fake an energy conservation (mainly to avoid super bright stuffs with low glossiness)\n    float att = hard > 100.0 ? 1.0 : smoothstep(0.0, 1.0, hard * 0.01);\n    specularContrib = specfac*materialSpecular*lightSpecular*att;\n}\n\nvoid lambert(const in float ndl,  const in vec3 materialDiffuse, const in vec3 lightDiffuse, out vec3 diffuseContrib)\n{\n    diffuseContrib = ndl*materialDiffuse*lightDiffuse;\n}\n////////////////////////\n/// Main func\n///////////////////////\n\n/// for each light\n//direction, dist, NDL, attenuation, compute diffuse, compute specular\n\nvec3 computeSpotLightShading(\n                             const in vec3 normal,\n                             const in vec3 eyeVector,\n\n                             const in vec3 materialAmbient,\n                             const in vec3 materialDiffuse,\n                             const in vec3 materialSpecular,\n                             const in float materialShininess,\n\n                             const in vec3 lightAmbient,\n                             const in vec3 lightDiffuse,\n                             const in vec3 lightSpecular,\n\n                             const in vec3  lightSpotDirection,\n                             const in vec4  lightAttenuation,\n                             const in vec4  lightSpotPosition,\n                             const in float lightCosSpotCutoff,\n                             const in float lightSpotBlend,\n\n                             const in mat4 lightMatrix,\n                             const in mat4 lightInvMatrix,\n\n                             out vec3 eyeLightPos,\n                             out vec3 eyeLightDir,\n                             out float NdotL,\n                             out bool lighted)\n{\n    lighted = false;\n    eyeLightPos = vec3(lightMatrix * lightSpotPosition);\n    eyeLightDir = eyeLightPos - FragEyeVector.xyz;\n    // compute dist\n    float dist = length(eyeLightDir);\n    // compute attenuation\n    float attenuation = getLightAttenuation(dist, lightAttenuation);\n    if (attenuation != 0.0)\n        {\n            // compute direction\n            eyeLightDir = dist > 0.0 ? eyeLightDir / dist :  vec3( 0.0, 1.0, 0.0 );\n            if (lightCosSpotCutoff > 0.0)\n                {\n                    //compute lightSpotBlend\n                    vec3 lightSpotDirectionEye = normalize(mat3(vec3(lightInvMatrix[0]), vec3(lightInvMatrix[1]), vec3(lightInvMatrix[2]))*lightSpotDirection);\n\n                    float cosCurAngle = dot(-eyeLightDir, lightSpotDirectionEye);\n                    float diffAngle = cosCurAngle - lightCosSpotCutoff;\n                    float spot = 1.0;\n                    if ( diffAngle < 0.0 ) {\n                        spot = 0.0;\n                    } else {\n                        if ( lightSpotBlend > 0.0 )\n                            spot = cosCurAngle * smoothstep(0.0, 1.0, (cosCurAngle - lightCosSpotCutoff) / (lightSpotBlend));\n                    }\n\n                    if (spot > 0.0)\n                        {\n                            // compute NdL\n                            NdotL = dot(eyeLightDir, normal);\n                            if (NdotL > 0.0)\n                                {\n                                    lighted = true;\n                                    vec3 diffuseContrib;\n                                    lambert(NdotL, materialDiffuse, lightDiffuse, diffuseContrib);\n                                    vec3 specularContrib;\n                                    specularCookTorrance(normal, eyeLightDir, eyeVector, materialShininess, materialSpecular, lightSpecular, specularContrib);\n                                    return spot * attenuation * (diffuseContrib + specularContrib);\n                                }\n                        }\n                }\n        }\n    return vec3(0.0);\n}\n\nvec3 computePointLightShading(\n                              const in vec3 normal,\n                              const in vec3 eyeVector,\n\n                              const in vec3 materialAmbient,\n                              const in vec3 materialDiffuse,\n                              const in vec3 materialSpecular,\n                              const in float materialShininess,\n\n                              const in vec3 lightAmbient,\n                              const in vec3 lightDiffuse,\n                              const in vec3 lightSpecular,\n\n                              const in vec4 lightPosition,\n                              const in vec4 lightAttenuation,\n\n                              const in mat4 lightMatrix,\n\n                              out vec3 eyeLightPos,\n                              out vec3 eyeLightDir,\n                              out float NdotL,\n                              out bool lighted)\n{\n\n    eyeLightPos =  vec3(lightMatrix * lightPosition);\n    eyeLightDir = eyeLightPos - FragEyeVector.xyz;\n    float dist = length(eyeLightDir);\n    // compute dist\n    // compute attenuation\n    float attenuation = getLightAttenuation(dist, lightAttenuation);\n    if (attenuation != 0.0)\n        {\n            // compute direction\n            eyeLightDir = dist > 0.0 ? eyeLightDir / dist :  vec3( 0.0, 1.0, 0.0 );\n            // compute NdL\n            NdotL = dot(eyeLightDir, normal);\n            if (NdotL > 0.0)\n                {\n                    lighted = true;\n                    vec3 diffuseContrib;\n                    lambert(NdotL, materialDiffuse, lightDiffuse, diffuseContrib);\n                    vec3 specularContrib;\n                    specularCookTorrance(normal, eyeLightDir, eyeVector, materialShininess, materialSpecular, lightSpecular, specularContrib);\n                    return attenuation * (diffuseContrib + specularContrib);\n                }\n        }\n    return vec3(0.0);\n}\n\nvec3 computeSunLightShading(\n\n                            const in vec3 normal,\n                            const in vec3 eyeVector,\n\n                            const in vec3 materialAmbient,\n                            const in vec3 materialDiffuse,\n                            const in vec3 materialSpecular,\n                            const in float materialShininess,\n\n                            const in vec3 lightAmbient,\n                            const in vec3 lightDiffuse,\n                            const in vec3 lightSpecular,\n\n                            const in vec4 lightPosition,\n\n                            const in mat4 lightMatrix,\n\n                            out vec3 eyeLightDir,\n                            out float NdotL,\n                            out bool lighted)\n{\n\n    lighted = false;\n    eyeLightDir = normalize( vec3(lightMatrix * lightPosition ) );\n    // compute NdL   // compute NdL\n    NdotL = dot(eyeLightDir, normal);\n    if (NdotL > 0.0)\n        {\n            lighted = true;\n            vec3 diffuseContrib;\n            lambert(NdotL, materialDiffuse, lightDiffuse, diffuseContrib);\n            vec3 specularContrib;\n            specularCookTorrance(normal, eyeLightDir, eyeVector, materialShininess, materialSpecular, lightSpecular, specularContrib);\n            return (diffuseContrib + specularContrib);\n        }\n    return vec3(0.0);\n}\n\nvec3 computeHemiLightShading(\n\n    const in vec3 normal,\n    const in vec3 eyeVector,\n\n    const in vec3 materialDiffuse,\n    const in vec3 materialSpecular,\n    const in float materialShininess,\n\n    const in vec3 lightDiffuse,\n    const in vec3 lightGround,\n\n    const in vec4 lightPosition,\n\n    const in mat4 lightMatrix,\n\n    out vec3 eyeLightDir,\n    out float NdotL,\n    out bool lighted)\n{\n    lighted = false;\n\n    eyeLightDir = normalize( vec3(lightMatrix * lightPosition ) );\n    NdotL = dot(eyeLightDir, normal);\n    float weight = 0.5 * NdotL + 0.5;\n    vec3 diffuseContrib = materialDiffuse * mix(lightGround, lightDiffuse, weight);\n\n    // same cook-torrance as above for sky/ground\n    float skyWeight = 0.5 * dot(normal, normalize(eyeVector + eyeLightDir)) + 0.5;\n    float gndWeight = 0.5 * dot(normal, normalize(eyeVector - eyeLightDir)) + 0.5;\n    float skySpec = pow(skyWeight, materialShininess);\n    float skyGround = pow(gndWeight, materialShininess);\n    float divisor = (0.1 + max( dot(normal, eyeVector), 0.0 ));\n    float att = materialShininess > 100.0 ? 1.0 : smoothstep(0.0, 1.0, materialShininess * 0.01);\n    vec3 specularContrib = lightDiffuse * materialSpecular * weight * att * (skySpec + skyGround) / divisor;\n\n    return diffuseContrib + specularContrib;\n}\n"

/***/ }),
/* 171 */
/***/ (function(module, exports) {

	module.exports = "//////////////////////////////\n// OPTIMIZED VERSION (NO IF)\n//////////////////////////////\nmat4 skeletalTransform( const in vec4 weightsVec, const in vec4 bonesIdx ) {\n    mat4 outMat_1;\n    mat4 tmpMat_2;\n    highp ivec4 tmpvar_3;\n    tmpvar_3 = (3 * ivec4(bonesIdx));\n    tmpMat_2 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    vec4 tmpvar_4;\n    tmpvar_4 = -(abs(weightsVec));\n    tmpMat_2[0] = uBones[tmpvar_3.x];\n    tmpMat_2[1] = uBones[(tmpvar_3.x + 1)];\n    tmpMat_2[2] = uBones[(tmpvar_3.x + 2)];\n    outMat_1 = ((float(\n    ((tmpvar_4.x + tmpvar_4.y) >= -((tmpvar_4.z + tmpvar_4.w)))\n    ) * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)) + (weightsVec.x * tmpMat_2));\n    tmpMat_2[0] = uBones[tmpvar_3.y];\n    tmpMat_2[1] = uBones[(tmpvar_3.y + 1)];\n    tmpMat_2[2] = uBones[(tmpvar_3.y + 2)];\n    outMat_1 = (outMat_1 + (weightsVec.y * tmpMat_2));\n    tmpMat_2[0] = uBones[tmpvar_3.z];\n    tmpMat_2[1] = uBones[(tmpvar_3.z + 1)];\n    tmpMat_2[2] = uBones[(tmpvar_3.z + 2)];\n    outMat_1 = (outMat_1 + (weightsVec.z * tmpMat_2));\n    tmpMat_2[0] = uBones[tmpvar_3.w];\n    tmpMat_2[1] = uBones[(tmpvar_3.w + 1)];\n    tmpMat_2[2] = uBones[(tmpvar_3.w + 2)];\n    outMat_1 = (outMat_1 + (weightsVec.w * tmpMat_2));\n\n    return outMat_1;\n}\n\n//////////////////////////////\n// UN-OPTIMIZED VERSION (WITH IF)\n//////////////////////////////\n\n// //http://http.developer.nvidia.com/GPUGems/gpugems_ch04.html\n// mat4 getMat4FromVec4( const int index, inout mat4 myMat ) {\n//     // We have to use a global variable because we can't access dynamically\n//     // matrix is transpose so we should do vec * matrix\n//     myMat[0] = uBones[ index ];\n//     myMat[1] = uBones[ index + 1];\n//     myMat[2] = uBones[ index + 2];\n//     return myMat;\n// }\n\n// mat4 skeletalTransform( const in vec4 weightsVec, const in vec4 bonesIdx ) {\n//     ivec4 idx =  3 * ivec4(bonesIdx);\n//     mat4 tmpMat = mat4(1.0);\n//     mat4 outMat = mat4(0.0);\n\n//     // we handle negative weights\n//     if(all(equal(weightsVec, vec4(0.0)))) return tmpMat;\n\n//     if(weightsVec.x != 0.0) outMat += weightsVec.x * getMat4FromVec4( idx.x, tmpMat );\n//     if(weightsVec.y != 0.0) outMat += weightsVec.y * getMat4FromVec4( idx.y, tmpMat );\n//     if(weightsVec.z != 0.0) outMat += weightsVec.z * getMat4FromVec4( idx.z, tmpMat );\n//     if(weightsVec.w != 0.0) outMat += weightsVec.w * getMat4FromVec4( idx.w, tmpMat );\n//     return outMat;\n// }\n\n//////////////////////////////\n// UN-OPTIMIZED VERSION (NO IF)\n//////////////////////////////\n\n// mat4 skeletalTransform( const in vec4 weightsVec, const in vec4 bonesIdx ) {\n//     ivec4 idx =  3 * ivec4(bonesIdx);\n//     mat4 tmpMat = mat4(1.0);\n\n//     // if sum is 0, return identity\n//     vec4 absWeights = -abs(weightsVec);\n//     mat4 outMat = step(0.0, absWeights.x + absWeights.y + absWeights.z + absWeights.w) * tmpMat;\n\n//     // we handle negative weights\n//     // outMat[3][3] += weightsVec.x + weightsVec.y + weightsVec.z + weightsVec.w;\n\n//     tmpMat[0] = uBones[ idx.x ];\n//     tmpMat[1] = uBones[ idx.x + 1];\n//     tmpMat[2] = uBones[ idx.x + 2];\n//     outMat += weightsVec.x * tmpMat;\n\n//     tmpMat[0] = uBones[ idx.y ];\n//     tmpMat[1] = uBones[ idx.y + 1];\n//     tmpMat[2] = uBones[ idx.y + 2];\n//     outMat += weightsVec.y * tmpMat;\n\n//     tmpMat[0] = uBones[ idx.z ];\n//     tmpMat[1] = uBones[ idx.z + 1];\n//     tmpMat[2] = uBones[ idx.z + 2];\n//     outMat += weightsVec.z * tmpMat;\n\n//     tmpMat[0] = uBones[ idx.w ];\n//     tmpMat[1] = uBones[ idx.w + 1];\n//     tmpMat[2] = uBones[ idx.w + 2];\n//     outMat += weightsVec.w * tmpMat;\n\n//     return outMat;\n// }\n"

/***/ }),
/* 172 */
/***/ (function(module, exports) {

	module.exports = "vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {\n    return texture2D(texture, uv.xy ).rgb;\n}\n\nvec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {\n    return texture2D(texture, uv.xy ).rgba;\n}\n\nfloat textureIntensity(const in sampler2D texture, const in vec2 uv) {\n    return texture2D(texture, uv).r;\n}\n\nfloat textureAlpha(const in sampler2D texture, const in vec2 uv) {\n    return texture2D(texture, uv.xy ).a;\n}\n"

/***/ }),
/* 173 */
/***/ (function(module, exports) {

	module.exports = "\nfloat decodeFloatRGBA( vec4 rgba ) {\n    return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\n\nvec4 encodeFloatRGBA( float v ) {\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n    return enc;\n}\n\nvec2 decodeHalfFloatRGBA( vec4 rgba ) {\n    return vec2(rgba.x + (rgba.y / 255.0), rgba.z + (rgba.w / 255.0));\n}\n\nvec4 encodeHalfFloatRGBA( vec2 v ) {\n    const vec2 bias = vec2(1.0 / 255.0, 0.0);\n    vec4 enc;\n    enc.xy = vec2(v.x, fract(v.x * 255.0));\n    enc.xy = enc.xy - (enc.yy * bias);\n\n    enc.zw = vec2(v.y, fract(v.y * 255.0));\n    enc.zw = enc.zw - (enc.ww * bias);\n    return enc;\n}\n"

/***/ }),
/* 174 */
/***/ (function(module, exports) {

	module.exports = "#pragma include \"hash.glsl\"\n\n//// noise glsl\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise2D(const in vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n//// end noise glsl\n"

/***/ }),
/* 175 */
/***/ (function(module, exports) {

	module.exports = "vec3 getScale( const in mat4 matrix ) {\n      // Only working with positive scales.\n      float xs = matrix[0][0] * matrix[0][1] * matrix[0][2] * matrix[0][3] < 0. ? -1. : 1.;\n      float ys = matrix[1][0] * matrix[1][1] * matrix[1][2] * matrix[1][3] < 0. ? -1. : 1.;\n      float zs = matrix[2][0] * matrix[2][1] * matrix[2][2] * matrix[2][3] < 0. ? -1. : 1.;\n      vec3 scale;\n      scale.x = xs * sqrt( matrix[0][0] * matrix[0][0] + matrix[0][1] * matrix[0][1] + matrix[0][2] * matrix[0][2]);\n      scale.y = ys * sqrt( matrix[1][0] * matrix[1][0] + matrix[1][1] * matrix[1][1] + matrix[1][2] * matrix[1][2]);\n      scale.z = zs * sqrt( matrix[2][0] * matrix[2][0] + matrix[2][1] * matrix[2][1] + matrix[2][2] * matrix[2][2]);\n      return scale;\n}\n\nvec4 billboard( const in vec3 vertex, const in mat4 modelViewMatrix, const in mat4 projectionMatrix ) {\n      vec3 scale = getScale( modelViewMatrix );\n      return projectionMatrix * ( vec4( scale.x* vertex.x , scale.y * vertex.y, scale.z * vertex.z, 1.0 ) + vec4( modelViewMatrix[ 3 ].xyz, 0.0 ) );\n}\n"

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var shadowsCastFrag = __webpack_require__( 177 );
	var shadowsReceive = __webpack_require__( 178 );
	var shadowsReceiveMain = __webpack_require__( 179 );
	var shadowLinearSoft = __webpack_require__( 180 );
	var pcf = __webpack_require__( 181 );
	var bandPCF = __webpack_require__( 182 );
	var tapPCF = __webpack_require__( 183 );
	var hash = __webpack_require__( 184 );
	var arrayPoisson = __webpack_require__( 185 );
	var poissonPCF = __webpack_require__( 186 );
	var esm = __webpack_require__( 187 );
	var vsm = __webpack_require__( 188 );
	var evsm = __webpack_require__( 189 );
	
	module.exports = {
	    'shadowsCastFrag.glsl': shadowsCastFrag,
	    'shadowsReceive.glsl': shadowsReceive,
	    'shadowsReceiveMain.glsl': shadowsReceiveMain,
	    'shadowLinearSoft.glsl': shadowLinearSoft,
	    'pcf.glsl': pcf,
	    'bandPCF.glsl': bandPCF,
	    'tapPCF.glsl': tapPCF,
	    'hash.glsl': hash,
	    'arrayPoisson.glsl': arrayPoisson,
	    'poissonPCF.glsl': poissonPCF,
	    'esm.glsl': esm,
	    'vsm.glsl': vsm,
	    'evsm.glsl': evsm
	};


/***/ }),
/* 177 */
/***/ (function(module, exports) {

	module.exports = "\n#pragma include \"colorEncode.glsl\"\n\n// see shadowSettings.js header for shadow algo param explanations\n\n#ifdef _EVSM\n// Convert depth to EVSM coefficients\n// Input depth should be in [0, 1]\nvec2 warpDepth(const in float depth, const in vec2 exponents) {\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\n// Convert depth value to EVSM representation\nvec4 shadowDepthToEVSM(const in float depth, const in float expo0, const in float expo1) {\n    vec2 warpedDepth = warpDepth(depth, vec2(expo0, expo1));\n    return vec4(warpedDepth.xy, warpedDepth.xy * warpedDepth.xy);\n}\n#endif // _EVSM\n\n\n#if defined(_NONE) ||  defined(_PCF)\nvec4 computeShadowDepth(const in vec4 fragEye,\n                        const in vec4 shadowRange)\n#else\nvec4 computeShadowDepth(const in vec4 fragEye,\n                        const in vec4 shadowRange,\n                        const in float expo0,\n                        const in float expo1)\n#endif\n{\n    // distance to camera\n    float depth =  -fragEye.z * fragEye.w;\n    // most precision near 0, make sure we are near 0 and in  [0,1]\n    depth = (depth - shadowRange.x ) * shadowRange.w;\n\n    vec4 outputFrag;\n\n#if defined (_FLOATTEX) && defined(_PCF)\n    outputFrag = vec4(depth, 0.0, 0.0, 1.0);\n#elif defined (_FLOATTEX)  && defined(_ESM)\n    float depthScale = expo1;\n    depth = exp(-depth * depthScale);\n    outputFrag = vec4(depth, 0.0, 0.0, 1.0);\n#elif defined (_FLOATTEX)  && defined(_VSM)\n    outputFrag = vec4(depth, depth * depth, 0.0, 1.0);\n#elif defined (_FLOATTEX)  && defined(_EVSM)\n    outputFrag = shadowDepthToEVSM(depth, expo0, expo1);\n#elif defined (_FLOATTEX) // && defined(_NONE)\n    outputFrag = vec4(depth, 0.0, 0.0, 1.0);\n#elif defined(_PCF)\n    outputFrag = encodeFloatRGBA(depth);\n#elif defined(_ESM)\n    float depthScale = expo1;\n    depthScale = exp(-depth * depthScale);\n    outputFrag = encodeFloatRGBA(depthScale);\n#elif defined(_VSM)\n    outputFrag = encodeHalfFloatRGBA(vec2(depth, depth* depth));\n#else // NONE\n    outputFrag = encodeFloatRGBA(depth);\n\n#endif\n\n    return outputFrag;\n}\n"

/***/ }),
/* 178 */
/***/ (function(module, exports) {

	module.exports = "//begin shadows\n\n#pragma include \"colorEncode.glsl\"\n\n// see shadowSettings.js header for shadow algo param explanations\n\n// end Float codec\nfloat getSingleFloatFromTex(const in sampler2D depths, const in vec2 uv){\n#ifndef _FLOATTEX\n    return  decodeFloatRGBA(texture2D(depths, uv));\n#else\n    return texture2D(depths, uv).x;\n#endif\n}\n\nvec2 getDoubleFloatFromTex(const in sampler2D depths, const in vec2 uv){\n#ifndef _FLOATTEX\n    return decodeHalfFloatRGBA(texture2D(depths, uv));\n#else\n    return texture2D(depths, uv).xy;\n#endif\n}\n\nvec4 getQuadFloatFromTex(const in sampler2D depths, const in vec2 uv){\n    return texture2D(depths, uv).xyzw;\n}\n// end Float codec\n\n\n#pragma include \"vsm.glsl\" \"_VSM\"\n\n#pragma include \"evsm.glsl\" \"_EVSM\"\n\n#pragma include \"esm.glsl\" \"_ESM\"\n\n#pragma include \"pcf.glsl\" \"_NONE\" \"_PCF\""

/***/ }),
/* 179 */
/***/ (function(module, exports) {

	module.exports = "\n    if (!lighted)\n        return 1.;\n\n    if (depthRange.x == depthRange.y)\n        return 1.;\n\n    vec4 shadowVertexEye = shadowViewMatrix *  vec4(vertexWorld, 1.0);\n    float shadowReceiverZ =  - shadowVertexEye.z;\n\n    if( shadowReceiverZ < 0.0)\n        return 1.0; // notably behind camera\n\n    vec4 shadowVertexProjected = shadowProjectionMatrix * shadowVertexEye;\n    if (shadowVertexProjected.w < 0.0)\n        return 1.0; // notably behind camera\n\n    vec2 shadowUV;\n\n    shadowUV.xy = shadowVertexProjected.xy / shadowVertexProjected.w;\n    shadowUV.xy = shadowUV.xy * 0.5 + 0.5;// mad like\n\n    bool outFrustum = any(bvec4 ( shadowUV.x > 1., shadowUV.x < 0., shadowUV.y > 1., shadowUV.y < 0. ));\n    if (outFrustum )\n        return 1.0;// limits of light frustum\n    // most precision near 0, make sure we are near 0 and in [0,1]\n    shadowReceiverZ =  (shadowReceiverZ - depthRange.x)* depthRange.w;\n\n    // depth bias: fighting shadow acne (depth imprecsion z-fighting)\n    float shadowBias = 0.0;\n    // cosTheta is dot( n, l ), clamped between 0 and 1\n    //float shadowBias = 0.005*tan(acos(N_Dot_L));\n    // same but 4 cycles instead of 15\n    shadowBias += 0.05 *  sqrt( 1. -  N_Dot_L*N_Dot_L) / clamp(N_Dot_L, 0.0005,  1.0);\n\n    //That makes sure that plane perpendicular to light doesn't flicker due to\n    //selfshadowing and 1 = dot(Normal, Light) using a min bias\n    shadowBias = clamp(shadowBias, 0.00005,  bias);\n\n    // shadowZ must be clamped to [0,1]\n    // otherwise it's not comparable to\n    // shadow caster depth map\n    // which is clamped to [0,1]\n    // Not doing that makes ALL shadowReceiver > 1.0 black\n    // because they ALL becomes behind any point in Caster depth map\n    shadowReceiverZ = clamp(shadowReceiverZ, 0., 1. - shadowBias);\n\n    shadowReceiverZ -= shadowBias;\n\n    // Now computes Shadow\n\n    // Calculate shadow amount\n    float shadow = 1.0;\n\n    // return 0.0 for black;\n    // return 1.0 for light;\n\n#ifdef _NONE\n\n    float shadowDepth = getSingleFloatFromTex(tex, shadowUV.xy);\n    // shadowReceiverZ : receiver depth in light view\n    // shadowDepth : caster depth in light view\n    // receiver is shadowed if its depth is superior to the caster\n    shadow = ( shadowReceiverZ > shadowDepth ) ? 0.0 : 1.0;\n\n#elif defined( _PCF )\n    // pcf pbias to add on offset\n    vec2 shadowBiasPCF = vec2(0.);\n\n\n// looks like derivative is broken on some mac + intel cg ...\n#ifdef GL_OES_standard_derivatives\n\n    shadowBiasPCF.x = clamp(dFdx(shadowReceiverZ)* shadowMapSize.z, -1.0, 1.0 );\n    shadowBiasPCF.y = clamp(dFdy(shadowReceiverZ)* shadowMapSize.w, -1.0, 1.0 );\n    \n#endif\n\n\n    shadow = getShadowPCF(tex, shadowMapSize, shadowUV, shadowReceiverZ, shadowBiasPCF);\n\n#elif defined( _ESM )\n\n    shadow = fetchESM(tex, shadowMapSize, shadowUV, shadowReceiverZ, exponent0, exponent1);\n\n#elif  defined( _VSM )\n\n    vec2 moments = getDoubleFloatFromTex(tex, shadowUV.xy);\n    shadow = chebyshevUpperBound(moments, shadowReceiverZ, epsilonVSM);\n\n#elif  defined( _EVSM )\n\n    vec4 occluder = getQuadFloatFromTex(tex, shadowUV.xy);\n    vec2 exponents = vec2(exponent0, exponent1);\n    vec2 warpedDepth = warpDepth(shadowReceiverZ, exponents);\n\n    float derivationEVSM = epsilonVSM;\n    // Derivative of warping at depth\n    vec2 depthScale = derivationEVSM * exponents * warpedDepth;\n    vec2 minVariance = depthScale * depthScale;\n\n    float epsilonEVSM = -epsilonVSM;\n\n    // Compute the upper bounds of the visibility function both for x and y\n    float posContrib = chebyshevUpperBound(occluder.xz, -warpedDepth.x, minVariance.x);\n    float negContrib = chebyshevUpperBound(occluder.yw, warpedDepth.y, minVariance.y);\n\n    shadow = min(posContrib, negContrib);\n\n#endif\n\n\n    return shadow;\n"

/***/ }),
/* 180 */
/***/ (function(module, exports) {

	module.exports = "\n// simulation of texture2Dshadow glsl call on HW\n// http://codeflow.org/entries/2013/feb/15/soft-shadow-mapping/\nfloat texture2DCompare(const in sampler2D depths, const in vec2 uv, const in float compare){\n\n    float depth = getSingleFloatFromTex(depths, uv);\n    return step(compare, depth);\n\n}\n\n// simulates linear fetch like texture2d shadow\nfloat texture2DShadowLerp(const in sampler2D depths, const in vec4 size, const in vec2 uv, const in float compare){\n\n#if defined(_FAKE_PCF)\n    // CHEAT: it's wrong, but 4x faster\n    // wronb because http://www.eng.utah.edu/~cs5610/handouts/reeves87.pdf p2\n    return texture2DCompare(depths, uv, compare);\n#else\n    vec2 f = fract(uv*size.xy+0.5);\n    vec2 centroidUV = floor(uv*size.xy+0.5)*size.zw;\n\n    float lb = texture2DCompare(depths, centroidUV+size.zw*vec2(0.0, 0.0), compare);\n    float lt = texture2DCompare(depths, centroidUV+size.zw*vec2(0.0, 1.0), compare);\n    float rb = texture2DCompare(depths, centroidUV+size.zw*vec2(1.0, 0.0), compare);\n    float rt = texture2DCompare(depths, centroidUV+size.zw*vec2(1.0, 1.0), compare);\n    float a = mix(lb, lt, f.y);\n    float b = mix(rb, rt, f.y);\n    float c = mix(a, b, f.x);\n    return c;\n#endif\n\n}\n"

/***/ }),
/* 181 */
/***/ (function(module, exports) {

	module.exports = "\n#pragma include \"bandPCF.glsl\" \"_BAND_PCF\"\n#pragma include \"poissonPCF.glsl\" \"_POISSON_PCF\"\n#pragma include \"tapPCF.glsl\" \"_TAP_PCF\"\n\nfloat computeShadow(const in bool lighted,\n                    const in sampler2D tex,\n                    const in vec4 shadowMapSize,\n                    const in mat4 shadowProjectionMatrix,\n                    const in mat4 shadowViewMatrix,\n                    const in vec4 depthRange,\n                    const in float N_Dot_L,\n                    const in vec3 vertexWorld,\n                    const in float bias\n    )\n{\n    #pragma include \"shadowsReceiveMain.glsl\" \"_PCF\" \"_NONE\"\n\n\n\n}\n"

/***/ }),
/* 182 */
/***/ (function(module, exports) {

	module.exports = "\n\n\nfloat getShadowPCF(const in sampler2D tex, const in vec4 size, const in vec2 uv, const in float shadowZ, const in vec2 biasPCF) {\n\n    float shadowed = 0.0;\n\n    #define TSF(off1, off2) getSingleFloatFromTex( tex, uv.xy + vec2(off1, off2) + biasPCF )\n\n    float dx0 = -size.z;\n    float dy0 = -size.w;\n    float dx1 = size.z;\n    float dy1 = size.w;\n\n    // fastest but gives banding\n#if defined(_PCFx4)\n\n    vec4 sV;\n\n    // vector ops faster alu\n    sV.x = TSF( dx0, dy0 );\n    sV.y = TSF( dx1, dy0 );\n    sV.z = TSF( dx1, dy0 );\n    sV.w = TSF( dx1, dy1 );\n    sV = vec4(lessThan(vec4(shadowZ), sV  ));\n    shadowed = dot(sV, vec4(0.25));\n\n    // here still didn't querying the real shadow at uv.\n    // This could be a single func checking for branching\n    // like before going to x9, x16 or anything\n    // or even complex \"blurring\"\n    if (shadowed != 0.0) // we're on an edge\n    {\n        shadowed += step(shadowZ, TSF(0.0, 0.0));\n        shadowed *= 0.5;\n    }\n\n#elif defined(_PCFx9)\n\n\n    mat3 kern;\n    mat3 depthKernel;\n\n\n    depthKernel[0][0] = TSF( dx0, dy0 );\n    depthKernel[0][1] = TSF( dx0, 0.0 );\n    depthKernel[0][2] = TSF( dx0, dy1 );\n    depthKernel[1][0] = TSF( 0.0, dy0 );\n    depthKernel[1][1] = TSF( 0.0, 0.0 );\n    depthKernel[1][2] = TSF( 0.0, dy1 );\n    depthKernel[2][0] = TSF( dx1, dy0 );\n    depthKernel[2][1] = TSF( dx1, 0.0 );\n    depthKernel[2][2] = TSF( dx1, dy1 );\n\n    // using 4 vector ops to save ALU\n    // filter is done post dept/shadow compare\n    vec3 shadowZ3 = vec3( shadowZ );\n    kern[0] = vec3(lessThan(shadowZ3, depthKernel[0]  ));\n    kern[0] *= vec3(0.25);\n\n    kern[1] = vec3(lessThan(shadowZ3, depthKernel[1] ));\n    kern[1] *= vec3(0.25);\n\n    kern[2] = vec3(lessThan(shadowZ3, depthKernel[2] ));\n    kern[2] *= vec3(0.25);\n\n    vec2 fractCoord = 1.0 - fract( uv.xy );\n\n    kern[0] = mix( kern[1], kern[0], fractCoord.x );\n    kern[1] = mix( kern[2], kern[1], fractCoord.x );\n\n    vec4 sV;\n    sV.x = mix( kern[0][1], kern[0][0], fractCoord.y );\n    sV.y = mix( kern[0][2], kern[0][1], fractCoord.y );\n    sV.z = mix( kern[1][1], kern[1][0], fractCoord.y );\n    sV.w = mix( kern[1][2], kern[1][1], fractCoord.x );\n\n    shadowed = dot( sV, vec4( 1.0 ) );\n\n#elif defined(_PCFx16)\n\n    float dx2 = -2.0 * size.z;\n    float dy2 = -2.0 * size.w;\n    float dx3 = 2.0 * size.z;\n    float dy3 = 2.0 * size.w;\n\n    shadowed += step(shadowZ , TSF(dx2, dy2));\n    shadowed += step(shadowZ , TSF(dx0, dy2));\n    shadowed += step(shadowZ , TSF(dx1, dy2));\n    shadowed += step(shadowZ , TSF(dx3, dy2));\n\n    shadowed += step(shadowZ , TSF(dx2, dy0));\n    shadowed += step(shadowZ , TSF(dx0, dy0));\n    shadowed += step(shadowZ , TSF(dx1, dy0));\n    shadowed += step(shadowZ , TSF(dx3, dy0));\n\n    shadowed += step(shadowZ , TSF(dx2, dy1));\n    shadowed += step(shadowZ , TSF(dx0, dy1));\n    shadowed += step(shadowZ , TSF(dx1, dy1));\n    shadowed += step(shadowZ , TSF(dx3, dy1));\n\n    shadowed += step(shadowZ , TSF(dx2, dy3));\n    shadowed += step(shadowZ , TSF(dx0, dy3));\n    shadowed += step(shadowZ , TSF(dx1, dy3));\n    shadowed += step(shadowZ , TSF(dx3, dy3));\n\n    shadowed = shadowed / 16.0;\n#endif // pcfx16\n    return shadowed;\n\n}\n"

/***/ }),
/* 183 */
/***/ (function(module, exports) {

	module.exports = "\n#pragma include \"noise.glsl\" \"_ROTATE_OFFSET\"\n\n#pragma include \"shadowLinearSoft.glsl\"\n\nfloat getShadowPCF(const in sampler2D depths, const in vec4 size, const in vec2 uv, const in float compare, const in vec2 biasPCF)\n{\n\n     float res = 0.0;\n\n#if defined(_ROTATE_OFFSET)\n     res += texture2DShadowLerp(depths, size,   uv + size.zw*(noise2D(uv*gl_FragCoord.xy)*2.0 - 1.0) + biasPCF, compare);\n#else\n     res += texture2DShadowLerp(depths, size,   uv + biasPCF, compare);\n#endif\n\n\n#if defined(_PCFx1)\n\n#else\n\n    float dx0 = -size.z;\n    float dy0 = -size.w;\n    float dx1 = size.z;\n    float dy1 = size.w;\n\n#define TSF(o1,o2) texture2DShadowLerp(depths, size, uv + vec2(o1, o2) + biasPCF,  compare)\n\n    res += TSF(dx0, dx0);\n    res += TSF(dx0, .0);\n    res += TSF(dx0, dx1);\n\n#if defined(_PCFx4)\n\n    res /=4.0;\n\n#elif defined(_PCFx9)\n    res += TSF(.0, dx0);\n    res += TSF(.0, dx1);\n\n    res += TSF(dx1, dx0);\n    res += TSF(dx1, .0);\n    res += TSF(dx1, dx1);\n\n\n    res /=9.0;\n\n#elif defined(_PCFx25)\n\n    float dx02 = -2.0*size.z;\n    float dy02 = -2.0*size.w;\n    float dx2 = 2.0*size.z;\n    float dy2 = 2.0*size.w;\n\n    // complete row above\n    res += TSF(dx0, dx02);\n    res += TSF(dx0, dx2);\n\n    res += TSF(.0, dx02);\n    res += TSF(.0, dx2);\n\n    res += TSF(dx1, dx02);\n    res += TSF(dx1, dx2);\n\n    // two new col\n    res += TSF(dx02, dx02);\n    res += TSF(dx02, dx0);\n    res += TSF(dx02, .0);\n    res += TSF(dx02, dx1);\n    res += TSF(dx02, dx2);\n\n    res += TSF(dx2, dx02);\n    res += TSF(dx2, dx0);\n    res += TSF(dx2, .0);\n    res += TSF(dx2, dx1);\n    res += TSF(dx2, dx2);\n\n\n    res/=25.0;\n\n#endif\n\n#undef TSF\n\n#endif\n    return res;\n}\n/////// end Tap\n"

/***/ }),
/* 184 */
/***/ (function(module, exports) {

	module.exports = "//// hash glsl\n\n// Dave Hoskins: hash without sin\n//https://www.shadertoy.com/view/4djSRW\n#define MOD2 vec2(443.8975,397.2973)\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\n//note: normalized uniform random, [0;1[\nfloat hash11(const in float p)\n{\n    vec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n    return fract(p2.x * p2.y);\n}\n//note: normalized uniform random, [0;1[\n//  2 out, 1 in...\nfloat hash21(const in vec2 p)\n{\n    vec2 p2 = fract(p * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n    return fract(p2.x * p2.y);\n}\n\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\n// using Sin\n//  1 out, 1 in...\nfloat hashSin11( const in float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n//note: normalized uniform random, [0;1[\n//  2 out, 1 in...\nfloat hashSin21( const in vec2 n ) {\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// note: [-1;1]\n// iq: https://www.shadertoy.com/view/Xsl3Dl\n// note: value noise\n//  2 out, 2 in...\nvec2 hashSin22( const in vec2 n )\n{\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* vec2(43758.5453,35458.5734));\n}\n//  3 out, 3 in...\nvec3 hashSin33( in vec3 p )\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n    return fract(sin(p)*43758.5453123);\n}\n\n// Returns a random number based on a vec3 and an int.\nfloat hashSin41(const in vec4 seed){\n    return fract(sin(dot(seed, vec4(12.9898,78.233,45.164,94.673)) * 43758.5453));\n}\n\n/////// end hash\n"

/***/ }),
/* 185 */
/***/ (function(module, exports) {

	module.exports = "vec2 poissonDisk[64];\n\npoissonDisk[0] = vec2(-0.613392, 0.617481);\npoissonDisk[1] = vec2(0.170019, -0.040254);\npoissonDisk[2] = vec2(-0.299417, 0.791925);\npoissonDisk[3] = vec2(0.645680, 0.493210);\npoissonDisk[4] = vec2(-0.651784, 0.717887);\npoissonDisk[5] = vec2(0.421003, 0.027070);\npoissonDisk[6] = vec2(-0.817194, -0.271096);\npoissonDisk[7] = vec2(-0.705374, -0.668203);\npoissonDisk[8] = vec2(0.977050, -0.108615);\npoissonDisk[9] = vec2(0.063326, 0.142369);\npoissonDisk[10] = vec2(0.203528, 0.214331);\npoissonDisk[11] = vec2(-0.667531, 0.326090);\npoissonDisk[12] = vec2(-0.098422, -0.295755);\npoissonDisk[13] = vec2(-0.885922, 0.215369);\npoissonDisk[14] = vec2(0.566637, 0.605213);\npoissonDisk[15] = vec2(0.039766, -0.396100);\npoissonDisk[16] = vec2(0.751946, 0.453352);\npoissonDisk[17] = vec2(0.078707, -0.715323);\npoissonDisk[18] = vec2(-0.075838, -0.529344);\npoissonDisk[19] = vec2(0.724479, -0.580798);\npoissonDisk[20] = vec2(0.222999, -0.215125);\npoissonDisk[21] = vec2(-0.467574, -0.405438);\npoissonDisk[22] = vec2(-0.248268, -0.814753);\npoissonDisk[23] = vec2(0.354411, -0.887570);\npoissonDisk[24] = vec2(0.175817, 0.382366);\npoissonDisk[25] = vec2(0.487472, -0.063082);\npoissonDisk[26] = vec2(-0.084078, 0.898312);\npoissonDisk[27] = vec2(0.488876, -0.783441);\npoissonDisk[28] = vec2(0.470016, 0.217933);\npoissonDisk[29] = vec2(-0.696890, -0.549791);\npoissonDisk[30] = vec2(-0.149693, 0.605762);\npoissonDisk[31] = vec2(0.034211, 0.979980);\npoissonDisk[32] = vec2(0.503098, -0.308878);\npoissonDisk[33] = vec2(-0.016205, -0.872921);\npoissonDisk[34] = vec2(0.385784, -0.393902);\npoissonDisk[35] = vec2(-0.146886, -0.859249);\npoissonDisk[36] = vec2(0.643361, 0.164098);\npoissonDisk[37] = vec2(0.634388, -0.049471);\npoissonDisk[38] = vec2(-0.688894, 0.007843);\npoissonDisk[39] = vec2(0.464034, -0.188818);\npoissonDisk[40] = vec2(-0.440840, 0.137486);\npoissonDisk[41] = vec2(0.364483, 0.511704);\npoissonDisk[42] = vec2(0.034028, 0.325968);\npoissonDisk[43] = vec2(0.099094, -0.308023);\npoissonDisk[44] = vec2(0.693960, -0.366253);\npoissonDisk[45] = vec2(0.678884, -0.204688);\npoissonDisk[46] = vec2(0.001801, 0.780328);\npoissonDisk[47] = vec2(0.145177, -0.898984);\npoissonDisk[48] = vec2(0.062655, -0.611866);\npoissonDisk[49] = vec2(0.315226, -0.604297);\npoissonDisk[50] = vec2(-0.780145, 0.486251);\npoissonDisk[51] = vec2(-0.371868, 0.882138);\npoissonDisk[52] = vec2(0.200476, 0.494430);\npoissonDisk[53] = vec2(-0.494552, -0.711051);\npoissonDisk[54] = vec2(0.612476, 0.705252);\npoissonDisk[55] = vec2(-0.578845, -0.768792);\npoissonDisk[56] = vec2(-0.772454, -0.090976);\npoissonDisk[57] = vec2(0.504440, 0.372295);\npoissonDisk[58] = vec2(0.155736, 0.065157);\npoissonDisk[59] = vec2(0.391522, 0.849605);\npoissonDisk[60] = vec2(-0.620106, -0.328104);\npoissonDisk[61] = vec2(0.789239, -0.419965);\npoissonDisk[62] = vec2(-0.545396, 0.538133);\npoissonDisk[63] = vec2(-0.178564, -0.596057);\n"

/***/ }),
/* 186 */
/***/ (function(module, exports) {

	module.exports = "\n\n#pragma include \"shadowLinearSoft.glsl\"\n\n#pragma include \"hash.glsl\"\n\nfloat getShadowPCF(const in sampler2D tex, const in vec4 size, const in vec2 uv, const in float shadowZ, const in vec2 biasPCF) {\n\n    vec2 o = size.zw;\n    float s = 0.0;\n\n// Not Good, as it needs the lerp things\n#pragma include \"arrayPoisson.glsl\"\n\n    int idx = 0;\n\n    // Not Good, as it needs the lerp things\n#define TSF_BASE(p, m) texture2DShadowLerp(tex, size, uv + m*poissonDisk[p]*o + biasPCF,  shadowZ)\n\n// fixed pattern in the shadow, no noise\n#define TSF_FIXED(i) TSF_BASE(i, 1.0)\n\n    // rand  using screenpos: No banding,\"moves\" camera\n#define TSF_SCREEN(i) TSF_BASE(i, hashSin22( float(i)*gl_FragCoord.xy ))\n\n//rand using worl proj +depth as world psace xyez\n#define TSF_SPACE(i)  TSF_BASE(i, hashSin41(vec4(uv.xy, shadowZ, float(i))))\n\n#define TSF(k) TSF_SPACE(k)\n\n\n    s += TSF(1);\n    s += TSF(2);\n    s += TSF(3);\n    s += TSF(4);\n\n#ifdef _PCFx4\n    const float kernSize = 4.;\n#else\n    s += TSF(5);\n    s += TSF(6);\n    s += TSF(7);\n    s += TSF(8);\n#ifdef _PCFx9\n    const float kernSize = 8.;\n#else\n    s += TSF(9);\n    s += TSF(10);\n    s += TSF(11);\n    s += TSF(12);\n    s += TSF(13);\n    s += TSF(14);\n    s += TSF(15);\n    s += TSF(16);\n#ifdef _PCFx16\n    const float kernSize = 16.;\n#else\n    s += TSF(17);\n    s += TSF(18);\n    s += TSF(19);\n    s += TSF(20);\n    s += TSF(21);\n    s += TSF(22);\n    s += TSF(23);\n    s += TSF(24);\n    s += TSF(25);\n#ifdef _PCFx25\n    const float kernSize = 25.;\n#else\n    s += TSF(26);\n    s += TSF(27);\n    s += TSF(28);\n    s += TSF(29);\n    s += TSF(30);\n    s += TSF(31);\n    s += TSF(32);\n#ifdef _PCFx32\n    const float kernSize = 32.;\n#endif // 32\n#endif // 25\n#endif // 16\n#endif // 8\n#endif // 4\n\n    s /= kernSize;\n    return s;\n}\n// end poisson\n#undef TSF\n"

/***/ }),
/* 187 */
/***/ (function(module, exports) {

	module.exports = "////////////////////////////////////////////////\n// ESM\nfloat fetchESM(const in sampler2D tex, const in vec4 shadowMapSize, const in vec2 shadowUV, const in float shadowZ,  const in float exponent0, const in float exponent1) {\n\n\n#if defined(_FLOATTEX) && (!defined(_FLOATLINEAR))\n    // emulate bilinear filtering (not needed if webgm/GPU support filtering FP32/FP16 textures)\n    vec2 unnormalized = shadowUV * shadowMapSize.xy;\n    vec2 fractional = fract(unnormalized);\n    unnormalized = floor(unnormalized);\n\n    vec4 occluder4;\n    occluder4.x = getSingleFloatFromTex(tex, (unnormalized + vec2( -0.5,  0.5 ))* shadowMapSize.zw );\n    occluder4.y = getSingleFloatFromTex(tex, (unnormalized + vec2( 0.5,   0.5 ))* shadowMapSize.zw );\n    occluder4.z = getSingleFloatFromTex(tex, (unnormalized + vec2( 0.5,  -0.5 ))* shadowMapSize.zw );\n    occluder4.w = getSingleFloatFromTex(tex, (unnormalized + vec2( -0.5, -0.5 ))* shadowMapSize.zw );\n\n    float occluder = (occluder4.w + (occluder4.x - occluder4.w) * fractional.y);\n    occluder = occluder + ((occluder4.z + (occluder4.y - occluder4.z) * fractional.y) - occluder)*fractional.x;\n\n#else\n    float occluder = getSingleFloatFromTex(tex, shadowUV);\n#endif\n\n\n    // we're on an edge\n    float depthScale = exponent1;\n    float over_darkening_factor = exponent0;\n    float receiver = depthScale * ( shadowZ);\n    return 1.0 - clamp(over_darkening_factor*(occluder*exp(receiver)), 0.0, 1.0);\n}\n\n\nfloat computeShadow(const in bool lighted,\n                    const in sampler2D tex,\n                    const in vec4 shadowMapSize,\n                    const in mat4 shadowProjectionMatrix,\n                    const in mat4 shadowViewMatrix,\n                    const in vec4 depthRange,\n                    const in float N_Dot_L,\n                    const in vec3 vertexWorld,\n                    const in float bias,\n                    const in float exponent0,\n                    const in float exponent1\n    )\n{\n    #pragma include \"shadowsReceiveMain.glsl\" \"_ESM\"\n}\n\n// end ESM\n"

/***/ }),
/* 188 */
/***/ (function(module, exports) {

	module.exports = "//////VSM\n//http://en.wikipedia.org/wiki/Chebyshev%27s_inequality\nfloat chebychevInequality (const in vec2 moments, const in float t)\n{\n    // No shadow if depth of fragment is in front\n    if ( t <= moments.x )\n        return 1.0;\n\n    // Calculate variance, which is actually the amount of\n    // error due to precision loss from fp32 to RG/BA\n    // (moment1 / moment2)\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, 0.02);\n\n    // Calculate the upper bound\n    float d = t - moments.x;\n    return variance / (variance + d * d);\n}\n\n// http://http.developer.nvidia.com/GPUGems3/gpugems3_ch08.html\nfloat chebyshevUpperBound(const in vec2 moments, const in float mean, const in float minVariance)\n{\n    float d = mean - moments.x;\n    if ( d <= 0.0 )\n        return 1.0;\n    // Compute variance\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, minVariance);\n\n    // Compute probabilistic upper bound\n    //p represent an upper bound on the visibility percentage of the receiver. This value //attempts to estimate how much of the distribution of occluders at the surface location is //beyond the surface's distance from the light. If it is 0, then there is no probability //that the fragment is partially lit, so it will be fully in shadow. If it is a value in the //[0, 1] range, it represent the penumbrae value of the shadow edge.\n    float p = smoothstep(mean, mean, moments.x);\n\n    // Remove the [0, Amount] tail and linearly rescale (Amount, 1].\n    /// light bleeding when shadows overlap.\n\n    float pMax = smoothstep(0.2, 1.0, variance / (variance + d*d));\n    // One-tailed chebyshev\n    return clamp(max(p, pMax), 0.0, 1.0);\n}\n\n// might be included for EVSM\n#ifdef _VSM\nfloat computeShadow(const in bool lighted,\n                    const in sampler2D tex,\n                    const in vec4 shadowMapSize,\n                    const in mat4 shadowProjectionMatrix,\n                    const in mat4 shadowViewMatrix,\n                    const in vec4 depthRange,\n                    const in float N_Dot_L,\n                    const in vec3 vertexWorld,\n                    const in float bias,\n                    const in float epsilonVSM\n    )\n{\n#pragma include \"shadowsReceiveMain.glsl\" \"_VSM\"\n}\n#endif // _VSM\n\n// end VSM\n"

/***/ }),
/* 189 */
/***/ (function(module, exports) {

	module.exports = "// EVSM\n\n#pragma include \"vsm.glsl\"\n\n// Convert depth to EVSM coefficients\n// Input depth should be in [0, 1]\nvec2 warpDepth(const in float depth, const in vec2 exponents)\n{\n    float pos =  exp( exponents.x * depth);\n    float neg = -exp(-exponents.y * depth);\n    return vec2(pos, neg);\n}\n\n\nfloat computeShadow(const in bool lighted,\n                    const in sampler2D tex,\n                    const in vec4 shadowMapSize,\n                    const in mat4 shadowProjectionMatrix,\n                    const in mat4 shadowViewMatrix,\n                    const in vec4 depthRange,\n                    const in float N_Dot_L,\n                    const in vec3 vertexWorld,\n                    const in float bias,\n                    const in float epsilonVSM,\n                    const in float exponent0,\n                    const in float exponent1\n    )\n{\n    #pragma include \"shadowsReceiveMain.glsl\" \"_EVSM\"\n}\n\n// _EVSM\n"

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var subnamespace = [
	    __webpack_require__( 160 ),
	    __webpack_require__( 191 ),
	    __webpack_require__( 193 ),
	    __webpack_require__( 194 ),
	    __webpack_require__( 195 ),
	    __webpack_require__( 196 ),
	    __webpack_require__( 197 )
	];
	
	var lib = {};
	
	// add all sub component to root level of the lib
	subnamespace.forEach( function ( component /*, index */ ) {
	
	    window.Object.keys( component ).forEach( function ( key ) {
	
	        var element = component[ key ];
	
	        if ( this[ key ] !== undefined ) { // if exist throw exception
	            throw 'duplicate entry in node library';
	        }
	
	        this[ key ] = element;
	
	    }, this );
	
	}, lib );
	
	module.exports = lib;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var ShaderUtils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	var Morph = function () {
	    Node.call( this );
	};
	
	var getVec3 = function ( vec ) {
	    return vec.getType() === 'vec4' ? vec.getVariable() + '.rgb' : vec;
	};
	
	Morph.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    type: 'Morph',
	    validInputs: [ 'weights', 'vertex', 'target0', /*'target1','target2','target3'*/ ],
	    validOutputs: [ 'out' ],
	
	    globalFunctionDeclaration: function () {
	
	        //vec3 morphTransform( const in vec4 weights,  const in vec3 vertex, const in vec3 target0, const in vec3 target1, const in vec3 target2 ) {
	        //  return vertex * (1.0 - ( + weights[0] + weights[1] + weights[2])) + target0 * weights[0] + target1 * weights[1] + target2 * weights[2];
	        //}
	        var nbTargets = window.Object.keys( this._inputs ).length - 2;
	        var i = 0;
	
	        // TODO: this should be rewrote with sprintf
	        ////// Signature
	        var str = 'vec3 morphTransform( const in vec4 weights,  const in vec3 vertex, const in vec3 target0';
	        for ( i = 1; i < nbTargets; ++i )
	            str += ', const in vec3 target' + i;
	        str += ' ) { \n';
	
	        ////// Morphing
	        if ( nbTargets === 1 ) {
	
	            str += 'return mix(vertex, target0, weights[0])';
	
	        } else {
	
	            str += '\tvec3 vecOut = vertex * (1.0 - ( weights[0]';
	            for ( i = 1; i < nbTargets; ++i )
	                str += ' + weights[' + i + ']';
	            str += '));\n';
	
	            for ( i = 0; i < nbTargets; ++i )
	                str += '\tvecOut += target' + i + ' * weights[' + i + '];\n';
	
	            str += '\treturn vecOut';
	        }
	
	        str += ';\n}\n';
	        return str;
	    },
	
	    computeShader: function () {
	
	        var inps = this._inputs;
	        var inputs = [ inps.weights, getVec3( inps.vertex ) ];
	
	        for ( var i = 0; i < 4; i++ ) {
	
	            if ( !inps[ 'target' + i ] ) break;
	            inputs.push( getVec3( inps[ 'target' + i ] ) );
	
	        }
	
	        return ShaderUtils.callFunction( 'morphTransform', this._outputs.out, inputs );
	
	    }
	} );
	
	module.exports = {
	    Morph: Morph
	};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	
	var instance = 0;
	var Node = function () {
	    this._name = 'AbstractNode';
	    this._inputs = [];
	    this._outputs = null;
	
	    // category of node
	    // same name implies same
	    // define/function
	    //this.type = '';
	
	    // uuid: unicity
	    // allows multipe node of same type
	    // declaring multipe code paths
	    // inside the main
	    this._id = instance++;
	
	    this._text = undefined;
	};
	
	Node.prototype = {
	
	    getID: function () {
	        return this._id;
	    },
	    getName: function () {
	        return this._name;
	    },
	
	    getType: function () {
	        return this.type;
	    },
	
	    toString: function () {
	        return 'name : ' + this._name + ', type : ' + this.type;
	    },
	
	    getInputs: function () {
	        return this._inputs;
	    },
	
	    getOutputs: function () {
	        return this._outputs;
	    },
	
	    checkInputsOutputs: function () {
	
	        var i, key;
	        if ( this.validInputs ) {
	
	            for ( i = 0; i < this.validInputs.length; i++ ) {
	                key = this.validInputs[ i ];
	                if ( !this._inputs[ key ] ) {
	                    Notify.error( 'Shader node ' + this.type + ' validation error input ' + key + ' is missing' );
	                    return false;
	                }
	            }
	        }
	
	        if ( this.validOutputs ) {
	
	            for ( i = 0; i < this.validOutputs.length; i++ ) {
	                key = this.validOutputs[ i ];
	                if ( !this._outputs[ key ] ) {
	                    Notify.error( 'Shader node ' + this.type + ' validation error output ' + key + ' is missing' );
	                    return false;
	                }
	            }
	        }
	
	        return true;
	    },
	
	    // accepts inputs like that:
	    // inputs( [ a, b, c , d] )
	    // inputs( { a: x, b: y } )
	    // inputs( a, b, c, d )
	    inputs: function () {
	        // handle inputs ( a, b, c, d)
	        for ( var i = 0, l = arguments.length; i < l; i++ ) {
	
	            var input = arguments[ i ];
	            if ( !input ) {
	                Notify.error( 'Shader node ' + this.type + ' input number ' + l + ' is undefined ' );
	                break;
	            }
	
	            // handle inputs( [a, b, c ,d] )
	            if ( Array.isArray( input ) ) {
	
	                this.inputs.apply( this, input );
	                return this;
	
	                // check for an object {} and not something from base class Node
	            } else if ( typeof input === 'object' && input !== null && ( input instanceof Node === false ) ) {
	                this._inputs = input;
	                return this;
	
	            } else { // add argument to the array
	                this._inputs.push( input );
	            }
	        }
	
	        return this;
	    },
	
	    // accepts inputs like that:
	    // outputs( { a: x, b: y } )
	    // outputs( a )
	    outputs: function ( outputs ) {
	
	        this._outputs = outputs;
	
	        // single output
	        if ( this._outputs instanceof Node === true ) {
	
	            this.autoLink( this._outputs );
	
	        } else {
	
	            // iterate on objects keys
	            var keys = window.Object.keys( this._outputs );
	            for ( var i = 0; i < keys.length; i++ ) {
	                var key = keys[ i ];
	                this.autoLink( this._outputs[ key ] );
	            }
	        }
	
	        return this;
	    },
	
	    autoLink: function ( output ) {
	
	        if ( output === undefined )
	            return this;
	
	        output.inputs( this );
	
	        return this;
	    },
	
	    computeShader: function () {
	        return this._text;
	    },
	
	    comment: function ( txt ) {
	        this._comment = '//' + txt;
	    },
	
	    getComment: function () {
	        return this._comment;
	    }
	};
	
	
	module.exports = Node;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var utils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	var sprintf = utils.sprintf;
	
	// Base Class for all variables Nodes
	// TODO: add precision
	// type {string} vec3/4/2, float, int, etc.
	// prefix {string} vec3/4/2, float, int, etc.
	var Variable = function ( type, prefix ) {
	    Node.call( this );
	    this._name = 'Variable';
	    this._prefix = prefix;
	    this._type = type;
	    this._value = undefined;
	};
	
	Variable.prototype = MACROUTILS.objectInherit( Node.prototype, {
	
	    getType: function () {
	        return this._type;
	    },
	
	    getVariable: function () {
	        return this._prefix;
	    },
	
	    setValue: function ( value ) {
	        this._value = value;
	        return this;
	    },
	
	    declare: function () {
	        if ( this._value !== undefined ) {
	            return sprintf( '%s %s = %s;', [ this._type, this.getVariable(), this._value ] );
	        } else {
	            return sprintf( '%s %s;', [ this._type, this.getVariable() ] );
	        }
	    }
	} );
	
	// Constant Variable
	// help glsl compiler and make sure no one writes in it :)
	var Constant = function ( type, prefix ) {
	    Variable.call( this, type, prefix );
	};
	Constant.prototype = MACROUTILS.objectInherit( Variable.prototype, {
	
	    declare: function () {
	        return sprintf( 'const %s %s = %s;', [ this._type, this.getVariable(), this._value ] );
	    }
	} );
	
	var Uniform = function ( type, prefix, size ) {
	    Variable.call( this, type, prefix );
	    this._size = size;
	};
	
	Uniform.prototype = MACROUTILS.objectInherit( Variable.prototype, {
	    declare: function () {
	        return undefined;
	    },
	
	    globalDeclaration: function () {
	        if ( this._size ) {
	            return sprintf( 'uniform %s %s[%s];', [ this._type, this.getVariable(), this._size ] );
	        } else {
	            return sprintf( 'uniform %s %s;', [ this._type, this.getVariable() ] );
	        }
	    }
	
	} );
	
	// Vertex Attribute Variables
	var Attribute = function ( type, prefix ) {
	    Variable.call( this, type, prefix );
	};
	
	Attribute.prototype = MACROUTILS.objectInherit( Variable.prototype, {
	    declare: function () {
	        return undefined;
	    },
	
	    globalDeclaration: function () {
	        return sprintf( 'attribute %s %s;', [ this._type, this.getVariable() ] );
	    }
	
	} );
	
	
	var Varying = function ( type, prefix ) {
	    Variable.call( this, type, prefix );
	};
	
	Varying.prototype = MACROUTILS.objectInherit( Variable.prototype, {
	    declare: function () {
	        return undefined;
	    },
	
	    globalDeclaration: function () {
	        return sprintf( 'varying %s %s;', [ this._type, this.getVariable() ] );
	    },
	
	    // bewteen vertex shader and fragmetn shader
	    // we keep varying but not associated
	    reset: function () {
	        this._inputs = [];
	        this._outputs = null;
	        this._text = undefined;
	    }
	} );
	
	
	
	
	var Sampler = function ( type, prefix ) {
	    Variable.call( this, type, prefix );
	};
	
	Sampler.prototype = MACROUTILS.objectInherit( Variable.prototype, {
	    declare: function () {
	        return undefined;
	    },
	
	    globalDeclaration: function () {
	        return sprintf( 'uniform %s %s;', [ this._type, this.getVariable() ] );
	    }
	
	} );
	
	
	// Graph Root Node Abstract Class
	// Derive from that for new outputs
	// gl_FragDepth, etc.
	var Output = function ( type, wholeName ) {
	    Variable.call( this, type, wholeName );
	};
	
	Output.prototype = MACROUTILS.objectInherit( Variable.prototype, {
	    _unique: true,
	    isUnique: function () {
	        return this._unique;
	    },
	    outputs: function () { /* do nothing for variable */
	        return this;
	    },
	    getVariable: function () {
	        return this._prefix;
	    }
	} );
	
	// Graph Root Nodes
	var glFragColor = function () {
	    Output.call( this, 'vec4', 'gl_FragColor' );
	    this._name = 'glFragColor';
	};
	glFragColor.prototype = MACROUTILS.objectInherit( Output.prototype, {} );
	
	var glPosition = function () {
	    Output.call( this, 'vec4', 'gl_Position' );
	    this._name = 'glPosition';
	};
	glPosition.prototype = MACROUTILS.objectInherit( Output.prototype, {} );
	
	
	var glPointSize = function () {
	    Output.call( this, 'vec4', 'gl_PointSize' );
	    this._name = 'glPointSize';
	};
	glPointSize.prototype = MACROUTILS.objectInherit( Output.prototype, {} );
	
	module.exports = {
	    Output: Output,
	    glPointSize: glPointSize,
	    glPosition: glPosition,
	    glFragColor: glFragColor,
	    Sampler: Sampler,
	    Variable: Variable,
	    Constant: Constant,
	    Attribute: Attribute,
	    Varying: Varying,
	    Uniform: Uniform
	};


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var utils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	var NodeTextures = function () {
	    Node.call( this );
	};
	
	NodeTextures.prototype = MACROUTILS.objectInherit( Node.prototype, {
	
	    type: 'TextureAbstractNode',
	
	    // functionName is here to simplify all texture base functions
	    // it's possible later it will have to move into another class
	    // if base class needs to be more generic. But right now it simplify
	    // all simple class to fetch texture ( seed above )
	    functionName: 'noTextureFunction',
	
	    validInputs: [ 'sampler', 'uv' ],
	    validOutputs: [ 'color' ],
	
	    computeShader: function () {
	
	        return utils.callFunction( this.functionName,
	            this._outputs.color, [
	                this._inputs.sampler,
	                this._inputs.uv.getVariable() + '.xy'
	            ] );
	    },
	
	    globalFunctionDeclaration: function () {
	        return '#pragma include "textures.glsl"';
	    }
	
	} );
	
	
	
	var TextureRGB = function () {
	    NodeTextures.call( this );
	};
	
	TextureRGB.prototype = MACROUTILS.objectInherit( NodeTextures.prototype, {
	
	    type: 'TextureRGB',
	    functionName: 'textureRGB'
	
	} );
	
	
	
	var TextureRGBA = function () {
	    TextureRGB.call( this );
	};
	
	TextureRGBA.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {
	
	    type: 'TextureRGBA',
	    functionName: 'textureRGBA'
	
	} );
	
	
	var TextureAlpha = function () {
	    TextureRGB.call( this );
	};
	
	TextureAlpha.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {
	
	    type: 'TextureAlpha',
	    functionName: 'textureAlpha'
	
	} );
	
	
	
	var TextureIntensity = function () {
	    TextureRGB.call( this );
	};
	
	TextureIntensity.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {
	
	    type: 'TextureIntensity',
	    functionName: 'textureIntensity'
	
	} );
	
	module.exports = {
	    NodeTextures: NodeTextures,
	    TextureRGB: TextureRGB,
	    TextureRGBA: TextureRGBA,
	    TextureAlpha: TextureAlpha,
	    TextureIntensity: TextureIntensity
	};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var utils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	var sprintf = utils.sprintf;
	
	// base to avoid redundant global declarations
	// it's to keep node more readable
	var NodeFunctions = function () {
	    Node.call( this );
	};
	
	NodeFunctions.prototype = MACROUTILS.objectInherit( Node.prototype, {
	
	    globalFunctionDeclaration: function () {
	        return '#pragma include "functions.glsl"';
	    }
	
	} );
	
	
	var Normalize = function () {
	    NodeFunctions.call( this );
	};
	Normalize.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {
	    type: 'Normalize',
	    validInputs: [ 'vec' ],
	    validOuputs: [ 'vec' ],
	    computeShader: function () {
	        return utils.callFunction( 'normalize', this._outputs.vec, [ this._inputs.vec ] );
	    }
	} );
	
	
	var sRGBToLinear = function () {
	    NodeFunctions.call( this );
	};
	
	sRGBToLinear.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {
	
	    type: 'sRGBToLinear',
	
	    validInputs: [ 'color' ],
	    validOuputs: [ 'color' ],
	
	    computeShader: function () {
	        return this.computeConversion( 'sRGBToLinear' );
	    },
	    computeConversion: function ( funcName ) {
	        var out = this._outputs.color;
	        var color = this._inputs.color;
	        var rgb = out.getType() !== color.getType() ? '.rgb' : '';
	
	        return utils.callFunction( funcName, out.getVariable() + rgb, [ color.getVariable() + rgb ] );
	    }
	
	} );
	
	var LinearTosRGB = function () {
	    sRGBToLinear.call( this );
	};
	
	LinearTosRGB.prototype = MACROUTILS.objectInherit( sRGBToLinear.prototype, {
	    type: 'LinearTosRGB',
	    computeShader: function () {
	        return this.computeConversion( 'linearTosRGB' );
	    }
	} );
	
	var FrontNormal = function () {
	    NodeFunctions.call( this );
	};
	
	FrontNormal.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {
	
	    type: 'FrontNormal',
	    validInputs: [ 'normal' ],
	    validOuputs: [ 'normal' ],
	
	    computeShader: function () {
	        return sprintf( '%s = gl_FrontFacing ? %s : -%s ;', [
	            this._outputs.normal.getVariable(),
	            this._inputs.normal.getVariable(),
	            this._inputs.normal.getVariable()
	        ] );
	    }
	} );
	
	var getVec3 = function ( vec ) {
	    return vec.getType && vec.getType() === 'vec4' ? vec.getVariable() + '.rgb' : vec;
	};
	var EncodeRGBM = function () {
	    NodeFunctions.call( this );
	};
	EncodeRGBM.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {
	    type: 'EncodeRGBM',
	    validInputs: [ 'color', 'range' ],
	    validOutputs: [ 'color' ],
	    computeShader: function () {
	        return utils.callFunction( 'encodeRGBM', this._outputs.color, [ getVec3( this._inputs.color ), this._inputs.range ] );
	    }
	} );
	
	var DecodeRGBM = function () {
	    NodeFunctions.call( this );
	};
	DecodeRGBM.prototype = MACROUTILS.objectInherit( NodeFunctions.prototype, {
	    type: 'DecodeRGBM',
	    validInputs: [ 'color', 'range' ],
	    validOutputs: [ 'color' ],
	    computeShader: function () {
	        return utils.callFunction( 'decodeRGBM', this._outputs.color, [ this._inputs.color, this._inputs.range ] );
	    }
	} );
	
	var Define = function ( name ) {
	    Node.call( this );
	    this._defineName = name;
	    this._defineValue = '';
	};
	Define.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    type: 'Define',
	    setValue: function ( value ) {
	        this._defineValue = value;
	        return this;
	    },
	    getDefines: function () {
	        return [ '#define ' + this._defineName + ' ' + this._defineValue ];
	    }
	} );
	
	module.exports = {
	    NodeFunctions: NodeFunctions,
	    Normalize: Normalize,
	    sRGBToLinear: sRGBToLinear,
	    LinearTosRGB: LinearTosRGB,
	    FrontNormal: FrontNormal,
	    DecodeRGBM: DecodeRGBM,
	    EncodeRGBM: EncodeRGBM,
	    Define: Define
	};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var shaderUtils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	// base class for all point based light: Point/Directional/Spot/Hemi
	// avoid duplicate code
	var NodeLights = function () {
	    Node.call( this );
	};
	
	NodeLights.prototype = MACROUTILS.objectInherit( Node.prototype, {
	
	    validOutputs: [ 'color' ],
	    globalFunctionDeclaration: function () {
	        return '#pragma include "lights.glsl"';
	    }
	
	} );
	
	var getVec3 = function ( vec ) {
	    return vec.getType() === 'vec4' ? vec.getVariable() + '.rgb' : vec;
	};
	
	var PointLight = function () {
	    NodeLights.call( this );
	};
	
	PointLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {
	
	    type: 'PointLight',
	
	    validInputs: [
	        'normal',
	        'eyeVector',
	        'materialambient',
	        'materialdiffuse',
	        'materialspecular',
	        'materialshininess',
	
	        'lightambient',
	        'lightdiffuse',
	        'lightspecular',
	
	        'lightposition',
	        'lightattenuation',
	
	        'lightmatrix',
	
	        'lighted',
	        'lightEyePos',
	        'lightEyeDir',
	        'lightNDL'
	
	    ],
	
	    computeShader: function () {
	
	        return shaderUtils.callFunction(
	            'computePointLightShading',
	            this._outputs.color, [ this._inputs.normal,
	                this._inputs.eyeVector,
	
	                getVec3( this._inputs.materialambient ),
	                getVec3( this._inputs.materialdiffuse ),
	                getVec3( this._inputs.materialspecular ),
	                this._inputs.materialshininess,
	
	                getVec3( this._inputs.lightambient ),
	                getVec3( this._inputs.lightdiffuse ),
	                getVec3( this._inputs.lightspecular ),
	
	                this._inputs.lightposition,
	                this._inputs.lightattenuation,
	
	                this._inputs.lightmatrix,
	
	                this._inputs.lightEyePos,
	                this._inputs.lightEyeDir,
	                this._inputs.lightNDL,
	                this._inputs.lighted
	            ] );
	    }
	
	} );
	
	
	
	var SpotLight = function () {
	    NodeLights.call( this );
	};
	
	SpotLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {
	
	    type: 'SpotLight',
	
	    validInputs: [
	        'normal',
	        'eyeVector',
	
	        'materialambient',
	        'materialdiffuse',
	        'materialspecular',
	        'materialshininess',
	
	        'lightambient',
	        'lightdiffuse',
	        'lightspecular',
	
	        'lightdirection',
	        'lightattenuation',
	        'lightposition',
	        'lightspotCutOff',
	        'lightspotBlend',
	
	        'lightmatrix',
	        'lightinvMatrix',
	
	        'lighted',
	        'lightEyePos',
	        'lightEyeDir',
	        'lightNDL'
	
	    ],
	
	    computeShader: function () {
	
	        return shaderUtils.callFunction(
	            'computeSpotLightShading',
	            this._outputs.color, [ this._inputs.normal,
	                this._inputs.eyeVector,
	
	                getVec3( this._inputs.materialambient ),
	                getVec3( this._inputs.materialdiffuse ),
	                getVec3( this._inputs.materialspecular ),
	                this._inputs.materialshininess,
	
	                getVec3( this._inputs.lightambient ),
	                getVec3( this._inputs.lightdiffuse ),
	                getVec3( this._inputs.lightspecular ),
	
	                this._inputs.lightdirection,
	                this._inputs.lightattenuation,
	                this._inputs.lightposition,
	                this._inputs.lightspotCutOff,
	                this._inputs.lightspotBlend,
	
	                this._inputs.lightmatrix,
	                this._inputs.lightinvMatrix,
	
	                this._inputs.lightEyePos,
	                this._inputs.lightEyeDir,
	                this._inputs.lightNDL,
	                this._inputs.lighted
	            ] );
	    }
	
	} );
	
	
	var SunLight = function () {
	    NodeLights.call( this );
	};
	
	SunLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {
	
	    type: 'SunLight',
	
	    validInputs: [
	        'normal',
	        'eyeVector',
	        'materialambient',
	        'materialdiffuse',
	        'materialspecular',
	        'materialshininess',
	
	        'lightambient',
	        'lightdiffuse',
	        'lightspecular',
	
	        'lightposition',
	
	        'lightmatrix',
	
	        'lighted',
	        'lightEyeDir',
	        'lightNDL'
	
	    ],
	
	    computeShader: function () {
	
	        return shaderUtils.callFunction(
	            'computeSunLightShading',
	            this._outputs.color, [ this._inputs.normal,
	                this._inputs.eyeVector,
	
	                getVec3( this._inputs.materialambient ),
	                getVec3( this._inputs.materialdiffuse ),
	                getVec3( this._inputs.materialspecular ),
	                this._inputs.materialshininess,
	
	                getVec3( this._inputs.lightambient ),
	                getVec3( this._inputs.lightdiffuse ),
	                getVec3( this._inputs.lightspecular ),
	
	                this._inputs.lightposition,
	
	                this._inputs.lightmatrix,
	
	                this._inputs.lightEyeDir,
	                this._inputs.lightNDL,
	                this._inputs.lighted
	            ] );
	    }
	} );
	
	var HemiLight = function () {
	    NodeLights.call( this );
	};
	
	HemiLight.prototype = MACROUTILS.objectInherit( NodeLights.prototype, {
	
	    type: 'HemiLight',
	
	    validInputs: [
	        'normal',
	        'eyeVector',
	        'materialdiffuse',
	        'materialspecular',
	        'materialshininess',
	
	        'lightdiffuse',
	        'lightground',
	
	        'lightposition',
	
	        'lightmatrix',
	
	        'lighted',
	        'lightEyeDir',
	        'lightNDL'
	    ],
	
	    computeShader: function () {
	
	        return shaderUtils.callFunction(
	            'computeHemiLightShading',
	            this._outputs.color, [ this._inputs.normal,
	                this._inputs.eyeVector,
	
	                getVec3( this._inputs.materialdiffuse ),
	                getVec3( this._inputs.materialspecular ),
	                this._inputs.materialshininess,
	
	                getVec3( this._inputs.lightdiffuse ),
	                getVec3( this._inputs.lightground ),
	
	                this._inputs.lightposition,
	
	                this._inputs.lightmatrix,
	
	                this._inputs.lightEyeDir,
	                this._inputs.lightNDL,
	                this._inputs.lighted
	            ] );
	    }
	} );
	
	module.exports = {
	    PointLight: PointLight,
	    SpotLight: SpotLight,
	    SunLight: SunLight,
	    HemiLight: HemiLight
	};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var MACROUTILS = __webpack_require__( 6 );
	var Node = __webpack_require__( 192 );
	var utils = __webpack_require__( 161 );
	
	var sprintf = utils.sprintf;
	
	// Abstract class
	// base operator contains helper for the constructor
	// it helps to do that:
	// arg0 = output
	// arg1 = input0 or [ inputs ]
	// arg2 = input1
	// ...
	var BaseOperator = function () {
	    Node.call( this );
	};
	
	BaseOperator.prototype = Node.prototype;
	
	
	// Add support this syntax:
	// new Add( output, input0, input1, ... )
	// new Add( output, [ inputs ] )
	// glsl code output = input0 + input1 +...
	var Add = function () {
	    BaseOperator.call( this );
	};
	
	Add.prototype = MACROUTILS.objectInherit( BaseOperator.prototype, {
	
	    type: 'Add',
	
	    operator: '+',
	
	    computeShader: function () {
	        // force inputs type to be all the same from the output
	        var outputType = this._outputs.getType();
	        var addType = '';
	
	        if ( outputType === 'vec4' )
	            addType = '.rgba';
	        else if ( outputType === 'vec3' )
	            addType = '.rgb';
	        else if ( outputType === 'vec2' )
	            addType = '.rg';
	
	
	        var str = this._outputs.getVariable() + ' = ' + this._inputs[ 0 ].getVariable() + addType;
	        for ( var i = 1, l = this._inputs.length; i < l; i++ ) {
	            var input = this._inputs[ i ];
	            str += this.operator + input.getVariable();
	            // special var case that doesn't need any postfix
	            if ( input.getType() !== 'float' )
	                str += addType;
	        }
	        str += ';';
	        return str;
	    }
	} );
	
	
	
	// Mult works like Add
	// glsl code output = input0 * input1 * ...
	var Mult = function () {
	    Add.call( this );
	};
	
	Mult.prototype = MACROUTILS.objectInherit( Add.prototype, {
	    type: 'Mult',
	    operator: '*'
	} );
	
	// basic assignement alias: output = input
	// glsl code output = input0
	var SetFromNode = function () {
	    Add.call( this );
	};
	SetFromNode.prototype = MACROUTILS.objectInherit( Add.prototype, {
	    type: 'SetFromNode'
	} );
	
	// Mult Matrix * vector4
	// making the cast vector4(input.xyz, 0)
	// if needed
	// glsl code output = matrix * vector4(vec.xyz, 0)
	var MatrixMultDirection = function () {
	    Add.call( this );
	    this._overwriteW = true; // if set to false, we copy the input alpha in the output alpha
	    this._forceComplement = true;
	    this._inverseOp = false;
	};
	
	MatrixMultDirection.prototype = MACROUTILS.objectInherit( Add.prototype, {
	    type: 'MatrixMultDirection',
	    operator: '*',
	    validInputs: [ 'vec', 'matrix' ],
	    validOutputs: [ 'vec' ],
	    complement: '0.',
	    setInverse: function ( bool ) {
	        this._inverseOp = bool;
	        return this;
	    },
	    setForceComplement: function ( bool ) {
	        this._forceComplement = bool;
	        return this;
	    },
	    setOverwriteW: function ( bool ) {
	        this._overwriteW = bool;
	        return this;
	    },
	    computeShader: function () {
	        // force inputs type to be all the same from the output
	        // and handle vector complement
	        var vecIn = this._inputs.vec.getVariable();
	        var matrix = this._inputs.matrix.getVariable();
	        var vecOut = this._outputs.vec.getVariable();
	
	        var inputType = this._inputs.vec.getType();
	        var outputType = this._outputs.vec.getType();
	
	        var strOut = vecOut + ' = ';
	
	        if ( outputType !== 'vec4' )
	            strOut += outputType + '(';
	
	        var strCasted = vecIn;
	        if ( this._forceComplement || inputType !== 'vec4' )
	            strCasted = 'vec4(' + vecIn + '.xyz, ' + this.complement + ')';
	
	        strOut += this._inverseOp ? strCasted + this.operator + matrix : matrix + this.operator + strCasted;
	
	        if ( outputType !== 'vec4' )
	            strOut += ')';
	
	        strOut += ';';
	
	        if ( !this._overwriteW && inputType === 'vec4' )
	            strOut += '\n' + vecOut + '.a = ' + vecIn + '.a;';
	
	        return strOut;
	    }
	} );
	
	// override only for complement.
	// glsl code output = matrix * vector4(vec.xyz, 1)
	var MatrixMultPosition = function () {
	    MatrixMultDirection.call( this );
	    this._forceComplement = false;
	};
	MatrixMultPosition.prototype = MACROUTILS.objectInherit( MatrixMultDirection.prototype, {
	    type: 'MatrixMultPosition',
	    complement: '1.'
	} );
	
	// For all you custom needs.
	//
	// call Code() with variable input/output replace
	// indexed by the '%'
	// getNode( 'InlineCode' ).code( '%out = %input;' ).inputs( {
	//             input: this.getOrCreateConstant( 'float', 'unitFloat' ).setValue( '1.0' )
	//        } ).outputs( {
	//            out: this.getNode( 'glPointSize' )
	// }
	// glsl code glPointSize = unitFloat;
	//
	var InlineCode = function () {
	    Node.call( this );
	};
	
	InlineCode.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    type: 'InlineCode',
	    code: function ( txt ) {
	        this._text = txt;
	        return this;
	    },
	    computeShader: function () {
	
	        // merge inputs and outputs dict to search in both
	        var replaceVariables = MACROUTILS.objectMix( {}, this._inputs );
	        replaceVariables = MACROUTILS.objectMix( replaceVariables, this._outputs );
	
	        // find all %string
	        var r = new RegExp( '%[A-Za-z0-9_]+', 'gm' );
	        var text = this._text;
	        var result = this._text.match( r );
	
	        var done = new Set(); // keep trace of replaced string
	
	        for ( var i = 0; i < result.length; i++ ) {
	
	            var str = result[ i ].substr( 1 );
	            if ( !done.has( str ) ) {
	                if ( !replaceVariables[ str ] ) {
	                    Notify.error( 'error with inline code\n' + this._text );
	                    Notify.error( 'input ' + str + ' not provided for ' + result[ i ] );
	                }
	                var reg = new RegExp( result[ i ].toString(), 'gm' );
	                text = text.replace( reg, replaceVariables[ str ].getVariable() );
	                done.add( str );
	            }
	        }
	
	        return text;
	    }
	} );
	
	
	// glsl code  output = vec4( color.rgb, alpha )
	var SetAlpha = function () {
	    BaseOperator.call( this );
	};
	
	SetAlpha.prototype = MACROUTILS.objectInherit( BaseOperator.prototype, {
	    type: 'SetAlpha',
	    validInputs: [ 'color', 'alpha' ],
	    validOuputs: [ 'color' ],
	    computeShader: function () {
	        var alpha = this._inputs.alpha;
	        return sprintf( '%s = vec4( %s.rgb, %s );', [
	            this._outputs.color.getVariable(),
	            this._inputs.color.getVariable(),
	            alpha.getType() !== 'float' ? alpha.getVariable() + '.a' : alpha.getVariable()
	        ] );
	    }
	} );
	
	
	
	// alpha is optional, if not provided the following operation is generated:
	// glsl code output.rgb = color.rgb * color.a;
	var PreMultAlpha = function () {
	    BaseOperator.call( this );
	};
	
	// TODO put the code in glsl
	PreMultAlpha.prototype = MACROUTILS.objectInherit( BaseOperator.prototype, {
	
	    type: 'PreMultAlpha',
	    validInputs: [ 'color' /*,'alpha'*/ ],
	    validOuputs: [ 'color' ],
	
	    computeShader: function () {
	        var variable = this._inputs.alpha !== undefined ? this._inputs.alpha : this._inputs.color;
	
	        var srcAlpha;
	        if ( variable.getType() !== 'float' )
	            srcAlpha = variable.getVariable() + '.a';
	        else
	            srcAlpha = variable.getVariable();
	
	        return sprintf( '%s.rgb = %s.rgb * %s;', [
	            this._outputs.color.getVariable(),
	            this._inputs.color.getVariable(),
	            srcAlpha
	        ] );
	    }
	} );
	
	module.exports = {
	    BaseOperator: BaseOperator,
	    Mult: Mult,
	    MatrixMultPosition: MatrixMultPosition,
	    MatrixMultDirection: MatrixMultDirection,
	    Add: Add,
	    InlineCode: InlineCode,
	    SetAlpha: SetAlpha,
	    SetFromNode: SetFromNode,
	    PreMultAlpha: PreMultAlpha
	};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var ShaderUtils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	var ShadowReceive = function () {
	    Node.call( this );
	
	};
	
	ShadowReceive.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    type: 'ShadowReceiveNode',
	    validInputs: [ 'lighted', 'shadowTexture', 'shadowTextureMapSize', 'shadowTextureProjectionMatrix', 'shadowTextureViewMatrix', 'shadowTextureDepthRange', 'lightNDL', 'vertexWorld', 'shadowbias', /* 'shadowexponent0', 'shadowexponent1', 'shadowepsilonVSM' */ ],
	    validOutputs: [ 'float' ],
	
	    globalFunctionDeclaration: function () {
	        return '#pragma include "shadowsReceive.glsl"';
	    },
	
	    setShadowAttribute: function ( shadowAttr ) {
	        this._shadow = shadowAttr;
	    },
	
	    // must return an array of defines
	    // because it will be passed to the ShaderGenerator
	    getDefines: function () {
	        return this._shadow.getDefines();
	    },
	    getExtensions: function () {
	        return this._shadow.getExtensions();
	    },
	    computeShader: function () {
	
	        var inp = this._inputs;
	
	        // common inputs
	        var inputs = [
	            inp.lighted,
	            inp.shadowTexture,
	            inp.shadowTextureMapSize,
	            inp.shadowTextureProjectionMatrix,
	            inp.shadowTextureViewMatrix,
	            inp.shadowTextureDepthRange,
	            inp.lightNDL,
	            inp.vertexWorld,
	            inp.shadowbias
	        ];
	
	        var algo = this._shadow.getAlgorithm();
	        if ( algo === 'ESM' ) {
	            inputs.push( this._inputs.shadowexponent0 );
	            inputs.push( this._inputs.shadowexponent1 );
	        } else if ( algo === 'EVSM' ) {
	            inputs.push( this._inputs.shadowepsilonVSM );
	            inputs.push( this._inputs.shadowexponent0 );
	            inputs.push( this._inputs.shadowexponent1 );
	        } else if ( algo === 'VSM' ) {
	            inputs.push( this._inputs.shadowepsilonVSM );
	        }
	
	        return ShaderUtils.callFunction( 'computeShadow', this._outputs.float, inputs );
	    }
	
	} );
	
	var ShadowCast = function () {
	    Node.call( this );
	
	};
	
	ShadowCast.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    type: 'ShadowCast',
	    validInputs: [ 'exponent0', 'exponent1', 'shadowDepthRange', 'fragEye' ],
	    validOutputs: [ 'color' ],
	
	    globalFunctionDeclaration: function () {
	        return '#pragma include "shadowsCastFrag.glsl"';
	    },
	    setShadowCastAttribute: function ( shadowAttr ) {
	        this._shadowCast = shadowAttr;
	        return this;
	    },
	    // must return an array of defines
	    // because it will be passed to the ShaderGenerator
	    getDefines: function () {
	        return this._shadowCast.getDefines();
	    },
	    computeShader: function () {
	        var inp = this._inputs;
	
	        var algo = this._shadowCast.getAlgorithm();
	        if ( algo === 'NONE' || algo === 'PCF' ) {
	            return ShaderUtils.callFunction( 'computeShadowDepth', this._outputs.color, [ inp.fragEye, inp.shadowDepthRange ] );
	        }
	
	        return ShaderUtils.callFunction( 'computeShadowDepth', this._outputs.color, [ inp.fragEye, inp.shadowDepthRange, inp.exponent0, inp.exponent1 ] );
	    }
	
	} );
	
	module.exports = {
	    ShadowCast: ShadowCast,
	    ShadowReceive: ShadowReceive
	};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var ShaderUtils = __webpack_require__( 161 );
	var Node = __webpack_require__( 192 );
	
	var Billboard = function () {
	    Node.apply( this );
	};
	
	Billboard.prototype = MACROUTILS.objectInherit( Node.prototype, {
	    type: 'Billboard',
	    validInputs: [ 'Vertex', 'ModelViewMatrix', 'ProjectionMatrix' ],
	    validOutputs: [ 'vec' ],
	
	    globalFunctionDeclaration: function () {
	        return '#pragma include "billboard.glsl"';
	    },
	    computeShader: function () {
	        return ShaderUtils.callFunction( 'billboard', this._outputs.vec, [ this._inputs.Vertex, this._inputs.ModelViewMatrix, this._inputs.ProjectionMatrix ] );
	    }
	} );
	
	module.exports = {
	    Billboard: Billboard
	};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var DisplayGraphRenderer = __webpack_require__( 201 );
	var DisplayGraphNode = __webpack_require__( 202 );
	var Notify = __webpack_require__( 10 );
	
	var $;
	
	var init$ = function () {
	    try {
	        $ = __webpack_require__( 203 );
	    } catch ( e ) {
	        Notify.warn( 'You will not be able to use osgUtil.DisplayGraph until you add jQuery in your page' );
	    }
	};
	
	// Simple tooltips implementation
	var SimpleTooltips = function ( options ) {
	
	    this.options = options;
	    var css = document.createElement( 'style' );
	    css.type = 'text/css';
	    css.innerHTML = [
	        '.osgDebugSimpleTooltip {',
	        'display: none;',
	        'position: absolute;',
	        'margin-left: 10px;',
	        'border-radius: 4px;',
	        'padding: 10px;',
	        'background: rgba(0,0,0,.9);',
	        'color: #ffffff;',
	        '}',
	        '.osgDebugSimpleTooltip:before {',
	        'content: ',
	        ';',
	        'position: absolute;',
	        'left: -10px;',
	        'top: 8px;',
	        'border: 10px solid transparent;',
	        'border-width: 10px 10px 10px 0;',
	        'border-right-color: rgba(0,0,0,.9);',
	        '}'
	    ].join( '\n' );
	    document.getElementsByTagName( 'head' )[ 0 ].appendChild( css );
	
	    this.el = document.createElement( 'div' );
	    this.el.className = 'osgDebugSimpleTooltip';
	    document.body.appendChild( this.el );
	    var nodes = document.querySelectorAll( this.options.selector );
	    for ( var i = 0; i < nodes.length; i++ ) {
	        nodes[ i ].addEventListener( 'mouseover', this.showTooltip.bind( this ), false );
	        nodes[ i ].addEventListener( 'mouseout', this.hideTooltip.bind( this ), false );
	    }
	};
	SimpleTooltips.prototype = {
	    showTooltip: function ( e ) {
	        if ( !$ ) return;
	
	        var target = e.currentTarget;
	        this.el.innerHTML = target.getAttribute( 'title' );
	        this.el.style.display = 'block';
	        this.el.style.left = $( target ).position().left + $( target ).get( 0 ).getBoundingClientRect().width + 'px';
	        this.el.style.top = $( target ).position().top + 'px';
	    },
	    hideTooltip: function () {
	        this.el.style.display = 'none';
	    }
	};
	
	var DisplayGraph = function () {
	
	    init$();
	    if ( !$ ) return;
	
	    // indexed with instanceID, references nodes, stateSet, sourceGeometry...
	    // referenced with strings !
	    this._selectables = new window.Map();
	
	    this._graphNode = new DisplayGraphNode( this._selectables );
	    this._graphRender = new DisplayGraphRenderer( this._selectables );
	
	    this._displayNode = true;
	    this._displayRenderer = false;
	
	    // callback when selecting a node
	    this._cbSelect = undefined;
	
	    this._focusedElement = 'graph';
	    this._idToDomElement = new window.Map();
	
	    this._$svg = $( '<svg width=100% height=100%></svg>' );
	    $( 'body' ).append( this._$svg );
	
	    this._css = '.node {text-align: center;cursor: pointer;}.node rect {stroke: #FFF;}.edgePath path {stroke: #FFF;fill: none;}table {text-align: right;}svg {position: absolute;left: 0px;top: 0px;}.osgDebugButton {position: absolute;left: 15px;top: 15px;z-index: 5;border: 0;background: #65a9d7;background: -webkit-gradient(linear, left top, left bottom, from(#3e779d), to(#65a9d7));background: -webkit-linear-gradient(top, #3e779d, #65a9d7);background: -moz-linear-gradient(top, #3e779d, #65a9d7);background: -ms-linear-gradient(top, #3e779d, #65a9d7);background: -o-linear-gradient(top, #3e779d, #65a9d7);padding: 5px 10px;-webkit-border-radius: 7px;-moz-border-radius: 7px;border-radius: 7px;-webkit-box-shadow: rgba(0,0,0,1) 0 1px 0;-moz-box-shadow: rgba(0,0,0,1) 0 1px 0;box-shadow: rgba(0,0,0,1) 0 1px 0;text-shadow: rgba(0,0,0,.4) 0 1px 0;color: white;font-size: 15px;font-family: Helvetica, Arial, Sans-Serif;text-decoration: none;vertical-align: middle;}.osgDebugButton:hover {border-top-color: #28597a;background: #28597a;color: #ccc;}.osgDebugButton:active {border-top-color: #1b435e;background: #1b435e;}.osgDebugSimpleTooltip .osgDebugName {font-weight: bold;color: #60b1fc;margin: 0;}.osgDebugSimpleTooltip .osgDebugDescription {margin: 0;}';
	};
	
	DisplayGraph.instance = function () {
	    if ( !DisplayGraph._instance )
	        DisplayGraph._instance = new DisplayGraph();
	    return DisplayGraph._instance;
	};
	
	DisplayGraph.prototype = {
	    getColorFromClassName: DisplayGraphNode.prototype.getColorFromClassName,
	
	    setCallbackSelect: function ( cb ) {
	        this._cbSelect = cb;
	    },
	
	    reset: function () {
	        if ( !$ ) return;
	
	        this._selectables.clear();
	        this._$svg.empty();
	        this._focusedElement = 'scene';
	        $( '.osgDebugButton' ).hide();
	    },
	
	    setDisplayGraphRenderer: function ( bool ) {
	        this._displayRenderer = bool;
	    },
	
	    createRenderGraph: function ( renderStage ) {
	        // called by renderer
	        this._graphRender.createGraph( renderStage );
	        this.displayGraph();
	    },
	
	    createGraph: function ( root ) {
	        if ( !$ ) return;
	        this.reset();
	
	        this._displayNode = !!root;
	        if ( root ) {
	            this._graphNode.createGraph( root );
	        }
	
	        // check if asynchronous is necessary
	        if ( !this._displayRenderer ) {
	            this.displayGraph();
	        } else {
	            // circular dependency
	            __webpack_require__( 204 ).debugGraph = true;
	        }
	    },
	
	    // Create and display a dagre d3 graph
	    displayGraph: function () {
	        if ( !$ ) return;
	        if ( window.d3 && window.dagreD3 ) {
	            this._createGraphApply();
	            return;
	        }
	
	        var d3url = '//cdnjs.cloudflare.com/ajax/libs/d3/3.4.13/d3.min.js';
	        var dagreurl = '//cdn.jsdelivr.net/dagre-d3/0.2.9/dagre-d3.min.js';
	
	        var cb = this._createGraphApply.bind( this );
	        $.getScript( d3url ).done( function () {
	            $.getScript( dagreurl ).done( cb );
	        } );
	    },
	
	    _createGraphApply: function () {
	        var diGraph = new window.dagreD3.Digraph();
	        if ( this._displayNode ) this._graphNode.generateNodeAndLink( diGraph );
	        if ( this._displayRenderer ) this._graphRender.generateNodeAndLink( diGraph );
	
	
	        // Add the style of the graph
	        this.injectStyleElement();
	        $( '.osgDebugButton' ).show();
	
	        // Create the renderer
	        var renderer = this.renderer = new window.dagreD3.Renderer();
	
	        // Set up an SVG group so that we can translate the final graph.
	        var svg = window.d3.select( this._$svg.get( 0 ) );
	        var svgGroup = svg.append( 'g' );
	
	        // Set initial zoom to 75%
	        var initialScale = 0.75;
	        var oldZoom = renderer.zoom();
	        renderer.zoom( function ( g, argSVG ) {
	            var zoom = oldZoom( g, argSVG );
	
	            zoom.scale( initialScale ).event( argSVG );
	            return zoom;
	        } );
	
	        // Simple function to style the tooltip for the given node.
	        var styleTooltip = function ( instanceID, description ) {
	            // instanceID is used by onNodeSelect to retrieve the node
	            return '<p class="osgDebugName">' + instanceID + '</p><pre class="osgDebugDescription">' + description + '</pre>';
	        };
	
	        var idToDom = this._idToDomElement;
	        // Override drawNodes to set up the hover.
	        var oldDrawNodes = renderer.drawNodes();
	        renderer.drawNodes( function ( g, argSVG ) {
	            var svgNodes = oldDrawNodes( g, argSVG );
	
	            // Set the title on each of the nodes and use tipsy to display the tooltip on hover
	            svgNodes.attr( 'title', function ( d ) {
	                idToDom.set( d, this );
	                return styleTooltip( d, g.node( d ).description || '' );
	            } );
	
	            return svgNodes;
	        } );
	
	        // Run the renderer. This is what draws the final graph.
	        renderer.run( diGraph, svgGroup );
	
	        this.tooltip = new SimpleTooltips( {
	            selector: '.node'
	        } );
	
	        // Do a console log of the node (or stateset) and save it in window.*
	        $( '.node' ).click( this.onNodeSelect.bind( this ) );
	        this.focusOnGraph();
	    },
	
	    selectNode: function ( node ) {
	        var id = node.getInstanceID();
	        var dom = this._idToDomElement.get( id );
	        if ( dom )
	            $( dom ).click();
	    },
	
	    onNodeSelect: function ( e ) {
	        var target = e.currentTarget;
	        var identifier = $( target.getAttribute( 'title' ) )[ 0 ].innerHTML;
	        var selectables = this._selectables;
	
	        // color the node back
	        if ( this.lastNode ) {
	            this.lastNode.style.fill = this.lastColor;
	        }
	
	        // non selectables nodes
	        var elt = selectables.get( identifier );
	        if ( !elt )
	            return;
	
	        this.lastNode = target.childNodes[ 0 ];
	        this.lastColor = this.lastNode.style.fill;
	        target.childNodes[ 0 ].style.fill = '#f00';
	
	        window.activeNode = elt;
	        Notify.info( 'window.activeNode is set with the node below !' );
	        Notify.log( window.activeNode );
	        Notify.log( '\n' );
	
	        if ( this._cbSelect )
	            this._cbSelect( elt );
	    },
	
	    focusOnScene: function () {
	        $( '.osgDebugButton' ).text( 'Access to the graph' );
	        this._$svg.css( 'zIndex', '-2' );
	        this._focusedElement = 'scene';
	    },
	
	    focusOnGraph: function () {
	        $( '.osgDebugButton' ).text( 'Access to the scene' );
	        this._$svg.css( 'zIndex', '2' );
	        $( '.osgDebugSimpleTooltip' ).css( 'zIndex', '3' );
	        this._focusedElement = 'graph';
	    },
	
	    // Apply all the style
	    injectStyleElement: function () {
	        if ( this._cssInjected )
	            return;
	        this._cssInjected = true;
	
	        $( 'body' ).append( '<button class="osgDebugButton">Access to the scene</button>' );
	        $( '.osgDebugButton' ).click( function () {
	            if ( this._focusedElement === 'scene' )
	                this.focusOnGraph();
	            else
	                this.focusOnScene();
	        }.bind( this ) );
	
	        var css = document.createElement( 'style' );
	        css.type = 'text/css';
	        css.innerHTML = this._css;
	        document.getElementsByTagName( 'head' )[ 0 ].appendChild( css );
	    }
	};
	
	module.exports = DisplayGraph;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var DisplayGraphNode = __webpack_require__( 202 );
	var RenderBin = __webpack_require__( 66 );
	
	var DisplayGraphRenderer = function ( selectables ) {
	
	    this._selectables = selectables;
	    this._nodeList = [];
	    this._linkList = [];
	
	    this._renderBinMap = new window.Map();
	    this._renderBinStack = [];
	
	    this._generatorID = 0;
	    this._refID = 0; // invalide old _instanceID if we recreate the graph
	
	    this._uniqueEdges = new window.Set();
	};
	
	DisplayGraphRenderer.prototype = {
	    getColorFromClassName: DisplayGraphNode.prototype.getColorFromClassName,
	
	    createGraph: function ( renderBin ) {
	        this.reset();
	        this.apply( renderBin );
	    },
	
	    reset: function () {
	        this._renderBinMap.clear();
	        this._renderBinStack.length = 0;
	        this._generatorID = 0;
	        this._refID++;
	
	        this._nodeList.length = 0;
	        this._linkList.length = 0;
	
	        this._uniqueEdges.clear();
	    },
	
	    apply: function ( rb ) {
	
	        var instanceID = rb.getInstanceID();
	        if ( !this._renderBinMap.has( instanceID ) ) {
	            this._renderBinMap.set( instanceID, rb );
	        }
	
	        this._renderBinStack.push( rb );
	
	        // pre render stage if render stage node
	        if ( rb.getPreRenderStageList ) {
	            var preRenderList = rb.getPreRenderStageList();
	            for ( var i = 0, ni = preRenderList.length; i < ni; ++i ) {
	                this.apply( preRenderList[ i ].renderStage );
	            }
	        }
	
	        // draw implementation
	        // handle rs camera
	        this.registerNode( rb );
	
	        // post render stage if render stage node
	        if ( rb.getPostRenderStageList ) {
	            var postRenderList = rb.getPostRenderStageList();
	            for ( var j = 0, nj = postRenderList.length; j < nj; ++j ) {
	                this.apply( postRenderList[ j ].renderStage );
	            }
	        }
	
	        this._renderBinStack.pop();
	    },
	
	    registerNode: function ( rb ) {
	
	        var childID = rb.getInstanceID();
	
	        this._nodeList.push( rb );
	
	        // register bins
	        var bins = rb._bins;
	        var binKeys = window.Object.keys( bins );
	        for ( var i = 0, ni = binKeys.length; i < ni; i++ ) {
	            var bin = bins[ binKeys[ i ] ];
	            this.apply( bin );
	        }
	
	        // register fine grained leafs
	        if ( rb._leafs.length ) {
	            for ( var j = 0, nj = rb._leafs.length; j < nj; j++ ) {
	                this.createNodeAndSetID( childID, rb._leafs[ j ] );
	            }
	        }
	
	        // register coarse grained leafs
	        for ( var k = 0, nk = rb.stateGraphList.length; k < nk; k++ ) {
	            var sg = rb.stateGraphList[ k ];
	            this.createNodeAndSetID( childID, sg );
	            var stateGraphID = sg._instanceID;
	            for ( var l = 0, nl = sg.leafs.length; l < nl; l++ )
	                this.createNodeAndSetID( stateGraphID, sg.leafs[ l ] );
	        }
	
	
	        // no parent no link
	        if ( this._renderBinStack.length < 2 )
	            return;
	
	        var parentID = this._renderBinStack[ this._renderBinStack.length - 2 ].getInstanceID();
	        this.createLink( parentID, childID );
	    },
	
	    createLink: function ( parent, child ) {
	        var key = parent + '+' + child;
	        if ( !this._uniqueEdges.has( key ) ) {
	            this._linkList.push( {
	                parentNode: parent,
	                childrenNode: child
	            } );
	            this._uniqueEdges.add( key );
	        }
	    },
	
	    createNodeAndSetID: function ( parentID, node ) {
	
	        // register render leaf
	        this._nodeList.push( node );
	
	        // generate fake id < 0 because RenderLeaf does not inherit from Object
	        if ( node._instanceID === undefined || ( node._instanceID < 0 && node._refID !== this._refID ) ) {
	            node._instanceID = -1 - this._generatorID++;
	            node._refID = this._refID;
	        }
	
	        this.createLink( parentID, node._instanceID );
	    },
	
	    generateRenderLeaf: function ( g, node ) {
	
	        var instanceID = node._instanceID;
	        var className = 'RenderLeaf';
	        var geomName = node._geometry && node._geometry.getName() ? '\n' + node._geometry.getName() : 'Geometry';
	
	        var label = className + ' ( ' + node._instanceID + ' )';
	        label += '\n' + geomName + ' ( ' + node._geometry.getInstanceID() + ' )';
	
	        this._selectables.set( instanceID.toString(), node );
	        g.addNode( instanceID, {
	            label: label,
	            description: '',
	            style: 'fill: ' + this.getColorFromClassName( className ) + ';stroke-width: 0px;'
	        } );
	    },
	
	    generateStateGraph: function ( g, node ) {
	
	        var instanceID = node._instanceID;
	        var className = 'StateGraph';
	        var label = className + ' ( ' + node._instanceID + ' )';
	        label += '\n' + node.leafs.length + ' leafs';
	
	        this._selectables.set( instanceID.toString(), node );
	        g.addNode( instanceID, {
	            label: label,
	            description: '',
	            style: 'fill: ' + this.getColorFromClassName( className ) + ';stroke-width: 0px;'
	        } );
	    },
	
	    generateRenderStage: function ( g, node ) {
	
	        var label = node.className() + ' ( ' + node._instanceID + ' )';
	        if ( node.getName() ) label += '\n' + node.getName();
	        label += '\nViewport ( ' + node.getViewport().width() + ' x ' + node.getViewport().height() + ' )';
	
	        this._selectables.set( node.getInstanceID().toString(), node );
	        g.addNode( node.getInstanceID(), {
	            label: label,
	            description: '',
	            style: 'fill: ' + this.getColorFromClassName( node.className() ) + ';stroke-width: 0px;'
	        } );
	
	    },
	
	    generateRenderBin: function ( g, rb ) {
	
	        var label = rb.className() + ' ( ' + rb.getInstanceID() + ' )';
	        if ( rb.getName() ) label += '\n' + rb.getName();
	
	        var sortMode = '';
	        if ( rb.getSortMode() === RenderBin.SORT_BACK_TO_FRONT )
	            sortMode = 'SortMode: BackToFront';
	
	        var description = 'BinNumber: ' + rb.getBinNumber() + '\n' + sortMode;
	
	        this._selectables.set( rb.getInstanceID().toString(), rb );
	        g.addNode( rb.getInstanceID(), {
	            label: label,
	            description: description,
	            style: 'fill: ' + this.getColorFromClassName( rb.className() ) + ';stroke-width: 0px;'
	        } );
	
	    },
	
	    // Subfunction of createGraph, will iterate to create all the node and link in dagre
	    generateNodeAndLink: function ( g ) {
	        for ( var i = 0, ni = this._nodeList.length; i < ni; i++ ) {
	
	            var node = this._nodeList[ i ];
	
	            // detect if RenderLeaf
	            if ( node._geometry && node._depth !== undefined ) {
	                this.generateRenderLeaf( g, node );
	
	            } else if ( node.depth !== undefined && node.leafs && node.children ) {
	                // it's StateGraph
	                this.generateStateGraph( g, node );
	
	            } else if ( node.className() === 'RenderStage' ) {
	                this.generateRenderStage( g, node );
	
	            } else {
	                // it's a RenderBin
	                this.generateRenderBin( g, node );
	            }
	
	        }
	
	        for ( var j = 0, nj = this._linkList.length; j < nj; j++ ) {
	            g.addEdge( null, this._linkList[ j ].parentNode, this._linkList[ j ].childrenNode );
	        }
	    }
	};
	
	module.exports = DisplayGraphRenderer;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var NodeVisitor = __webpack_require__( 22 );
	var MorphGeometry = __webpack_require__( 79 );
	
	var DisplayGraphNode = function ( selectables ) {
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );
	
	    this._selectables = selectables;
	    this._nodeList = [];
	    this._linkList = [];
	
	    // don't reference twice same node
	    this._uniqueNodes = new window.Set();
	    this._uniqueEdges = new window.Set();
	};
	
	DisplayGraphNode.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    getColorFromClassName: function ( name ) {
	        switch ( name ) {
	        case 'ShadowedScene':
	            return '#3D3D3D';
	        case 'Camera':
	            return '#AB7BCF';
	        case 'RenderBin':
	            return '#59778B';
	        case 'LightSource':
	            return '#53967D';
	        case 'RenderStage':
	            return '#DDCC55';
	        case 'RenderLeaf':
	        case 'Geometry':
	            return '#FFCC55';
	        case 'RigGeometry':
	            return '#DD8800';
	        case 'MorphGeometry':
	            return '#AA5500';
	        case 'MatrixTransform':
	            return '#CE697E';
	        case 'StateSet':
	            return '#0099FF';
	        case 'StateGraph':
	        case 'Skeleton':
	            return '#96999E';
	        case 'Bone':
	            return '#A9DEAA';
	        case 'Node':
	            return '#FFFFFF';
	        default:
	            return '#FF00AA';
	        }
	    },
	
	    createGraph: function ( root ) {
	        this.reset();
	        root.accept( this );
	    },
	
	    reset: function () {
	        this._nodeList.length = 0;
	        this._linkList.length = 0;
	        this._uniqueNodes.clear();
	        this._uniqueEdges.clear();
	    },
	
	    apply: function ( node ) {
	        if ( node._isNormalDebug )
	            return;
	
	        if ( !this._uniqueNodes.has( node.getInstanceID() ) ) {
	            this._uniqueNodes.add( node.getInstanceID() );
	            this._nodeList.push( node );
	        }
	
	        if ( this.nodePath.length >= 2 ) {
	            var parentID = this.nodePath[ this.nodePath.length - 2 ].getInstanceID();
	            var childID = node.getInstanceID();
	            var key = parentID + '+' + childID;
	            if ( !this._uniqueEdges.has( key ) ) {
	                this._linkList.push( {
	                    parentNode: parentID,
	                    childrenNode: childID
	                } );
	                this._uniqueEdges.add( key );
	            }
	        }
	
	        this.traverse( node );
	    },
	
	    // Create an array to display the matrix
	    createMatrixGrid: function ( node, matrixArray ) {
	
	        var nodeMatrix = '';
	
	        nodeMatrix += '<table><tr><td>' + matrixArray[ 0 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 4 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 8 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 12 ] + '</td></tr>';
	
	        nodeMatrix += '<tr><td>' + matrixArray[ 1 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 5 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 9 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 13 ] + '</td></tr>';
	
	        nodeMatrix += '<tr><td>' + matrixArray[ 2 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 6 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 10 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 14 ] + '</td></tr>';
	
	        nodeMatrix += '<tr><td>' + matrixArray[ 3 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 7 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 11 ] + '</td>';
	        nodeMatrix += '<td>' + matrixArray[ 15 ] + '</td></tr></table>';
	
	        return nodeMatrix;
	    },
	
	    getLabel: function ( obj ) {
	        var label = obj.className() + ' (' + obj.getInstanceID() + ')';
	        if ( obj.getName && obj.getName() ) label += '\n' + obj.getName();
	        return label;
	    },
	
	    generateNode: function ( g, node ) {
	        var description = '';
	        if ( node.getMatrix && node.getMatrix() ) {
	            description += '<br /><br />' + this.createMatrixGrid( node, node.getMatrix() );
	        }
	
	        this._selectables.set( node.getInstanceID().toString(), node );
	        g.addNode( node.getInstanceID(), {
	            label: this.getLabel( node ),
	            description: description,
	            style: 'fill: ' + this.getColorFromClassName( node.className() ) + ';stroke-width: 0px;'
	        } );
	    },
	
	    generateStateSet: function ( g, node ) {
	        var stateSet = node.getStateSet();
	        var stateSetID = stateSet.getInstanceID();
	
	        var label = this.getLabel( stateSet );
	        label += '\nNbTexture : ' + stateSet.getNumTextureAttributeLists();
	
	        if ( !g.hasNode( stateSetID ) ) {
	
	            this._selectables.set( stateSetID.toString(), stateSet );
	            g.addNode( stateSetID, {
	                label: label,
	                style: 'fill: ' + this.getColorFromClassName( stateSet.className() ) + ';stroke-width: 0px;'
	            } );
	        }
	
	        g.addEdge( null, node.getInstanceID(), stateSetID, {
	            style: 'stroke: ' + this.getColorFromClassName( stateSet.className() ) + ';'
	        } );
	    },
	
	    generateSourceGeometry: function ( g, node ) {
	        var sourceGeom = node.getSourceGeometry();
	        var sourceGeomID = sourceGeom.getInstanceID();
	
	        this._selectables.set( sourceGeomID.toString(), sourceGeom );
	        g.addNode( sourceGeomID, {
	            label: this.getLabel( sourceGeom ),
	            style: 'fill: ' + this.getColorFromClassName( sourceGeom.className() ) + ';stroke-width: 0px;'
	        } );
	
	        g.addEdge( null, node.getInstanceID(), sourceGeomID, {
	            style: 'stroke: ' + this.getColorFromClassName( sourceGeom.className() ) + ';'
	        } );
	    },
	
	    // Subfunction of createGraph, will iterate to create all the node and link in dagre
	    generateNodeAndLink: function ( g ) {
	
	        for ( var i = 0, ni = this._nodeList.length; i < ni; i++ ) {
	            var node = this._nodeList[ i ];
	
	            // node
	            this.generateNode( g, node );
	
	            // adds statesets node
	            if ( node.getStateSet() ) {
	                this.generateStateSet( g, node );
	            }
	
	            // adds source geometry node
	            if ( node.getSourceGeometry && node.getSourceGeometry() instanceof MorphGeometry ) {
	                this.generateSourceGeometry( g, node );
	            }
	        }
	
	        for ( var j = 0, nj = this._linkList.length; j < nj; j++ ) {
	            g.addEdge( null, this._linkList[ j ].parentNode, this._linkList[ j ].childrenNode );
	        }
	    }
	} );
	
	module.exports = DisplayGraphNode;


/***/ }),
/* 203 */
/***/ (function(module, exports) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_203__ === 'undefined') {var e = new Error("Cannot find module \"undefined\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_203__;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var CullSettings = __webpack_require__( 57 );
	var CullVisitor = __webpack_require__( 63 );
	var Object = __webpack_require__( 13 );
	var RenderStage = __webpack_require__( 67 );
	var State = __webpack_require__( 104 );
	var StateGraph = __webpack_require__( 8 );
	var Vec4 = __webpack_require__( 25 );
	var osgShader = __webpack_require__( 162 );
	var DisplayGraph = __webpack_require__( 200 );
	
	
	var Renderer = function ( camera ) {
	    Object.call( this );
	
	    this._state = undefined;
	    this._camera = camera;
	    this._renderStage = undefined;
	    this._stateGraph = undefined;
	
	    this._frameStamp = undefined;
	
	    this._previousCullsettings = new CullSettings();
	
	    this.setDefaults();
	};
	
	Renderer.debugGraph = false;
	
	Renderer.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	
	    setDefaults: function () {
	
	        this._state = new State( new osgShader.ShaderGeneratorProxy() );
	
	        this._cullVisitor = new CullVisitor();
	        this._cullVisitor.setRenderer( this );
	        this._stateGraph = new StateGraph();
	
	        this.getCamera().setClearColor( Vec4.create() );
	        this.setRenderStage( new RenderStage() );
	
	        var osg = __webpack_require__( 4 );
	        var stateSet = this.getCamera().getOrCreateStateSet();
	        stateSet.setAttributeAndModes( new osg.Material() );
	        stateSet.setAttributeAndModes( new osg.Depth() );
	        stateSet.setAttributeAndModes( new osg.BlendFunc() );
	        stateSet.setAttributeAndModes( new osg.CullFace() );
	
	    },
	
	    getCullVisitor: function () {
	        return this._cullVisitor;
	    },
	
	    setCullVisitor: function ( cv ) {
	        if ( cv && !cv.getRenderer() ) cv.setRenderer( this );
	        this._cullVisitor = cv;
	    },
	
	    setRenderStage: function ( rs ) {
	        this._renderStage = rs;
	    },
	
	    getCamera: function () {
	        return this._camera;
	    },
	
	    setFrameStamp: function ( fs ) {
	        this._frameStamp = fs;
	    },
	
	    getFrameStamp: function () {
	        return this._frameStamp;
	    },
	
	    getState: function () {
	        return this._state;
	    },
	
	    setState: function ( state ) {
	        this._state = state;
	    },
	
	    setGraphicContext: function ( gc ) {
	        this._state.setGraphicContext( gc );
	    },
	
	    getGraphicContext: function () {
	        return this._state.getGraphicContext();
	    },
	
	    cullAndDraw: function () {
	        this.cull();
	        this.draw();
	    },
	
	    cull: function () {
	
	        var camera = this.getCamera();
	        var view = camera.getView();
	
	        this._cullVisitor.setFrameStamp( this._frameStamp );
	
	        // reset stats
	        this._cullVisitor.resetStats();
	
	        // this part of code should be called for each view
	        // right now, we dont support multi view
	        this._stateGraph.clean();
	        this._renderStage.reset();
	
	        this._cullVisitor.reset();
	        this._cullVisitor.setStateGraph( this._stateGraph );
	        this._cullVisitor.setRenderStage( this._renderStage );
	
	        this._cullVisitor.pushStateSet( camera.getStateSet() );
	
	        // save cullSettings
	        this._previousCullsettings.reset();
	        this._previousCullsettings.setCullSettings( this._cullVisitor );
	        this._cullVisitor.setCullSettings( camera );
	        if ( this._previousCullsettings.getSettingSourceOverrider() === this._cullVisitor && this._previousCullsettings.getEnableFrustumCulling() ) {
	            this._cullVisitor.setEnableFrustumCulling( true );
	        }
	
	        // Push reference on the projection stack, it means that if compute near/far
	        // is activated, it will update the projection matrix of the camera
	        this._cullVisitor.pushCameraModelViewProjectionMatrix( camera, camera.getViewMatrix(), camera.getProjectionMatrix() );
	
	        // update bound
	        camera.getBound();
	
	        var light = view.getLight();
	        var View = __webpack_require__( 205 );
	
	        if ( light ) {
	
	            switch ( view.getLightingMode() ) {
	
	            case View.LightingMode.HEADLIGHT:
	                this._cullVisitor.addPositionedAttribute( null, light );
	                break;
	
	            case View.LightingMode.SKY_LIGHT:
	                this._cullVisitor.addPositionedAttribute( camera.getViewMatrix(), light );
	                break;
	
	            default:
	                break;
	            }
	        }
	
	        this._cullVisitor.pushViewport( camera.getViewport() );
	
	
	        this._renderStage.setClearDepth( camera.getClearDepth() );
	        this._renderStage.setClearColor( camera.getClearColor() );
	        this._renderStage.setClearMask( camera.getClearMask() );
	        this._renderStage.setViewport( camera.getViewport() );
	
	        // pass de dbpager to the cullvisitor, so plod's can do the requests
	        this._cullVisitor.setDatabaseRequestHandler( this._camera.getView().getDatabasePager() );
	        // dont add camera on the stack just traverse it
	        this._cullVisitor.handleCullCallbacksAndTraverse( camera );
	
	        // fix projection matrix if camera has near/far auto compute
	        this._cullVisitor.popCameraModelViewProjectionMatrix( camera );
	
	        // Important notes about near/far
	        // If you are using the picking on the main camera and
	        // you use only children sub camera for RTT, your
	        // main camera will keep +/-infinity for near/far because
	        // the computation of near/far is done by camera and use Geometry
	
	
	        // restore previous state of the camera
	        this._cullVisitor.setCullSettings( this._previousCullsettings );
	
	        this._cullVisitor.popViewport();
	        this._cullVisitor.popStateSet();
	
	        this._renderStage.sort();
	
	    },
	
	    draw: function () {
	
	        var state = this.getState();
	
	        // important because cache are used in cullvisitor
	        state.resetCacheFrame();
	
	        // reset stats counter
	        state.resetStats();
	
	        this._renderStage.setCamera( this._camera );
	        this._renderStage.draw( state );
	
	        if ( Renderer.debugGraph ) {
	            DisplayGraph.instance().createRenderGraph( this._renderStage );
	            Renderer.debugGraph = false;
	        }
	
	        this._renderStage.setCamera( undefined );
	
	        state.applyDefault();
	
	    }
	
	
	} ), 'osgViewer', 'Renderer' );
	
	module.exports = Renderer;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BufferArray = __webpack_require__( 40 );
	var Camera = __webpack_require__( 56 );
	var FrameStamp = __webpack_require__( 88 );
	var FrameBufferObject = __webpack_require__( 68 );
	var Light = __webpack_require__( 97 );
	var Matrix = __webpack_require__( 23 );
	var Texture = __webpack_require__( 34 );
	var Program = __webpack_require__( 100 );
	var Shader = __webpack_require__( 101 );
	var Vec3 = __webpack_require__( 15 );
	var Viewport = __webpack_require__( 107 );
	var WebGLCaps = __webpack_require__( 32 );
	var IntersectionVisitor = __webpack_require__( 143 );
	var LineSegmentIntersector = __webpack_require__( 144 );
	var Renderer = __webpack_require__( 204 );
	var Scene = __webpack_require__( 206 );
	var DisplayGraph = __webpack_require__( 200 );
	var Notify = __webpack_require__( 10 );
	
	
	// View is normally inherited from osg/View. In osgjs we dont need it yet
	// this split, so everything is in osgViewer/View
	
	var View = function () {
	
	    this._camera = new Camera();
	    this._scene = new Scene();
	    this._frameStamp = new FrameStamp();
	    this._lightingMode = undefined;
	    this._manipulator = undefined;
	    this._canvasWidth = 0;
	    this._canvasHeight = 0;
	
	    this._requestContinousUpdate = true;
	    this._requestRedraw = true;
	
	    this.setLightingMode( View.LightingMode.HEADLIGHT );
	    // assign a renderer to the camera
	    var renderer = this.createRenderer( this.getCamera() );
	    renderer.setFrameStamp( this._frameStamp );
	    this.getCamera().setRenderer( renderer );
	    this.getCamera().setView( this );
	
	};
	
	View.LightingMode = {
	    NO_LIGHT: 0,
	    HEADLIGHT: 1,
	    SKY_LIGHT: 2
	};
	
	View.prototype = {
	    requestRedraw: function () {
	        this._requestRedraw = true;
	    },
	    requestContinuousUpdate: function ( bool ) {
	        this._requestContinousUpdate = bool;
	    },
	    createRenderer: function ( camera ) {
	        var render = new Renderer( camera );
	        //camera->setStats(new osg::Stats("Camera"));
	        return render;
	    },
	
	    setGraphicContext: function ( gc ) {
	        this.getCamera().getRenderer().getState().setGraphicContext( gc );
	    },
	
	    getGraphicContext: function () {
	        return this.getCamera().getRenderer().getState().getGraphicContext();
	    },
	
	
	    initWebGLCaps: function ( gl ) {
	
	        WebGLCaps.instance( gl );
	
	    },
	
	    // check Each frame because HTML standard inconsistencies
	    // - mobile full-screen, device orientation, etc
	    // peculiarity of webgl canvas resizing here some details
	    // http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
	    // screen size
	    // http://tripleodeon.com/2011/12/first-understand-your-screen/
	    // touchy is touchy: many things to know
	    // http://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html
	    computeCanvasSize: ( function () {
	        return function ( canvas ) {
	
	            var clientWidth, clientHeight;
	            clientWidth = canvas.clientWidth;
	            clientHeight = canvas.clientHeight;
	
	            if ( clientWidth < 1 ) clientWidth = 1;
	            if ( clientHeight < 1 ) clientHeight = 1;
	
	            var devicePixelRatio = this._devicePixelRatio;
	
	            var widthPixel = Math.floor( clientWidth * devicePixelRatio );
	            var heightPixel = Math.floor( clientHeight * devicePixelRatio );
	
	            var hasChanged = false;
	            if ( this._canvasWidth !== widthPixel ) {
	                canvas.width = widthPixel;
	                this._canvasWidth = widthPixel;
	                hasChanged = true;
	            }
	
	            if ( this._canvasHeight !== heightPixel ) {
	                canvas.height = heightPixel;
	                this._canvasHeight = heightPixel;
	                hasChanged = true;
	            }
	            return hasChanged;
	        };
	    } )(),
	
	    setUpView: function ( canvas, options ) {
	
	
	        var devicePixelRatio = window.devicePixelRatio || 1;
	        var overrideDevicePixelRatio = options.getNumber( 'overrideDevicePixelRatio' );
	        var maxDevicePixelRatio = options.getNumber( 'maxDevicePixelRatio' ) || -1;
	
	        // override the pixel ratio, used to save pixel on mobile
	        if ( typeof overrideDevicePixelRatio === 'number' ) {
	            devicePixelRatio = overrideDevicePixelRatio;
	        } else if ( maxDevicePixelRatio !== -1 ) {
	            devicePixelRatio = Math.min( devicePixelRatio, maxDevicePixelRatio );
	        }
	        this._devicePixelRatio = devicePixelRatio;
	
	        this.computeCanvasSize( canvas );
	
	        var ratio = canvas.clientWidth / canvas.clientHeight;
	
	        var width = canvas.width;
	        var height = canvas.height;
	
	        this._camera.setViewport( new Viewport( 0, 0, width, height ) );
	
	        this._camera.setGraphicContext( this.getGraphicContext() );
	        Matrix.makeLookAt( Vec3.createAndSet( 0.0, 0.0, -10.0 ), Vec3.create(), Vec3.createAndSet( 0.0, 1.0, 0.0 ), this._camera.getViewMatrix() );
	        Matrix.makePerspective( 55, ratio, 1.0, 1000.0, this._camera.getProjectionMatrix() );
	
	
	        if ( options && options.enableFrustumCulling )
	            this.getCamera().getRenderer().getCullVisitor().setEnableFrustumCulling( true );
	
	
	        // add a function to refresh the graph from the console
	        if ( options && options.debugGraph ) {
	
	            var camera = this.getCamera();
	            DisplayGraph.instance().refreshGraph = function () {
	                var displayGraph = DisplayGraph.instance();
	                displayGraph.setDisplayGraphRenderer( true );
	                displayGraph.createGraph( camera );
	            };
	
	            Notify.log( 'to refresh the graphs type in the console:\nOSG.osgUtil.DisplayGraph.instance().refreshGraph()' );
	
	        }
	
	    },
	
	    /**
	     * X = 0 at the left
	     * Y = 0 at the BOTTOM
	     */
	    computeIntersections: function ( x, y, traversalMask ) {
	
	        /*jshint bitwise: false */
	        if ( traversalMask === undefined ) {
	            traversalMask = ~0;
	        }
	        /*jshint bitwise: true */
	
	
	        if ( !this._lsi ) {
	            this._lsi = new LineSegmentIntersector();
	        } else {
	            this._lsi.reset();
	        }
	
	        if ( !this._origIntersect ) {
	            this._origIntersect = Vec3.create();
	            this._dstIntersect = Vec3.create();
	        }
	
	        this._lsi.set( Vec3.set( x, y, 0.0, this._origIntersect ), Vec3.set( x, y, 1.0, this._dstIntersect ) );
	
	
	        if ( !this._iv ) {
	            this._iv = new IntersectionVisitor();
	            this._iv.setIntersector( this._lsi );
	        } else {
	            this._iv.reset();
	        }
	        this._iv.setTraversalMask( traversalMask );
	        this._camera.accept( this._iv );
	
	        return this._lsi.getIntersections();
	    },
	
	    setFrameStamp: function ( frameStamp ) {
	        this._frameStamp = frameStamp;
	    },
	
	    getFrameStamp: function () {
	        return this._frameStamp;
	    },
	
	    setCamera: function ( camera ) {
	        this._camera = camera;
	    },
	
	    getCamera: function () {
	        return this._camera;
	    },
	
	    setSceneData: function ( node ) {
	
	        if ( node === this._scene.getSceneData() )
	            return;
	
	        this._scene.setSceneData( node );
	
	        this._camera.removeChildren();
	        this._camera.addChild( node );
	
	    },
	
	    getSceneData: function () {
	        return this._scene.getSceneData();
	    },
	
	    setDatabasePager: function ( dbpager ) {
	        this._scene.setDatabasePager( dbpager );
	    },
	
	    getDatabasePager: function () {
	        return this._scene.getDatabasePager();
	    },
	
	    getScene: function () {
	        return this._scene;
	    },
	
	    getManipulator: function () {
	        return this._manipulator;
	    },
	
	    setManipulator: function ( manipulator ) {
	        this._manipulator = manipulator;
	    },
	
	    getLight: function () {
	        return this._light;
	    },
	
	    setLight: function ( light ) {
	        this._light = light;
	        if ( this._lightingMode !== View.LightingMode.NO_LIGHT ) {
	            this._scene.getOrCreateStateSet().setAttributeAndModes( this._light );
	        }
	    },
	
	    getLightingMode: function () {
	        return this._lightingMode;
	    },
	
	    setLightingMode: function ( lightingMode ) {
	
	        if ( this._lightingMode !== lightingMode ) {
	            this._lightingMode = lightingMode;
	
	            if ( this._lightingMode !== View.LightingMode.NO_LIGHT ) {
	
	                if ( !this._light ) this._light = new Light();
	
	            } else {
	                this._light = undefined;
	            }
	        }
	    },
	
	    // In OSG this call is done in SceneView
	    flushDeletedGLObjects: function ( /*currentTime,*/ availableTime ) {
	        // Flush all deleted OpenGL objects within the specified availableTime
	        var gl = this.getGraphicContext();
	        availableTime = BufferArray.flushDeletedGLBufferArrays( gl, availableTime );
	        availableTime = Texture.getTextureManager( gl ).flushDeletedTextureObjects( gl, availableTime );
	        availableTime = Program.flushDeletedGLPrograms( gl, availableTime );
	        availableTime = Shader.flushDeletedGLShaders( gl, availableTime );
	        availableTime = FrameBufferObject.flushDeletedGLFrameBuffers( gl, availableTime );
	        availableTime = FrameBufferObject.flushDeletedGLRenderBuffers( gl, availableTime );
	    },
	
	    flushAllDeletedGLObjects: function () {
	        // Flush all deleted OpenGL objects
	        var gl = this.getGraphicContext();
	        BufferArray.flushAllDeletedGLBufferArrays( gl );
	        Texture.getTextureManager( gl ).flushAllDeletedTextureObjects( gl );
	        Program.flushAllDeletedGLPrograms( gl );
	        Shader.flushAllDeletedGLShaders( gl );
	        FrameBufferObject.flushAllDeletedGLFrameBuffers( gl );
	        FrameBufferObject.flushAllDeletedGLRenderBuffers( gl );
	    }
	};
	
	module.exports = View;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Object = __webpack_require__( 13 );
	var DatabasePager = __webpack_require__( 125 );
	
	
	var Scene = function () {
	    Object.call( this );
	    this._databasePager = new DatabasePager();
	    this._sceneData = undefined;
	};
	
	Scene.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	
	    getSceneData: function () {
	        return this._sceneData;
	    },
	
	    setSceneData: function ( node ) {
	        this._sceneData = node;
	    },
	
	    setDatabasePager: function ( dbpager ) {
	        this._databasePager = dbpager;
	    },
	
	    getDatabasePager: function () {
	        return this._databasePager;
	    },
	
	    // database pager are not implemented yet here
	    updateSceneGraph: function ( updateVisitor ) {
	        if ( this._databasePager )
	            this._databasePager.updateSceneGraph( updateVisitor.getFrameStamp() );
	        if ( this._sceneData )
	            this._sceneData.accept( updateVisitor );
	    }
	
	
	} ), 'osgViewer', 'Scene' );
	
	module.exports = Scene;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Node = __webpack_require__( 12 );
	var MatrixTransform = __webpack_require__( 44 );
	var Notify = __webpack_require__( 10 );
	var Depth = __webpack_require__( 86 );
	var BlendFunc = __webpack_require__( 39 );
	var CullFace = __webpack_require__( 59 );
	var Uniform = __webpack_require__( 35 );
	var Vec2 = __webpack_require__( 70 );
	var Vec3 = __webpack_require__( 15 );
	var Vec4 = __webpack_require__( 25 );
	var Matrix = __webpack_require__( 23 );
	var Quat = __webpack_require__( 26 );
	var IntersectionVisitor = __webpack_require__( 143 );
	var LineSegmentIntersector = __webpack_require__( 144 );
	var GizmoGeometry = __webpack_require__( 208 );
	var TransformEnums = __webpack_require__( 29 );
	var MACROUTILS = __webpack_require__( 6 );
	
	
	var getCanvasCoord = function ( vec, e ) {
	    vec[ 0 ] = e.offsetX === undefined ? e.layerX : e.offsetX;
	    vec[ 1 ] = e.offsetY === undefined ? e.layerY : e.offsetY;
	};
	
	var HideCullCallback = function () {};
	HideCullCallback.prototype = {
	    cull: function () {
	        return false;
	    }
	};
	
	var blendAttribute = new BlendFunc( BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA );
	
	var LineCustomIntersector = function ( testPlane ) {
	    this._testPlane = testPlane; // intersection plane or line
	    this._inter = Vec3.create(); // translate distance
	    LineSegmentIntersector.call( this );
	};
	LineCustomIntersector.prototype = MACROUTILS.objectInherit( LineSegmentIntersector.prototype, {
	    setTestPlane: function ( testPlane ) {
	        this._testPlane = testPlane; // intersection plane or line
	    },
	    getTranslateDistance: function () {
	        return this._inter;
	    },
	    enter: ( function () {
	        var axis = Vec3.create();
	        var dir = Vec3.create();
	
	        return function ( node ) {
	            if ( node._nbAxis === undefined )
	                return true;
	
	            Vec3.init( axis );
	            axis[ node._nbAxis ] = 1.0;
	            if ( !this._testPlane ) {
	                // intersection line line
	                Vec3.normalize( Vec3.sub( this._iEnd, this._iStart, dir ), dir );
	
	                var a01 = -Vec3.dot( dir, axis );
	                var b0 = Vec3.dot( this._iStart, dir );
	                var det = Math.abs( 1.0 - a01 * a01 );
	
	                var b1 = -Vec3.dot( this._iStart, axis );
	                Vec3.init( this._inter );
	                this._inter[ node._nbAxis ] = ( a01 * b0 - b1 ) / det;
	            } else {
	                // intersection line plane
	                var dist1 = Vec3.dot( this._iStart, axis );
	                var dist2 = Vec3.dot( this._iEnd, axis );
	                // ray copplanar to triangle
	                if ( dist1 === dist2 )
	                    return false;
	                // intersection between ray and triangle
	                var val = -dist1 / ( dist2 - dist1 );
	                this._inter[ 0 ] = this._iStart[ 0 ] + ( this._iEnd[ 0 ] - this._iStart[ 0 ] ) * val;
	                this._inter[ 1 ] = this._iStart[ 1 ] + ( this._iEnd[ 1 ] - this._iStart[ 1 ] ) * val;
	                this._inter[ 2 ] = this._iStart[ 2 ] + ( this._iEnd[ 2 ] - this._iStart[ 2 ] ) * val;
	            }
	            return false;
	        };
	    } )(),
	    intersect: function () {
	        return false;
	    }
	} );
	
	// The MT node can be detected as such because they
	// have a '_nbAxis' property on them (x=0, y=1, z=2)
	//
	// MatrixTransform _________________________________________
	//           |                    |                         |
	//    ____ Rotate             Translate               TranslatePlane
	//   |     / | \                / | \                     / | \
	//   MT   MT MT MT             MT MT MT                  MT MT MT
	//   |     \ | /                \ | /                     \ | /
	// FullArc  \|/                  \|/                       \|/
	//       ____|_____            ___|________              ___|________
	//      |          |          |            |            |            |
	//   DrawArc   HideNode   DrawArrow    HideNode     DrawPlane    HideNode
	//                 |                       |                         |
	//              PickArc                PickArrow                  PickPlane
	//
	var NodeGizmo = function ( viewer ) {
	    MatrixTransform.call( this );
	
	    this._tmask = 1; // traversal mask when picking the scene
	
	    // We can set this boolean to true if we want to insert a MatrixTransform just
	    // before the picked geometry.
	    // Otherwise, we simply select the first MatrixTransform with an 'editMask' property
	    this._autoInsertMT = false;
	
	    this._viewer = viewer;
	    this._canvas = viewer.getGraphicContext().canvas;
	    this._manipulator = viewer.getManipulator();
	
	    this._rotateNode = new MatrixTransform();
	    this._translateNode = new MatrixTransform();
	    this._planeNode = new MatrixTransform();
	
	    this._rotateInLocal = true; // local vs world space
	    this._translateInLocal = true; // local vs world space
	    this._showAngle = new MatrixTransform();
	
	    //for realtime picking
	    this._downCanvasCoord = Vec2.create();
	    this._hoverNode = null; // the hovered x/y/z MT node
	    this._keepHoverColor = Vec4.create();
	
	    // for editing
	    this._isEditing = false;
	
	    this._editLineOrigin = Vec3.create();
	    this._editLineDirection = Vec3.create();
	    this._editOffset = Vec3.create();
	
	    // cached matrices when starting the editing operations
	    this._editLocal = Matrix.create();
	    this._editWorldTrans = Matrix.create();
	    this._editWorldScaleRot = Matrix.create();
	    this._editInvWorldScaleRot = Matrix.create();
	
	    // red line, it can be useful as helpers too
	    this._debugNode = new Node();
	
	    this._lastDistToEye = 0.0; // see updateGizmo comment
	
	    this._attachedNode = null;
	    this.attachToGeometry( null );
	
	    // Intersectors
	    this._lsi = new LineCustomIntersector();
	    this._origIntersect = Vec3.create();
	    this._dstIntersect = Vec3.create();
	    this._iv = new IntersectionVisitor();
	    this._iv.setIntersector( this._lsi );
	
	    this.init();
	};
	
	// picking masks
	NodeGizmo.NO_PICK = 1 << 0;
	
	NodeGizmo.PICK_ARC_X = 1 << 1;
	NodeGizmo.PICK_ARC_Y = 1 << 2;
	NodeGizmo.PICK_ARC_Z = 1 << 3;
	
	NodeGizmo.PICK_ARROW_X = 1 << 4;
	NodeGizmo.PICK_ARROW_Y = 1 << 5;
	NodeGizmo.PICK_ARROW_Z = 1 << 6;
	
	NodeGizmo.PICK_PLANE_X = 1 << 7;
	NodeGizmo.PICK_PLANE_Y = 1 << 8;
	NodeGizmo.PICK_PLANE_Z = 1 << 9;
	
	NodeGizmo.NO_FULL_CIRCLE = 1 << 10; // don't display the full non pickable circle (visual cue)
	
	NodeGizmo.PICK_ARC = NodeGizmo.PICK_ARC_X | NodeGizmo.PICK_ARC_Y | NodeGizmo.PICK_ARC_Z;
	NodeGizmo.PICK_ARROW = NodeGizmo.PICK_ARROW_X | NodeGizmo.PICK_ARROW_Y | NodeGizmo.PICK_ARROW_Z;
	NodeGizmo.PICK_PLANE = NodeGizmo.PICK_PLANE_X | NodeGizmo.PICK_PLANE_Y | NodeGizmo.PICK_PLANE_Z;
	
	NodeGizmo.PICK_GIZMO = NodeGizmo.PICK_ARC | NodeGizmo.PICK_ARROW | NodeGizmo.PICK_PLANE;
	
	NodeGizmo.prototype = MACROUTILS.objectInherit( MatrixTransform.prototype, {
	
	    setRotateInLocal: function ( bool ) {
	        this._rotateInLocal = bool;
	    },
	
	    setTranslateInLocal: function ( bool ) {
	        this._translateInLocal = bool;
	    },
	
	    setTraversalMask: function ( tmask ) {
	        this._tmask = tmask;
	    },
	
	    init: function () {
	        this.getOrCreateStateSet().setAttributeAndModes( new Depth( Depth.DISABLE ) );
	        this.getOrCreateStateSet().setAttributeAndModes( new CullFace( CullFace.DISABLE ) );
	
	        var UpdateCallback = function () {};
	        UpdateCallback.prototype = {
	            update: this.updateGizmo.bind( this )
	        };
	        this.addUpdateCallback( new UpdateCallback() );
	        this.addChild( this.initNodeTranslate() );
	        this.addChild( this.initNodeTranslatePlane() );
	        this.addChild( this.initNodeRotate() );
	        if ( this._debugNode ) {
	            this._debugNode.addChild( GizmoGeometry.createDebugLineGeometry() );
	            this.addChild( this._debugNode );
	            this._debugNode.setNodeMask( 0x0 );
	        }
	
	        var canvas = this._canvas;
	        canvas.addEventListener( 'mousemove', this.onMouseMove.bind( this ) );
	        canvas.addEventListener( 'mousedown', this.onMouseDown.bind( this ) );
	        canvas.addEventListener( 'mouseup', this.onMouseUp.bind( this ) );
	        canvas.addEventListener( 'mouseout', this.onMouseUp.bind( this ) );
	    },
	
	    attachToNodePath: function ( nodepath ) {
	        var node;
	        if ( nodepath ) {
	            for ( var i = nodepath.length - 1; i >= 0; --i ) {
	                var editMask = nodepath[ i ].editMask || 0;
	                if ( editMask & NodeGizmo.PICK_GIZMO ) {
	                    node = nodepath[ i ];
	                    break;
	                }
	            }
	        }
	        if ( !node ) {
	            this._attachedNode = null;
	            this.setNodeMask( 0x0 );
	            return;
	        }
	
	        this._attachedNode = node;
	        this.updateGizmoMask();
	    },
	
	    attachToMatrixTransform: function ( node ) {
	        if ( !node ) {
	            this._attachedNode = null;
	            this.setNodeMask( 0x0 );
	            return;
	        }
	        if ( node.editMask === undefined )
	            node.editMask = NodeGizmo.PICK_GIZMO;
	
	        this._attachedNode = node;
	        this.updateGizmoMask();
	    },
	
	    attachToGeometry: function ( argNode ) {
	
	        var node = argNode;
	
	        if ( !node ) {
	            this._attachedNode = null;
	            this.setNodeMask( 0x0 );
	            return;
	        }
	
	        // insert MatrixTransform node before geometry node
	        var pr = node.getParents();
	        if ( pr[ 0 ].editMask === undefined ) {
	            var imt = new MatrixTransform();
	            while ( pr.length > 0 ) {
	                pr[ 0 ].addChild( imt );
	                pr[ 0 ].removeChild( node );
	            }
	            imt.addChild( node );
	            imt.editMask = NodeGizmo.PICK_GIZMO;
	            node = imt;
	        } else {
	            node = pr[ 0 ];
	        }
	
	        this._attachedNode = node;
	        this.updateGizmoMask();
	    },
	
	    updateGizmoMask: function () {
	        if ( !this._attachedNode ) {
	            this.setNodeMask( 0x0 );
	            return;
	        }
	
	        var mask = this._attachedNode.editMask;
	
	        this.setNodeMask( mask & NodeGizmo.PICK_GIZMO ? NodeGizmo.NO_PICK : 0x0 );
	
	        this._translateNode.setNodeMask( mask & NodeGizmo.PICK_ARROW ? NodeGizmo.PICK_ARROW : 0x0 );
	        this._rotateNode.setNodeMask( mask & NodeGizmo.PICK_ARC ? NodeGizmo.PICK_ARC : 0x0 );
	        this._planeNode.setNodeMask( mask & NodeGizmo.PICK_PLANE ? NodeGizmo.PICK_PLANE : 0x0 );
	
	        var transChildren = this._translateNode.getChildren();
	        transChildren[ 0 ].setNodeMask( mask & NodeGizmo.PICK_ARROW_X ? NodeGizmo.PICK_ARROW_X : 0x0 );
	        transChildren[ 1 ].setNodeMask( mask & NodeGizmo.PICK_ARROW_Y ? NodeGizmo.PICK_ARROW_Y : 0x0 );
	        transChildren[ 2 ].setNodeMask( mask & NodeGizmo.PICK_ARROW_Z ? NodeGizmo.PICK_ARROW_Z : 0x0 );
	
	        // children 0 is full arc
	        var rotChildren = this._rotateNode.getChildren();
	        rotChildren[ 0 ].setNodeMask( mask & NodeGizmo.NO_FULL_CIRCLE ? 0x0 : NodeGizmo.NO_PICK );
	        rotChildren[ 1 ].setNodeMask( mask & NodeGizmo.PICK_ARC_X ? NodeGizmo.PICK_ARC_X : 0x0 );
	        rotChildren[ 2 ].setNodeMask( mask & NodeGizmo.PICK_ARC_Y ? NodeGizmo.PICK_ARC_Y : 0x0 );
	        rotChildren[ 3 ].setNodeMask( mask & NodeGizmo.PICK_ARC_Z ? NodeGizmo.PICK_ARC_Z : 0x0 );
	
	        var planeChildren = this._planeNode.getChildren();
	        planeChildren[ 0 ].setNodeMask( mask & NodeGizmo.PICK_PLANE_X ? NodeGizmo.PICK_PLANE_X : 0x0 );
	        planeChildren[ 1 ].setNodeMask( mask & NodeGizmo.PICK_PLANE_Y ? NodeGizmo.PICK_PLANE_Y : 0x0 );
	        planeChildren[ 2 ].setNodeMask( mask & NodeGizmo.PICK_PLANE_Z ? NodeGizmo.PICK_PLANE_Z : 0x0 );
	    },
	
	    onNodeHovered: ( function () {
	        var hoverColor = Vec4.createAndSet( 1.0, 1.0, 0.0, 1.0 );
	
	        return function ( hit ) {
	
	            if ( this._hoverNode )
	                this._hoverNode.getStateSet().getUniform( 'uColor' ).setFloat4( this._keepHoverColor );
	            if ( !hit ) {
	                this._hoverNode = null;
	                return;
	            }
	
	            // stop at the first X/Y/Z matrix node
	            var np = hit.nodepath;
	            var i = np.length - 1;
	            var node = np[ i ];
	            while ( node._nbAxis === undefined ) {
	                if ( i === 0 )
	                    return;
	                node = np[ --i ];
	            }
	
	            var unif = node.getStateSet().getUniform( 'uColor' );
	            this._hoverNode = node;
	            Vec4.copy( unif.getInternalArray(), this._keepHoverColor );
	            unif.setFloat4( hoverColor );
	        };
	    } )(),
	
	    initNodeRotate: function () {
	        var drawArcXYZ = GizmoGeometry.createTorusGeometry( 1.0, 0.01, 6, 64, Math.PI * 2 );
	        var drawArc = GizmoGeometry.createTorusGeometry( 1.0, 0.01, 6, 64, Math.PI );
	        var pickArc = GizmoGeometry.createTorusGeometry( 1.0, 0.1, 6, 64, Math.PI );
	
	        var mtXYZ = new MatrixTransform();
	        var mtX = new MatrixTransform();
	        var mtY = new MatrixTransform();
	        var mtZ = new MatrixTransform();
	        mtX._nbAxis = 0;
	        mtY._nbAxis = 1;
	        mtZ._nbAxis = 2;
	
	        var hideNode = new Node();
	        hideNode.setCullCallback( new HideCullCallback() );
	        hideNode.addChild( pickArc );
	
	        // set masks
	        drawArcXYZ.setNodeMask( NodeGizmo.NO_PICK );
	        drawArc.setNodeMask( NodeGizmo.NO_PICK );
	        mtX.setNodeMask( NodeGizmo.PICK_ARC_X );
	        mtY.setNodeMask( NodeGizmo.PICK_ARC_Y );
	        mtZ.setNodeMask( NodeGizmo.PICK_ARC_Z );
	
	        mtXYZ.addChild( drawArcXYZ );
	        mtX.addChild( drawArc );
	        mtY.addChild( drawArc );
	        mtZ.addChild( drawArc );
	
	        mtX.addChild( hideNode );
	        mtY.addChild( hideNode );
	        mtZ.addChild( hideNode );
	
	        mtXYZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 0.2, 0.2, 0.2, 1.0 ), 'uColor' ) );
	        mtX.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 1.0, 0.0, 0.0, 1.0 ), 'uColor' ) );
	        mtY.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 0.0, 1.0, 0.0, 1.0 ), 'uColor' ) );
	        mtZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 0.0, 0.0, 1.0, 1.0 ), 'uColor' ) );
	
	        var showAngle = this._showAngle;
	        showAngle.getOrCreateStateSet().setAttributeAndModes( blendAttribute );
	        showAngle.setNodeMask( 0x0 );
	        showAngle.getOrCreateStateSet().addUniform( Uniform.createFloat3( Vec3.createAndSet( 1.0, 0.0, 0.0 ), 'uBase' ) );
	        showAngle.getOrCreateStateSet().addUniform( Uniform.createFloat( 0.0, 'uAngle' ) );
	        showAngle.addChild( GizmoGeometry.createQuadCircleGeometry() );
	
	        var rotate = this._rotateNode;
	        rotate.setNodeMask( NodeGizmo.PICK_ARC );
	        rotate.addChild( mtXYZ );
	        rotate.addChild( mtX );
	        rotate.addChild( mtY );
	        rotate.addChild( mtZ );
	        rotate.addChild( showAngle );
	        return rotate;
	    },
	
	    initNodeTranslate: function () {
	        var aHeight = 1.5;
	        var aConeHeight = 0.3;
	        var pickStart = 0.5; // offset (because of the picking plane)
	        var pickHeight = ( aHeight - pickStart + aConeHeight ) * 1.1;
	
	        // cone arrow
	        var mtCone = new MatrixTransform();
	        Matrix.makeTranslate( 0.0, 0.0, aHeight + aConeHeight * 0.5, mtCone.getMatrix() );
	        mtCone.addChild( GizmoGeometry.createCylinderGeometry( 0.0, 0.07, aConeHeight, 32, 1, true, true ) );
	        // arrow base
	        var mtArrow = new MatrixTransform();
	        Matrix.makeTranslate( 0.0, 0.0, aHeight * 0.5, mtArrow.getMatrix() );
	        mtArrow.addChild( GizmoGeometry.createCylinderGeometry( 0.01, 0.01, aHeight, 32, 1, true, true ) );
	        // draw arrow
	        var drawArrow = new Node();
	        drawArrow.addChild( mtArrow );
	        drawArrow.addChild( mtCone );
	
	        var pickArrow = GizmoGeometry.createCylinderGeometry( 0.1, 0.1, pickHeight, 32, 1, true, true );
	
	        var mtX = new MatrixTransform();
	        var mtY = new MatrixTransform();
	        var mtZ = new MatrixTransform();
	        mtX._nbAxis = 0;
	        mtY._nbAxis = 1;
	        mtZ._nbAxis = 2;
	
	        Matrix.makeRotate( Math.PI * 0.5, 0.0, 1.0, 0.0, mtX.getMatrix() );
	        Matrix.makeRotate( -Math.PI * 0.5, 1.0, 0.0, 0.0, mtY.getMatrix() );
	
	        var hideNode = new MatrixTransform();
	        hideNode.setCullCallback( new HideCullCallback() );
	        Matrix.makeTranslate( 0.0, 0.0, pickStart + pickHeight * 0.5, hideNode.getMatrix() );
	        hideNode.addChild( pickArrow );
	
	        // set masks
	        drawArrow.setNodeMask( NodeGizmo.NO_PICK );
	        mtX.setNodeMask( NodeGizmo.PICK_ARROW_X );
	        mtY.setNodeMask( NodeGizmo.PICK_ARROW_Y );
	        mtZ.setNodeMask( NodeGizmo.PICK_ARROW_Z );
	
	        mtX.addChild( drawArrow );
	        mtY.addChild( drawArrow );
	        mtZ.addChild( drawArrow );
	
	        mtX.addChild( hideNode );
	        mtY.addChild( hideNode );
	        mtZ.addChild( hideNode );
	
	        mtX.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 1.0, 0.0, 0.0, 1.0 ), 'uColor' ) );
	        mtY.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 0.0, 1.0, 0.0, 1.0 ), 'uColor' ) );
	        mtZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 0.0, 0.0, 1.0, 1.0 ), 'uColor' ) );
	
	        var translate = this._translateNode;
	        translate.setNodeMask( NodeGizmo.PICK_ARROW );
	        translate.addChild( mtX );
	        translate.addChild( mtY );
	        translate.addChild( mtZ );
	        return translate;
	    },
	
	    initNodeTranslatePlane: function () {
	        var mtPlane = new MatrixTransform();
	        Matrix.makeTranslate( 0.5, 0.5, 0.0, mtPlane.getMatrix() );
	        Matrix.postMult( Matrix.makeScale( 0.5, 0.5, 1.0, Matrix.create() ), mtPlane.getMatrix() );
	        mtPlane.addChild( GizmoGeometry.createPlaneGeometry() );
	
	        var mtX = new MatrixTransform();
	        var mtY = new MatrixTransform();
	        var mtZ = new MatrixTransform();
	        mtX._nbAxis = 0;
	        mtY._nbAxis = 1;
	        mtZ._nbAxis = 2;
	
	        Matrix.makeRotate( -Math.PI * 0.5, 0.0, 1.0, 0.0, mtX.getMatrix() );
	        Matrix.makeRotate( Math.PI * 0.5, 1.0, 0.0, 0.0, mtY.getMatrix() );
	
	        // set masks
	        mtX.setNodeMask( NodeGizmo.PICK_PLANE_X );
	        mtY.setNodeMask( NodeGizmo.PICK_PLANE_Y );
	        mtZ.setNodeMask( NodeGizmo.PICK_PLANE_Z );
	
	        mtX.addChild( mtPlane );
	        mtY.addChild( mtPlane );
	        mtZ.addChild( mtPlane );
	
	        mtX.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 1.0, 0.0, 0.0, 0.3 ), 'uColor' ) );
	        mtY.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 0.0, 1.0, 0.0, 0.3 ), 'uColor' ) );
	        mtZ.getOrCreateStateSet().addUniform( Uniform.createFloat4( Vec4.createAndSet( 0.0, 0.0, 1.0, 0.3 ), 'uColor' ) );
	
	        var plane = this._planeNode;
	        plane.setNodeMask( NodeGizmo.PICK_PLANE );
	        plane.getOrCreateStateSet().setAttributeAndModes( blendAttribute );
	        plane.addChild( mtX );
	        plane.addChild( mtY );
	        plane.addChild( mtZ );
	        return plane;
	    },
	
	    updateArcRotation: ( function () {
	        var quat = Quat.create();
	        var quatx = Quat.makeRotate( -Math.PI * 0.5, 0.0, 1.0, 0.0, Quat.create() );
	        var quaty = Quat.makeRotate( -Math.PI * 0.5, 1.0, 0.0, 0.0, Quat.create() );
	        return function ( eye ) {
	            var rotateNode = this._rotateNode;
	            var arcs = rotateNode.getChildren();
	            // eye arc
	            quat[ 0 ] = -eye[ 1 ];
	            quat[ 1 ] = eye[ 0 ];
	            quat[ 2 ] = 0.0;
	            quat[ 3 ] = 1.0 + eye[ 2 ];
	            Quat.normalize( quat, quat );
	            Matrix.makeRotateFromQuat( quat, arcs[ 0 ].getMatrix() );
	            // x arc
	            Quat.makeRotate( Math.atan2( eye[ 2 ], eye[ 1 ] ), 1.0, 0.0, 0.0, quat );
	            Quat.mult( quat, quatx, quat );
	            Matrix.makeRotateFromQuat( quat, arcs[ 1 ].getMatrix() );
	            // y arc
	            Quat.makeRotate( Math.atan2( -eye[ 0 ], -eye[ 2 ] ), 0.0, 1.0, 0.0, quat );
	            Quat.mult( quat, quaty, quat );
	            Matrix.makeRotateFromQuat( quat, arcs[ 2 ].getMatrix() );
	            // z arc
	            Quat.makeRotate( Math.atan2( -eye[ 0 ], eye[ 1 ] ), 0.0, 0.0, 1.0, quat );
	            Matrix.makeRotateFromQuat( quat, arcs[ 3 ].getMatrix() );
	
	            arcs[ 1 ].dirtyBound();
	            arcs[ 2 ].dirtyBound();
	            arcs[ 3 ].dirtyBound();
	        };
	    } )(),
	
	    getTransformType: function ( node ) {
	        var n = node;
	        while ( n.parents.length > 0 ) {
	            if ( n.referenceFrame !== undefined && n.referenceFrame === TransformEnums.ABSOLUTE_RF )
	                return TransformEnums.ABSOLUTE_RF;
	            n = n.parents[ 0 ];
	        }
	        return TransformEnums.RELATIVE_RF;
	    },
	
	    updateGizmo: ( function () {
	        var eye = Vec3.create();
	        var trVec = Vec3.create();
	        var tmpVec = Vec3.create();
	
	        var temp = Matrix.create();
	        var trWorld = Matrix.create();
	        var invScale = Matrix.create();
	        var scGiz = Matrix.create();
	
	        return function () {
	            if ( !this._attachedNode )
	                return;
	            var ttype = this.getTransformType( this._attachedNode );
	            this.setReferenceFrame( ttype );
	            this.setCullingActive( ttype === TransformEnums.RELATIVE_RF );
	            var worldMat = this._attachedNode.getWorldMatrices()[ 0 ];
	
	            // world trans
	            Matrix.getTrans( worldMat, trVec );
	            Matrix.makeTranslate( trVec[ 0 ], trVec[ 1 ], trVec[ 2 ], trWorld );
	
	            // normalize gizmo size
	            var scaleFactor = 3.0;
	            if ( ttype === TransformEnums.ABSOLUTE_RF ) {
	                eye[ 0 ] = eye[ 1 ] = eye[ 2 ] = 0.0;
	                tmpVec[ 0 ] = tmpVec[ 1 ] = tmpVec[ 2 ] = 1.0;
	            } else {
	                // normalize gizmo size relative to screen size
	                var proj = this._viewer.getCamera().getProjectionMatrix();
	                var scaleFov = this._canvas.clientWidth * 0.023 * proj[ 0 ];
	                this._manipulator.getEyePosition( eye );
	                // while we are editing we don't normalize the gizmo
	                // it gives a better depth feedback, especially if we are editing a geometry that has
	                // a constant screen size (for example an icon)
	                this._lastDistToEye = this._isEditing ? this._lastDistToEye : Vec3.distance( eye, trVec );
	                scaleFactor *= this._lastDistToEye / scaleFov;
	            }
	            Matrix.makeScale( scaleFactor, scaleFactor, scaleFactor, scGiz );
	
	            // gizmo node
	            Matrix.mult( trWorld, scGiz, this.getMatrix() );
	
	            Vec3.sub( eye, trVec, eye );
	            Vec3.normalize( eye, eye );
	
	            // rotate node
	            if ( this._rotateInLocal || this._translateInLocal ) {
	                // world scale
	                Matrix.getScale( worldMat, tmpVec );
	                Matrix.makeScale( tmpVec[ 0 ], tmpVec[ 1 ], tmpVec[ 2 ], invScale );
	                Matrix.inverse( invScale, invScale );
	
	                Matrix.mult( worldMat, invScale, temp );
	                temp[ 12 ] = temp[ 13 ] = temp[ 14 ] = 0.0;
	
	                if ( this._translateInLocal ) {
	                    Matrix.copy( temp, this._translateNode.getMatrix() );
	                    Matrix.copy( temp, this._planeNode.getMatrix() );
	                }
	
	                if ( this._rotateInLocal ) {
	                    Matrix.copy( temp, this._rotateNode.getMatrix() );
	                    Matrix.inverse( temp, temp );
	                    Matrix.transformVec3( temp, eye, eye );
	                }
	            } else {
	                Matrix.makeIdentity( this._rotateNode.getMatrix() );
	            }
	
	            this.updateArcRotation( eye );
	
	            this._rotateNode.dirtyBound();
	            this._translateNode.dirtyBound();
	            this._planeNode.dirtyBound();
	
	            if ( this._isEditing )
	                Matrix.copy( this._hoverNode.getMatrix(), this._showAngle.getMatrix() );
	        };
	    } )(),
	
	    computeNearestIntersection: ( function () {
	        var sortByRatio = function ( a, b ) {
	            return a.ratio - b.ratio;
	        };
	        var coord = Vec2.create();
	
	        return function ( e, tmask ) {
	            getCanvasCoord( coord, e );
	
	            // canvas to webgl coord
	            var viewer = this._viewer;
	            var canvas = this._canvas;
	            var x = coord[ 0 ] * ( viewer._canvasWidth / canvas.clientWidth );
	            var y = ( canvas.clientHeight - coord[ 1 ] ) * ( viewer._canvasHeight / canvas.clientHeight );
	
	            var hits = this._viewer.computeIntersections( x, y, tmask );
	
	            if ( hits.length === 0 )
	                return undefined;
	
	            hits.sort( sortByRatio );
	            return hits[ 0 ];
	        };
	    } )(),
	
	    setOnlyGizmoPicking: function () {
	        // enable picking only for the gizmo
	        this._viewer.getCamera().addChild( this );
	        this._viewer.getSceneData().setNodeMask( 0x0 );
	        this.setNodeMask( ~0x0 );
	    },
	
	    setOnlyScenePicking: function () {
	        this._viewer.getCamera().removeChild( this );
	        this._viewer.getSceneData().setNodeMask( ~0x0 );
	        this.setNodeMask( NodeGizmo.NO_PICK );
	    },
	
	    pickGizmo: function ( e, tmask ) {
	        this.setOnlyGizmoPicking();
	        var hit = this.computeNearestIntersection( e, tmask );
	        this.setOnlyScenePicking();
	        return hit;
	    },
	
	    getCanvasPositionFromWorldPoint: ( function () {
	        var mat = Matrix.create();
	
	        return function ( worldPoint, out ) {
	            var cam = this._viewer.getCamera();
	
	            var screenPoint = out;
	            if ( !out ) {
	                Notify.warn( 'deprecated, use out argument for result ' );
	                screenPoint = Vec3.create();
	            }
	
	            if ( cam.getViewport() ) {
	                cam.getViewport().computeWindowMatrix( mat );
	            } else {
	                Matrix.makeIdentity( mat );
	            }
	
	            Matrix.preMult( mat, cam.getProjectionMatrix() );
	            if ( this.getReferenceFrame() === TransformEnums.RELATIVE_RF )
	                Matrix.preMult( mat, cam.getViewMatrix() );
	
	            Matrix.transformVec3( mat, worldPoint, screenPoint );
	
	            // canvas to webgl coord
	            var viewer = this._viewer;
	            var canvas = this._canvas;
	            screenPoint[ 0 ] = screenPoint[ 0 ] / ( viewer._canvasWidth / canvas.clientWidth );
	            screenPoint[ 1 ] = canvas.clientHeight - screenPoint[ 1 ] / ( viewer._canvasHeight / canvas.clientHeight );
	            return screenPoint;
	        };
	    } )(),
	
	    onMouseDown: function ( e ) {
	        getCanvasCoord( this._downCanvasCoord, e );
	        if ( !this._hoverNode || !this._attachedNode )
	            return;
	        this._viewer._eventProxy.StandardMouseKeyboard._enable = false;
	
	        this.saveEditMatrices();
	        var nm = this._hoverNode.getParents()[ 0 ].getNodeMask();
	        this._isEditing = true;
	
	        if ( nm & NodeGizmo.PICK_ARC ) {
	            this._translateNode.setNodeMask( 0x0 );
	            this._planeNode.setNodeMask( 0x0 );
	            this.startRotateEdit( e );
	        } else if ( nm & NodeGizmo.PICK_ARROW ) {
	            this._rotateNode.setNodeMask( 0x0 );
	            this._planeNode.setNodeMask( 0x0 );
	            this.startTranslateEdit( e );
	        } else if ( nm & NodeGizmo.PICK_PLANE ) {
	            this._rotateNode.setNodeMask( 0x0 );
	            this._translateNode.setNodeMask( 0x0 );
	            this.startPlaneEdit( e );
	        }
	    },
	
	    saveEditMatrices: function () {
	        Matrix.copy( this._attachedNode.getMatrix(), this._editLocal );
	        // save the world translation
	        var wm = this._attachedNode.getWorldMatrices()[ 0 ];
	        Matrix.makeTranslate( wm[ 12 ], wm[ 13 ], wm[ 14 ], this._editWorldTrans );
	        // save the inv of world rotation + scale
	        Matrix.copy( wm, this._editWorldScaleRot );
	        // removes translation
	        this._editWorldScaleRot[ 12 ] = this._editWorldScaleRot[ 13 ] = this._editWorldScaleRot[ 14 ] = 0.0;
	        Matrix.inverse( this._editWorldScaleRot, this._editInvWorldScaleRot );
	    },
	
	    startRotateEdit: function ( e ) {
	        var gizmoMat = this._rotateNode.getWorldMatrices()[ 0 ];
	
	        // center of gizmo on screen
	        var projCenter = Vec3.create();
	        Matrix.transformVec3( gizmoMat, projCenter, projCenter );
	        this.getCanvasPositionFromWorldPoint( projCenter, projCenter );
	
	        // pick rotate gizmo
	        var hit = this.pickGizmo( e, this._hoverNode.getNodeMask() | NodeGizmo.PICK_ARC );
	        if ( !hit ) return;
	
	        // compute tangent direction
	        var sign = this._hoverNode._nbAxis === 0 ? -1.0 : 1.0;
	        var tang = Vec3.create();
	        tang[ 0 ] = sign * hit.point[ 1 ];
	        tang[ 1 ] = -sign * hit.point[ 0 ];
	        tang[ 2 ] = hit.point[ 2 ];
	
	        // project tangent on screen
	        var projArc = Vec3.create();
	        Matrix.transformVec3( this._hoverNode.getMatrix(), tang, projArc );
	        Matrix.transformVec3( gizmoMat, projArc, projArc );
	        this.getCanvasPositionFromWorldPoint( projArc, projArc );
	
	        var dir = this._editLineDirection;
	        Vec2.sub( projArc, projCenter, dir );
	        Vec2.normalize( dir, dir );
	
	        // show angle
	        this._showAngle.setNodeMask( NodeGizmo.NO_PICK );
	        hit.point[ 2 ] = 0.0;
	        var stateAngle = this._showAngle.getStateSet();
	        stateAngle.getUniform( 'uAngle' ).setFloat( 0.0 );
	        stateAngle.getUniform( 'uBase' ).setVec3( Vec3.normalize( hit.point, hit.point ) );
	
	        getCanvasCoord( this._editLineOrigin, e );
	    },
	
	    startTranslateEdit: function ( e ) {
	        var origin = this._editLineOrigin;
	        var dir = this._editLineDirection;
	
	        // 3d origin (center of gizmo)
	        var gizmoMat = this._translateNode.getWorldMatrices()[ 0 ];
	        Matrix.getTrans( gizmoMat, origin );
	
	        // 3d direction
	        Vec3.init( dir );
	        dir[ this._hoverNode._nbAxis ] = 1.0;
	        if ( this._translateInLocal ) {
	            Matrix.transformVec3( this._editWorldScaleRot, dir, dir );
	            Vec3.normalize( dir, dir );
	        }
	        Vec3.add( origin, dir, dir );
	
	        // project on canvas
	        this.getCanvasPositionFromWorldPoint( origin, origin );
	        this.getCanvasPositionFromWorldPoint( dir, dir );
	
	        Vec2.sub( dir, origin, dir );
	        Vec2.normalize( dir, dir );
	
	        var offset = this._editOffset;
	        getCanvasCoord( offset, e );
	        Vec2.sub( offset, origin, offset );
	    },
	
	    startPlaneEdit: function ( e ) {
	        var origin = this._editLineOrigin; // just used to determine the 2d offset
	
	        // 3d origin (center of gizmo)
	        var gizmoMat = this._planeNode.getWorldMatrices()[ 0 ];
	        Matrix.getTrans( gizmoMat, origin );
	
	        // project on canvas
	        this.getCanvasPositionFromWorldPoint( origin, origin );
	
	        var offset = this._editOffset;
	        getCanvasCoord( offset, e );
	        Vec2.sub( offset, origin, offset );
	    },
	
	    drawLineCanvasDebug: function ( x1, y1, x2, y2 ) {
	        this._debugNode.setNodeMask( NodeGizmo.NO_PICK );
	        var buffer = this._debugNode.getChildren()[ 0 ].getAttributes().Vertex;
	        buffer.getElements()[ 0 ] = ( ( x1 / this._canvas.clientWidth ) * 2 ) - 1.0;
	        buffer.getElements()[ 1 ] = ( ( ( this._canvas.clientHeight - y1 ) / this._canvas.clientHeight ) ) * 2 - 1.0;
	        buffer.getElements()[ 2 ] = ( ( x2 / this._canvas.clientWidth ) * 2 ) - 1.0;
	        buffer.getElements()[ 3 ] = ( ( ( this._canvas.clientHeight - y2 ) / this._canvas.clientHeight ) ) * 2 - 1.0;
	        buffer.dirty();
	    },
	
	    pickAndSelect: function ( e ) {
	        this.setNodeMask( 0x0 );
	        var hit = this.computeNearestIntersection( e, this._tmask );
	        if ( this._autoInsertMT )
	            this.attachToGeometry( hit ? hit.nodepath[ hit.nodepath.length - 1 ] : hit );
	        else
	            this.attachToNodePath( hit ? hit.nodepath : hit );
	    },
	
	    onMouseUp: function ( e ) {
	        var smk = this._viewer._eventProxy.StandardMouseKeyboard;
	        if ( smk._enable === false ) {
	            smk._enable = true;
	            this._viewer._eventProxy.StandardMouseKeyboard.mouseup( e );
	        }
	        if ( this._debugNode )
	            this._debugNode.setNodeMask( 0x0 );
	
	        var v = Vec2.create();
	        getCanvasCoord( v, e );
	        if ( Vec2.distance( this._downCanvasCoord, v ) === 0.0 )
	            this.pickAndSelect( e );
	
	        this._showAngle.setNodeMask( 0x0 );
	        this._isEditing = false;
	        if ( !this._hoverNode )
	            return;
	        this.updateGizmoMask();
	    },
	
	    onMouseMove: function ( e ) {
	        if ( !this._attachedNode )
	            return;
	        var hit;
	        if ( this._isEditing === false ) {
	            hit = this.pickGizmo( e, NodeGizmo.PICK_GIZMO );
	            this.onNodeHovered( hit );
	            return;
	        }
	
	        if ( !this._hoverNode )
	            return;
	
	        var par = this._hoverNode.getParents()[ 0 ];
	        if ( par === this._rotateNode )
	            this.updateRotateEdit( e );
	        else if ( par === this._translateNode )
	            this.updateTranslateEdit( e );
	        else if ( par === this._planeNode )
	            this.updatePlaneEdit( e );
	    },
	
	    updateRotateEdit: ( function () {
	        var mrot = Matrix.create();
	        var vec = Vec2.create();
	
	        return function ( e ) {
	
	            var origin = this._editLineOrigin;
	            var dir = this._editLineDirection;
	
	            getCanvasCoord( vec, e );
	            Vec2.sub( vec, origin, vec );
	            var dist = Vec2.dot( vec, dir );
	
	            if ( this._debugNode )
	                this.drawLineCanvasDebug( origin[ 0 ], origin[ 1 ], origin[ 0 ] + dir[ 0 ] * dist, origin[ 1 ] + dir[ 1 ] * dist );
	
	            var angle = 7 * dist / Math.min( this._canvas.clientWidth, this._canvas.clientHeight );
	            angle %= ( Math.PI * 2 );
	            var nbAxis = this._hoverNode._nbAxis;
	            if ( nbAxis === 0 )
	                Matrix.makeRotate( -angle, 1.0, 0.0, 0.0, mrot );
	            else if ( nbAxis === 1 )
	                Matrix.makeRotate( -angle, 0.0, 1.0, 0.0, mrot );
	            else if ( nbAxis === 2 )
	                Matrix.makeRotate( -angle, 0.0, 0.0, 1.0, mrot );
	
	            this._showAngle.getOrCreateStateSet().getUniform( 'uAngle' ).setFloat( nbAxis === 0 ? -angle : angle );
	
	            if ( !this._rotateInLocal ) {
	                Matrix.postMult( this._editInvWorldScaleRot, mrot );
	                Matrix.preMult( mrot, this._editWorldScaleRot );
	            }
	
	            Matrix.mult( this._editLocal, mrot, this._attachedNode.getMatrix() );
	
	            this._attachedNode.dirtyBound();
	        };
	    } )(),
	
	    updateTranslateEdit: ( function () {
	        var vec = Vec2.create();
	        var tra = Vec3.create();
	
	        return function ( e ) {
	
	            var origin = this._editLineOrigin;
	            var dir = this._editLineDirection;
	
	            getCanvasCoord( vec, e );
	            Vec2.sub( vec, origin, vec );
	            Vec2.sub( vec, this._editOffset, vec );
	
	            var dist = Vec2.dot( vec, dir );
	            vec[ 0 ] = origin[ 0 ] + dir[ 0 ] * dist;
	            vec[ 1 ] = origin[ 1 ] + dir[ 1 ] * dist;
	
	            if ( this._debugNode )
	                this.drawLineCanvasDebug( origin[ 0 ], origin[ 1 ], vec[ 0 ], vec[ 1 ] );
	
	            // canvas to webgl coord
	            var viewer = this._viewer;
	            var canvas = this._canvas;
	            var coordx = vec[ 0 ] * ( viewer._canvasWidth / canvas.clientWidth );
	            var coordy = ( canvas.clientHeight - vec[ 1 ] ) * ( viewer._canvasHeight / canvas.clientHeight );
	
	            // project 2D point on the 3d line
	            this._lsi.reset();
	            this._lsi.setTestPlane( false );
	            this._lsi.set( Vec3.set( coordx, coordy, 0.0, this._origIntersect ), Vec3.set( coordx, coordy, 1.0, this._dstIntersect ) );
	            this._iv.reset();
	            this._iv.setTraversalMask( this._hoverNode.getNodeMask() );
	
	            Matrix.copy( this._editWorldTrans, this.getMatrix() );
	
	            this.setOnlyGizmoPicking();
	            this._viewer._camera.accept( this._iv );
	            this.setOnlyScenePicking();
	
	            if ( !this._translateInLocal ) {
	                Matrix.transformVec3( this._editInvWorldScaleRot, this._lsi.getTranslateDistance(), tra );
	            } else {
	                Matrix.getScale( this._editInvWorldScaleRot, tra );
	                var inter = this._lsi.getTranslateDistance();
	                tra[ 0 ] *= inter[ 0 ];
	                tra[ 1 ] *= inter[ 1 ];
	                tra[ 2 ] *= inter[ 2 ];
	            }
	
	            Matrix.multTranslate( this._editLocal, tra, this._attachedNode.getMatrix() );
	
	            this._attachedNode.dirtyBound();
	        };
	    } )(),
	
	    updatePlaneEdit: ( function () {
	        var vec = Vec2.create();
	        var tra = Vec3.create();
	
	        return function ( e ) {
	            getCanvasCoord( vec, e );
	            Vec2.sub( vec, this._editOffset, vec );
	
	            // canvas to webgl coord
	            var viewer = this._viewer;
	            var canvas = this._canvas;
	            var coordx = vec[ 0 ] * ( viewer._canvasWidth / canvas.clientWidth );
	            var coordy = ( canvas.clientHeight - vec[ 1 ] ) * ( viewer._canvasHeight / canvas.clientHeight );
	
	            // project 2D point on the 3d plane
	            this._lsi.reset();
	            this._lsi.setTestPlane( true );
	            this._lsi.set( Vec3.set( coordx, coordy, 0.0, this._origIntersect ), Vec3.set( coordx, coordy, 1.0, this._dstIntersect ) );
	            this._iv.reset();
	            this._iv.setTraversalMask( this._hoverNode.getNodeMask() );
	
	            Matrix.copy( this._editWorldTrans, this.getMatrix() );
	
	            this.setOnlyGizmoPicking();
	            this._viewer._camera.accept( this._iv );
	            this.setOnlyScenePicking();
	
	            if ( !this._translateInLocal ) {
	                Matrix.transformVec3( this._editInvWorldScaleRot, this._lsi.getTranslateDistance(), tra );
	            } else {
	                Matrix.getScale( this._editInvWorldScaleRot, tra );
	                var inter = this._lsi.getTranslateDistance();
	                tra[ 0 ] *= inter[ 0 ];
	                tra[ 1 ] *= inter[ 1 ];
	                tra[ 2 ] *= inter[ 2 ];
	            }
	
	            Matrix.multTranslate( this._editLocal, tra, this._attachedNode.getMatrix() );
	
	            this._attachedNode.dirtyBound();
	        };
	    } )(),
	
	} );
	
	module.exports = NodeGizmo;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BufferArray = __webpack_require__( 40 );
	var Geometry = __webpack_require__( 31 );
	var PrimitiveSet = __webpack_require__( 41 );
	var DrawArrays = __webpack_require__( 42 );
	var DrawElements = __webpack_require__( 43 );
	var Program = __webpack_require__( 100 );
	var Shader = __webpack_require__( 101 );
	
	
	var glPrecision = [ '#ifdef GL_ES',
	    'precision highp float;',
	    '#endif'
	].join( '\n' );
	
	var program;
	var getOrCreateShader = function () {
	    if ( program )
	        return program;
	    var shaderName = '#define SHADER_NAME GizmoLine3D';
	    var vertexshader = [
	        glPrecision,
	        'attribute vec3 Vertex;',
	        'uniform mat4 ModelViewMatrix;',
	        'uniform mat4 ProjectionMatrix;',
	        shaderName,
	        '',
	        'void main(void) {',
	        '  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);',
	        '}'
	    ].join( '\n' );
	
	    var fragmentshader = [
	        glPrecision,
	        'uniform vec4 uColor;',
	        shaderName,
	        '',
	        'void main(void) {',
	        '  gl_FragColor = uColor;',
	        '}'
	    ].join( '\n' );
	
	    program = new Program( new Shader( Shader.VERTEX_SHADER, vertexshader ),
	        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );
	    return program;
	};
	
	var program2D;
	var getOrCreateShader2D = function () {
	    if ( program2D )
	        return program2D;
	    var shaderName = '#define SHADER_NAME GizmoLine2D';
	    var vertexshader = [
	        glPrecision,
	        'attribute vec2 Vertex;',
	        shaderName,
	        '',
	        'void main(void) {',
	        '  gl_Position = vec4(Vertex, 0.0, 1.0);',
	        '}'
	    ].join( '\n' );
	
	    var fragmentshader = [
	        glPrecision,
	        shaderName,
	        '',
	        'void main(void) {',
	        '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',
	        '}'
	    ].join( '\n' );
	
	    program2D = new Program( new Shader( Shader.VERTEX_SHADER, vertexshader ),
	        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );
	    return program2D;
	};
	
	var programQC;
	var getOrCreateShaderQuadCircle = function () {
	    if ( programQC )
	        return programQC;
	    var shaderName = '#define SHADER_NAME GizmoQuadCircle';
	    var vertexshader = [
	        glPrecision,
	        'attribute vec3 Vertex;',
	        'uniform mat4 ModelViewMatrix;',
	        'uniform mat4 ProjectionMatrix;',
	        'varying vec3 vVertex;',
	        shaderName,
	        '',
	        'void main(void) {',
	        '  vVertex = Vertex;',
	        '  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);',
	        '}'
	    ].join( '\n' );
	
	    var fragmentshader = [
	        glPrecision,
	        'uniform float uAngle;',
	        'uniform vec3 uBase;',
	        'varying vec3 vVertex;',
	        'const float PI = 3.14159265358979323846264;',
	        'const float PI2 = PI * 2.0;',
	        shaderName,
	        '',
	        'void main(void) {',
	        '  if(length(vVertex) > 0.5)',
	        '    discard;',
	        '  vec3 vn = normalize(vVertex);',
	        '  float angle = atan(uBase.y * vn.x - uBase.x * vn.y, dot(uBase, vn));',
	        '  if(angle > 0.0) {',
	        '    if(uAngle >= 0.0 && angle > uAngle) discard;',
	        '    if(uAngle < -PI && angle < uAngle + PI2) discard;',
	        '    if(uAngle < 0.0 && uAngle > -PI) discard;',
	        '  }',
	        '  if(angle < 0.0) {',
	        '    if(uAngle <= 0.0 && angle < uAngle) discard;',
	        '    if(uAngle > PI && angle > uAngle - PI2) discard;',
	        '    if(uAngle > 0.0 && uAngle < PI) discard;',
	        '  }',
	        '  gl_FragColor = vec4(1.0, 1.0, 0.0, 0.5);',
	        '}'
	    ].join( '\n' );
	
	    programQC = new Program( new Shader( Shader.VERTEX_SHADER, vertexshader ),
	        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );
	    return programQC;
	};
	
	var createDebugLineGeometry = function () {
	    var g = new Geometry();
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, new Float32Array( 4 ), 2 );
	    var primitive = new DrawArrays( PrimitiveSet.LINES, 0, 2 );
	    g.getPrimitives().push( primitive );
	    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader2D() );
	    return g;
	};
	
	var createTorusGeometry = function ( argRadiusOut, argRadiusWidth, argNbRadial, argNbTubular, argArc ) {
	    var radiusOut = argRadiusOut !== undefined ? argRadiusOut : 1.0;
	    var radiusWidth = argRadiusWidth !== undefined ? argRadiusWidth : 0.2;
	    var nbRadial = argNbRadial !== undefined ? argNbRadial : 6;
	    var nbTubular = argNbTubular !== undefined ? argNbTubular : 64;
	    var arc = argArc !== undefined ? argArc : Math.PI * 2;
	
	    var nbVertices = ( nbRadial + 1 ) * ( nbTubular + 1 );
	    var nbTriangles = nbRadial * nbTubular * 2;
	    var g = new Geometry();
	    var vertices = new Float32Array( nbVertices * 3 );
	    var indices = new Uint16Array( nbTriangles * 3 );
	    arc = arc || Math.PI * 2;
	    var id = 0;
	    var k = 0;
	    var i = 0;
	    var j = 0;
	    for ( j = 0; j <= nbRadial; ++j ) {
	        for ( i = 0; i <= nbTubular; ++i ) {
	            var u = i / nbTubular * arc;
	            var v = j / nbRadial * Math.PI * 2;
	            k = id * 3;
	            vertices[ k ] = ( radiusOut + radiusWidth * Math.cos( v ) ) * Math.cos( u );
	            vertices[ k + 1 ] = ( radiusOut + radiusWidth * Math.cos( v ) ) * Math.sin( u );
	            vertices[ k + 2 ] = radiusWidth * Math.sin( v );
	            id++;
	        }
	    }
	    id = 0;
	    for ( j = 1; j <= nbRadial; ++j ) {
	        for ( i = 1; i <= nbTubular; ++i ) {
	            k = id * 6;
	            indices[ k ] = ( nbTubular + 1 ) * j + i - 1;
	            indices[ k + 1 ] = indices[ k + 3 ] = ( nbTubular + 1 ) * ( j - 1 ) + i - 1;
	            indices[ k + 2 ] = indices[ k + 5 ] = ( nbTubular + 1 ) * j + i;
	            indices[ k + 4 ] = ( nbTubular + 1 ) * ( j - 1 ) + i;
	            id++;
	        }
	    }
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );
	    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );
	    g.getPrimitives().push( new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indices, 1 ) ) );
	    return g;
	};
	
	var createCylinderGeometry = function ( argRadiusTop, argRadiusBottom, argHeight, argRadialSegments, argHeightSegments, argTopCap, argLowCap ) {
	    var radiusTop = argRadiusTop !== undefined ? argRadiusTop : 1.0;
	    var radiusBottom = argRadiusBottom !== undefined ? argRadiusBottom : 1.0;
	    var height = argHeight !== undefined ? argHeight : 5.0;
	    var radialSegments = argRadialSegments !== undefined ? argRadialSegments : 32;
	    var heightSegments = argHeightSegments !== undefined ? argHeightSegments : 1;
	    var topCap = argTopCap !== undefined ? argTopCap : true;
	    var lowCap = argLowCap !== undefined ? argLowCap : true;
	
	    topCap = topCap && radiusTop > 0.0;
	    lowCap = lowCap && radiusBottom > 0.0;
	    var heightHalf = height * 0.5;
	
	    var nbVertices = ( heightSegments + 1 ) * ( radialSegments + 1 );
	    var nbTriangles = heightSegments * radialSegments * 2;
	    if ( topCap ) {
	        nbVertices += 1;
	        nbTriangles += radialSegments;
	    }
	    if ( lowCap ) {
	        nbVertices += 1;
	        nbTriangles += radialSegments;
	    }
	    var g = new Geometry();
	    var vertices = new Float32Array( nbVertices * 3 );
	    var indices = new Uint16Array( nbTriangles * 3 );
	
	    var id = 0;
	    var k = 0;
	    var i = 0;
	    var j = 0;
	    for ( i = 0; i <= heightSegments; i++ ) {
	        var v = i / heightSegments;
	        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	        for ( j = 0; j <= radialSegments; j++ ) {
	            var u = j / radialSegments;
	            k = id * 3;
	            vertices[ k ] = radius * Math.sin( u * Math.PI * 2 );
	            vertices[ k + 1 ] = radius * Math.cos( u * Math.PI * 2 );
	            vertices[ k + 2 ] = -v * height + heightHalf;
	            id++;
	        }
	    }
	
	    id = 0;
	    for ( j = 0; j < radialSegments; j++ ) {
	        for ( i = 0; i < heightSegments; i++ ) {
	            k = id * 6;
	            indices[ k ] = ( radialSegments + 1 ) * i + j;
	            indices[ k + 1 ] = indices[ k + 3 ] = ( radialSegments + 1 ) * ( i + 1 ) + j;
	            indices[ k + 2 ] = indices[ k + 5 ] = ( radialSegments + 1 ) * i + j + 1;
	            indices[ k + 4 ] = ( radialSegments + 1 ) * ( i + 1 ) + j + 1;
	            id++;
	        }
	    }
	    id *= 2;
	    var last;
	    if ( topCap ) {
	        last = ( lowCap ? vertices.length - 6 : vertices.length - 3 ) / 3;
	        vertices[ last * 3 + 2 ] = heightHalf;
	        for ( j = 0; j < radialSegments; j++ ) {
	            k = id * 3;
	            indices[ k ] = j;
	            indices[ k + 1 ] = j + 1;
	            indices[ k + 2 ] = last;
	            id++;
	        }
	    }
	
	    if ( lowCap ) {
	        last = ( vertices.length - 3 ) / 3;
	        vertices[ last * 3 + 2 ] = -heightHalf;
	        var end = ( radialSegments + 1 ) * i;
	        for ( j = 0; j < radialSegments; j++ ) {
	            k = id * 3;
	            indices[ k ] = end + j + 1;
	            indices[ k + 1 ] = end + j;
	            indices[ k + 2 ] = last;
	            id++;
	        }
	    }
	
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );
	    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );
	    g.getPrimitives().push( new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indices, 1 ) ) );
	    return g;
	};
	
	var createCircleGeometry = function ( nbVertices, radius, argArc ) {
	    var g = new Geometry();
	    var vertices = new Float32Array( nbVertices * 3 );
	    var arc = argArc || Math.PI * 2;
	    for ( var i = 0; i < nbVertices; ++i ) {
	        var j = i * 3;
	        var segment = arc * i / nbVertices;
	        vertices[ j ] = Math.cos( segment ) * radius;
	        vertices[ j + 1 ] = Math.sin( segment ) * radius;
	    }
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );
	    var primitive = new DrawArrays( PrimitiveSet.LINE_STRIP, 0, nbVertices );
	    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );
	    g.getPrimitives().push( primitive );
	    return g;
	};
	
	var createPlaneGeometry = function ( width, height ) {
	    var offx = width ? width * 0.5 : 0.5;
	    var offy = height ? height * 0.5 : 0.5;
	
	    var g = new Geometry();
	    var vertices = new Float32Array( 12 );
	    vertices[ 0 ] = -offx;
	    vertices[ 1 ] = -offy;
	
	    vertices[ 3 ] = offx;
	    vertices[ 4 ] = -offy;
	
	    vertices[ 6 ] = -offx;
	    vertices[ 7 ] = offy;
	
	    vertices[ 9 ] = offx;
	    vertices[ 10 ] = offy;
	
	    g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertices, 3 );
	    var primitive = new DrawArrays( PrimitiveSet.TRIANGLE_STRIP, 0, 4 );
	    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShader() );
	    g.getPrimitives().push( primitive );
	    return g;
	};
	
	var createQuadCircleGeometry = function () {
	    var g = createPlaneGeometry();
	    g.getOrCreateStateSet().setAttributeAndModes( getOrCreateShaderQuadCircle() );
	    return g;
	};
	
	var GizmoGeometry = {};
	GizmoGeometry.createCircleGeometry = createCircleGeometry;
	GizmoGeometry.createCylinderGeometry = createCylinderGeometry;
	GizmoGeometry.createTorusGeometry = createTorusGeometry;
	GizmoGeometry.createDebugLineGeometry = createDebugLineGeometry;
	GizmoGeometry.createPlaneGeometry = createPlaneGeometry;
	GizmoGeometry.createQuadCircleGeometry = createQuadCircleGeometry;
	
	module.exports = GizmoGeometry;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Notify = __webpack_require__( 10 );
	var Uniform = __webpack_require__( 35 );
	var NodeVisitor = __webpack_require__( 22 );
	
	var ArraySlider = function ( params ) {
	    if ( params !== undefined ) {
	        if ( params.object !== undefined && params.field !== undefined ) {
	            this.createInternalSlider( params );
	        }
	        this._uniform = this.createInternalSliderUniform( params );
	    }
	};
	
	ArraySlider.prototype = {
	    setTargetHTML: function ( target ) {
	        this.parent = target;
	    },
	    addToDom: function ( content ) {
	        var mydiv = document.createElement( 'div' );
	        mydiv.innerHTML = content;
	        this.parent.appendChild( mydiv );
	    },
	
	    getValue: function ( name ) {
	        if ( window.localStorage ) {
	            var value = window.localStorage.getItem( name );
	            return value;
	        }
	        return null;
	    },
	    setValue: function ( name, value ) {
	        if ( window.localStorage ) {
	            window.localStorage.setItem( name, value );
	        }
	    },
	    createHTMLSlider: function ( param, value, nameIndex, cbnameIndex ) {
	        var input = '<div>NAME [ MIN - MAX ] <input type="range" min="MIN" max="MAX" value="VALUE" step="STEP" onchange="ONCHANGE" /><span id="UPDATE"></span></div>';
	        var min = param.min;
	        var max = param.max;
	        var step = param.step;
	        var name = nameIndex;
	        var cbname = cbnameIndex;
	        var onchange = cbname + '(this.value)';
	        input = input.replace( /MIN/g, min );
	        input = input.replace( /MAX/g, ( max + step ) );
	        input = input.replace( 'STEP', step );
	        input = input.replace( 'VALUE', value );
	        input = input.replace( /NAME/g, name );
	        input = input.replace( /UPDATE/g, cbname );
	        input = input.replace( 'ONCHANGE', onchange );
	        return input;
	    },
	
	    createUniformFunction: function ( param, name, index, uniform, cbnameIndex ) {
	        var self = this;
	        return ( function () {
	            var cname = name;
	            var cindex = index;
	            var cuniform = uniform;
	            var id = cbnameIndex;
	            var func = function ( value ) {
	                cuniform.get()[ cindex ] = value;
	                cuniform.dirty();
	                Notify.debug( cname + ' value ' + value );
	                document.getElementById( cbnameIndex ).innerHTML = Number( value ).toFixed( 4 );
	                self.setValue( id, value );
	                if ( param.onchange !== undefined ) {
	                    param.onchange( cuniform.get() );
	                }
	                // store the value to localstorage
	            };
	            return func;
	        } )();
	    },
	
	    createFunction: function ( param, name, index, object, field, cbnameIndex ) {
	        var self = this;
	        return ( function () {
	            var cname = name;
	            //var cindex = index;
	            var cfield = field;
	            var id = cbnameIndex;
	            var obj = object;
	            var func = function ( value ) {
	                if ( typeof ( value ) === 'string' ) {
	                    value = parseFloat( value );
	                }
	
	                if ( typeof ( object[ cfield ] ) === 'number' ) {
	                    obj[ cfield ] = value;
	                } else {
	                    obj[ cfield ][ index ] = value;
	                }
	                Notify.debug( cname + ' value ' + value );
	                document.getElementById( cbnameIndex ).innerHTML = Number( value ).toFixed( 4 );
	                self.setValue( id, value );
	                if ( param.onchange !== undefined ) {
	                    param.onchange( obj[ cfield ] );
	                }
	
	                // store the value to localstorage
	            };
	            return func;
	        } )();
	    },
	
	    getCallbackName: function ( name, prgId ) {
	        return 'change_' + prgId + '_' + name;
	    },
	
	    copyDefaultValue: function ( param ) {
	        var uvalue = param.value;
	        if ( Array.isArray( param.value ) ) {
	            uvalue = param.value.slice();
	        } else {
	            uvalue = [ uvalue ];
	        }
	        return uvalue;
	    },
	
	    createInternalSliderUniform: function ( param ) {
	        var uvalue = param.value;
	        var uniform = param.uniform;
	        if ( uniform === undefined ) {
	            var type = param.type;
	            type = type.charAt( 0 ).toUpperCase() + type.slice( 1 );
	            uniform = Uniform[ 'create' + type ]( uvalue, param.name );
	        }
	
	        var cbname = this.getCallbackName( param.name, param.id );
	        var dim = uvalue.length;
	        for ( var i = 0; i < dim; i++ ) {
	
	            var istring = i.toString();
	            var nameIndex = param.name + istring;
	            var cbnameIndex = cbname + istring;
	
	            // default value
	            var value = uvalue[ i ];
	
	            // read local storage value if it exist
	            var readValue = this.getValue( cbnameIndex );
	            if ( readValue !== null ) {
	                value = readValue;
	            } else if ( param.uniform && param.uniform.get()[ i ] !== undefined ) {
	                // read value from original uniform
	                value = param.uniform.get()[ i ];
	            }
	
	            var dom = this.createHTMLSlider( param, value, nameIndex, cbnameIndex );
	            this.addToDom( dom );
	            window[ cbnameIndex ] = this.createUniformFunction( param, nameIndex, i, uniform, cbnameIndex );
	            Notify.log( nameIndex + ' ' + value );
	            window[ cbnameIndex ]( value );
	        }
	        this.uniform = uniform;
	        return uniform;
	    },
	
	    createInternalSlider: function ( param ) {
	        var uvalue = param.value;
	        var name = param.name;
	        var id = param.id;
	        var dim = uvalue.length;
	        var cbname = this.getCallbackName( name, id );
	        var object = param.object;
	        var field = param.field;
	        for ( var i = 0; i < dim; i++ ) {
	
	            var istring = i.toString();
	            var nameIndex = name + istring;
	            var cbnameIndex = cbname + istring;
	
	            // default value
	            var value = uvalue[ i ];
	
	            // read local storage value if it exist
	            var readValue = this.getValue( cbnameIndex );
	            if ( readValue !== null ) {
	                value = readValue;
	            } else {
	                if ( typeof object[ field ] === 'number' ) {
	                    value = object[ field ];
	                } else {
	                    value = object[ field ][ i ];
	                }
	            }
	
	            var dom = this.createHTMLSlider( param, value, nameIndex, cbnameIndex );
	            this.addToDom( dom );
	            window[ cbnameIndex ] = this.createFunction( param, nameIndex, i, object, field, cbnameIndex );
	            Notify.log( nameIndex + ' ' + value );
	            window[ cbnameIndex ]( value );
	        }
	    },
	
	    createSlider: function ( param ) {
	        if ( param.html !== undefined ) {
	            this.setTargetHTML( param.html );
	        }
	        if ( param.id === undefined ) {
	            param.id = param.name;
	        }
	        param.value = this.copyDefaultValue( param );
	        if ( param.type !== undefined ) {
	            return this.createInternalSliderUniform( param );
	        } else {
	            if ( param.object === undefined ) {
	                param.object = {
	                    'data': param.value
	                };
	                param.field = 'data';
	            }
	            return this.createInternalSlider( param );
	        }
	    }
	};
	
	
	var ParameterVisitor = function () {
	    NodeVisitor.call( this );
	
	    this.arraySlider = new ArraySlider();
	    this.setTargetHTML( document.body );
	};
	
	ParameterVisitor.createSlider = function ( param ) {
	    ( new ArraySlider() ).createSlider( param );
	};
	
	ParameterVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	
	    setTargetHTML: function ( html ) {
	        this.targetHTML = html;
	        this.arraySlider.setTargetHTML( this.targetHTML );
	    },
	
	    getUniformList: function ( str, map ) {
	
	        //var txt='uniform float Power; // { min: 0.1, max: 2.0, step: 0.1, value: [0,0,0]  }';
	
	        var re1 = '(uniform)'; // Word 1
	        var re2 = '.*?'; // Non-greedy match on filler
	        var re3 = '((?:[a-z][a-z]+))'; // Word 2
	        var re4 = '.*?'; // Non-greedy match on filler
	        var re5 = '((?:[a-z][a-z]+))'; // Word 3
	        var re6 = '.*?'; // Non-greedy match on filler
	        var re7 = '.'; // Uninteresting: c
	        var re8 = '.*?'; // Non-greedy match on filler
	        var re9 = '.'; // Uninteresting: c
	        var re10 = '.*?'; // Non-greedy match on filler
	        var re11 = '(.)'; // Any Single Character 1
	        var re12 = '(.)'; // Any Single Character 2
	        var re13 = '.*?'; // Non-greedy match on filler
	        var re14 = '(\\{.*?\\})'; // Curly Braces 1
	
	        var p = new RegExp( re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9 + re10 + re11 + re12 + re13 + re14, [ 'g' ] );
	        var r = str.match( p );
	        var list = map;
	
	        var createGetter = function ( value ) {
	            return function () {
	                return value;
	            };
	        };
	
	        if ( r !== null ) {
	            var re = new RegExp( re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9 + re10 + re11 + re12 + re13 + re14, [ 'i' ] );
	            for ( var i = 0, l = r.length; i < l; i++ ) {
	                var result = r[ i ].match( re );
	                //var result = p.exec(str);
	                if ( result !== null ) {
	                    //var word1 = result[ 1 ];
	                    var type = result[ 2 ];
	                    var name = result[ 3 ];
	                    //var c1 = result[ 4 ];
	                    //var c2 = result[ 5 ];
	                    var json = result[ 6 ];
	
	                    var param = JSON.parse( json );
	                    param.type = type;
	                    param.name = name;
	                    var value = param.value;
	                    param.value = createGetter( value );
	                    list[ name ] = param;
	                }
	            }
	        }
	        return list;
	    },
	
	    getUniformFromStateSet: function ( stateSet, uniformMap ) {
	        var maps = stateSet.getUniformList();
	        if ( !maps ) {
	            return;
	        }
	        var keys = window.Object.keys( uniformMap );
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	            var k = keys[ i ];
	            // get the first one found in the tree
	            if ( maps[ k ] !== undefined && uniformMap[ k ].uniform === undefined ) {
	                uniformMap[ k ].uniform = maps[ k ].object;
	            }
	        }
	    },
	
	    findExistingUniform: function ( node, uniformMap ) {
	        var BackVisitor = function () {
	            NodeVisitor.call( this, NodeVisitor.TRAVERSE_PARENTS );
	        };
	        BackVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	            setUniformMap: function ( map ) {
	                this.uniformMap = map;
	            },
	            apply: function ( node ) {
	                var stateSet = node.getStateSet();
	                if ( stateSet ) {
	                    ParameterVisitor.prototype.getUniformFromStateSet( stateSet, this.uniformMap );
	                }
	                this.traverse( node );
	            }
	        } );
	        var visitor = new BackVisitor();
	        visitor.setUniformMap( uniformMap );
	        node.accept( visitor );
	    },
	
	    applyProgram: function ( node, stateset ) {
	        var program = stateset.getAttribute( 'Program' );
	        var programName = program.getName();
	        //var string = program.getVertexShader().getText();
	        var uniformMap = {};
	        this.getUniformList( program.getVertexShader().getText(), uniformMap );
	        this.getUniformList( program.getFragmentShader().getText(), uniformMap );
	
	        var i = 0;
	
	        var keys = window.Object.keys( uniformMap );
	
	        if ( programName === undefined ) {
	            var hashCode = function ( str ) {
	                var hash = 0;
	                var chara = 0;
	                if ( str.length === 0 ) {
	                    return hash;
	                }
	                for ( i = 0; i < str.length; i++ ) {
	                    chara = str.charCodeAt( i );
	                    /*jshint bitwise: false */
	                    hash = ( ( hash << 5 ) - hash ) + chara;
	                    hash = hash & hash; // Convert to 32bit integer
	                    /*jshint bitwise: true */
	                }
	                if ( hash < 0 ) {
	                    hash = -hash;
	                }
	                return hash;
	            };
	            var str = keys.join( '' );
	            programName = hashCode( str ).toString();
	        }
	
	        this.findExistingUniform( node, uniformMap );
	
	        var addedSlider = false;
	        for ( i = 0; i < keys.length; i++ ) {
	            var k = keys[ i ];
	            var entry = uniformMap[ k ];
	            var type = entry.type;
	            var name = entry.name;
	            entry.id = programName;
	            var uniform = this.arraySlider.createSlider( entry );
	            if ( false ) {
	                uniform = this.arraySlider.createSlider( {
	                    name: name,
	                    type: type,
	                    id: programName,
	                    uniform: entry.uniform
	                } );
	            }
	            if ( entry.uniform === undefined && uniform ) {
	                stateset.addUniform( uniform );
	            }
	            addedSlider = true;
	        }
	
	        // add a separator
	        if ( addedSlider ) {
	            var mydiv = document.createElement( 'div' );
	            mydiv.innerHTML = '<p> </p>';
	            this.targetHTML.appendChild( mydiv );
	        }
	
	        Notify.log( uniformMap );
	    },
	
	
	    applyStateSet: function ( node, stateset ) {
	        if ( stateset.getAttribute( 'Program' ) !== undefined ) {
	            this.applyProgram( node, stateset );
	        }
	    },
	
	    apply: function ( node ) {
	        var element = this.targetHTML;
	        if ( element === undefined || element === null ) {
	            return;
	        }
	
	        var st = node.getStateSet();
	        if ( st !== undefined ) {
	            this.applyStateSet( node, st );
	        }
	
	        this.traverse( node );
	    }
	} );
	
	module.exports = ParameterVisitor;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec3 = __webpack_require__( 15 );
	var Matrix = __webpack_require__( 23 );
	var TriangleSphereIntersector = __webpack_require__( 95 );
	
	
	var SphereIntersector = function () {
	    this._center = Vec3.create();
	    this._iCenter = Vec3.create();
	    this._radius = 1.0;
	    this._iRadius = 1.0;
	    this._intersections = [];
	};
	
	SphereIntersector.prototype = {
	    set: function ( center, radius ) {
	        // we copy iCenter and iRadius in case setCurrentTransformation is never called
	        Vec3.copy( center, this._center );
	        Vec3.copy( center, this._iCenter );
	        this._radius = this._iRadius = radius;
	        this.reset();
	    },
	    setCenter: function ( center ) {
	        Vec3.copy( center, this._center );
	        Vec3.copy( center, this._iCenter );
	    },
	    setRadius: function ( radius ) {
	        this._radius = this._iRadius = radius;
	    },
	    reset: function () {
	        // Clear the intersections vector
	        this._intersections.length = 0;
	    },
	    enter: function ( node ) {
	        // Not working if culling disabled ??
	        return !node.isCullingActive() || this.intersects( node.getBound() );
	    },
	    // Intersection Sphere/Sphere 
	    intersects: function ( bsphere ) {
	        if ( !bsphere.valid() ) return false;
	        var r = this._iRadius + bsphere.radius();
	        return Vec3.distance2( this._iCenter, bsphere.center() ) <= r * r;
	    },
	
	    intersect: ( function () {
	
	        var ti = new TriangleSphereIntersector();
	
	        return function ( iv, node ) {
	
	            var kdtree = node.getShape();
	            if ( kdtree )
	                return kdtree.intersectSphere( this._iCenter, this._iRadius, this._intersections, iv.nodePath );
	
	            ti.reset();
	            ti.setNodePath( iv.nodePath );
	            ti.set( this._iCenter, this._iRadius );
	
	            // handle rig transformed vertices
	            if ( node.computeTransformedVertices ) {
	                var vList = node.getVertexAttributeList();
	                var originVerts = vList.Vertex.getElements();
	
	                // temporarily hook vertex buffer for the tri intersections
	                // don't call setElements as it dirty some stuffs because of gl buffer 
	                vList.Vertex._elements = node.computeTransformedVertices();
	                ti.apply( node );
	                vList.Vertex._elements = originVerts;
	            } else {
	                ti.apply( node );
	            }
	
	            var l = ti._intersections.length;
	            for ( var i = 0; i < l; i++ ) {
	                this._intersections.push( ti._intersections[ i ] );
	            }
	
	            return l > 0;
	        };
	    } )(),
	
	    getIntersections: function () {
	        return this._intersections;
	    },
	
	    setCurrentTransformation: ( function () {
	        var tmp = Vec3.create();
	
	        return function ( matrix ) {
	            Matrix.inverse( matrix, matrix );
	            Matrix.transformVec3( matrix, this._center, this._iCenter );
	            this._iRadius = this._radius * Matrix.getScale( matrix, tmp )[ 0 ];
	        };
	    } )()
	};
	
	module.exports = SphereIntersector;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var BufferArray = __webpack_require__( 40 );
	var Geometry = __webpack_require__( 31 );
	var NodeVisitor = __webpack_require__( 22 );
	var PrimitiveSet = __webpack_require__( 41 );
	var Vec3 = __webpack_require__( 15 );
	
	
	var osg = MACROUTILS;
	
	var TangentSpaceGenerator = function () {
	    NodeVisitor.call( this );
	    this._T = undefined;
	    this._B = undefined;
	    this._N = undefined;
	    this._texCoordUnit = 0;
	};
	
	TangentSpaceGenerator.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	
	    apply: function ( node ) {
	
	        if ( node.getTypeID() === Geometry.getTypeID() )
	            this.generate( node, this._texCoordUnit );
	        else
	            this.traverse( node );
	
	    },
	
	    setTexCoordUnit: function ( texCoordUnit ) {
	        this._texCoordUnit = texCoordUnit;
	    },
	
	    computePrimitiveSet: function ( geometry, primitiveSet ) {
	
	        // no indices -> exit
	        if ( !primitiveSet.getIndices )
	            return;
	
	        var numIndices = primitiveSet.getNumIndices();
	
	        var vx = geometry.getAttributes().Vertex;
	        var nx = geometry.getAttributes().Normal;
	        var tx = geometry.getAttributes()[ 'TexCoord' + this._texCoordUnit ];
	
	        var i;
	
	        if ( primitiveSet.getMode() === PrimitiveSet.TRIANGLES ) {
	
	            for ( i = 0; i < numIndices; i += 3 ) {
	                this.compute( primitiveSet, vx, nx, tx, i, i + 1, i + 2 );
	            }
	
	        } else if ( primitiveSet.getMode() === PrimitiveSet.TRIANGLE_STRIP ) {
	
	            for ( i = 0; i < numIndices - 2; ++i ) {
	                if ( ( i % 2 ) === 0 ) {
	                    this.compute( primitiveSet, vx, nx, tx, i, i + 1, i + 2 );
	                } else {
	                    this.compute( primitiveSet, vx, nx, tx, i + 1, i, i + 2 );
	                }
	            }
	        }
	
	    },
	
	    generate: function ( geometry, texCoordUnit ) {
	
	        this._texCoordUnit = texCoordUnit;
	
	        if ( this._texCoordUnit === undefined )
	            this._texCoordUnit = 0;
	
	        var size = geometry.getAttributes().Vertex.getElements().length;
	        this._T = new osg.Float32Array( size );
	        this._B = new osg.Float32Array( size );
	        this._N = new osg.Float32Array( size );
	
	        geometry.getPrimitiveSetList().forEach( function ( primitiveSet ) {
	
	            this.computePrimitiveSet( geometry, primitiveSet );
	
	        }, this );
	
	        var nbElements = size / 3;
	        var tangents = new osg.Float32Array( nbElements * 4 );
	
	        var tmp0 = Vec3.create();
	        var tmp1 = Vec3.create();
	        var t3 = Vec3.create();
	
	        for ( var i = 0; i < nbElements; i++ ) {
	            var t = this._T.subarray( i * 3, i * 3 + 3 );
	            var n = this._N.subarray( i * 3, i * 3 + 3 );
	            var b = this._B.subarray( i * 3, i * 3 + 3 );
	
	            Vec3.normalize( n, n );
	
	            // Gram-Schmidt orthogonalize
	            // Vec3 t3 = (t - n * (n * t));
	            // t3.normalize();
	            // finalTangent = Vec4(t3, 0.0);
	            // Calculate handedness
	            // finalTangent[3] = (((n ^ t) * b) < 0.0) ? -1.0 : 1.0;
	            // The bitangent vector B is then given by B = (N √ó T) ¬∑ Tw
	
	            var nt = Vec3.dot( n, t );
	            Vec3.mult( n, nt, tmp1 );
	            Vec3.sub( t, tmp1, tmp0 );
	            Vec3.normalize( tmp0, t3 );
	
	            Vec3.cross( n, t, tmp0 );
	            var sign = Vec3.dot( tmp0, b );
	            sign = sign < 0.0 ? -1.0 : 0.0;
	
	            // TODO perf : cache index var id = i * 4;
	            tangents[ i * 4 ] = t3[ 0 ];
	            tangents[ i * 4 + 1 ] = t3[ 1 ];
	            tangents[ i * 4 + 2 ] = t3[ 2 ];
	            tangents[ i * 4 + 3 ] = sign;
	        }
	
	        geometry.getAttributes().Normal.setElements( this._N );
	        geometry.getAttributes().Tangent = new BufferArray( 'ARRAY_BUFFER', tangents, 4 );
	
	    },
	
	    compute: function ( primitiveSet, vx, nx, tx, ia, ib, ic ) {
	
	        var i0 = primitiveSet.index( ia );
	        var i1 = primitiveSet.index( ib );
	        var i2 = primitiveSet.index( ic );
	
	        // TODO perf : cache xx.getElements() but more importantly
	        // subarray call have very high overhead, it's super useful
	        // when you call it a few times for big array chunk, but for
	        // small array extraction (each vertex) it's better to use a temporary
	        // pre allocated array and simply fill it
	        // then, you'll have to write in the big arrays at the end
	        var P1 = vx.getElements().subarray( i0 * 3, i0 * 3 + 3 );
	        var P2 = vx.getElements().subarray( i1 * 3, i1 * 3 + 3 );
	        var P3 = vx.getElements().subarray( i2 * 3, i2 * 3 + 3 );
	
	        var N1 = nx.getElements().subarray( i0 * 3, i0 * 3 + 3 );
	        var N2 = nx.getElements().subarray( i1 * 3, i1 * 3 + 3 );
	        var N3 = nx.getElements().subarray( i2 * 3, i2 * 3 + 3 );
	
	        var uv1 = tx.getElements().subarray( i0 * 2, i0 * 2 + 2 );
	        var uv2 = tx.getElements().subarray( i1 * 2, i1 * 2 + 2 );
	        var uv3 = tx.getElements().subarray( i2 * 2, i2 * 2 + 2 );
	
	        var vz, vy;
	        // TODO perf : use temporary vec
	        var V = Vec3.create();
	
	        var B1 = Vec3.create();
	        var B2 = Vec3.create();
	        var B3 = Vec3.create();
	
	        var T1 = Vec3.create();
	        var T2 = Vec3.create();
	        var T3 = Vec3.create();
	
	        var v1 = Vec3.create();
	        var v2 = Vec3.create();
	
	
	        Vec3.set( P2[ 0 ] - P1[ 0 ], uv2[ 0 ] - uv1[ 0 ], uv2[ 1 ] - uv1[ 1 ], v1 );
	        Vec3.set( P3[ 0 ] - P1[ 0 ], uv3[ 0 ] - uv1[ 0 ], uv3[ 1 ] - uv1[ 1 ], v2 );
	
	        Vec3.cross( v1, v2, V );
	
	        if ( V[ 0 ] !== 0.0 ) {
	            Vec3.normalize( V, V );
	            vy = -V[ 1 ] / V[ 0 ];
	            vz = -V[ 2 ] / V[ 0 ];
	            T1[ 0 ] += vy;
	            B1[ 0 ] += vz;
	            T2[ 0 ] += vy;
	            B2[ 0 ] += vz;
	            T3[ 0 ] += vy;
	            B3[ 0 ] += vz;
	        }
	
	
	        Vec3.set( P2[ 1 ] - P1[ 1 ], uv2[ 0 ] - uv1[ 0 ], uv2[ 1 ] - uv1[ 1 ], v1 );
	        Vec3.set( P3[ 1 ] - P1[ 1 ], uv3[ 0 ] - uv1[ 0 ], uv3[ 1 ] - uv1[ 1 ], v2 );
	
	        Vec3.cross( v1, v2, V );
	
	        if ( V[ 0 ] !== 0.0 ) {
	            Vec3.normalize( V, V );
	            vy = -V[ 1 ] / V[ 0 ];
	            vz = -V[ 2 ] / V[ 0 ];
	            T1[ 1 ] += vy;
	            B1[ 1 ] += vz;
	            T2[ 1 ] += vy;
	            B2[ 1 ] += vz;
	            T3[ 1 ] += vy;
	            B3[ 1 ] += vz;
	        }
	
	
	        Vec3.set( P2[ 2 ] - P1[ 2 ], uv2[ 0 ] - uv1[ 0 ], uv2[ 1 ] - uv1[ 1 ], v1 );
	        Vec3.set( P3[ 2 ] - P1[ 2 ], uv3[ 0 ] - uv1[ 0 ], uv3[ 1 ] - uv1[ 1 ], v2 );
	
	        Vec3.cross( v1, v2, V );
	
	        if ( V[ 0 ] !== 0.0 ) {
	            Vec3.normalize( V, V );
	            vy = -V[ 1 ] / V[ 0 ];
	            vz = -V[ 2 ] / V[ 0 ];
	            T1[ 2 ] += vy;
	            B1[ 2 ] += vz;
	            T2[ 2 ] += vy;
	            B2[ 2 ] += vz;
	            T3[ 2 ] += vy;
	            B3[ 2 ] += vz;
	        }
	
	        var tempVec = Vec3.create();
	        var tempVec2 = Vec3.create();
	
	        var Tdst, Bdst, Ndst;
	
	        Vec3.cross( N1, T1, tempVec );
	        Vec3.cross( tempVec, N1, tempVec2 );
	        Tdst = this._T.subarray( i0 * 3, i0 * 3 + 3 );
	        Vec3.add( tempVec2, Tdst, Tdst );
	
	        Vec3.cross( B1, N1, tempVec );
	        Vec3.cross( N1, tempVec, tempVec2 );
	        Bdst = this._B.subarray( i0 * 3, i0 * 3 + 3 );
	        Vec3.add( tempVec2, Bdst, Bdst );
	
	
	        Vec3.cross( N2, T2, tempVec );
	        Vec3.cross( tempVec, N2, tempVec2 );
	        Tdst = this._T.subarray( i1 * 3, i1 * 3 + 3 );
	        Vec3.add( tempVec2, Tdst, Tdst );
	
	        Vec3.cross( B2, N2, tempVec );
	        Vec3.cross( N2, tempVec, tempVec2 );
	        Bdst = this._B.subarray( i1 * 3, i1 * 3 + 3 );
	        Vec3.add( tempVec2, Bdst, Bdst );
	
	
	        Vec3.cross( N3, T3, tempVec );
	        Vec3.cross( tempVec, N3, tempVec2 );
	        Tdst = this._T.subarray( i2 * 3, i2 * 3 + 3 );
	        Vec3.add( tempVec2, Tdst, Tdst );
	
	        Vec3.cross( B3, N3, tempVec );
	        Vec3.cross( N3, tempVec, tempVec2 );
	        Bdst = this._B.subarray( i2 * 3, i2 * 3 + 3 );
	        Vec3.add( tempVec2, Bdst, Bdst );
	
	
	        Ndst = this._N.subarray( i0 * 3, i0 * 3 + 3 );
	        Vec3.add( N1, Ndst, Ndst );
	
	        Ndst = this._N.subarray( i1 * 3, i1 * 3 + 3 );
	        Vec3.add( N2, Ndst, Ndst );
	
	        Ndst = this._N.subarray( i2 * 3, i2 * 3 + 3 );
	        Vec3.add( N3, Ndst, Ndst );
	    }
	
	} );
	
	module.exports = TangentSpaceGenerator;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Camera = __webpack_require__( 56 );
	var FrameBufferObject = __webpack_require__( 68 );
	var Matrix = __webpack_require__( 23 );
	var Node = __webpack_require__( 12 );
	var Program = __webpack_require__( 100 );
	var Shader = __webpack_require__( 101 );
	var Shape = __webpack_require__( 102 );
	var Texture = __webpack_require__( 34 );
	var Transform = __webpack_require__( 11 );
	var Uniform = __webpack_require__( 35 );
	var Vec2 = __webpack_require__( 70 );
	var Vec4 = __webpack_require__( 25 );
	var Viewport = __webpack_require__( 107 );
	var Composer = __webpack_require__( 155 );
	
	
	var WebVRCustom = {};
	
	// no smart resize, we just recreate everything
	var UpdateRecreateOnResize = function ( viewer, rttScene, hmdConfig, root, canvas ) {
	    this._viewer = viewer;
	    this._rttScene = rttScene;
	    this._hmdConfig = hmdConfig;
	    this._root = root;
	    this._canvas = canvas;
	    this._width = canvas.width;
	    this._height = canvas.height;
	};
	
	UpdateRecreateOnResize.prototype = {
	    update: function () {
	        var canvas = this._canvas;
	        var width = canvas.width;
	        var height = canvas.height;
	
	        if ( width !== this._width || height !== this._height ) {
	            this._root.removeChildren();
	
	            var hmdConfig = this._hmdConfig;
	            if ( hmdConfig && hmdConfig.isCardboard ) {
	                hmdConfig.hResolution = width;
	                hmdConfig.vResolution = height;
	            }
	            this._width = width;
	            this._height = height;
	
	            WebVRCustom.createScene( this._viewer, this._rttScene, hmdConfig, this._root );
	        }
	        return true;
	    }
	};
	
	var UpdateOffsetCamera = function ( rootView, offsetView ) {
	    this._rootView = rootView;
	    this._offsetView = offsetView;
	};
	
	UpdateOffsetCamera.prototype = {
	    update: function ( node ) {
	        var nodeView = node.getViewMatrix();
	        Matrix.mult( this._offsetView, this._rootView, nodeView );
	        return true;
	    }
	};
	
	var setupWebVR = function ( worldFactor, HMD, webVRUniforms, webVRMatrices ) {
	
	    var aspect = HMD.hResolution / ( 2.0 * HMD.vResolution );
	    var r = -1.0 - ( 4.0 * ( HMD.hScreenSize * 0.25 - HMD.lensSeparationDistance * 0.5 ) / HMD.hScreenSize );
	    var distScale = ( HMD.distortionK[ 0 ] + HMD.distortionK[ 1 ] * Math.pow( r, 2 ) + HMD.distortionK[ 2 ] * Math.pow( r, 4 ) + HMD.distortionK[ 3 ] * Math.pow( r, 6 ) );
	    var fov = ( 180.0 / Math.PI ) * 2.0 * Math.atan2( HMD.vScreenSize * distScale, 2.0 * HMD.eyeToScreenDistance );
	
	    var proj = Matrix.makePerspective( fov, aspect, 0.3, 10000.0, Matrix.create() );
	    var hOffset = 4.0 * ( HMD.hScreenSize * 0.25 - HMD.interpupillaryDistance * 0.5 ) / HMD.hScreenSize;
	    var lensShift = 4.0 * ( HMD.hScreenSize * 0.25 - HMD.lensSeparationDistance * 0.5 ) / HMD.hScreenSize;
	
	    webVRMatrices.projectionLeft = Matrix.preMult( Matrix.makeTranslate( hOffset, 0.0, 0.0, Matrix.create() ), proj );
	    webVRMatrices.projectionRight = Matrix.preMult( Matrix.makeTranslate( -hOffset, 0.0, 0.0, Matrix.create() ), proj );
	    webVRMatrices.viewLeft = Matrix.makeTranslate( worldFactor * HMD.interpupillaryDistance * 0.5, 0.0, 0.0, Matrix.create() );
	    webVRMatrices.viewRight = Matrix.makeTranslate( -worldFactor * HMD.interpupillaryDistance * 0.5, 0.0, 0.0, Matrix.create() );
	
	    webVRUniforms.lensCenterLeft = Vec2.createAndSet( lensShift, 0.0 );
	    webVRUniforms.lensCenterRight = Vec2.createAndSet( -lensShift, 0.0 );
	    webVRUniforms.hmdWarpParam = HMD.distortionK;
	    webVRUniforms.chromAbParam = HMD.chromaAbParameter;
	    webVRUniforms.scaleIn = Vec2.createAndSet( 1.0, 1.0 / aspect );
	    webVRUniforms.scale = Vec2.createAndSet( 1.0 / distScale, 1.0 * aspect / distScale );
	};
	
	var getWebVRShader = function () {
	
	    var fragmentshader = [
	        '',
	        '#ifdef GL_ES',
	        'precision highp float;',
	        '#endif',
	
	        'uniform vec2 uScale;',
	        'uniform vec2 uScaleIn;',
	        'uniform vec2 uLensCenter;',
	        'uniform vec4 uHmdWarpParam;',
	        'uniform vec4 uChromAbParam;',
	        'uniform sampler2D Texture0;',
	
	        'varying vec2 FragTexCoord0;',
	
	        // from http://paradise.untergrund.net/tmp/demoshit/examples/js/effects/OculusRiftEffect.js
	        'void main(void) {',
	        '  vec2 uv = (FragTexCoord0 * 2.0) - 1.0;', // range from [0,1] to [-1,1]
	        '  vec2 theta = (uv - uLensCenter) * uScaleIn;',
	        '  float rSq = theta.x * theta.x + theta.y * theta.y;',
	        '  vec2 rvector = theta * (uHmdWarpParam.x + uHmdWarpParam.y * rSq + uHmdWarpParam.z * rSq * rSq + uHmdWarpParam.w * rSq * rSq * rSq);',
	        '  vec2 rBlue = rvector * (uChromAbParam.z + uChromAbParam.w * rSq);',
	        '  vec2 tcBlue = (uLensCenter + uScale * rBlue);',
	        '  tcBlue = (tcBlue + 1.0) * 0.5;', // range from [-1,1] to [0,1]
	        '  if (any(bvec2(clamp(tcBlue, vec2(0.0, 0.0), vec2(1.0, 1.0)) - tcBlue))) {',
	        '    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
	        '    return;',
	        '  }',
	        '  vec2 tcGreen = uLensCenter + uScale * rvector;',
	        '  tcGreen = (tcGreen + 1.0) * 0.5;', // range from [-1,1] to [0,1]
	        '  vec2 rRed = rvector * (uChromAbParam.x + uChromAbParam.y * rSq);',
	        '  vec2 tcRed = uLensCenter + uScale * rRed;',
	        '  tcRed = (tcRed + 1.0) * 0.5;', // range from [-1,1] to [0,1]
	        '  gl_FragColor = vec4(texture2D(Texture0, tcRed).r, texture2D(Texture0, tcGreen).g, texture2D(Texture0, tcBlue).b, 1);',
	        '}',
	        ''
	    ].join( '\n' );
	
	    return new Program(
	        new Shader( Shader.VERTEX_SHADER, Composer.Filter.defaultVertexShader ),
	        new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );
	};
	
	var createTextureRtt = function ( rttSize ) {
	    var rttTexture = new Texture();
	    rttTexture.setTextureSize( rttSize[ 0 ], rttSize[ 1 ] );
	    rttTexture.setMinFilter( 'LINEAR' );
	    rttTexture.setMagFilter( 'LINEAR' );
	    return rttTexture;
	};
	
	var createOrthoRtt = function ( left, viewportSize, canvasSize, cardboard, texture, webVRUniforms ) {
	    var orthoCamera = new Camera();
	    var vw = viewportSize[ 0 ];
	    var vh = viewportSize[ 1 ];
	    var cw = canvasSize[ 0 ];
	    var ch = canvasSize[ 1 ];
	    if ( cardboard === true ) {
	        if ( left )
	            orthoCamera.setViewport( new Viewport( 0.0, 0.0, cw / 2.0, ch ) );
	        else
	            orthoCamera.setViewport( new Viewport( cw / 2.0, 0.0, cw / 2.0, ch ) );
	    } else {
	        if ( left )
	            orthoCamera.setViewport( new Viewport( 0.5 * cw - vw, 0.5 * ( ch - vh ), vw, vh ) );
	        else
	            orthoCamera.setViewport( new Viewport( 0.5 * cw, 0.5 * ( ch - vh ), vw, vh ) );
	    }
	    Matrix.makeOrtho( -0.5, 0.5, -0.5, 0.5, -5, 5, orthoCamera.getProjectionMatrix() );
	    orthoCamera.setRenderOrder( Camera.NESTED_RENDER, 0 );
	    orthoCamera.setReferenceFrame( Transform.ABSOLUTE_RF );
	
	    var stateSet = orthoCamera.getOrCreateStateSet();
	    stateSet.setTextureAttributeAndModes( 0, texture );
	    stateSet.setAttributeAndModes( getWebVRShader() );
	    stateSet.addUniform( Uniform.createFloat2( webVRUniforms.scale, 'uScale' ) );
	    stateSet.addUniform( Uniform.createFloat2( webVRUniforms.scaleIn, 'uScaleIn' ) );
	    stateSet.addUniform( Uniform.createFloat2( left ? webVRUniforms.lensCenterLeft : webVRUniforms.lensCenterRight, 'uLensCenter' ) );
	    stateSet.addUniform( Uniform.createFloat4( webVRUniforms.hmdWarpParam, 'uHmdWarpParam' ) );
	    stateSet.addUniform( Uniform.createFloat4( webVRUniforms.chromAbParam, 'uChromAbParam' ) );
	
	    return orthoCamera;
	};
	
	var createCameraRtt = function ( texture, projMatrix ) {
	    var camera = new Camera();
	    camera.setName( 'rtt camera' );
	    camera.setViewport( new Viewport( 0, 0, texture.getWidth(), texture.getHeight() ) );
	    camera.setProjectionMatrix( projMatrix );
	    camera.setClearColor( Vec4.createAndSet( 0.3, 0.3, 0.3, 0.0 ) );
	    camera.setRenderOrder( Camera.POST_RENDER, 0 );
	    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );
	    camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );
	    camera.setReferenceFrame( Transform.ABSOLUTE_RF );
	    return camera;
	};
	
	WebVRCustom.createScene = function ( viewer, rttScene, HMDconfig, rootOverride, worldFactorOverride ) {
	    var HMD = WebVRCustom.getDefaultConfig( HMDconfig );
	    var rttSize = Vec2.createAndSet( HMD.hResolution * 0.5, HMD.vResolution );
	    var viewportSize = Vec2.createAndSet( HMD.hResolution * 0.5, HMD.vResolution );
	    var vp = viewer.getCamera().getViewport();
	    var canvasSize = Vec2.createAndSet( vp.width(), vp.height() );
	
	    var canvas = viewer.getGraphicContext().canvas;
	    if ( HMD.isCardboard ) {
	        canvasSize[ 0 ] = canvas.width;
	        canvasSize[ 1 ] = canvas.height;
	    }
	
	    var worldFactor = worldFactorOverride !== undefined ? worldFactorOverride : 1.0;
	    var webVRUniforms = {};
	    var webVRMatrices = {};
	    setupWebVR( worldFactor, HMD, webVRUniforms, webVRMatrices );
	
	    var rootViewMatrix = viewer.getCamera().getViewMatrix();
	
	    var root = rootOverride || new Node();
	    root.setUpdateCallback( new UpdateRecreateOnResize( viewer, rttScene, HMDconfig, root, canvas ) );
	
	    var rttTextureLeft = createTextureRtt( rttSize );
	    var rttCamLeft = createCameraRtt( rttTextureLeft, webVRMatrices.projectionLeft );
	    var orthoCameraLeft = createOrthoRtt( true, viewportSize, canvasSize, HMD.isCardboard, rttTextureLeft, webVRUniforms );
	    rttCamLeft.setUpdateCallback( new UpdateOffsetCamera( rootViewMatrix, webVRMatrices.viewLeft ) );
	
	    var rttTextureRight = createTextureRtt( rttSize );
	    var rttCamRight = createCameraRtt( rttTextureRight, webVRMatrices.projectionRight );
	    var orthoCameraRight = createOrthoRtt( false, viewportSize, canvasSize, HMD.isCardboard, rttTextureRight, webVRUniforms );
	    rttCamRight.setUpdateCallback( new UpdateOffsetCamera( rootViewMatrix, webVRMatrices.viewRight ) );
	
	    rttCamLeft.addChild( rttScene );
	    rttCamRight.addChild( rttScene );
	
	    orthoCameraLeft.addChild( Shape.createTexturedFullScreenFakeQuadGeometry() );
	    orthoCameraRight.addChild( Shape.createTexturedFullScreenFakeQuadGeometry() );
	
	    root.addChild( rttCamLeft );
	    root.addChild( rttCamRight );
	
	
	    root.addChild( orthoCameraLeft );
	    root.addChild( orthoCameraRight );
	
	    return root;
	};
	
	WebVRCustom.getDefaultConfig = function ( hmdConfig ) {
	    // FOV: 103.506416
	    // vScreenCenter: 0.03645
	
	    // Oculus Rift DK2
	    var hmd = {
	        hResolution: 1920,
	        vResolution: 1080,
	        hScreenSize: 0.1296,
	        vScreenSize: 0.0729,
	        interpupillaryDistance: 0.064,
	        lensSeparationDistance: 0.0635,
	        eyeToScreenDistance: 0.04,
	        distortionK: Vec4.createAndSet( 1.0, 0.22, 0.13, 0.02 ),
	        chromaAbParameter: Vec4.createAndSet( 0.996, -0.004, 1.014, 0.0 ),
	        isCardboard: false
	    };
	
	    if ( hmdConfig === 2 || hmdConfig === undefined )
	        return hmd;
	
	    if ( hmdConfig === 1 ) {
	        // Oculus Rift DK1
	        hmd.hResolution = 1280;
	        hmd.vResolution = 800;
	        hmd.hScreenSize = 0.14976;
	        hmd.vScreenSize = 0.0936;
	        hmd.lensSeparationDistance = 0.064;
	        hmd.eyeToScreenDistance = 0.041;
	        hmd.distortionK = Vec4.createAndSet( 1.0, 0.22, 0.24, 0.0 );
	        return hmd;
	    }
	
	    // custom param
	    if ( hmdConfig.hResolution !== undefined ) hmd.hResolution = hmdConfig.hResolution;
	    if ( hmdConfig.vResolution !== undefined ) hmd.vResolution = hmdConfig.vResolution;
	    if ( hmdConfig.hScreenSize !== undefined ) hmd.hScreenSize = hmdConfig.hScreenSize;
	    if ( hmdConfig.vScreenSize !== undefined ) hmd.vScreenSize = hmdConfig.vScreenSize;
	    if ( hmdConfig.interpupillaryDistance !== undefined ) hmd.interpupillaryDistance = hmdConfig.interpupillaryDistance;
	    if ( hmdConfig.lensSeparationDistance !== undefined ) hmd.lensSeparationDistance = hmdConfig.lensSeparationDistance;
	    if ( hmdConfig.eyeToScreenDistance !== undefined ) hmd.eyeToScreenDistance = hmdConfig.eyeToScreenDistance;
	    if ( hmdConfig.distortionK !== undefined ) hmd.distortionK = hmdConfig.distortionK;
	    if ( hmdConfig.chromaAbParameter !== undefined ) hmd.chromaAbParameter = hmdConfig.chromaAbParameter;
	    if ( hmdConfig.isCardboard !== undefined ) hmd.isCardboard = hmdConfig.isCardboard;
	
	    return hmd;
	};
	
	module.exports = WebVRCustom;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Camera = __webpack_require__( 56 );
	var FrameBufferObject = __webpack_require__( 68 );
	var Matrix = __webpack_require__( 23 );
	var Node = __webpack_require__( 12 );
	var Program = __webpack_require__( 100 );
	var Shader = __webpack_require__( 101 );
	var Shape = __webpack_require__( 102 );
	var Texture = __webpack_require__( 34 );
	var Transform = __webpack_require__( 11 );
	var Uniform = __webpack_require__( 35 );
	var Vec4 = __webpack_require__( 25 );
	var Viewport = __webpack_require__( 107 );
	var Composer = __webpack_require__( 155 );
	
	
	var UpdateRttCameraCallback = function ( rootView, offsetView ) {
	    this._rootView = rootView;
	    this._offsetView = offsetView;
	};
	
	UpdateRttCameraCallback.prototype = {
	    update: function ( node /*, nv */ ) {
	        var nodeView = node.getViewMatrix();
	        Matrix.mult( this._offsetView, this._rootView, nodeView );
	        return true;
	    }
	};
	
	var perspectiveMatrixFromVRFieldOfView = function ( fov, zNear, zFar ) {
	
	    var matrix = Matrix.create();
	
	    var degToRad = Math.PI / 180.0;
	    var upTan = Math.tan( fov.upDegrees * degToRad );
	    var downTan = Math.tan( fov.downDegrees * degToRad );
	    var leftTan = Math.tan( fov.leftDegrees * degToRad );
	    var rightTan = Math.tan( fov.rightDegrees * degToRad );
	
	    var xScale = 2.0 / ( leftTan + rightTan );
	    var yScale = 2.0 / ( upTan + downTan );
	
	    // http://mozvr.github.io/webvr-spec/webvr.html
	    // (with ndc normalized)
	    matrix[ 0 ] = xScale;
	    matrix[ 1 ] = 0.0;
	    matrix[ 2 ] = 0.0;
	    matrix[ 3 ] = 0.0;
	
	    matrix[ 4 ] = 0.0;
	    matrix[ 5 ] = yScale;
	    matrix[ 6 ] = 0.0;
	    matrix[ 7 ] = 0.0;
	
	    matrix[ 8 ] = -( ( leftTan - rightTan ) * xScale * 0.5 );
	    matrix[ 9 ] = ( ( upTan - downTan ) * yScale * 0.5 );
	    matrix[ 10 ] = -( zNear + zFar ) / ( zFar - zNear );
	    matrix[ 11 ] = -1.0;
	
	    matrix[ 12 ] = 0.0;
	    matrix[ 13 ] = 0.0;
	    matrix[ 14 ] = -( 2.0 * zFar * zNear ) / ( zFar - zNear );
	    matrix[ 15 ] = 0.0;
	
	    return matrix;
	};
	
	var createTexture = function ( size ) {
	    var texture = new Texture();
	    texture.setTextureSize( size.width, size.height );
	    texture.setMinFilter( 'LINEAR' );
	    texture.setMagFilter( 'LINEAR' );
	    return texture;
	};
	
	var getAssembleShader = function () {
	
	    var fragmentShader = [
	        '#ifdef GL_ES',
	        '   precision highp float;',
	        '#endif',
	        'varying vec2 FragTexCoord0;',
	        'uniform sampler2D TextureLeft;',
	        'uniform sampler2D TextureRight;',
	
	        'void main() {',
	        '   if (FragTexCoord0.x < 0.5)',
	        '       gl_FragColor = texture2D(TextureLeft, vec2(FragTexCoord0.x * 2.0, FragTexCoord0.y));',
	        '   else',
	        '       gl_FragColor = texture2D(TextureRight, vec2(FragTexCoord0.x * 2.0 - 1.0, FragTexCoord0.y));',
	        '}',
	    ].join( '\n' );
	
	    return new Program(
	        new Shader( Shader.VERTEX_SHADER, Composer.Filter.defaultVertexShader ),
	        new Shader( Shader.FRAGMENT_SHADER, fragmentShader )
	    );
	};
	
	// This camera will render both textures on the canvas in a single pass
	var createCameraCanvas = function ( leftEyeTexture, rightEyeTexture, viewport ) {
	
	    var orthoCamera = new Camera();
	    orthoCamera.setViewport( viewport );
	    orthoCamera.setRenderOrder( Camera.NESTED_RENDER, 0 );
	    orthoCamera.setReferenceFrame( Transform.ABSOLUTE_RF );
	    Matrix.makeOrtho( 0.0, 1.0, 0.0, 1.0, -5.0, 5.0, orthoCamera.getProjectionMatrix() );
	
	    var stateSet = orthoCamera.getOrCreateStateSet();
	    stateSet.addUniform( Uniform.createInt( 0, 'TextureLeft' ) );
	    stateSet.addUniform( Uniform.createInt( 1, 'TextureRight' ) );
	    stateSet.setTextureAttributeAndModes( 0, leftEyeTexture );
	    stateSet.setTextureAttributeAndModes( 1, rightEyeTexture );
	    stateSet.setAttributeAndModes( getAssembleShader() );
	
	    orthoCamera.addChild( Shape.createTexturedFullScreenFakeQuadGeometry() );
	
	    return orthoCamera;
	};
	
	// This camera will render the scene on a texture for an eye
	var createCameraRtt = function ( texture, projection ) {
	    var camera = new Camera();
	    camera.setName( 'rtt camera' );
	    camera.setViewport( new Viewport( 0.0, 0.0, texture.getWidth(), texture.getHeight() ) );
	    camera.setProjectionMatrix( projection );
	    camera.setClearColor( Vec4.createAndSet( 0.3, 0.3, 0.3, 0.0 ) );
	    camera.setRenderOrder( Camera.POST_RENDER, 0 );
	    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );
	    camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );
	    camera.setReferenceFrame( Transform.ABSOLUTE_RF );
	    return camera;
	};
	
	var WebVR = {};
	
	WebVR.createScene = function ( viewer, rttScene, HMDdevice, rootOverride, worldFactorOverride ) {
	
	    var root = rootOverride || new Node();
	    var worldFactor = worldFactorOverride !== undefined ? worldFactorOverride : 1.0;
	
	    var left = HMDdevice.getEyeParameters( 'left' );
	    var right = HMDdevice.getEyeParameters( 'right' );
	
	    // Compute projections and view matrices for both eyes
	    var projectionLeft = perspectiveMatrixFromVRFieldOfView( left.fieldOfView, 0.1, 1000.0 );
	    var projectionRight = perspectiveMatrixFromVRFieldOfView( right.fieldOfView, 0.1, 1000.0 );
	    var viewLeft = Matrix.makeTranslate( -worldFactor * left.offset[ 0 ], left.offset[ 1 ], left.offset[ 2 ], Matrix.create() );
	    var viewRight = Matrix.makeTranslate( -worldFactor * right.offset[ 0 ], right.offset[ 1 ], right.offset[ 2 ], Matrix.create() );
	
	    // Each eye is rendered on a texture whose width is half of the final combined texture
	    var eyeTextureSize = {
	        width: Math.max( left.renderWidth, right.renderWidth ),
	        height: Math.max( left.renderHeight, right.renderHeight )
	    };
	
	    var leftEyeTexture = createTexture( eyeTextureSize );
	    var rightEyeTexture = createTexture( eyeTextureSize );
	
	    // Setup the render cameras for both eyes
	    var camRttLeft = createCameraRtt( leftEyeTexture, projectionLeft );
	    var camRttRight = createCameraRtt( rightEyeTexture, projectionRight );
	
	    // The viewMatrix of each eye is updated with the current viewer's camera viewMatrix
	    var rootViewMatrix = viewer.getCamera().getViewMatrix();
	    camRttLeft.setUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, viewLeft ) );
	    camRttRight.setUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, viewRight ) );
	
	    // Render both textures on the canvas, using the viewer's camera viewport to render on the fullscreen canvas
	    var camCanvas = createCameraCanvas( leftEyeTexture, rightEyeTexture, viewer.getCamera().getViewport() );
	
	    camRttLeft.addChild( rttScene );
	    camRttRight.addChild( rttScene );
	
	    root.addChild( camRttLeft );
	    root.addChild( camRttRight );
	    root.addChild( camCanvas );
	
	    return root;
	};
	
	module.exports = WebVR;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Renderer = __webpack_require__( 204 );
	var View = __webpack_require__( 205 );
	var Viewer = __webpack_require__( 215 );
	var EventProxy = __webpack_require__( 218 );
	var Scene = __webpack_require__( 206 );
	
	
	var osgViewer = {};
	
	osgViewer.Renderer = Renderer;
	osgViewer.View = View;
	osgViewer.Viewer = Viewer;
	osgViewer.EventProxy = EventProxy;
	osgViewer.Scene = Scene;
	
	module.exports = osgViewer;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Matrix = __webpack_require__( 23 );
	var Options = __webpack_require__( 216 );
	var Timer = __webpack_require__( 9 );
	var UpdateVisitor = __webpack_require__( 106 );
	var MACROUTILS = __webpack_require__( 6 );
	var Texture = __webpack_require__( 34 );
	var OrbitManipulator = __webpack_require__( 134 );
	var createStats = __webpack_require__( 217 );
	var EventProxy = __webpack_require__( 218 );
	var View = __webpack_require__( 205 );
	var WebGLUtils = __webpack_require__( 33 );
	var WebGLDebugUtils = __webpack_require__( 226 );
	
	
	var OptionsURL = ( function () {
	    var options = {};
	    ( function ( options ) {
	        var vars = [],
	            hash;
	        if ( !window.location.search ) return;
	
	        // slice(1) to remove leading '?'
	        var hashes = window.location.search.slice( 1 ).split( '&' );
	        for ( var i = 0; i < hashes.length; i++ ) {
	            hash = hashes[ i ].split( '=' );
	            var element = hash[ 0 ];
	            vars.push( element );
	            var result = hash[ 1 ];
	            if ( result === undefined ) {
	                result = '1';
	            }
	            options[ element ] = result;
	        }
	    } )( options );
	
	    if ( options.log !== undefined ) {
	        var level = options.log.toLowerCase();
	
	        switch ( level ) {
	        case 'debug':
	            Notify.setNotifyLevel( Notify.DEBUG );
	            break;
	        case 'info':
	            Notify.setNotifyLevel( Notify.INFO );
	            break;
	        case 'notice':
	            Notify.setNotifyLevel( Notify.NOTICE );
	            break;
	        case 'warn':
	            Notify.setNotifyLevel( Notify.WARN );
	            break;
	        case 'error':
	            Notify.setNotifyLevel( Notify.ERROR );
	            break;
	        case 'html':
	            ( function () {
	                var logContent = [];
	                var divLogger = document.createElement( 'div' );
	                var codeElement = document.createElement( 'pre' );
	                document.addEventListener( 'DOMContentLoaded', function () {
	                    document.body.appendChild( divLogger );
	                    divLogger.appendChild( codeElement );
	                } );
	                var logFunc = function ( str ) {
	                    logContent.unshift( str );
	                    codeElement.innerHTML = logContent.join( '\n' );
	                };
	                divLogger.style.overflow = 'hidden';
	                divLogger.style.position = 'absolute';
	                divLogger.style.zIndex = '10000';
	                divLogger.style.height = '100%';
	                divLogger.style.maxWidth = '600px';
	                codeElement.style.overflow = 'scroll';
	                codeElement.style.width = '105%';
	                codeElement.style.height = '100%';
	                codeElement.style.fontSize = '10px';
	
	                [ 'log', 'error', 'warn', 'info', 'debug' ].forEach( function ( value ) {
	                    window.console[ value ] = logFunc;
	                } );
	            } )();
	            break;
	        }
	    }
	
	    return options;
	} )();
	
	
	var Viewer = function ( canvas, userOptions, error ) {
	    View.call( this );
	
	    this._startTick = Timer.instance().tick();
	    this._stats = undefined;
	    this._done = false;
	
	    var options = this.initOptions( userOptions );
	    var gl = this.initWebGLContext( canvas, options, error );
	
	    if ( !gl )
	        throw 'No WebGL implementation found';
	
	    // this MACROUTILS.init(); should be removed and replace by something
	    // more natural
	    MACROUTILS.init();
	
	    this.initDeviceEvents( options, canvas );
	    this.initStats( options, canvas );
	
	    this._updateVisitor = new UpdateVisitor();
	
	    this.setUpView( gl.canvas, options );
	
	    this._hmd = null;
	    this._requestAnimationFrame = window.requestAnimationFrame.bind( window );
	
	    this._contextLost = false;
	};
	
	
	Viewer.prototype = MACROUTILS.objectInherit( View.prototype, {
	
	    initDeviceEvents: function ( options, canvas ) {
	
	        // default argument for mouse binding
	        var defaultMouseEventNode = options.mouseEventNode || canvas;
	
	        var eventsBackend = options.EventBackend || {};
	        if ( !options.EventBackend ) options.EventBackend = eventsBackend;
	        eventsBackend.StandardMouseKeyboard = options.EventBackend.StandardMouseKeyboard || {};
	        var mouseEventNode = eventsBackend.StandardMouseKeyboard.mouseEventNode || defaultMouseEventNode;
	        eventsBackend.StandardMouseKeyboard.mouseEventNode = mouseEventNode;
	        eventsBackend.StandardMouseKeyboard.keyboardEventNode = eventsBackend.StandardMouseKeyboard.keyboardEventNode || document;
	
	        // hammer, Only activate it if we have a touch device in order to fix problems with IE11
	        if ( 'ontouchstart' in window ) {
	            eventsBackend.Hammer = eventsBackend.Hammer || {};
	            eventsBackend.Hammer.eventNode = eventsBackend.Hammer.eventNode || defaultMouseEventNode;
	        }
	        // gamepad
	        eventsBackend.GamePad = eventsBackend.GamePad || {};
	
	        this._eventProxy = this.initEventProxy( options );
	    },
	
	    initOptions: function ( userOptions ) {
	        // use default options
	        var options = new Options();
	
	        if ( userOptions ) {
	            // user options override by user options
	            options.extend( userOptions );
	        }
	
	        // if url options override url options
	        options.extend( OptionsURL );
	
	
	        // Check if Frustum culling is enabled to calculate the clip planes
	        if ( options.getBoolean( 'enableFrustumCulling' ) === true )
	            this.getCamera().getRenderer().getCullVisitor().setEnableFrustumCulling( true );
	
	
	        return options;
	    },
	
	    initWebGLContext: function ( canvas, options, error ) {
	
	        // #FIXME see tojiro's blog for webgl lost context stuffs
	        if ( options.get( 'SimulateWebGLLostContext' ) ) {
	            canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas( canvas );
	            canvas.loseContextInNCalls( options.get( 'SimulateWebGLLostContext' ) );
	        }
	
	        var gl = WebGLUtils.setupWebGL( canvas, options, error );
	
	        canvas.addEventListener( 'webglcontextlost', function ( event ) {
	            this.contextLost();
	            event.preventDefault();
	        }.bind( this ), false );
	
	        canvas.addEventListener( 'webglcontextrestored', function () {
	            this.contextRestored();
	        }.bind( this ), false );
	
	        if ( Notify.reportWebGLError || options.get( 'reportWebGLError' ) ) {
	            gl = WebGLDebugUtils.makeDebugContext( gl );
	        }
	
	        this.initWebGLCaps( gl );
	        this.setGraphicContext( gl );
	
	        return gl;
	    },
	
	    setContextLostCallback: function ( cb ) {
	        this._contextLostCallback = cb;
	        // just in case callback registration
	        // happens after the context lost 
	        if ( this._contextLost ) {
	            cb();
	        }
	    },
	
	    contextLost: function () {
	        Notify.log( 'webgl context lost' );
	        if ( this._contextLostCallback ) {
	            this._contextLostCallback();
	        }
	        this._contextLost = true;
	        window.cancelAnimationFrame( this._requestID );
	    },
	
	    contextRestored: function () {
	        Notify.log( 'webgl context restored, but not supported - reload the page' );
	        // Supporting it implies to have
	        // reloaded all your resources:
	        // textures, vertex/index buffers, shaders, frame buffers
	        // so only set it back if you happen to have restored the context
	        // this._contextLost = false;
	    },
	
	    init: function () {
	        //this._done = false;
	    },
	
	    getUpdateVisitor: function () {
	        return this._updateVisitor;
	    },
	
	    getState: function () {
	        return this.getCamera().getRenderer().getState();
	    },
	
	    initStats: function ( options ) {
	
	        if ( !options.getBoolean( 'stats' ) )
	            return;
	
	        this._stats = createStats();
	    },
	
	    getViewerStats: function () {
	        return this._stats;
	    },
	
	    renderingTraversal: function () {
	
	        if ( this.getScene().getSceneData() )
	            this.getScene().getSceneData().getBound();
	
	
	        if ( this.getCamera() ) {
	
	            var stats = this._stats;
	            var renderer = this.getCamera().getRenderer();
	
	            if ( stats ) stats.rStats( 'cull' ).start();
	            renderer.cull();
	            if ( stats ) stats.rStats( 'cull' ).end();
	
	            if ( stats ) stats.rStats( 'render' ).start();
	            renderer.draw();
	            if ( stats ) stats.rStats( 'render' ).end();
	
	            if ( stats ) {
	                var cullVisitor = renderer.getCullVisitor();
	                stats.rStats( 'cullcamera' ).set( cullVisitor._numCamera );
	                stats.rStats( 'cullmatrixtransform' ).set( cullVisitor._numMatrixTransform );
	                stats.rStats( 'cullprojection' ).set( cullVisitor._numProjection );
	                stats.rStats( 'cullnode' ).set( cullVisitor._numNode );
	                stats.rStats( 'cullightsource' ).set( cullVisitor._numLightSource );
	                stats.rStats( 'cullgeometry' ).set( cullVisitor._numGeometry );
	
	                stats.rStats( 'pushstateset' ).set( renderer.getState()._numPushStateSet );
	            }
	
	        }
	
	    },
	
	
	    updateTraversal: function () {
	
	        var stats = this._stats;
	
	        if ( stats ) stats.rStats( 'update' ).start();
	
	        // update the scene
	        this._updateVisitor.resetStats();
	        this.getScene().updateSceneGraph( this._updateVisitor );
	
	        if ( stats ) stats.rStats( 'updatecallback' ).set( this._updateVisitor._numUpdateCallback );
	
	        // Remove ExpiredSubgraphs from DatabasePager
	        this.getDatabasePager().releaseGLExpiredSubgraphs( 0.005 );
	        // In OSG this.is deferred until the draw traversal, to handle multiple contexts
	        this.flushDeletedGLObjects( 0.005 );
	
	        if ( stats ) stats.rStats( 'update' ).end();
	
	    },
	
	    advance: function ( simulationTime ) {
	
	        var sTime = simulationTime;
	
	        if ( sTime === undefined )
	            sTime = Number.MAX_VALUE;
	
	        var frameStamp = this._frameStamp;
	        var previousFrameNumber = frameStamp.getFrameNumber();
	
	        frameStamp.setFrameNumber( previousFrameNumber + 1 );
	
	        var deltaS = Timer.instance().deltaS( this._startTick, Timer.instance().tick() );
	        frameStamp.setReferenceTime( deltaS );
	
	        var lastSimulationTime = frameStamp.getSimulationTime();
	        frameStamp.setSimulationTime( sTime === Number.MAX_VALUE ? deltaS : sTime ); // set simul time
	        frameStamp.setDeltaTime( frameStamp.getSimulationTime() - lastSimulationTime ); // compute delta since last tick
	
	    },
	
	    beginFrame: function () {
	
	        var stats = this._stats;
	
	        if ( stats ) stats.rStats( 'frame' ).start();
	        if ( stats ) stats.glS.start();
	
	        if ( stats ) stats.rStats( 'rAF' ).tick();
	        if ( stats ) stats.rStats( 'FPS' ).frame();
	
	    },
	
	    endFrame: function () {
	
	        var frameNumber = this.getFrameStamp().getFrameNumber();
	
	        var stats = this._stats;
	        var rStats = stats ? stats.rStats : undefined;
	
	        // update texture stats
	        if ( rStats ) {
	            Texture.getTextureManager( this.getGraphicContext() ).updateStats( frameNumber, rStats );
	        }
	
	        if ( rStats ) rStats( 'frame' ).end();
	
	        if ( rStats ) rStats( 'rStats' ).start();
	        if ( rStats ) rStats().update();
	        if ( rStats ) rStats( 'rStats' ).end();
	
	    },
	
	    checkNeedToDoFrame: function () {
	        return this._requestContinousUpdate || this._requestRedraw;
	    },
	
	    frame: function () {
	
	        // _contextLost check for code calling viewer::frame directly
	        // (likely force preload gl resource or direct render control )
	        if ( this._contextLost ) return;
	
	        this.beginFrame();
	
	        this.advance();
	
	        // update viewport if a resize occured
	        var canvasSizeChanged = this.updateViewport();
	
	        // update inputs devices
	        this.updateEventProxy( this._eventProxy, this.getFrameStamp() );
	
	        // setup framestamp
	        this._updateVisitor.setFrameStamp( this.getFrameStamp() );
	        // Update Manipulator/Event
	        if ( this.getManipulator() ) {
	            this.getManipulator().update( this._updateVisitor );
	            Matrix.copy( this.getManipulator().getInverseMatrix(), this.getCamera().getViewMatrix() );
	        }
	
	        if ( this.checkNeedToDoFrame() || canvasSizeChanged ) {
	            this._requestRedraw = false;
	            this.updateTraversal();
	            this.renderingTraversal();
	        }
	
	        this.endFrame();
	
	        // submit frame to vr headset
	        if ( this._hmd && this._hmd.isPresenting )
	            this._hmd.submitFrame( this._eventProxy.WebVR._lastPose );
	    },
	
	    setDone: function ( bool ) {
	        this._done = bool;
	    },
	
	    done: function () {
	        return this._done;
	    },
	
	    run: function () {
	        var self = this;
	        var render = function () {
	            if ( !self.done() ) {
	                self._requestID = self._requestAnimationFrame( render, self.getGraphicContext().canvas );
	                self.frame();
	            }
	        };
	        render();
	    },
	
	    setVRDisplay: function ( hmd ) {
	        this._hmd = hmd;
	        this._requestAnimationFrame = hmd.requestAnimationFrame.bind( hmd );
	    },
	
	    getVRDisplay: function () {
	        return this._hmd;
	    },
	
	    setPresentVR: function ( bool ) {
	        if ( !this._hmd ) {
	            Notify.warn( 'no hmd device provided to the viewer!' );
	            return;
	        }
	
	        // reset position/orientation of hmd device
	        if ( !this._hmd.capabilities.hasPosition )
	            this._hmd.resetPose();
	
	        if ( !this._hmd.capabilities.canPresent )
	            return;
	
	        if ( bool ) {
	            var layers = [ {
	                source: this.getGraphicContext().canvas
	            } ];
	            this._hmd.requestPresent( layers );
	
	        } else {
	            this._hmd.exitPresent();
	        }
	    },
	
	    setupManipulator: function ( manipulator /*, dontBindDefaultEvent */ ) {
	        if ( manipulator === undefined ) {
	            manipulator = new OrbitManipulator();
	        }
	
	        if ( manipulator.setNode !== undefined ) {
	            manipulator.setNode( this.getSceneData() );
	        } else {
	            // for backward compatibility
	            manipulator.view = this;
	        }
	
	        manipulator.setCamera( this.getCamera() );
	        this.setManipulator( manipulator );
	    },
	
	
	    // updateViewport
	    updateViewport: function () {
	
	        var gl = this.getGraphicContext();
	        var canvas = gl.canvas;
	
	        var hasChanged = this.computeCanvasSize( canvas );
	        if ( !hasChanged )
	            return false;
	
	        var camera = this.getCamera();
	        var vp = camera.getViewport();
	
	        var prevWidth = vp.width();
	        var prevHeight = vp.height();
	
	        var widthChangeRatio = canvas.width / prevWidth;
	        var heightChangeRatio = canvas.height / prevHeight;
	        var aspectRatioChange = widthChangeRatio / heightChangeRatio;
	        vp.setViewport( vp.x() * widthChangeRatio, vp.y() * heightChangeRatio, vp.width() * widthChangeRatio, vp.height() * heightChangeRatio );
	
	        if ( aspectRatioChange !== 1.0 ) {
	            Matrix.preMult( camera.getProjectionMatrix(), Matrix.makeScale( 1.0 / aspectRatioChange, 1.0, 1.0, Matrix.create() ) );
	        }
	
	        return true;
	    },
	
	    // intialize all input devices
	    initEventProxy: function ( argsObject ) {
	        var args = argsObject || {};
	        var deviceEnabled = {};
	
	        var lists = EventProxy;
	        var argumentEventBackend = args.EventBackend;
	
	
	        // loop on each devices and try to initialize it
	        var keys = window.Object.keys( lists );
	        for ( var i = 0, l = keys.length; i < l; i++ ) {
	            var device = keys[ i ];
	
	            // check if the config has a require
	            var initialize = true;
	            var argDevice = {};
	            if ( argumentEventBackend && ( argumentEventBackend[ device ] !== undefined ) ) {
	                var bool = argumentEventBackend[ device ].enable;
	                initialize = bool !== undefined ? bool : true;
	                argDevice = argumentEventBackend[ device ];
	            }
	
	            // extend argDevice with regular options eg:
	            // var options = {
	            //     EventBackend: {
	            //         Hammer: {
	            //             drag_max_touches: 4,
	            //             transform_min_scale: 0.08,
	            //             transform_min_rotation: 180,
	            //             transform_always_block: true
	            //         }
	            //     },
	            //     zoomscroll: false
	            // };
	
	            // to options merged:
	            // var options = {
	            //     drag_max_touches: 4,
	            //     transform_min_scale: 0.08,
	            //     transform_min_rotation: 180,
	            //     transform_always_block: true,
	            //     zoomscroll: false
	            // };
	            //
	            var options = new Options();
	            options.extend( argDevice ).extend( argsObject );
	            delete options.EventBackend;
	
	            if ( initialize ) {
	                var inputDevice = new lists[ device ]( this );
	                inputDevice.init( options );
	                deviceEnabled[ device ] = inputDevice;
	            }
	        }
	        return deviceEnabled;
	    },
	    updateEventProxy: function ( list, frameStamp ) {
	        var keys = window.Object.keys( list );
	        keys.forEach( function ( key ) {
	            var device = list[ key ];
	            if ( device.update )
	                device.update( frameStamp );
	        } );
	    },
	
	    setManipulator: function ( manipulator ) {
	
	        if ( this._manipulator )
	            this.removeEventProxy();
	
	        if ( !manipulator.getCamera() )
	            manipulator.setCamera( this.getCamera() );
	
	        View.prototype.setManipulator.call( this, manipulator );
	    },
	
	    removeEventProxy: function () {
	        var list = this._eventProxy;
	        var keys = window.Object.keys( list );
	        keys.forEach( function ( key ) {
	            var device = list[ key ];
	            if ( device.remove )
	                device.remove();
	        } );
	    },
	
	    getEventProxy: function () {
	        return this._eventProxy;
	    }
	
	} );
	
	module.exports = Viewer;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	
	var OptionsDefault = {
	    'antialias': true, // activate MSAA
	    //'overrideDevicePixelRatio': 1, // if specified override the device pixel ratio
	    'fullscreen': true,
	    'enableFrustumCulling': false,
	    'stats': false, // display canvas with stats for the viewer
	    'scrollwheel': true,
	    'webgl2': false
	};
	
	var Options = function () {
	
	    window.Object.keys( OptionsDefault ).forEach( function ( key ) {
	        this[ key ] = OptionsDefault[ key ];
	    }.bind( this ) );
	
	};
	
	
	Options.prototype = {
	
	    extend: function ( options ) {
	        MACROUTILS.objectMix( this, options );
	        return this;
	    },
	
	    get: function ( key ) {
	        return this[ key ];
	    },
	
	    getBoolean: function ( key ) {
	        var val = this.getString( key );
	        if ( val ) return ( val !== 'false' && val !== '0' );
	        return undefined;
	    },
	
	    getNumber: function ( key ) {
	        var val = this[ key ];
	        if ( val ) return Number( val );
	        return undefined;
	    },
	
	    getString: function ( key ) {
	        var val = this[ key ];
	        if ( val !== undefined ) return this[ key ].toString();
	        return undefined;
	    }
	
	};
	
	module.exports = Options;


/***/ }),
/* 217 */
/***/ (function(module, exports) {

	'use strict';
	
	var BrowserStats = window.BrowserStats;
	var glStats = window.glStats;
	var rStats = window.rStats;
	
	var CanvasStats = function () {
	
	    this.bS = new BrowserStats();
	    this.glS = new glStats();
	
	    this.rStats = new rStats( {
	        values: {
	            frame: {
	                caption: 'Total frame time (ms)',
	                over: 16,
	                average: true
	            },
	            fps: {
	                caption: 'Framerate (FPS)',
	                below: 30
	            },
	            calls: {
	                caption: 'Calls (three.js)',
	                over: 3000
	            },
	            raf: {
	                caption: 'Time since last rAF (ms)',
	                average: true,
	                avgMs: 500
	            },
	            rstats: {
	                caption: 'rStats update (ms)',
	                average: true,
	                avgMs: 100
	            },
	            update: {
	                caption: 'update',
	                average: true
	            },
	            cull: {
	                caption: 'cull',
	                average: true
	            },
	            render: {
	                caption: 'render',
	                average: true
	            },
	            textureused: {
	                caption: 'texture used'
	            },
	            texturereserved: {
	                caption: 'texture reserved'
	            },
	            texturetotal: {
	                caption: 'texture total'
	            },
	
	            pushstateset: {
	                caption: 'num pushStateSet'
	            },
	            updatecallback: {
	                caption: 'num updateCallback'
	            },
	
	            cullcamera: {
	                caption: 'camera'
	            },
	            cullmatrixtransform: {
	                caption: 'matrixTransform'
	            },
	            cullprojection: {
	                caption: 'projection'
	            },
	            cullnode: {
	                caption: 'node'
	            },
	            culllightsource: {
	                caption: 'lightSource'
	            },
	            cullgeometry: {
	                caption: 'geometry'
	            }
	
	        },
	        groups: [ {
	            caption: 'Framerate',
	            values: [ 'fps', 'raf' ]
	        }, {
	            caption: 'Frame Budget',
	            values: [ 'frame', 'update', 'cull', 'render' ]
	        }, {
	            caption: 'Scene Graph',
	            values: [ 'pushstateset', 'updatecallback' ]
	        }, {
	            caption: 'Cull',
	            values: [ 'cullnode', 'cullmatrixtransform', 'cullgeometry', 'cullcamera', 'culllighsource', 'cullprojection' ]
	        }, {
	            caption: 'Texture Memory',
	            values: [ 'texturereserved', 'textureused', 'texturetotal' ]
	        } ],
	        fractions: [ {
	            base: 'frame',
	            steps: [ 'update', 'cull', 'render' ]
	        } ],
	        plugins: [
	            this.bS,
	            this.glS
	        ],
	        colours: [ '#cc9933', '#f20041', '#69818c', '#d90074', '#b6f2ee', '#660044', '#50664d', '#330022', '#f2eeb6', '#ee00ff', '#806460', '#1600a6', '#994d57', '#00004d', '#f279da', '#002933', '#395073', '#00eeff', '#79baf2', '#008066', '#79f2aa', '#00ff66', '#1a331d', '#004d14', '#8c6c46', '#388c00', '#602080', '#ff8800', '#6d3df2', '#995200', '#0d1233', '#402200', '#3d6df2', '#330e00', '#e6f23d', '#730000' ]
	    } );
	
	};
	
	var createStats = function () {
	    // in case the deps are not here
	    if ( !rStats ) return undefined;
	
	
	    var css = '.rs-base{ position: absolute; z-index: 10000; padding: 10px; background-color: #222; font-size: 12px; line-height: 1.2em; width: 350px; font-family: \'Roboto Condensed\', tahoma, sans-serif; left: 0; top: 0; overflow: hidden; } .rs-base h1{ margin: 0; padding: 0; font-size: 1.4em; color: #fff; margin-bottom: 5px; cursor: pointer; } .rs-base div.rs-group{ margin-bottom: 10px; } .rs-base div.rs-group.hidden{ display: none; } .rs-base div.rs-fraction{ position: relative; margin-bottom: 5px; } .rs-base div.rs-fraction p{ width: 145px; text-align: right; margin: 0; padding: 0; } .rs-base div.rs-legend{ position: absolute; line-height: 1em; } .rs-base div.rs-counter-base{ position: relative; margin: 2px 0; height: 1em; } .rs-base span.rs-counter-id{ position: absolute; left: 0; top: 0; } .rs-base div.rs-counter-value{ position: absolute; left: 115px; width: 30px; height: 1em; top: 0; text-align: right; } .rs-base canvas.rs-canvas{ position: absolute; right: 0; } ',
	        head = document.head || document.getElementsByTagName( 'head' )[ 0 ],
	        style = document.createElement( 'style' );
	
	    style.type = 'text/css';
	    if ( style.styleSheet ) {
	        style.styleSheet.cssText = css;
	    } else {
	        style.appendChild( document.createTextNode( css ) );
	    }
	    head.appendChild( style );
	
	    return new CanvasStats();
	};
	
	module.exports = createStats;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var GamePad = __webpack_require__( 219 );
	var HammerOsg = __webpack_require__( 220 );
	var LeapMotion = __webpack_require__( 221 );
	var StandardMouseKeyboard = __webpack_require__( 223 );
	var WebVR = __webpack_require__( 224 );
	var DeviceOrientation = __webpack_require__( 225 );
	
	module.exports = {
	    GamePad: GamePad,
	    Hammer: HammerOsg,
	    LeapMotion: LeapMotion,
	    StandardMouseKeyboard: StandardMouseKeyboard,
	    WebVR: WebVR,
	    DeviceOrientation: DeviceOrientation
	};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	
	
	var GamePad = function ( viewer ) {
	    this._viewer = viewer;
	    this._type = 'GamePad';
	    this._enable = true;
	    this._gamepadIndex = -1;
	};
	
	GamePad.prototype = {
	
	    setEnable: function ( bool ) {
	        this._enable = bool;
	    },
	
	    getEnable: function () {
	        return this._enable;
	    },
	
	    init: function ( /*args*/) {},
	
	    isValid: function () {
	        if ( !this._enable )
	            return false;
	
	        var manipulator = this._viewer.getManipulator();
	        if ( !manipulator )
	            return false;
	
	        var constrollerList = manipulator.getControllerList();
	        if ( !constrollerList[ this._type ] )
	            return false;
	
	        return true;
	    },
	
	    getManipulatorController: function () {
	        return this._viewer.getManipulator().getControllerList()[ this._type ];
	    },
	
	    gamepadPoll: function () {
	        if ( !navigator.getGamepads )
	            return null;
	        var gamepads = navigator.getGamepads();
	        var gamepad = gamepads[ this._gamepadIndex ];
	        if ( gamepad )
	            return gamepad;
	
	        for ( var i = 0, nb = gamepads.length; i < nb; ++i ) {
	            var gm = gamepads[ i ];
	            // https://code.google.com/p/chromium/issues/detail?id=413805
	            if ( gm && gm.id && gm.id.indexOf( 'Unknown Gamepad' ) === -1 ) {
	                this._gamepadIndex = i;
	                this.onGamepadConnect( gm );
	                return gm;
	            }
	        }
	        if ( this._gamepadIndex >= 0 ) {
	            this._gamepadIndex = -1;
	            this.onGamepadConnect();
	        }
	        return null;
	    },
	
	    onGamepadConnect: function ( gamepad ) {
	        Notify.log( 'Detected new gamepad!', gamepad );
	    },
	
	    onGamepadDisconnect: function () {
	        Notify.log( 'Gamepad disconnected' );
	    },
	
	    // Called in each frame
	    update: function () {
	        // we poll instead
	
	        if ( !this.isValid() )
	            return;
	
	        var gamepad = this.gamepadPoll();
	        if ( !gamepad )
	            return;
	
	        var manipulatorAdapter = this.getManipulatorController();
	        //manipulatorAdapter.setEventProxy(this);
	        if ( manipulatorAdapter.update ) {
	            manipulatorAdapter.update( gamepad );
	        }
	    }
	};
	module.exports = GamePad;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Hammer = __webpack_require__( 131 );
	
	
	var HammerController = function ( viewer ) {
	    this._enable = true;
	    this._viewer = viewer;
	    this._type = 'Hammer';
	
	    this._eventNode = undefined;
	
	};
	
	HammerController.prototype = {
	
	    setEnable: function ( bool ) {
	        this._enable = bool;
	    },
	
	    getEnable: function () {
	        return this._enable;
	    },
	
	    init: function ( options ) {
	
	        /*jshint camelcase: false */
	
	        var deviceOptions = {
	            prevent_default: true,
	            drag_max_touches: 2,
	            transform_min_scale: 0.08,
	            transform_min_rotation: 180,
	            transform_always_block: true,
	            hold: false,
	            release: false,
	            swipe: false,
	            tap: false
	        };
	        /*jshint camelcase: true */
	
	        this._eventNode = options.eventNode;
	
	        if ( this._eventNode ) {
	
	            this._hammer = new Hammer( this._eventNode, deviceOptions );
	
	            if ( options.getBoolean( 'scrollwheel' ) === false )
	                this._hammer.get( 'pinch' ).set( {
	                    enable: false
	                } );
	            else
	                this._hammer.get( 'pinch' ).set( {
	                    enable: true
	                } );
	
	        }
	    },
	
	    isValid: function () {
	        if ( this._enable && this._viewer.getManipulator() && this._viewer.getManipulator().getControllerList()[ this._type ] )
	            return true;
	        return false;
	    },
	    getManipulatorController: function () {
	        return this._viewer.getManipulator().getControllerList()[ this._type ];
	    },
	
	    // use the update to set the input device to mouse controller
	    // it's needed to compute size
	    update: function () {
	        if ( !this.isValid() )
	            return;
	
	        // we pass directly hammer object
	        this.getManipulatorController().setEventProxy( this._hammer );
	    },
	    remove: function () {
	        if ( !this.isValid() )
	            return;
	        this.getManipulatorController().removeEventProxy( this._hammer );
	    }
	
	};
	module.exports = HammerController;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Leap = __webpack_require__( 222 );
	var Notify = __webpack_require__( 10 );
	
	var LeapMotion = function ( viewer ) {
	    this._viewer = viewer;
	    this._type = 'LeapMotion';
	    this._enable = true;
	};
	
	LeapMotion.prototype = {
	
	    setEnable: function ( bool ) {
	        this._enable = bool;
	    },
	
	    getEnable: function () {
	        return this._enable;
	    },
	
	    init: function ( args ) {
	
	        // add condition if no leap in global space
	        if ( typeof Leap === 'undefined' || !Leap.Controller )
	            return;
	
	        var self = this;
	        this._controller = new Leap.Controller( {
	            enableGestures: args.gestures || true,
	            tryReconnectOnDisconnect: true,
	            connectAttempts: 3
	        } );
	        this._controller.on( 'ready', function () {
	            if ( args.readyCallback )
	                args.readyCallback( self._controller );
	            self._leapMotionReady = true;
	            Notify.info( 'leapmotion ready' );
	        } );
	        this._controller.loop( this._update.bind( this ) );
	    },
	
	    isValid: function () {
	        if ( !this._enable )
	            return false;
	
	        var manipulator = this._viewer.getManipulator();
	        if ( !manipulator )
	            return false;
	
	        var constrollerList = manipulator.getControllerList();
	        if ( !constrollerList[ this._type ] )
	            return false;
	
	        return true;
	    },
	    getManipulatorController: function () {
	        return this._viewer.getManipulator().getControllerList()[ this._type ];
	    },
	
	    // this is binded
	    _update: function ( frame ) {
	        if ( !frame.valid || !this.isValid() ) {
	            return;
	        }
	        var manipulatorAdapter = this.getManipulatorController();
	        if ( manipulatorAdapter.update ) {
	            manipulatorAdapter.update( frame );
	        }
	    }
	};
	module.exports = LeapMotion;


/***/ }),
/* 222 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_222__;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Vec2 = __webpack_require__( 70 );
	
	
	var StandardMouseKeyboard = function ( viewer ) {
	    this._enable = true;
	    this._viewer = viewer;
	    this._type = 'StandardMouseKeyboard';
	
	    this._mouseEventNode = undefined;
	    this._wheelEventNode = undefined;
	    this._keyboardEventNode = undefined;
	    this._eventList = [ 'mousedown', 'mouseup', 'mouseout', 'mousemove', 'dblclick' ];
	    this._mousePosition = Vec2.create();
	};
	
	StandardMouseKeyboard.prototype = {
	
	    setEnable: function ( bool ) {
	        this._enable = bool;
	    },
	
	    getEnable: function () {
	        return this._enable;
	    },
	
	    init: function ( options ) {
	
	        this.removeEventListeners( this._mouseEventNode, this._wheelEventNode, this._keyboardEventNode );
	
	        var mouse = options.mouseEventNode;
	
	        var mousewheel = options.wheelEventNode || mouse;
	        var keyboard = options.keyboardEventNode || mouse;
	
	        if ( options.getBoolean( 'scrollwheel' ) === false )
	            mousewheel = null;
	
	        this.addEventListeners( mouse, mousewheel, keyboard );
	        this._mouseEventNode = mouse;
	        this._wheelEventNode = mousewheel;
	        this._keyboardEventNode = keyboard;
	    },
	
	    addEventListeners: function ( mouse, mousewheel, keyboard ) {
	        if ( mouse ) {
	            for ( var i = 0, l = this._eventList.length; i < l; i++ ) {
	                var ev = this._eventList[ i ];
	                if ( this[ ev ] ) {
	                    mouse.addEventListener( ev, this[ ev ].bind( this ), false );
	                }
	            }
	        }
	        if ( mousewheel ) {
	            mousewheel.addEventListener( 'DOMMouseScroll', this.mousewheel.bind( this ), false );
	            mousewheel.addEventListener( 'mousewheel', this.mousewheel.bind( this ), false );
	            mousewheel.addEventListener( 'MozMousePixelScroll', this.preventDefault.bind( this ), false );
	        }
	
	        if ( keyboard ) {
	            keyboard.addEventListener( 'keydown', this.keydown.bind( this ), false );
	            keyboard.addEventListener( 'keyup', this.keyup.bind( this ), false );
	        }
	    },
	
	    removeEventListeners: function ( mouse, mousewheel, keyboard ) {
	        if ( mouse ) {
	            for ( var i = 0, l = this._eventList.length; i < l; i++ ) {
	                var ev = this._eventList[ i ];
	                if ( this[ ev ] ) {
	                    mouse.removeEventListener( ev, this[ ev ] );
	                }
	            }
	        }
	        if ( mousewheel ) {
	            mousewheel.removeEventListener( 'DOMMouseScroll', this.mousewheel );
	            mousewheel.removeEventListener( 'mousewheel', this.mousewheel );
	            mousewheel.removeEventListener( 'MozMousePixelScroll', this.preventDefault );
	        }
	        if ( keyboard ) {
	            keyboard.removeEventListener( 'keydown', this.keydown );
	            keyboard.removeEventListener( 'keyup', this.keyup );
	        }
	    },
	
	    isValid: function () {
	        if ( this._enable && this._viewer.getManipulator() && this._viewer.getManipulator().getControllerList()[ this._type ] )
	            return true;
	        return false;
	    },
	    getManipulatorController: function () {
	        return this._viewer.getManipulator().getControllerList()[ this._type ];
	    },
	
	    keyup: function ( ev ) {
	
	        if ( this.isValid() && this.getManipulatorController().keyup )
	            return this.getManipulatorController().keyup( ev );
	
	        return undefined;
	    },
	
	    keydown: function ( ev ) {
	
	        if ( this.isValid() && this.getManipulatorController().keydown )
	            return this.getManipulatorController().keydown( ev );
	
	        return undefined;
	    },
	
	    mousedown: function ( ev ) {
	
	        if ( this.isValid() && this.getManipulatorController().mousedown )
	            return this.getManipulatorController().mousedown( ev );
	
	        return undefined;
	    },
	
	    mouseup: function ( ev ) {
	
	        if ( this.isValid() && this.getManipulatorController().mouseup )
	            return this.getManipulatorController().mouseup( ev );
	
	        return undefined;
	    },
	
	    mouseout: function ( ev ) {
	
	        if ( this.isValid() && this.getManipulatorController().mouseout )
	            return this.getManipulatorController().mouseout( ev );
	
	        return undefined;
	    },
	
	    mousemove: function ( ev ) {
	
	        if ( this.isValid() && this.getManipulatorController().mousemove )
	            return this.getManipulatorController().mousemove( ev );
	
	        return undefined;
	    },
	
	    dblclick: function ( ev ) {
	
	        if ( this.isValid() && this.getManipulatorController().dblclick )
	            return this.getManipulatorController().dblclick( ev );
	
	        return undefined;
	    },
	
	    mousewheel: function ( event ) {
	
	        if ( !this.isValid() )
	            return undefined;
	
	        var manipulatorAdapter = this.getManipulatorController();
	
	        if ( !manipulatorAdapter.mousewheel )
	            return undefined;
	
	        // from jquery
	        var orgEvent = event || window.event,
	            args = [].slice.call( arguments, 1 ),
	            delta = 0,
	            deltaX = 0,
	            deltaY = 0;
	
	        // Old school scrollwheel delta
	        if ( event.wheelDelta ) {
	            delta = event.wheelDelta / 120;
	        }
	        if ( event.detail ) {
	            delta = -event.detail / 3;
	        }
	
	        // New school multidimensional scroll (touchpads) deltas
	        deltaY = delta;
	
	        // Gecko
	        if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
	            deltaY = 0;
	            deltaX = -1 * delta;
	        }
	
	        // Webkit
	        if ( orgEvent.wheelDeltaY !== undefined ) {
	            deltaY = orgEvent.wheelDeltaY / 120;
	        }
	        if ( orgEvent.wheelDeltaX !== undefined ) {
	            deltaX = -1 * orgEvent.wheelDeltaX / 120;
	        }
	        // Add event and delta to the front of the arguments
	        args.unshift( event, delta, deltaX, deltaY );
	
	        return this.getManipulatorController().mousewheel.apply( manipulatorAdapter, args );
	    },
	
	    preventDefault: function ( event ) {
	        event.preventDefault();
	    },
	
	    divGlobalOffset: function ( obj ) {
	        var x = 0,
	            y = 0;
	        x = obj.offsetLeft;
	        y = obj.offsetTop;
	        var body = document.getElementsByTagName( 'body' )[ 0 ];
	        while ( obj.offsetParent && obj !== body ) {
	            x += obj.offsetParent.offsetLeft;
	            y += obj.offsetParent.offsetTop;
	            obj = obj.offsetParent;
	        }
	        this._mousePosition[ 0 ] = x;
	        this._mousePosition[ 1 ] = y;
	        return this._mousePosition;
	    },
	
	    getPositionRelativeToCanvas: function ( e, result ) {
	        var myObject = e.target;
	        var posx, posy;
	        if ( e.pageX || e.pageY ) {
	            posx = e.pageX;
	            posy = e.pageY;
	        } else if ( e.clientX || e.clientY ) {
	            posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
	            posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
	        }
	
	        // posx and posy contain the mouse position relative to the document
	        // Do something with this information
	        var globalOffset = this.divGlobalOffset( myObject );
	        posx = posx - globalOffset[ 0 ];
	        posy = myObject.height - ( posy - globalOffset[ 1 ] );
	
	        // copy data to result if need to keep result
	        // else we use a tmp variable inside manipulator
	        // that we override at each call
	        if ( result === undefined ) {
	            result = this._mousePosition;
	        }
	        result[ 0 ] = posx;
	        result[ 1 ] = posy;
	        return result;
	    },
	
	    // use the update to set the input device to mouse controller
	    // it's needed to compute size
	    update: function () {
	        if ( !this.isValid() )
	            return;
	
	        this.getManipulatorController().setEventProxy( this );
	    }
	
	};
	module.exports = StandardMouseKeyboard;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Quat = __webpack_require__( 26 );
	var Vec3 = __webpack_require__( 15 );
	var Matrix = __webpack_require__( 23 );
	
	
	var WebVR = function ( viewer ) {
	    this._viewer = viewer;
	
	    this._type = 'WebVR';
	    this._enable = false;
	    this._hmd = undefined;
	    this._sensor = undefined;
	
	    this._lastPose = undefined; // so that we can pass it to the submitFrame call
	    this._quat = Quat.create();
	    this._pos = Vec3.create();
	
	    this._worldScale = 1.0;
	};
	
	WebVR.prototype = {
	
	    setWorldScale: function ( val ) {
	        this._worldScale = val;
	    },
	
	    setEnable: function ( bool ) {
	        this._enable = bool;
	    },
	
	    getEnable: function () {
	        return this._enable;
	    },
	
	    init: function () {
	
	        if ( !navigator.getVRDisplays )
	            return;
	
	        var self = this;
	        navigator.getVRDisplays().then( function ( displays ) {
	            if ( displays.length > 0 ) {
	                self._hmd = displays[ 0 ];
	                Notify.log( 'Found a VR display' );
	                // currently it's the event proxy webvr that has the responsability of detecting vr devices
	                self._viewer.setVRDisplay( self._hmd );
	            }
	        } );
	    },
	
	    getManipulatorController: function () {
	        return this._viewer.getManipulator().getControllerList()[ this._type ];
	    },
	
	    isValid: function () {
	        if ( !this._enable )
	            return false;
	
	        var manipulator = this._viewer.getManipulator();
	        if ( !manipulator )
	            return false;
	
	        if ( !manipulator.getControllerList()[ this._type ] )
	            return false;
	
	        if ( !this._hmd )
	            return false;
	
	        return true;
	    },
	
	    update: ( function () {
	        var tempQuat = Quat.create();
	        var tempPos = Vec3.create();
	
	        return function () {
	
	            if ( !this.isValid() )
	                return;
	
	            var manipulatorAdapter = this.getManipulatorController();
	
	            // update the manipulator with the rotation of the device
	            if ( !manipulatorAdapter.update )
	                return;
	
	            if ( !this._hmd.capabilities.hasOrientation && !this._hmd.capabilities.hasPosition )
	                return;
	
	            this._lastPose = this._hmd.getPose(); // if no prediction, call this._hmd.getImmediatePose()
	
	            // WebVR up vector is Y
	            // OSGJS up vector is Z
	
	            var sitToStand = this._hmd.stageParameters && this._hmd.stageParameters.sittingToStandingTransform;
	
	            var quat = this._lastPose.orientation;
	            if ( quat ) {
	                if ( sitToStand ) {
	                    quat = Matrix.getRotate( sitToStand, tempQuat );
	                    Quat.mult( quat, this._lastPose.orientation, quat );
	                }
	
	                this._quat[ 0 ] = quat[ 0 ];
	                this._quat[ 1 ] = -quat[ 2 ];
	                this._quat[ 2 ] = quat[ 1 ];
	                this._quat[ 3 ] = quat[ 3 ];
	            }
	
	            var pos = this._lastPose.position;
	            if ( pos ) {
	                if ( sitToStand ) {
	                    pos = Matrix.transformVec3( sitToStand, pos, tempPos );
	                }
	                this._pos[ 0 ] = pos[ 0 ] * this._worldScale;
	                this._pos[ 1 ] = -pos[ 2 ] * this._worldScale;
	                this._pos[ 2 ] = pos[ 1 ] * this._worldScale;
	            }
	
	            manipulatorAdapter.update( this._quat, this._pos );
	        };
	    } )(),
	
	
	    getHmd: function () {
	        return this._hmd;
	    }
	};
	module.exports = WebVR;


/***/ }),
/* 225 */
/***/ (function(module, exports) {

	'use strict';
	
	var DeviceOrientation = function ( viewer ) {
	    this._viewer = viewer;
	    this._type = 'DeviceOrientation';
	    this._enable = false;
	
	    // Landscape mobile orientation testing defaults
	    this._deviceOrientation = undefined;
	    this._screenOrientation = window.orientation || 90;
	};
	
	DeviceOrientation.prototype = {
	
	    setEnable: function ( bool ) {
	        this._enable = bool;
	    },
	
	    getEnable: function () {
	        return this._enable;
	    },
	
	    init: function () {
	
	        var self = this;
	
	        // Check because Chrome send _one_ event with all angles to null
	        window.addEventListener( 'deviceorientation', function ( rawEvtData ) {
	            if ( rawEvtData.alpha !== null && rawEvtData.alpha !== undefined )
	                self._deviceOrientation = rawEvtData;
	        }, false );
	
	        window.addEventListener( 'orientationchange', function () {
	            if ( window.orientation !== null && window.orientation !== undefined )
	                self._screenOrientation = window.orientation;
	        }, false );
	
	    },
	
	    getManipulatorController: function () {
	        return this._viewer.getManipulator().getControllerList()[ this._type ];
	    },
	
	    isValid: function () {
	        if ( !this._enable )
	            return false;
	
	        if ( !this._deviceOrientation )
	            return false;
	
	        var manipulator = this._viewer.getManipulator();
	        if ( !manipulator )
	            return false;
	
	        if ( !manipulator.getControllerList()[ this._type ] )
	            return false;
	
	        return true;
	    },
	
	    update: function () {
	
	        if ( !this.isValid() )
	            return;
	
	        // update the manipulator with the rotation of the device
	        var manipulatorAdapter = this.getManipulatorController();
	        if ( manipulatorAdapter.update ) {
	            manipulatorAdapter.update( this._deviceOrientation, this._screenOrientation );
	        }
	    }
	
	};
	
	module.exports = DeviceOrientation;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	// jshint ignore: start
	
	'use strict';
	var Notify = __webpack_require__( 10 );
	
	//Copyright (c) 2009 The Chromium Authors. All rights reserved.
	//Use of this source code is governed by a BSD-style license that can be
	//found in the LICENSE file.
	
	// Various functions for helping debug WebGL apps.
	
	var WebGLDebugUtils = function () {
	
	    /**
	     * Which arguements are enums.
	     * @type {!Object.<number, string>}
	     */
	    var glValidEnumContexts = {
	
	        // Generic setters and getters
	
	        'enable': {
	            0: true
	        },
	        'disable': {
	            0: true
	        },
	        'getParameter': {
	            0: true
	        },
	
	        // Rendering
	
	        'drawArrays': {
	            0: true
	        },
	        'drawElements': {
	            0: true,
	            2: true
	        },
	
	        // Shaders
	
	        'createShader': {
	            0: true
	        },
	        'getShaderParameter': {
	            1: true
	        },
	        'getProgramParameter': {
	            1: true
	        },
	
	        // Vertex attributes
	
	        'getVertexAttrib': {
	            1: true
	        },
	        'vertexAttribPointer': {
	            2: true
	        },
	
	        // Textures
	
	        'bindTexture': {
	            0: true
	        },
	        'activeTexture': {
	            0: true
	        },
	        'getTexParameter': {
	            0: true,
	            1: true
	        },
	        'texParameterf': {
	            0: true,
	            1: true
	        },
	        'texParameteri': {
	            0: true,
	            1: true,
	            2: true
	        },
	        'texImage2D': {
	            0: true,
	            2: true,
	            6: true,
	            7: true
	        },
	        'texSubImage2D': {
	            0: true,
	            6: true,
	            7: true
	        },
	        'copyTexImage2D': {
	            0: true,
	            2: true
	        },
	        'copyTexSubImage2D': {
	            0: true
	        },
	        'generateMipmap': {
	            0: true
	        },
	
	        // Buffer objects
	
	        'bindBuffer': {
	            0: true
	        },
	        'bufferData': {
	            0: true,
	            2: true
	        },
	        'bufferSubData': {
	            0: true
	        },
	        'getBufferParameter': {
	            0: true,
	            1: true
	        },
	
	        // Renderbuffers and framebuffers
	
	        'pixelStorei': {
	            0: true,
	            1: true
	        },
	        'readPixels': {
	            4: true,
	            5: true
	        },
	        'bindRenderbuffer': {
	            0: true
	        },
	        'bindFramebuffer': {
	            0: true
	        },
	        'checkFramebufferStatus': {
	            0: true
	        },
	        'framebufferRenderbuffer': {
	            0: true,
	            1: true,
	            2: true
	        },
	        'framebufferTexture2D': {
	            0: true,
	            1: true,
	            2: true
	        },
	        'getFramebufferAttachmentParameter': {
	            0: true,
	            1: true,
	            2: true
	        },
	        'getRenderbufferParameter': {
	            0: true,
	            1: true
	        },
	        'renderbufferStorage': {
	            0: true,
	            1: true
	        },
	
	        // Frame buffer operations (clear, blend, depth test, stencil)
	
	        'clear': {
	            0: true
	        },
	        'depthFunc': {
	            0: true
	        },
	        'blendFunc': {
	            0: true,
	            1: true
	        },
	        'blendFuncSeparate': {
	            0: true,
	            1: true,
	            2: true,
	            3: true
	        },
	        'blendEquation': {
	            0: true
	        },
	        'blendEquationSeparate': {
	            0: true,
	            1: true
	        },
	        'stencilFunc': {
	            0: true
	        },
	        'stencilFuncSeparate': {
	            0: true,
	            1: true
	        },
	        'stencilMaskSeparate': {
	            0: true
	        },
	        'stencilOp': {
	            0: true,
	            1: true,
	            2: true
	        },
	        'stencilOpSeparate': {
	            0: true,
	            1: true,
	            2: true,
	            3: true
	        },
	
	        // Culling
	
	        'cullFace': {
	            0: true
	        },
	        'frontFace': {
	            0: true
	        }
	    };
	
	    /**
	     * Map of numbers to names.
	     * @type {Object}
	     */
	    var glEnums = null;
	
	    /**
	     * Initializes this module. Safe to call more than once.
	     * @param {!WebGLRenderingContext} ctx A WebGL context. If
	     *    you have more than one context it doesn't matter which one
	     *    you pass in, it is only used to pull out constants.
	     */
	    function init( ctx ) {
	        if ( glEnums === null ) {
	            glEnums = {};
	            for ( var propertyName in ctx ) {
	                if ( typeof ctx[ propertyName ] === 'number' ) {
	                    glEnums[ ctx[ propertyName ] ] = propertyName;
	                }
	            }
	        }
	    }
	
	    /**
	     * Checks the utils have been initialized.
	     */
	    function checkInit() {
	        if ( glEnums === null ) {
	            throw 'WebGLDebugUtils.init(ctx) not called';
	        }
	    }
	
	    /**
	     * Returns true or false if value matches any WebGL enum
	     * @param {*} value Value to check if it might be an enum.
	     * @return {boolean} True if value matches one of the WebGL defined enums
	     */
	    function mightBeEnum( value ) {
	        checkInit();
	        return ( glEnums[ value ] !== undefined );
	    }
	
	    /**
	     * Gets an string version of an WebGL enum.
	     *
	     * Example:
	     *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
	     *
	     * @param {number} value Value to return an enum for
	     * @return {string} The string version of the enum.
	     */
	    function glEnumToString( value ) {
	        checkInit();
	        var name = glEnums[ value ];
	        return ( name !== undefined ) ? name :
	            ( '*UNKNOWN WebGL ENUM (0x' + value.toString( 16 ) + ')' );
	    }
	
	    /**
	     * Returns the string version of a WebGL argument.
	     * Attempts to convert enum arguments to strings.
	     * @param {string} functionName the name of the WebGL function.
	     * @param {number} argumentIndx the index of the argument.
	     * @param {*} value The value of the argument.
	     * @return {string} The value as a string.
	     */
	    function glFunctionArgToString( functionName, argumentIndex, value ) {
	        var funcInfo = glValidEnumContexts[ functionName ];
	        if ( funcInfo !== undefined ) {
	            if ( funcInfo[ argumentIndex ] ) {
	                return glEnumToString( value );
	            }
	        }
	        return value.toString();
	    }
	
	    function makePropertyWrapper( wrapper, original, propertyName ) {
	        //Notify.log("wrap prop: " + propertyName);
	        wrapper.__defineGetter__( propertyName, function () {
	            return original[ propertyName ];
	        } );
	        // TODO(gmane): this needs to handle properties that take more than
	        // one value?
	        wrapper.__defineSetter__( propertyName, function ( value ) {
	            //Notify.log("set: " + propertyName);
	            original[ propertyName ] = value;
	        } );
	    }
	
	    // Makes a function that calls a function on another object.
	    function makeFunctionWrapper( original, functionName ) {
	        //Notify.log("wrap fn: " + functionName);
	        var f = original[ functionName ];
	        return function () {
	            //Notify.log("call: " + functionName);
	            var result = f.apply( original, arguments );
	            return result;
	        };
	    }
	
	    /**
	     * Given a WebGL context returns a wrapped context that calls
	     * gl.getError after every command and calls a function if the
	     * result is not gl.NO_ERROR.
	     *
	     * @param {!WebGLRenderingContext} ctx The webgl context to
	     *        wrap.
	     * @param {!function(err, funcName, args): void} opt_onErrorFunc
	     *        The function to call when gl.getError returns an
	     *        error. If not specified the default function calls
	     *        Notify.log with a message.
	     */
	    function makeDebugContext( ctx, opt_onErrorFunc ) {
	        init( ctx );
	        opt_onErrorFunc = opt_onErrorFunc || function ( err, functionName, args ) {
	            // apparently we can't do args.join(",");
	            var argStr = "";
	            for ( var ii = 0; ii < args.length; ++ii ) {
	                argStr += ( ( ii === 0 ) ? '' : ', ' ) +
	                    glFunctionArgToString( functionName, ii, args[ ii ] );
	            }
	            Notify.log( "WebGL error " + glEnumToString( err ) + " in " + functionName +
	                "(" + argStr + ")" );
	        };
	
	        // Holds booleans for each GL error so after we get the error ourselves
	        // we can still return it to the client app.
	        var glErrorShadow = {};
	
	        // Makes a function that calls a WebGL function and then calls getError.
	        function makeErrorWrapper( ctx, functionName ) {
	            return function () {
	                var result = ctx[ functionName ].apply( ctx, arguments );
	                var err = ctx.getError();
	                if ( err !== 0 ) {
	                    glErrorShadow[ err ] = true;
	                    opt_onErrorFunc( err, functionName, arguments );
	                }
	                return result;
	            };
	        }
	
	        // Make a an object that has a copy of every property of the WebGL context
	        // but wraps all functions.
	        var wrapper = {};
	        for ( var propertyName in ctx ) {
	            if ( typeof ctx[ propertyName ] == 'function' ) {
	                wrapper[ propertyName ] = makeErrorWrapper( ctx, propertyName );
	            } else {
	                makePropertyWrapper( wrapper, ctx, propertyName );
	            }
	        }
	
	        // Override the getError function with one that returns our saved results.
	        wrapper.getError = function () {
	            for ( var err in glErrorShadow ) {
	                if ( glErrorShadow[ err ] ) {
	                    glErrorShadow[ err ] = false;
	                    return err;
	                }
	            }
	            return ctx.NO_ERROR;
	        };
	
	        return wrapper;
	    }
	
	    function resetToInitialState( ctx ) {
	        var numAttribs = ctx.getParameter( ctx.MAX_VERTEX_ATTRIBS );
	        var tmp = ctx.createBuffer();
	        ctx.bindBuffer( ctx.ARRAY_BUFFER, tmp );
	        var ii;
	        for ( ii = 0; ii < numAttribs; ++ii ) {
	            ctx.disableVertexAttribArray( ii );
	            ctx.vertexAttribPointer( ii, 4, ctx.FLOAT, false, 0, 0 );
	            ctx.vertexAttrib1f( ii, 0 );
	        }
	        ctx.deleteBuffer( tmp );
	
	        var numTextureUnits = ctx.getParameter( ctx.MAX_TEXTURE_IMAGE_UNITS );
	        for ( ii = 0; ii < numTextureUnits; ++ii ) {
	            ctx.activeTexture( ctx.TEXTURE0 + ii );
	            ctx.bindTexture( ctx.TEXTURE_CUBE_MAP, null );
	            ctx.bindTexture( ctx.TEXTURE_2D, null );
	        }
	
	        ctx.activeTexture( ctx.TEXTURE0 );
	        ctx.useProgram( null );
	        ctx.bindBuffer( ctx.ARRAY_BUFFER, null );
	        ctx.bindBuffer( ctx.ELEMENT_ARRAY_BUFFER, null );
	        ctx.bindFramebuffer( ctx.FRAMEBUFFER, null );
	        ctx.bindRenderbuffer( ctx.RENDERBUFFER, null );
	        ctx.disable( ctx.BLEND );
	        ctx.disable( ctx.CULL_FACE );
	        ctx.disable( ctx.DEPTH_TEST );
	        ctx.disable( ctx.DITHER );
	        ctx.disable( ctx.SCISSOR_TEST );
	        ctx.blendColor( 0, 0, 0, 0 );
	        ctx.blendEquation( ctx.FUNC_ADD );
	        ctx.blendFunc( ctx.ONE, ctx.ZERO );
	        ctx.clearColor( 0, 0, 0, 0 );
	        ctx.clearDepth( 1 );
	        ctx.clearStencil( -1 );
	        ctx.colorMask( true, true, true, true );
	        ctx.cullFace( ctx.BACK );
	        ctx.depthFunc( ctx.LESS );
	        ctx.depthMask( true );
	        ctx.depthRange( 0, 1 );
	        ctx.frontFace( ctx.CCW );
	        ctx.hint( ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE );
	        ctx.lineWidth( 1 );
	        ctx.pixelStorei( ctx.PACK_ALIGNMENT, 4 );
	        ctx.pixelStorei( ctx.UNPACK_ALIGNMENT, 4 );
	        ctx.pixelStorei( ctx.UNPACK_FLIP_Y_WEBGL, false );
	        ctx.pixelStorei( ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
	        // TODO: Delete this IF.
	        if ( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL ) {
	            ctx.pixelStorei( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL );
	        }
	        ctx.polygonOffset( 0, 0 );
	        ctx.sampleCoverage( 1, false );
	        ctx.scissor( 0, 0, ctx.canvas.width, ctx.canvas.height );
	        ctx.stencilFunc( ctx.ALWAYS, 0, 0xFFFFFFFF );
	        ctx.stencilMask( 0xFFFFFFFF );
	        ctx.stencilOp( ctx.KEEP, ctx.KEEP, ctx.KEEP );
	        ctx.viewport( 0, 0, ctx.canvas.width, ctx.canvas.height );
	        ctx.clear( ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT );
	
	        // TODO: This should NOT be needed but Firefox fails with 'hint'
	        while ( ctx.getError() ) {}
	    }
	
	    function makeLostContextSimulatingCanvas( canvas ) {
	        var unwrappedContext_;
	        //var wrappedContext_;
	        var onLost_ = [];
	        var onRestored_ = [];
	        var wrappedContext_ = {};
	        var contextId_ = 1;
	        var contextLost_ = false;
	        var resourceId_ = 0;
	        var resourceDb_ = [];
	        var numCallsToLoseContext_ = 0;
	        var numCalls_ = 0;
	        var canRestore_ = false;
	        var restoreTimeout_ = 0;
	
	        // Holds booleans for each GL error so can simulate errors.
	        var glErrorShadow_ = {};
	
	        canvas.getContext = function ( f ) {
	            return function () {
	                var ctx = f.apply( canvas, arguments );
	                // Did we get a context and is it a WebGL context?
	                if ( ctx instanceof WebGLRenderingContext ) {
	                    if ( ctx != unwrappedContext_ ) {
	                        if ( unwrappedContext_ ) {
	                            throw "got different context";
	                        }
	                        unwrappedContext_ = ctx;
	                        wrappedContext_ = makeLostContextSimulatingContext( unwrappedContext_ );
	                    }
	                    return wrappedContext_;
	                }
	                return ctx;
	            };
	        }( canvas.getContext );
	
	        function wrapEvent( listener ) {
	            if ( typeof ( listener ) == "function" ) {
	                return listener;
	            } else {
	                return function ( info ) {
	                    listener.handleEvent( info );
	                };
	            }
	        }
	
	        var addOnContextLostListener = function ( listener ) {
	            onLost_.push( wrapEvent( listener ) );
	        };
	
	        var addOnContextRestoredListener = function ( listener ) {
	            onRestored_.push( wrapEvent( listener ) );
	        };
	
	
	        function wrapAddEventListener( canvas ) {
	            var f = canvas.addEventListener;
	            canvas.addEventListener = function ( type, listener, bubble ) {
	                switch ( type ) {
	                case 'webglcontextlost':
	                    addOnContextLostListener( listener );
	                    break;
	                case 'webglcontextrestored':
	                    addOnContextRestoredListener( listener );
	                    break;
	                default:
	                    f.apply( canvas, arguments );
	                }
	            };
	        }
	
	        wrapAddEventListener( canvas );
	
	        canvas.loseContext = function () {
	            if ( !contextLost_ ) {
	                contextLost_ = true;
	                numCallsToLoseContext_ = 0;
	                ++contextId_;
	                while ( unwrappedContext_.getError() ) {}
	                clearErrors();
	                glErrorShadow_[ unwrappedContext_.CONTEXT_LOST_WEBGL ] = true;
	                var event = makeWebGLContextEvent( "context lost" );
	                var callbacks = onLost_.slice();
	                setTimeout( function () {
	                    //Notify.log("numCallbacks:" + callbacks.length);
	                    for ( var ii = 0; ii < callbacks.length; ++ii ) {
	                        //Notify.log("calling callback:" + ii);
	                        callbacks[ ii ]( event );
	                    }
	                    if ( restoreTimeout_ >= 0 ) {
	                        setTimeout( function () {
	                            canvas.restoreContext();
	                        }, restoreTimeout_ );
	                    }
	                }, 0 );
	            }
	        };
	
	        canvas.restoreContext = function () {
	            if ( contextLost_ ) {
	                if ( onRestored_.length ) {
	                    setTimeout( function () {
	                        if ( !canRestore_ ) {
	                            throw "can not restore. webglcontestlost listener did not call event.preventDefault";
	                        }
	                        freeResources();
	                        resetToInitialState( unwrappedContext_ );
	                        contextLost_ = false;
	                        numCalls_ = 0;
	                        canRestore_ = false;
	                        var callbacks = onRestored_.slice();
	                        var event = makeWebGLContextEvent( "context restored" );
	                        for ( var ii = 0; ii < callbacks.length; ++ii ) {
	                            callbacks[ ii ]( event );
	                        }
	                    }, 0 );
	                }
	            }
	        };
	
	        canvas.loseContextInNCalls = function ( numCalls ) {
	            if ( contextLost_ ) {
	                throw "You can not ask a lost contet to be lost";
	            }
	            numCallsToLoseContext_ = numCalls_ + numCalls;
	        };
	
	        canvas.getNumCalls = function () {
	            return numCalls_;
	        };
	
	        canvas.setRestoreTimeout = function ( timeout ) {
	            restoreTimeout_ = timeout;
	        };
	
	        function isWebGLObject( obj ) {
	            //return false;
	            return ( obj instanceof WebGLBuffer ||
	                obj instanceof WebGLFramebuffer ||
	                obj instanceof WebGLProgram ||
	                obj instanceof WebGLRenderbuffer ||
	                obj instanceof WebGLShader ||
	                obj instanceof WebGLTexture );
	        }
	
	        function checkResources( args ) {
	            for ( var ii = 0; ii < args.length; ++ii ) {
	                var arg = args[ ii ];
	                if ( isWebGLObject( arg ) ) {
	                    return arg.__webglDebugContextLostId__ == contextId_;
	                }
	            }
	            return true;
	        }
	
	        function clearErrors() {
	            var k = window.Object.keys( glErrorShadow_ );
	            for ( var ii = 0; ii < k.length; ++ii ) {
	                delete glErrorShadow_[ k ];
	            }
	        }
	
	        function loseContextIfTime() {
	            ++numCalls_;
	            if ( !contextLost_ ) {
	                if ( numCallsToLoseContext_ == numCalls_ ) {
	                    canvas.loseContext();
	                }
	            }
	        }
	
	        // Makes a function that simulates WebGL when out of context.
	        function makeLostContextFunctionWrapper( ctx, functionName ) {
	            var f = ctx[ functionName ];
	            return function () {
	                // Notify.log("calling:" + functionName);
	                // Only call the functions if the context is not lost.
	                loseContextIfTime();
	                if ( !contextLost_ ) {
	                    //if (!checkResources(arguments)) {
	                    //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
	                    //  return;
	                    //}
	                    var result = f.apply( ctx, arguments );
	                    return result;
	                }
	            };
	        }
	
	        function freeResources() {
	            for ( var ii = 0; ii < resourceDb_.length; ++ii ) {
	                var resource = resourceDb_[ ii ];
	                if ( resource instanceof WebGLBuffer ) {
	                    unwrappedContext_.deleteBuffer( resource );
	                } else if ( resource instanceof WebGLFramebuffer ) {
	                    unwrappedContext_.deleteFramebuffer( resource );
	                } else if ( resource instanceof WebGLProgram ) {
	                    unwrappedContext_.deleteProgram( resource );
	                } else if ( resource instanceof WebGLRenderbuffer ) {
	                    unwrappedContext_.deleteRenderbuffer( resource );
	                } else if ( resource instanceof WebGLShader ) {
	                    unwrappedContext_.deleteShader( resource );
	                } else if ( resource instanceof WebGLTexture ) {
	                    unwrappedContext_.deleteTexture( resource );
	                }
	            }
	        }
	
	        function makeWebGLContextEvent( statusMessage ) {
	            return {
	                statusMessage: statusMessage,
	                preventDefault: function () {
	                    canRestore_ = true;
	                }
	            };
	        }
	
	
	        function makeLostContextSimulatingContext( ctx ) {
	            // copy all functions and properties to wrapper
	            for ( var propertyName in ctx ) {
	                if ( typeof ctx[ propertyName ] == 'function' ) {
	                    wrappedContext_[ propertyName ] = makeLostContextFunctionWrapper(
	                        ctx, propertyName );
	                } else {
	                    makePropertyWrapper( wrappedContext_, ctx, propertyName );
	                }
	            }
	
	            // Wrap a few functions specially.
	            wrappedContext_.getError = function () {
	                loseContextIfTime();
	                var err;
	                if ( !contextLost_ ) {
	                    while ( err = unwrappedContext_.getError() ) {
	                        glErrorShadow_[ err ] = true;
	                    }
	                }
	                for ( err in glErrorShadow_ ) {
	                    if ( glErrorShadow_[ err ] ) {
	                        delete glErrorShadow_[ err ];
	                        return err;
	                    }
	                }
	                return wrappedContext_.NO_ERROR;
	            };
	
	            var creationFunctions = [
	                "createBuffer",
	                "createFramebuffer",
	                "createProgram",
	                "createRenderbuffer",
	                "createShader",
	                "createTexture"
	            ];
	            var functionName, ii;
	            for ( ii = 0; ii < creationFunctions.length; ++ii ) {
	                functionName = creationFunctions[ ii ];
	                wrappedContext_[ functionName ] = function ( f ) {
	                    return function () {
	                        loseContextIfTime();
	                        if ( contextLost_ ) {
	                            return null;
	                        }
	                        var obj = f.apply( ctx, arguments );
	                        obj.__webglDebugContextLostId__ = contextId_;
	                        resourceDb_.push( obj );
	                        return obj;
	                    };
	                }( ctx[ functionName ] );
	            }
	
	            var functionsThatShouldReturnNull = [
	                "getActiveAttrib",
	                "getActiveUniform",
	                "getBufferParameter",
	                "getContextAttributes",
	                "getAttachedShaders",
	                "getFramebufferAttachmentParameter",
	                "getParameter",
	                "getProgramParameter",
	                "getProgramInfoLog",
	                "getRenderbufferParameter",
	                "getShaderParameter",
	                "getShaderInfoLog",
	                "getShaderSource",
	                "getTexParameter",
	                "getUniform",
	                "getUniformLocation",
	                "getVertexAttrib"
	            ];
	            for ( ii = 0; ii < functionsThatShouldReturnNull.length; ++ii ) {
	                functionName = functionsThatShouldReturnNull[ ii ];
	                wrappedContext_[ functionName ] = function ( f ) {
	                    return function () {
	                        loseContextIfTime();
	                        if ( contextLost_ ) {
	                            return null;
	                        }
	                        return f.apply( ctx, arguments );
	                    };
	                }( wrappedContext_[ functionName ] );
	            }
	
	            var isFunctions = [
	                "isBuffer",
	                "isEnabled",
	                "isFramebuffer",
	                "isProgram",
	                "isRenderbuffer",
	                "isShader",
	                "isTexture"
	            ];
	            for ( ii = 0; ii < isFunctions.length; ++ii ) {
	                functionName = isFunctions[ ii ];
	                wrappedContext_[ functionName ] = function ( f ) {
	                    return function () {
	                        loseContextIfTime();
	                        if ( contextLost_ ) {
	                            return false;
	                        }
	                        return f.apply( ctx, arguments );
	                    };
	                }( wrappedContext_[ functionName ] );
	            }
	
	            wrappedContext_.checkFramebufferStatus = function ( f ) {
	                return function () {
	                    loseContextIfTime();
	                    if ( contextLost_ ) {
	                        return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
	                    }
	                    return f.apply( ctx, arguments );
	                };
	            }( wrappedContext_.checkFramebufferStatus );
	
	            wrappedContext_.getAttribLocation = function ( f ) {
	                return function () {
	                    loseContextIfTime();
	                    if ( contextLost_ ) {
	                        return -1;
	                    }
	                    return f.apply( ctx, arguments );
	                };
	            }( wrappedContext_.getAttribLocation );
	
	            wrappedContext_.getVertexAttribOffset = function ( f ) {
	                return function () {
	                    loseContextIfTime();
	                    if ( contextLost_ ) {
	                        return 0;
	                    }
	                    return f.apply( ctx, arguments );
	                };
	            }( wrappedContext_.getVertexAttribOffset );
	
	            wrappedContext_.isContextLost = function () {
	                return contextLost_;
	            };
	
	            return wrappedContext_;
	        }
	
	        // TODO: find why this is there ?
	        return canvas;
	    }
	
	    return {
	        /**
	   * Initializes this module. Safe to call more than once.
	   * @param {!WebGLRenderingContext} ctx A WebGL context. If
	  }
	 *    you have more than one context it doesn't matter which one
	 *    you pass in, it is only used to pull out constants.
	 */
	        'init': init,
	
	        /**
	         * Returns true or false if value matches any WebGL enum
	         * @param {*} value Value to check if it might be an enum.
	         * @return {boolean} True if value matches one of the WebGL defined enums
	         */
	        'mightBeEnum': mightBeEnum,
	
	        /**
	         * Gets an string version of an WebGL enum.
	         *
	         * Example:
	         *   WebGLDebugUtil.init(ctx);
	         *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
	         *
	         * @param {number} value Value to return an enum for
	         * @return {string} The string version of the enum.
	         */
	        'glEnumToString': glEnumToString,
	
	        /**
	         * Converts the argument of a WebGL function to a string.
	         * Attempts to convert enum arguments to strings.
	         *
	         * Example:
	         *   WebGLDebugUtil.init(ctx);
	         *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
	         *
	         * would return 'TEXTURE_2D'
	         *
	         * @param {string} functionName the name of the WebGL function.
	         * @param {number} argumentIndx the index of the argument.
	         * @param {*} value The value of the argument.
	         * @return {string} The value as a string.
	         */
	        'glFunctionArgToString': glFunctionArgToString,
	
	        /**
	         * Given a WebGL context returns a wrapped context that calls
	         * gl.getError after every command and calls a function if the
	         * result is not NO_ERROR.
	         *
	         * You can supply your own function if you want. For example, if you'd like
	         * an exception thrown on any GL error you could do this
	         *
	         *    function throwOnGLError(err, funcName, args) {
	         *      throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to" +
	         *            funcName;
	         *    };
	         *
	         *    ctx = WebGLDebugUtils.makeDebugContext(
	         *        canvas.getContext("webgl"), throwOnGLError);
	         *
	         * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
	         * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
	         *     to call when gl.getError returns an error. If not specified the default
	         *     function calls Notify.log with a message.
	         */
	        'makeDebugContext': makeDebugContext,
	
	        /**
	         * Given a canvas element returns a wrapped canvas element that will
	         * simulate lost context. The canvas returned adds the following functions.
	         *
	         * loseContext:
	         *   simulates a lost context event.
	         *
	         * restoreContext:
	         *   simulates the context being restored.
	         *
	         * lostContextInNCalls:
	         *   loses the context after N gl calls.
	         *
	         * getNumCalls:
	         *   tells you how many gl calls there have been so far.
	         *
	         * setRestoreTimeout:
	         *   sets the number of milliseconds until the context is restored
	         *   after it has been lost. Defaults to 0. Pass -1 to prevent
	         *   automatic restoring.
	         *
	         * @param {!Canvas} canvas The canvas element to wrap.
	         */
	        'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,
	
	        /**
	         * Resets a context to the initial state.
	         * @param {!WebGLRenderingContext} ctx The webgl context to
	         *     reset.
	         */
	        'resetToInitialState': resetToInitialState
	    };
	
	}();
	
	module.exports = WebGLDebugUtils;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ShadowCastAttribute = __webpack_require__( 228 );
	var ShadowCastCompiler = __webpack_require__( 165 );
	var ShadowCastShaderGenerator = __webpack_require__( 164 );
	var ShadowCasterVisitor = __webpack_require__( 229 );
	var ShadowFrustumIntersection = __webpack_require__( 230 );
	var ShadowMap = __webpack_require__( 231 );
	var ShadowReceiveAttribute = __webpack_require__( 232 );
	var ShadowSettings = __webpack_require__( 235 );
	var ShadowTechnique = __webpack_require__( 233 );
	var ShadowTexture = __webpack_require__( 234 );
	var ShadowedScene = __webpack_require__( 236 );
	
	
	var osgShadow = {};
	
	osgShadow.ShadowCastAttribute = ShadowCastAttribute;
	osgShadow.ShadowCastCompiler = ShadowCastCompiler;
	osgShadow.ShadowReceiveAttribute = ShadowReceiveAttribute;
	osgShadow.ShadowCasterVisitor = ShadowCasterVisitor;
	osgShadow.ShadowFrustumIntersection = ShadowFrustumIntersection;
	osgShadow.ShadowMap = ShadowMap;
	osgShadow.ShadowedScene = ShadowedScene;
	osgShadow.ShadowSettings = ShadowSettings;
	osgShadow.ShadowCastShaderGenerator = ShadowCastShaderGenerator;
	osgShadow.ShadowTechnique = ShadowTechnique;
	osgShadow.ShadowTexture = ShadowTexture;
	
	
	module.exports = osgShadow;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	
	
	// Used to notify the Compiler to create a Depth Casting optimized shader
	var ShadowCastAttribute = function ( disable, shadowReceiveAttribute ) {
	    StateAttribute.call( this );
	    this._enable = !disable;
	    this._shadowReceiveAttribute = shadowReceiveAttribute;
	};
	ShadowCastAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	    attributeType: 'ShadowCast',
	    cloneType: function () {
	        return new ShadowCastAttribute( true );
	    },
	    //
	    setReceiveAttribute: function ( shadowReceiveAttribute ) {
	        this._shadowReceiveAttribute = shadowReceiveAttribute;
	    },
	    getReceiveAttribute: function () {
	        return this._shadowReceiveAttribute;
	    },
	    getDefines: function () {
	        if ( !this._shadowReceiveAttribute ) return undefined; // test here because of cloneType
	        return this._shadowReceiveAttribute.getDefines();
	    },
	    getAlgorithm: function () {
	        if ( !this._shadowReceiveAttribute ) return undefined; // test here because of cloneType
	        return this._shadowReceiveAttribute.getAlgorithm();
	    },
	    getHash: function () {
	        return 'ShadowCast' + this._enable + this._shadowReceiveAttribute.getAlgorithm() + this._shadowReceiveAttribute.getPrecision();
	    },
	    // need a isEnabled to let the ShaderGenerator to filter
	    // StateAttribute from the shader compilation
	    isEnabled: function () {
	        return this._enable;
	    }
	} ), 'osgShadow', 'ShadowCastAttribute' );
	
	MACROUTILS.setTypeID( ShadowCastAttribute );
	
	module.exports = ShadowCastAttribute;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BlendFunc = __webpack_require__( 39 );
	var Camera = __webpack_require__( 56 );
	var Depth = __webpack_require__( 86 );
	var Light = __webpack_require__( 97 );
	var LightSource = __webpack_require__( 64 );
	var NodeVisitor = __webpack_require__( 22 );
	var MACROUTILS = __webpack_require__( 6 );
	
	
	
	/*
	 * Remove nodes that shouldn't not be culled when casting
	 * like lights, camera with render texture targets,
	 * transparent (alphablended) geometries
	 * (otherwise it might break things)
	 * visits whole underlying scene recursively
	 */
	var ShadowCasterVisitor = function ( mask ) {
	    NodeVisitor.call( this );
	    // mask setting to avoid casting shadows
	    this._noCastMask = mask;
	    this._nodeList = [];
	};
	
	ShadowCasterVisitor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    reset: function () {
	        this._nodeList = [];
	    },
	    removeNodeFromCasting: function ( node ) {
	
	        /*jshint bitwise: false */
	
	        var nm = node.getNodeMask();
	        // ~0x0 as not to be processed
	
	        if ( nm === ~0x0 ) {
	
	            // set to avoid casting shadow
	            nm = this._noCastMask;
	            node.setNodeMask( nm );
	            this._nodeList.push( node );
	
	        } else if ( ( nm & ~( this._noCastMask ) ) !== 0 ) {
	
	            // set to avoid casting shadow
	            node.setNodeMask( nm | this._noCastMask );
	            this._nodeList.push( node );
	
	        }
	        /*jshint bitwise: true */
	
	    },
	    // Visiting whole casting scene recursively
	    apply: function ( node ) {
	
	        // check that and other things ?
	        // TODO: should check whole hierarchy to check for override/protected/etc
	        // Depth, BlendFunc Attributes...
	        var st = node.getStateSet();
	        if ( st ) {
	
	            // check for transparency not casting shadows
	            // as no alpha blending transparency shadow (no transmittance support)
	            var blend = st.getAttribute( 'BlendFunc' );
	            if ( blend !== undefined && blend.getSource() !== BlendFunc.DISABLE ) {
	                var depth = st.getAttribute( 'Depth' );
	                if ( depth && ( depth.getFunc() === Depth.DISABLE || depth.getWriteMask() === false ) ) {
	                    this.removeNodeFromCasting( node );
	                    return;
	                }
	            }
	        }
	
	        // check for lights, as lights are positionned attributes
	        if ( node.getTypeID() === Light.typeID || node.getTypeID() === LightSource.typeID ) {
	            this.removeNodeFromCasting( node );
	            return;
	        } else if ( node.getTypeID() === Camera.typeID && node.isRenderToTextureCamera() ) {
	            // no "Subrender" when rendering the shadow map as from light point of view
	            this.removeNodeFromCasting( node );
	            return;
	        }
	        this.traverse( node );
	    },
	
	    setNoCastMask: function ( mask ) {
	        this._noCastMask = mask;
	    },
	
	    // restore to any previous mask avoiding any breaks
	    // in other application mask usage.
	    restore: function () {
	
	        for ( var i = 0, l = this._nodeList.length; i < l; i++ ) {
	
	            var node = this._nodeList[ i ];
	            var nm = node.getNodeMask();
	
	            if ( nm === this._noCastMask ) {
	
	                node.setNodeMask( ~0x0 );
	
	            } else {
	
	                node.setNodeMask( nm & ~this._noCastMask );
	
	            }
	
	        }
	
	    }
	
	
	} ), 'osgShadow', 'ShadowCasterVisitor' );
	
	
	MACROUTILS.setTypeID( ShadowCasterVisitor );
	
	module.exports = ShadowCasterVisitor;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var BoundingBox = __webpack_require__( 14 );
	var BoundingSphere = __webpack_require__( 18 );
	var Camera = __webpack_require__( 56 );
	var Geometry = __webpack_require__( 31 );
	var Light = __webpack_require__( 97 );
	var Matrix = __webpack_require__( 23 );
	var MatrixMemoryPool = __webpack_require__( 27 );
	var MatrixTransform = __webpack_require__( 44 );
	var NodeVisitor = __webpack_require__( 22 );
	var Plane = __webpack_require__( 24 );
	var MACROUTILS = __webpack_require__( 6 );
	
	/**
	 * [ComputeFrustumBoundsVisitor get a scene bounds limited by a light and camera frustum]
	 */
	var ComputeMultiFrustumBoundsVisitor = function () {
	
	    NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );
	    this._matrixStack = [ Matrix.create() ];
	    this._reservedMatrixStack = new MatrixMemoryPool();
	    this._bb = new BoundingBox();
	    this._bs = new BoundingSphere();
	
	};
	
	/*
	 * TODO: apply world matrix on the traverse instead of per node
	 */
	ComputeMultiFrustumBoundsVisitor.prototype = MACROUTILS.objectInherit( NodeVisitor.prototype, {
	    reset: function ( traversalMask, worldLightPos, cameraFrustum, cameraNearFar, lightFrustum ) {
	
	        this.setTraversalMask( traversalMask );
	
	        this._cameraFrustum = cameraFrustum;
	        this._lightFrustum = lightFrustum;
	
	        // what plane to exclude from shadowedscene
	        this.getCameraPlaneMaskForLightNear( worldLightPos, cameraFrustum, cameraNearFar ? 6 : 4 );
	
	        this._reservedMatrixStack.reset();
	        this._matrixStack.length = 1;
	        this._bb.init();
	    },
	
	    getBoundingBox: function () {
	        return this._bb;
	    },
	
	
	    getCameraPlaneMaskForLightNear: function ( point, cameraFrustum, len ) {
	        var selectorMask = 0x1;
	        var resultMask = 15;
	        var i;
	
	        for ( i = 0; i < len; ++i ) {
	            resultMask = ( resultMask << 1 ) | 1;
	        }
	
	        var planeList = cameraFrustum.getPlanes();
	        for ( i = 0; i < len; ++i ) {
	            if ( Plane.distanceToPlane( planeList[ i ], point ) < 0.0 ) {
	                // Ligth frustum source poitn is outside this plane.
	                // subsequent checks against this plane not required.
	                // as light position is behind those,
	                // and culling that would cull light near
	                resultMask ^= selectorMask;
	            }
	            selectorMask <<= 1;
	        }
	        this._cameraPlaneMaskedByLightNear = resultMask;
	
	        cameraFrustum.setResultMask( resultMask );
	        cameraFrustum.pushCurrentMask( resultMask );
	        return resultMask;
	    },
	
	    applyTransform: function ( transform ) {
	
	        var matrix = this._reservedMatrixStack.get();
	        var stackLength = this._matrixStack.length;
	        Matrix.copy( this._matrixStack[ stackLength - 1 ], matrix );
	        transform.computeLocalToWorldMatrix( matrix, this );
	
	        var bs = this._bs;
	        Matrix.transformBoundingSphere( matrix, transform.getBound(), this._bs );
	
	        // camera cull
	        if ( this._cameraFrustum.getCurrentMask() !== 0 ) {
	            // father bounding sphere is not totally inside
	            // now test this one
	            if ( !this._cameraFrustum.containsBoundingSphere( bs ) )
	                return; // culled
	        }
	
	        // light cull
	        if ( this._lightFrustum.getCurrentMask() !== 0 ) {
	            // father bounding sphere is not totally inside
	            // now test this one
	            if ( !this._lightFrustum.containsBoundingSphere( bs ) )
	                return; // culled
	        }
	
	        this._cameraFrustum.pushCurrentMask();
	        this._lightFrustum.pushCurrentMask();
	
	        this.pushMatrix( matrix );
	
	        this.traverse( transform );
	
	        this._cameraFrustum.popCurrentMask();
	        this._lightFrustum.popCurrentMask();
	
	        this.popMatrix();
	    },
	    applyBoundingBox: ( function () {
	        var bbOut = new BoundingBox();
	        return function ( bbox ) {
	            var stackLength = this._matrixStack.length;
	            var matrix = this._matrixStack[ stackLength - 1 ];
	            if ( Matrix.isIdentity( matrix ) ) {
	                this._bb.expandByBoundingBox( bbox );
	            } else if ( bbox.valid() ) {
	                Matrix.transformBoundingBox( matrix, bbox, bbOut );
	                this._bb.expandByBoundingBox( bbOut );
	            }
	        };
	    } )(),
	
	    apply: function ( node ) {
	
	        var typeID = node.getTypeID();
	
	        if ( node instanceof MatrixTransform ) {
	            this.applyTransform( node );
	            return;
	
	        } else if ( typeID === Geometry.getTypeID() ) {
	            var bs = this._bs;
	            var matrix = this._matrixStack[ this._matrixStack.length - 1 ];
	            Matrix.transformBoundingSphere( matrix, node.getBound(), bs );
	
	            // camera cull
	            if ( this._cameraFrustum.getCurrentMask() !== 0 ) {
	                // father bounding sphere is not totally inside
	                // now test this one
	                if ( !this._cameraFrustum.containsBoundingSphere( bs ) )
	                    return; // culled
	            }
	
	            // light cull
	            if ( this._lightFrustum.getCurrentMask() !== 0 ) {
	                // father bounding sphere is not totally inside
	                // now test this one
	                if ( !this._lightFrustum.containsBoundingSphere( bs ) )
	                    return; // culled
	            }
	
	            // Visible: we enlarge the bbox
	            this.applyBoundingBox( node.getBoundingBox() );
	
	            return;
	        } else if ( typeID === Camera.getTypeID() ) {
	
	        } else if ( typeID === Light.getTypeID() ) {
	
	        }
	
	
	        this.traverse( node );
	
	    },
	
	    pushMatrix: function ( matrix ) {
	        this._matrixStack.push( matrix );
	    },
	
	    popMatrix: function () {
	        this._matrixStack.pop();
	    },
	
	} );
	
	module.exports = ComputeMultiFrustumBoundsVisitor;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Camera = __webpack_require__( 56 );
	var BlendFunc = __webpack_require__( 39 );
	var ComputeBoundsVisitor = __webpack_require__( 30 );
	var Depth = __webpack_require__( 86 );
	var FrameBufferObject = __webpack_require__( 68 );
	var Matrix = __webpack_require__( 23 );
	var Notify = __webpack_require__( 10 );
	var StateAttribute = __webpack_require__( 21 );
	var StateSet = __webpack_require__( 19 );
	var Texture = __webpack_require__( 34 );
	var Transform = __webpack_require__( 11 );
	var Uniform = __webpack_require__( 35 );
	var MACROUTILS = __webpack_require__( 6 );
	var Vec3 = __webpack_require__( 15 );
	var Vec4 = __webpack_require__( 25 );
	var Viewport = __webpack_require__( 107 );
	var WebGLCaps = __webpack_require__( 32 );
	var ShadowReceiveAttribute = __webpack_require__( 232 );
	var ShadowCasterVisitor = __webpack_require__( 229 );
	var ShadowFrustumIntersection = __webpack_require__( 230 );
	var ShadowCastAttribute = __webpack_require__( 228 );
	var ShadowTechnique = __webpack_require__( 233 );
	var ShadowTexture = __webpack_require__( 234 );
	
	
	// Custom camera cull callback
	// we customize it just to avoid to add extra 'virtual' function
	// on the shadowTecnique class
	var CameraCullCallback = function ( shadowTechnique ) {
	    this._shadowTechnique = shadowTechnique;
	};
	
	CameraCullCallback.prototype = {
	    cull: function ( node, nv ) {
	
	        // see ShadowTechnique CameraCullCallback
	        this._shadowTechnique.getShadowedScene().nodeTraverse( nv );
	
	
	
	        var cs = nv.getCurrentCullingSet();
	        if ( nv.getComputeNearFar() === true && nv.getComputedFar() >= nv.getComputedNear() ) {
	            var m = nv.getCurrentProjectionMatrix();
	
	            //Matrix.clampProjectionMatrix( m, nv.getComputedNear(), nv.getComputedFar(), nv.getNearFarRatio() );
	            this._shadowTechnique.getDepthRange()[ 0 ] = nv.getComputedNear();
	            this._shadowTechnique.getDepthRange()[ 1 ] = nv.getComputedFar();
	
	            Matrix.getFrustumPlanes( m, nv.getCurrentModelViewMatrix(), cs.getFrustum().getPlanes(), false );
	            // TODO: no far no near.
	            // should check if we have them
	            // should add at least a near 0 clip if not
	            cs.getFrustum().setupMask( 6 );
	        }
	
	        this._shadowTechnique.setLightFrustum( cs.getFrustum() );
	        return false;
	    }
	};
	
	/**
	 *  ShadowMap provides an implementation of shadow textures.
	 *  @class ShadowMap
	 */
	var ShadowMap = function ( settings ) {
	    ShadowTechnique.call( this );
	
	    this._projectionMatrix = Matrix.create();
	    this._viewMatrix = Matrix.create();
	
	    this._lightUp = Vec3.createAndSet( 0.0, 0.0, 1.0 );
	
	    this._light = settings.light;
	
	    // data
	    this._cameraShadow = new Camera();
	    this._cameraShadow.setCullCallback( new CameraCullCallback( this ) );
	    this._cameraShadow.setRenderOrder( Camera.PRE_RENDER, 0 );
	    this._cameraShadow.setReferenceFrame( Transform.ABSOLUTE_RF );
	    this._cameraShadow.setClearColor( Vec4.createAndSet( 1.0, 1.0, 1.0, 1.0 ) );
	
	    this._texture = new ShadowTexture();
	    this._textureUnitBase = 4;
	    this._textureUnit = this._textureUnitBase;
	
	    // see shadowSettings.js header for param explanations
	    this._textureMagFilter = undefined;
	    this._textureMinFilter = undefined;
	    this._textureSize = 256;
	
	    this._receivingStateset = undefined;
	
	    this._casterStateSet = new StateSet();
	    this._casterStateSet.addUniform( Uniform.createFloat1( 0, 'exponent0' ) );
	    this._casterStateSet.addUniform( Uniform.createFloat1( 0, 'exponent1' ) );
	    this._casterStateSet.addUniform( Uniform.createFloat1( 0.005, 'bias' ) );
	
	    this._texelSizeUniform = Uniform.createFloat1( 1.0 / this._textureSize, 'texelSize' );
	    this._casterStateSet.addUniform( this._texelSizeUniform );
	
	    var unifRenderSize = Uniform.createFloat2( 'RenderSize' );
	    this._casterStateSet.addUniform( unifRenderSize );
	    this._renderSize = unifRenderSize.getInternalArray();
	    this._renderSize[ 0 ] = this._renderSize[ 1 ] = this._textureSize;
	
	    // make sure no unintended blend happens
	    // if casting semi-transparent (alphablend material with full opaque pixels) shadow
	    this._casterStateSet.setAttributeAndModes( new Depth( Depth.LESS ), StateAttribute.ON | StateAttribute.OVERRIDE );
	    this._casterStateSet.setAttributeAndModes( new BlendFunc(), StateAttribute.ON | StateAttribute.OVERRIDE );
	
	    this._shadowReceiveAttribute = new ShadowReceiveAttribute( this._light.getLightNumber() );
	    this._casterStateSet.setAttributeAndModes( this._shadowReceiveAttribute, StateAttribute.ON | StateAttribute.OVERRIDE );
	
	    // default name, overridable with shadow settings
	    this._shadowCastShaderGeneratorName = 'ShadowCast';
	
	
	    var near = 0.001;
	    var far = 1000;
	    var unifRange = Uniform.createFloat4( 'Shadow_DepthRange' );
	    this._casterStateSet.addUniform( unifRange );
	    this._depthRange = unifRange.getInternalArray();
	    this._depthRange[ 0 ] = near;
	    this._depthRange[ 1 ] = far;
	    this._depthRange[ 2 ] = far - near;
	    this._depthRange[ 3 ] = 1.0 / ( far - near );
	
	    this._worldLightPos = Vec4.create();
	    this._worldLightPos[ 3 ] = 0;
	    this._worldLightDir = Vec4.create();
	    this._worldLightDir[ 3 ] = 1;
	
	    this._castsShadowDrawTraversalMask = 0xffffffff;
	    this._castsShadowBoundsTraversalMask = 0xffffffff;
	
	
	    this._shaderProcessor = undefined;
	
	    // tmp variables
	    this._tmpVec = Vec3.create();
	    this._tmpVecBis = Vec3.create();
	    this._tmpVecTercio = Vec3.create();
	    this._tmpMatrix = Matrix.create();
	
	    if ( settings )
	        this.setShadowSettings( settings );
	
	    this._computeFrustumBounds = new ShadowFrustumIntersection();
	    this._computeBoundsVisitor = new ComputeBoundsVisitor();
	
	    // Overridable Visitor so that user can override the visitor to enable disable
	    // in its own shadowmap implementation
	    // settings.userShadowCasterVisitor:
	    // - undefined means using default
	    // - false means no removal visitor needed
	    // - otherwise must be an instance of a class inherited from shadowCaster
	    if ( settings.userShadowCasterVisitor !== false ) {
	
	        this._removeNodesNeverCastingVisitor = settings.userShadowCasterVisitor || new ShadowCasterVisitor( this._castsShadowTraversalMask );
	
	    }
	
	    this._infiniteFrustum = true;
	    var shadowStateAttribute = new ShadowCastAttribute( false, this._shadowReceiveAttribute );
	
	    this._casterStateSet.setAttributeAndModes( shadowStateAttribute, StateAttribute.ON | StateAttribute.OVERRIDE );
	    this._casterStateSet.setShaderGeneratorName( this._shadowCastShaderGeneratorName, StateAttribute.OVERRIDE | StateAttribute.ON );
	
	};
	
	
	/** @lends ShadowMap.prototype */
	ShadowMap.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( ShadowTechnique.prototype, {
	
	    getDepthRange: function () {
	        return this._depthRange;
	    },
	    setLightFrustum: function ( lf ) {
	        this._lightFrustum = lf;
	    },
	    getCamera: function () {
	        return this._cameraShadow;
	    },
	
	    getTexture: function () {
	        return this._texture;
	    },
	
	    isDirty: function () {
	        return this._dirty;
	    },
	    /**
	     * at which Texture unit number we start adding texture shadow
	     */
	    setTextureUnitBase: function ( unitBase ) {
	        this._textureUnitBase = unitBase;
	        this._textureUnit = unitBase;
	    },
	
	    /* Sets  shadowSettings
	     */
	    setShadowSettings: function ( shadowSettings ) {
	
	        if ( !shadowSettings )
	            return;
	
	        this._light = shadowSettings.light;
	        this._shadowCastShaderGeneratorName = shadowSettings.getShadowCastShaderGeneratorName();
	
	        this.setCastsShadowDrawTraversalMask( shadowSettings.castsShadowDrawTraversalMask );
	        this.setCastsShadowBoundsTraversalMask( shadowSettings.castsShadowBoundsTraversalMask );
	
	        this.setLight( this._light );
	        this.setTextureSize( shadowSettings.textureSize );
	        this.setTexturePrecision( shadowSettings.textureType );
	
	        this.setFakePCF( shadowSettings.fakePCF );
	        this.setRotateOffset( shadowSettings.rotateOffset );
	        this.setKernelSizePCF( shadowSettings.kernelSizePCF );
	        this.setAlgorithm( shadowSettings.algorithm );
	        this.setBias( shadowSettings.bias );
	        this.setExponent0( shadowSettings.exponent );
	        this.setExponent1( shadowSettings.exponent1 );
	        this.setEpsilonVSM( shadowSettings.epsilonVSM );
	
	
	    },
	
	    setCastsShadowDrawTraversalMask: function ( mask ) {
	        this._castsShadowDrawTraversalMask = mask;
	    },
	
	    getCastsShadowDrawTraversalMask: function () {
	        return this._castsDrawShadowTraversalMask;
	    },
	
	    setCastsShadowBoundsTraversalMask: function ( mask ) {
	        this._castsShadowBoundsTraversalMask = mask;
	    },
	
	    getCastsShadowBoundsTraversalMask: function () {
	        return this._castsShadowBoundsTraversalMask;
	    },
	
	
	    getBias: function () {
	        return this._shadowReceiveAttribute.getBias();
	    },
	
	    setBias: function ( value ) {
	        this._shadowReceiveAttribute.setBias( value );
	        this._casterStateSet.getUniformList()[ 'bias' ].getUniform().setFloat( value );
	    },
	
	    getExponent0: function () {
	        return this._shadowReceiveAttribute.getExponent0();
	    },
	
	    setExponent0: function ( value ) {
	        this._shadowReceiveAttribute.setExponent0( value );
	        this._casterStateSet.getUniformList()[ 'exponent0' ].getUniform().setFloat( value );
	    },
	
	    getExponent1: function () {
	        return this._shadowReceiveAttribute.getExponent1();
	    },
	
	    setExponent1: function ( value ) {
	        this._shadowReceiveAttribute.setExponent1( value );
	        this._casterStateSet.getUniformList()[ 'exponent1' ].getUniform().setFloat( value );
	    },
	
	    getEpsilonVSM: function () {
	        return this._shadowReceiveAttribute.getEpsilonVSM();
	    },
	
	    setEpsilonVSM: function ( value ) {
	        this._shadowReceiveAttribute.setEpsilonVSM( value );
	    },
	
	    getKernelSizePCF: function () {
	        return this._shadowReceiveAttribute.getKernelSizePCF();
	    },
	
	    setKernelSizePCF: function ( value ) {
	        this._shadowReceiveAttribute.setKernelSizePCF( value );
	    },
	
	    getFakePCF: function () {
	        return this._shadowReceiveAttribute.getFakePCF();
	    },
	
	    setFakePCF: function ( value ) {
	        if ( this._shadowReceiveAttribute.getFakePCF() !== value ) {
	            this._shadowReceiveAttribute.setFakePCF( value );
	            this.setTextureFiltering();
	        }
	    },
	
	    getRotateOffset: function () {
	        return this._shadowReceiveAttribute.getRotateOffset();
	    },
	
	    setRotateOffset: function ( value ) {
	        if ( this._shadowReceiveAttribute.getRotateOffset() !== value ) {
	            this._shadowReceiveAttribute.setRotateOffset( value );
	        }
	    },
	
	    setShadowedScene: function ( shadowedScene ) {
	        ShadowTechnique.prototype.setShadowedScene.call( this, shadowedScene );
	        this._receivingStateset = this._shadowedScene.getReceivingStateSet();
	        this.dirty();
	    },
	
	    checkLightNumber: function () {
	        var lightNumber = this._light.getLightNumber();
	
	        // if light number changed we need to remove cleanly
	        // attributes from receiveStateSet
	        // it's because it use a typemember like light attribute
	        // so the number if very important to keep State clean
	        if ( this._shadowReceiveAttribute.getLightNumber() !== lightNumber ) {
	            if ( this._receivingStateset.getAttribute( this._shadowReceiveAttribute.getTypeMember() ) === this._shadowReceiveAttribute )
	                this._receivingStateset.removeAttribute( this._shadowReceiveAttribute.getTypeMember() );
	        }
	
	
	
	        if ( this._texture && this._texture.getLightUnit() !== lightNumber ) {
	            // remove this._texture, but not if it's not this._texture
	            if ( this._receivingStateset.getTextureAttribute( this._textureUnit, this._texture.getTypeMember() ) === this._texture )
	                this._receivingStateset.removeTextureAttribute( this._textureUnit, this._texture.getTypeMember() );
	        }
	
	    },
	
	    /** initialize the ShadowedScene and local cached data structures.*/
	    init: function () {
	
	        if ( !this._shadowedScene ) return;
	
	        this._filledOnce = false;
	
	        this.checkLightNumber();
	
	        if ( !this._cameraShadow ) {
	            this._cameraShadow = new Camera();
	            this._cameraShadow.setCullCallback( new CameraCullCallback( this ) );
	            this._cameraShadow.setRenderOrder( Camera.PRE_RENDER, 0 );
	            this._cameraShadow.setReferenceFrame( Transform.ABSOLUTE_RF );
	            this._cameraShadow.setClearColor( Vec4.createAndSet( 1.0, 1.0, 1.0, 1.0 ) );
	        }
	
	        this.initTexture();
	
	        var lightNumber = this._light.getLightNumber();
	        this._textureUnit = this._textureUnitBase + lightNumber;
	        this._cameraShadow.setName( 'light_shadow_camera' + this._light.getName() );
	
	        this._texture.setLightUnit( lightNumber );
	        this._texture.setName( 'ShadowTexture' + this._textureUnit );
	
	        this._shadowReceiveAttribute.setLightNumber( lightNumber );
	
	
	        // Idea is to make sure the null texture is "binded" to all shadow casting scene
	        // so we override all existing texture bind in the scene, preventing any texture bind.
	        // When user implements alpha mask casting, they use PROTECTED to prevent OVERRIDE to remove their alpha mask texture needed.
	        var fullOverride = StateAttribute.OVERRIDE | StateAttribute.ON;
	
	
	        this._receivingStateset.setAttributeAndModes( this._shadowReceiveAttribute, fullOverride );
	
	        // prevent unnecessary texture bindings
	        this._preventTextureBindingDuringShadowCasting();
	
	        // Mandatory: prevent binding shadow textures themselves
	        // ( ShadowedScene StateSet is applied  just above in StateSet hierarchy)
	        // that would mean undefined values as it would be read/write access...
	        // So we force it against Texture.null binding done just above (PROTECTED)
	        // and Prevent any under hierarchy bind with OVERRIDE
	        // must be done AFTER the prevent binding.
	        this._casterStateSet.setTextureAttributeAndModes( this._textureUnit, Texture.textureNull, StateAttribute.PROTECTED );
	
	
	        // add shadow texture to the receivers
	        // should make sure somehow that
	        // alpha blender transparent receiver doesn't use it
	        // compiler wise at least
	        this._receivingStateset.setTextureAttributeAndModes( this._textureUnit, this._texture, fullOverride );
	
	        this._dirty = false;
	    },
	    // Make sure we don't bind texture and thus make GPU work for nothing
	    // as shadow casting just output Depth ( no color )
	    // os we set a null texture and OVERRIDE StateAttribute flag
	    // only case you want to use a texture is
	    // alpha masked material, then you have StateAttribute to 'PROTECTED'
	    _preventTextureBindingDuringShadowCasting: function () {
	
	        // prevent unnecessary texture bindings on all texture unit
	        var shouldGetMaxTextureUnits = WebGLCaps.instance().getWebGLParameter( 'MAX_TEXTURE_IMAGE_UNITS' );
	        for ( var k = 0; k < shouldGetMaxTextureUnits; k++ ) {
	            // bind  null texture which OSGJS will not bind,
	            // effectively preventing any other texture bind
	            // just not touching texture unit state.
	            this._casterStateSet.setTextureAttributeAndModes( k, Texture.textureNull, StateAttribute.OVERRIDE | StateAttribute.ON );
	        }
	
	    },
	    valid: function () {
	        // checks
	        return true;
	    },
	
	    updateShadowTechnique: function ( /*nv*/) {
	
	        var camera = this._cameraShadow;
	        var texture = this._texture;
	
	        if ( camera && texture ) {
	
	            var vp = camera.getViewport();
	            if ( !vp ) {
	                vp = new Viewport();
	                camera.setViewport( vp );
	            }
	
	            // if texture size changed update the camera rtt params
	            if ( vp.width() !== texture.getWidth() ||
	                vp.height() !== texture.getHeight() ) {
	
	                camera.detachAll();
	
	                camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture );
	                camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );
	
	                camera.getViewport().setViewport( 0, 0, texture.getWidth(), texture.getHeight() );
	            }
	        }
	    },
	
	    updateShadowTechnic: function ( /*nv*/) {
	        Notify.log( 'ShadowMap.updateShadowTechnic() is deprecated, use updateShadowTechnique instead' );
	        this.updateShadowTechnique();
	    },
	
	    setTextureFiltering: function () {
	
	        var textureType, texFilterMin, texFilterMag;
	        var texType = this.getTexturePrecision();
	        if ( this._texture ) {
	            // see shadowSettings.js header
	            switch ( this.getAlgorithm() ) {
	            case 'ESM':
	            case 'VSM':
	            case 'EVSM':
	                texFilterMin = Texture.LINEAR;
	                texFilterMag = Texture.LINEAR;
	                break;
	
	            default:
	            case 'PCF':
	            case 'NONE':
	                if ( this.getFakePCF() ) {
	                    texFilterMin = Texture.LINEAR;
	                    texFilterMag = Texture.LINEAR;
	
	                    // // TODO try anisotropy with better biaspcf
	                    // texFilterMin = Texture.LINEAR_MIPMAP_LINEAR;
	                    // texFilterMag = Texture.LINEAR_MIPMAP_LINEAR;
	                    // this._texture.setMaxAnisotropy( 16 );
	
	
	                } else {
	                    texFilterMin = Texture.NEAREST;
	                    texFilterMag = Texture.NEAREST;
	                }
	                break;
	            }
	
	            switch ( texType ) {
	            case 'HALF_FLOAT':
	                textureType = Texture.HALF_FLOAT;
	                texFilterMin = Texture.NEAREST;
	                texFilterMag = Texture.NEAREST;
	                break;
	            case 'HALF_FLOAT_LINEAR':
	                textureType = Texture.HALF_FLOAT;
	                texFilterMin = Texture.LINEAR;
	                texFilterMag = Texture.LINEAR;
	                break;
	            case 'FLOAT':
	                textureType = Texture.FLOAT;
	                texFilterMin = Texture.NEAREST;
	                texFilterMag = Texture.NEAREST;
	                break;
	            case 'FLOAT_LINEAR':
	                textureType = Texture.FLOAT;
	                texFilterMin = Texture.LINEAR;
	                texFilterMag = Texture.LINEAR;
	                break;
	            default:
	            case 'UNSIGNED_BYTE':
	                textureType = Texture.UNSIGNED_BYTE;
	                break;
	            }
	        }
	
	        this._texture.setInternalFormatType( textureType );
	        this._texture.setMinFilter( texFilterMin );
	        this._texture.setMagFilter( texFilterMag );
	        this._textureMagFilter = texFilterMag;
	        this._textureMinFilter = texFilterMin;
	
	    },
	
	    // internal texture allocation
	    // handle any change like resize, filter param, etc.
	    initTexture: function () {
	
	        if ( !this._dirty ) return;
	
	        if ( !this._texture ) {
	            this._texture = new ShadowTexture();
	            this._textureUnit = this._textureUnitBase;
	        }
	
	
	        this._texture.setTextureSize( this._textureSize, this._textureSize );
	        this._texelSizeUniform.setFloat( 1.0 / this._textureSize );
	        this._renderSize[ 0 ] = this._textureSize;
	        this._renderSize[ 1 ] = this._textureSize;
	
	        var textureFormat;
	        // luminance Float format ?
	        textureFormat = Texture.RGBA;
	
	        this.setTextureFiltering();
	        this._texture.setInternalFormat( textureFormat );
	
	        this._texture.setWrapS( Texture.CLAMP_TO_EDGE );
	        this._texture.setWrapT( Texture.CLAMP_TO_EDGE );
	
	        this._texture.dirty();
	
	    },
	    setTexturePrecision: function ( format ) {
	        if ( format === this._shadowReceiveAttribute.getPrecision() ) return;
	
	        this._shadowReceiveAttribute.setPrecision( format );
	        this.dirty();
	    },
	
	    getTexturePrecision: function () {
	        return this._shadowReceiveAttribute.getPrecision();
	    },
	
	    setTextureSize: function ( mapSize ) {
	
	        if ( mapSize === this._textureSize ) return;
	
	        this._textureSize = mapSize;
	
	        this.dirty();
	    },
	
	    setAlgorithm: function ( algo ) {
	
	        if ( algo === this.getAlgorithm() ) return;
	        this._shadowReceiveAttribute.setAlgorithm( algo );
	        this.dirty();
	    },
	
	    getAlgorithm: function () {
	        return this._shadowReceiveAttribute.getAlgorithm();
	    },
	
	    setLight: function ( light ) {
	
	        if ( !light || light === this._light )
	            return;
	
	        this._light = light;
	        this.dirty();
	    },
	
	    getUp: function ( dir ) {
	        //avoid dir/up wrong angle breaking computation
	
	        // compute a up vector ensuring avoiding parallel vectors
	        // also might reverting to it once got the change here done once
	        // Vec3.createAndSet( 0.0, 0.0, 1.0 );
	
	        if ( Math.abs( Vec3.dot( this._lightUp, dir ) ) >= 1.0 ) {
	            // another camera up
	            // Vec3.createAndSet( 1.0, 0.0, 0.0 );
	            if ( this._lightUp[ 0 ] === 1.0 ) {
	                this._lightUp[ 0 ] = 0.0;
	                this._lightUp[ 1 ] = 1.0;
	                this._lightUp[ 2 ] = 0.0;
	            } else {
	                this._lightUp[ 0 ] = 1.0;
	                this._lightUp[ 1 ] = 0.0;
	                this._lightUp[ 2 ] = 0.0;
	            }
	        }
	        return this._lightUp;
	    },
	
	    // makes sure we don't have incorrect near/far
	    // or we actually have to render something.
	    // Empty or Bad Frustums
	    // No objects, handle it gracefully
	    nearFarBounding: function () {
	
	        var zNear = this._depthRange[ 0 ];
	        var zFar = this._depthRange[ 1 ];
	
	        var epsilon = ShadowMap.EPSILON;
	        if ( zFar < zNear - epsilon ) {
	            // early out
	            this._emptyCasterScene = true;
	            zFar = 1;
	            zNear = epsilon;
	        } else if ( zNear < epsilon ) {
	            zNear = epsilon;
	        }
	
	        var nearFarRatio = 0.005;
	        if ( zNear < zFar * nearFarRatio ) {
	            zNear = zFar * nearFarRatio;
	        }
	
	        this._depthRange[ 0 ] = zNear;
	        this._depthRange[ 1 ] = zFar;
	    },
	
	    makePerspectiveFromBoundingBox: function ( bbox, fov, eyePos, eyeDir, view, projection ) {
	        var center = bbox.center( this._tmpVec );
	        var radius = bbox.radius();
	        var epsilon = ShadowMap.EPSILON;
	        var zNear = epsilon;
	        var zFar = 1.0;
	
	        Vec3.copy( eyeDir, this._tmpVecBis );
	        Vec3.neg( this._tmpVecBis, this._tmpVecBis );
	        Vec3.normalize( this._tmpVecBis, this._tmpVecBis );
	
	        // light Near Plane Equation
	        // E = eyeDir + d
	        var d = Vec3.dot( eyePos, this._tmpVecBis );
	        // then distance to center point of sphere
	        // perpendicular to lightdir
	        var distance = Vec3.dot( center, this._tmpVecBis ) + d;
	
	        // inside or not have unfluence
	        // on using radius for fov
	        if ( distance < -radius ) {
	            // won't render anything the object  is behind..
	            this._emptyCasterScene = true;
	        } else if ( distance <= 0.0 ) {
	            // shhh.. we're inside !
	            // sphere center is behind
	            zNear = epsilon;
	            zFar = distance + radius;
	        } else if ( distance < radius ) {
	            // shhh.. we're inside !
	            // sphere center is in front
	            zNear = epsilon;
	            zFar = distance + radius;
	        } else {
	            //  Sphere totally in front
	            // long distance runner
	            // we must make a nicer zNear here!
	            zNear = distance - radius;
	            zFar = distance + radius;
	        }
	
	        this._depthRange[ 0 ] = zNear;
	        this._depthRange[ 1 ] = zFar;
	        this.nearFarBounding();
	
	        // positional light: spot, point, area
	        //  fov < 180.0
	        // statically defined by spot, only needs zNear zFar estimates
	        var fovRadius = this._depthRange[ 0 ] * Math.tan( fov * Math.PI / 180.0 );
	        // if scene radius is smaller than fov on scene
	        // Tighten and enhance precision
	        fovRadius = fovRadius > radius ? radius : fovRadius;
	
	        var ymax = fovRadius;
	        var ymin = -ymax;
	
	        var xmax = fovRadius;
	        var xmin = -xmax;
	
	        var up = this.getUp( eyeDir );
	
	        if ( this._infiniteFrustum ) {
	            Matrix.makeFrustumInfinite( xmin, xmax, ymin, ymax, this._depthRange[ 0 ], this._depthRange[ 1 ], projection );
	        } else {
	            Matrix.makeFrustum( xmin, xmax, ymin, ymax, this._depthRange[ 0 ], this._depthRange[ 1 ], projection );
	        }
	
	        Matrix.makeLookFromDirection( eyePos, eyeDir, up, view );
	    },
	
	    makeOrthoFromBoundingBox: function ( bbox, eyeDir, view, projection ) {
	
	        var center = bbox.center( this._tmpVecTercio );
	
	        var radius = bbox.radius();
	        var diameter = radius + radius;
	
	        var zNear = 0.0001;
	        var zFar = diameter + 0.0001;
	
	        // compute eye Pos from a inverted lightDir Ray shot from center of bbox
	        // firs make a RAY
	        var ray = this._tmpVecBis;
	        Vec3.mult( eyeDir, -diameter, ray );
	        // then move the eye to the that far pos following the ray
	        var eyePos = this._tmpVec;
	        Vec3.add( center, ray, eyePos );
	
	        zNear = radius;
	        zFar += radius;
	
	        var zNearRatio = 0.001;
	        if ( zNear < zFar * zNearRatio ) {
	            zNear = zFar * zNearRatio;
	        }
	
	        var up = this.getUp( eyeDir );
	        Matrix.makeLookFromDirection( eyePos, eyeDir, up, view );
	
	        var right, top;
	        top = radius;
	        right = top;
	        Matrix.makeOrtho( -right, right, -top, top, zNear, zFar, projection );
	
	        this._depthRange[ 0 ] = zNear;
	        this._depthRange[ 1 ] = zFar;
	
	    },
	    /*
	     * Sync camera and light vision so that
	     * shadow map render using a camera whom
	     * settings come from the light
	     * and the scene being shadowed
	     */
	    aimShadowCastingCamera: function ( cullVisitor, frustumBound ) {
	
	        var light = this._light;
	
	        if ( !light ) {
	            this._emptyCasterScene = true;
	            return;
	        }
	
	        var camera = this._cameraShadow;
	
	        var worldLightPos = this._worldLightPos;
	        var worldLightDir = this._worldLightDir;
	
	        // make sure it's not modified outside our computations
	        // camera matrix can be modified by cullvisitor afterwards...
	        Matrix.copy( camera.getProjectionMatrix(), this._projectionMatrix );
	        Matrix.copy( camera.getViewMatrix(), this._viewMatrix );
	        var projection = this._projectionMatrix;
	        var view = this._viewMatrix;
	
	        // inject camera world matrix.
	        // from light current world/pos and camera eye pos.
	        // inject camera world matrix.
	        // from light current world/pos
	        // NEED same camera eye pos
	        var positionedAttribute = cullVisitor.getCurrentRenderBin().getPositionedAttribute();
	
	        var lightMatrix;
	        positionedAttribute = positionedAttribute.find( function ( element ) {
	            if ( element.length > 0 && element[ 1 ] === light ) {
	                lightMatrix = element[ 0 ];
	                return true;
	            }
	            return false;
	        } );
	        if ( lightMatrix === undefined ) {
	            Notify.warn( 'light isnt inside children of shadowedScene Node' );
	            this._emptyCasterScene = true;
	            return;
	        }
	
	        var eyeToWorld = this._tmpMatrix;
	        Matrix.inverse( cullVisitor.getCurrentModelViewMatrix(), eyeToWorld );
	
	        //  light pos & lightTarget in World Space
	        if ( light.getPosition()[ 3 ] !== 0.0 && light.getSpotCutoff() < 180 ) {
	            //TODO: check when spot light is camera attached?
	            Matrix.mult( eyeToWorld, lightMatrix, this._tmpMatrix );
	            var worldMatrix = this._tmpMatrix;
	            // same code as light spot shader
	            Matrix.transformVec3( worldMatrix, light.getPosition(), worldLightPos );
	            worldMatrix[ 12 ] = 0;
	            worldMatrix[ 13 ] = 0;
	            worldMatrix[ 14 ] = 0;
	            Matrix.inverse( worldMatrix, worldMatrix );
	            Matrix.transpose( worldMatrix, worldMatrix );
	
	            // not a directionnal light, compute the world light dir
	            Vec3.copy( light.getDirection(), worldLightDir );
	            Matrix.transformVec4( worldMatrix, worldLightDir, worldLightDir );
	            Vec3.normalize( worldLightDir, worldLightDir );
	
	            // and compute a perspective frustum
	            this.makePerspectiveFromBoundingBox( frustumBound, light.getSpotCutoff(), worldLightPos, worldLightDir, view, projection );
	        } else {
	            Matrix.transformVec4( lightMatrix, light.getPosition(), worldLightPos );
	            Matrix.transformVec4( eyeToWorld, worldLightPos, worldLightPos );
	            // same code as light sun shader
	            // lightpos is a light dir
	            // so we now have to normalize
	            // since the transform to world above
	            Vec3.mult( worldLightPos, -1.0, worldLightPos );
	            Vec3.normalize( worldLightPos, worldLightPos );
	            this.makeOrthoFromBoundingBox( frustumBound, worldLightPos, view, projection );
	        }
	
	        Matrix.copy( this._projectionMatrix, camera.getProjectionMatrix() );
	        Matrix.copy( this._viewMatrix, camera.getViewMatrix() );
	
	        // set values now
	        this.setShadowUniformsDepthValue();
	
	    },
	
	    // culling is done,
	    // now try for a the tightest frustum
	    // possible for shadowcasting
	    frameShadowCastingFrustum: function ( cullVisitor ) {
	
	        if ( !this._infiniteFrustum ) {
	            this.nearFarBounding();
	            Matrix.clampProjectionMatrix( this._projectionMatrix, this._depthRange[ 0 ], this._depthRange[ 1 ], cullVisitor.getNearFarRatio(), this._depthRange );
	            this.setShadowUniformsDepthValue();
	        }
	
	        // overwrite any cullvisitor wrongness
	        var camera = this._cameraShadow;
	        Matrix.copy( this._projectionMatrix, camera.getProjectionMatrix() );
	        Matrix.copy( this._viewMatrix, camera.getViewMatrix() );
	
	    },
	
	    setShadowUniformsDepthValue: function () {
	
	        this.nearFarBounding();
	
	        // set values now
	        this._depthRange[ 2 ] = this._depthRange[ 1 ] - this._depthRange[ 0 ];
	        this._depthRange[ 3 ] = 1.0 / ( this._depthRange[ 2 ] );
	
	        var castUniforms = this._casterStateSet.getUniformList();
	        castUniforms[ 'Shadow_DepthRange' ].getUniform().setVec4( this._depthRange );
	
	        this._texture.setViewMatrix( this._viewMatrix );
	        this._texture.setProjectionMatrix( this._projectionMatrix );
	        this._texture.setDepthRange( this._depthRange );
	
	    },
	
	    noDraw: function () {
	
	        this._depthRange[ 0 ] = 0.0;
	        this._depthRange[ 1 ] = 0.0;
	        this._depthRange[ 2 ] = 0.0;
	        this._depthRange[ 3 ] = 0.0;
	
	        var castUniforms = this._casterStateSet.getUniformList();
	
	        castUniforms[ 'Shadow_DepthRange' ].getUniform().setVec4( this._depthRange );
	        this._texture.setDepthRange( this._depthRange );
	
	        var camera = this._cameraShadow;
	
	        // make sure it's not modified outside our computations
	        // camera matrix can be modified by cullvisitor afterwards...
	        Matrix.copy( camera.getProjectionMatrix(), this._projectionMatrix );
	        Matrix.copy( camera.getViewMatrix(), this._viewMatrix );
	
	        this._texture.setViewMatrix( this._viewMatrix );
	        this._texture.setProjectionMatrix( this._projectionMatrix );
	
	        this._filledOnce = true;
	    },
	
	    // Defines the frustum from light param.
	    //
	    cullShadowCasting: function ( cullVisitor ) {
	
	        var bbox;
	
	        if ( this._removeNodesNeverCastingVisitor ) {
	
	            this._removeNodesNeverCastingVisitor.setNoCastMask( ~( this._castsShadowBoundsTraversalMask | this._castsShadowDrawTraversalMask ) );
	            this._removeNodesNeverCastingVisitor.reset();
	            this.getShadowedScene().accept( this._removeNodesNeverCastingVisitor );
	
	        }
	
	        this._computeBoundsVisitor.setTraversalMask( this._castsShadowBoundsTraversalMask );
	        this._computeBoundsVisitor.reset();
	        this.getShadowedScene().accept( this._computeBoundsVisitor );
	        bbox = this._computeBoundsVisitor.getBoundingBox();
	
	        if ( !bbox.valid() ) {
	
	            // nothing to draw Early out.
	            this.noDraw();
	
	            if ( this._removeNodesNeverCastingVisitor ) {
	
	                // remove our flags changes on any bitmask
	                // not to break things
	                this._removeNodesNeverCastingVisitor.restore();
	
	            }
	
	            return;
	
	        }
	
	        // HERE we get the shadowedScene Current World Matrix
	        // to get any world transform ABOVE the shadowedScene
	        var worldMatrix = cullVisitor.getCurrentModelWorldMatrix();
	        // it does fuck up the results.
	        Matrix.transformBoundingBox( worldMatrix, bbox, bbox );
	
	        this._emptyCasterScene = false;
	        this.aimShadowCastingCamera( cullVisitor, bbox );
	
	        if ( this._emptyCasterScene ) {
	            // nothing to draw Early out.
	            //console.log( 'shadow early OUT' );
	            this.noDraw();
	
	            if ( this._removeNodesNeverCastingVisitor ) {
	
	                // remove our flags changes on any bitmask
	                // not to break things
	                this._removeNodesNeverCastingVisitor.restore();
	
	            }
	
	            return;
	        }
	
	
	        // get renderer to make the cull program
	        // record the traversal mask on entry so we can reapply it later.
	        var traversalMask = cullVisitor.getTraversalMask();
	
	        cullVisitor.setTraversalMask( this._castsShadowDrawTraversalMask );
	
	        // cast geometries into depth shadow map
	        cullVisitor.pushStateSet( this._casterStateSet );
	
	        this._cameraShadow.setEnableFrustumCulling( true );
	        // enabling this makes for strange projection fuck up
	        // (as in clamped too tight projection)
	        var needNearFar = this._castsShadowDrawTraversalMask === this._castsShadowBoundsTraversalMask;
	        this._cameraShadow.setComputeNearFar( needNearFar );
	
	
	        // do RTT from the camera traversal mimicking light pos/orient
	        this._cameraShadow.accept( cullVisitor );
	
	        // Here culling is done, we do have near/far.
	        // and cull/non-culled info
	        // if we wanted a tighter frustum.
	        if ( needNearFar ) {
	            this.frameShadowCastingFrustum( cullVisitor );
	        }
	
	
	        // enabling this makes for strange projection fuck up
	        // (as in clamped too tight projection)
	        this._cameraShadow.setComputeNearFar( false );
	
	        if ( this._removeNodesNeverCastingVisitor ) {
	
	            // remove our flags changes on any bitmask
	            // not to break things
	            this._removeNodesNeverCastingVisitor.restore();
	
	        }
	
	        cullVisitor.popStateSet();
	
	        // reapply the original traversal mask
	        cullVisitor.setTraversalMask( traversalMask );
	        this._filledOnce = true;
	    },
	
	    cleanReceivingStateSet: function () {
	        if ( this._receivingStateset ) {
	
	            if ( this._texture ) {
	                // remove this._texture, but not if it's not this._texture
	                if ( this._receivingStateset.getTextureAttribute( this._textureUnit, this._texture.getTypeMember() ) === this._texture )
	                    this._receivingStateset.removeTextureAttribute( this._textureUnit, this._texture.getTypeMember() );
	            }
	
	            if ( this._receivingStateset.getAttribute( this._shadowReceiveAttribute.getTypeMember() ) === this._shadowReceiveAttribute )
	                this._receivingStateset.removeAttribute( this._shadowReceiveAttribute.getTypeMember() );
	        }
	
	    },
	    cleanSceneGraph: function () {
	        // well release a lot more things when it works
	        this._cameraShadow = undefined;
	        this._filledOnce = false;
	
	
	        this.cleanReceivingStateSet();
	
	        // TODO: need state
	        //this._texture.releaseGLObjects();
	        //this._shadowReceiveAttribute = undefined;
	        this._texture = undefined;
	        this._shadowedScene = undefined;
	    }
	
	} ), 'osgShadow', 'ShadowMap' );
	
	ShadowMap.EPSILON = 5e-3;
	
	MACROUTILS.setTypeID( ShadowMap );
	
	module.exports = ShadowMap;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var StateAttribute = __webpack_require__( 21 );
	var Uniform = __webpack_require__( 35 );
	var Map = __webpack_require__( 20 );
	var Notify = __webpack_require__( 10 );
	
	
	/**
	 * ShadowReceiveAttribute encapsulate Shadow Main State object
	 * @class ShadowReceiveAttribute
	 * @inherits StateAttribute
	 */
	var ShadowReceiveAttribute = function ( lightNum, disable ) {
	    StateAttribute.call( this );
	
	    this._lightNumber = lightNum;
	
	
	    // see shadowSettings.js header for shadow algo param explanations
	    // hash change var
	    this._algoType = 'NONE';
	
	    // shadow depth bias as projected in shadow camera space texture
	    // and viewer camera space projection introduce its bias
	    this._bias = 0.001;
	    // algo dependant
	    // Exponential shadow maps use exponential
	    // to allows fuzzy depth
	    this._exponent0 = 0.001;
	    this._exponent1 = 0.001;
	    // Variance Shadow mapping use One more epsilon
	    this._epsilonVSM = 0.001;
	    // shader compilation different upon texture precision
	    this._precision = 'UNSIGNED_BYTE';
	    // kernel size & type for pcf
	    this._kernelSizePCF = undefined;
	
	    this._fakePCF = true;
	
	    this._rotateOffset = false;
	
	    this._enable = !disable;
	
	};
	
	ShadowReceiveAttribute.uniforms = {};
	ShadowReceiveAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {
	
	    attributeType: 'ShadowReceive',
	
	    cloneType: function () {
	        return new ShadowReceiveAttribute( this._lightNumber, true );
	    },
	
	    getTypeMember: function () {
	        return this.attributeType + this.getLightNumber();
	    },
	
	    getLightNumber: function () {
	        return this._lightNumber;
	    },
	
	    getUniformName: function ( name ) {
	        var prefix = this.getType() + this.getLightNumber().toString();
	        return prefix + '_uniform_' + name;
	    },
	
	    getRotateOffset: function () {
	        return this._rotateOffset;
	    },
	
	    setRotateOffset: function ( v ) {
	        this._rotateOffset = v;
	    },
	
	    setAlgorithm: function ( algo ) {
	        this._algoType = algo;
	    },
	
	    getAlgorithm: function () {
	        return this._algoType;
	    },
	
	    setBias: function ( bias ) {
	        this._bias = bias;
	    },
	
	    getBias: function () {
	        return this._bias;
	    },
	
	    setExponent0: function ( exp ) {
	        this._exponent0 = exp;
	    },
	
	    getExponent0: function () {
	        return this._exponent0;
	    },
	
	    setExponent1: function ( exp ) {
	        this._exponent1 = exp;
	    },
	
	    getExponent1: function () {
	        return this._exponent1;
	    },
	
	    setEpsilonVSM: function ( epsilon ) {
	        this._epsilonVSM = epsilon;
	    },
	
	    getEpsilonVSM: function () {
	        return this._epsilonVSM;
	    },
	
	    getKernelSizePCF: function () {
	        return this._kernelSizePCF;
	    },
	
	    setKernelSizePCF: function ( v ) {
	        this._kernelSizePCF = v;
	    },
	
	    getFakePCF: function () {
	        return this._fakePCF;
	    },
	
	    setFakePCF: function ( v ) {
	        this._fakePCF = v;
	    },
	
	    setPrecision: function ( precision ) {
	        this._precision = precision;
	    },
	
	    getPrecision: function () {
	        return this._precision;
	    },
	
	    setLightNumber: function ( lightNum ) {
	        this._lightNumber = lightNum;
	    },
	
	    getOrCreateUniforms: function () {
	        // uniform are once per CLASS attribute, not per instance
	        var obj = ShadowReceiveAttribute;
	
	        var typeMember = this.getTypeMember();
	
	        if ( obj.uniforms[ typeMember ] ) return obj.uniforms[ typeMember ];
	
	        // Variance Shadow mapping use One more epsilon
	        var uniformList = {
	            bias: 'createFloat',
	            exponent0: 'createFloat',
	            exponent1: 'createFloat',
	            epsilonVSM: 'createFloat'
	        };
	
	        var uniforms = {};
	
	        window.Object.keys( uniformList ).forEach( function ( key ) {
	
	            var type = uniformList[ key ];
	            var func = Uniform[ type ];
	            uniforms[ key ] = func( this.getUniformName( key ) );
	
	        }.bind( this ) );
	
	        obj.uniforms[ typeMember ] = new Map( uniforms );
	
	        return obj.uniforms[ typeMember ];
	    },
	
	    getExtensions: function () {
	        var algo = this.getAlgorithm();
	        if ( algo === 'PCF' ) {
	            return [ '#extension GL_OES_standard_derivatives : enable' ];
	        }
	        return [];
	    },
	
	    // Here to be common between  caster and receiver
	    // (used by shadowMap and shadow node shader)
	    getDefines: function () {
	
	        var textureType = this.getPrecision();
	        var algo = this.getAlgorithm();
	        var defines = [];
	
	        var isFloat = false;
	        var isLinearFloat = false;
	
	        if ( textureType !== 'UNSIGNED_BYTE' )
	            isFloat = true;
	
	        if ( isFloat && ( textureType === 'HALF_FLOAT_LINEAR' || textureType === 'FLOAT_LINEAR' ) )
	            isLinearFloat = true;
	
	
	        if ( algo === 'ESM' ) {
	            defines.push( '#define _ESM' );
	        } else if ( algo === 'NONE' ) {
	            defines.push( '#define _NONE' );
	        } else if ( algo === 'PCF' ) {
	            defines.push( '#define _PCF' );
	            var pcf = this.getKernelSizePCF();
	
	            if ( this._fakePCF ) {
	                defines.push( '#define _FAKE_PCF 1' );
	            }
	
	            switch ( pcf ) {
	            case '4Poisson(16texFetch)':
	                defines.push( '#define _POISSON_PCF' );
	                defines.push( '#define _PCFx4' );
	                break;
	            case '8Poisson(32texFetch)':
	                defines.push( '#define _POISSON_PCF' );
	                defines.push( '#define _PCFx9' );
	                break;
	            case '16Poisson(64texFetch)':
	                defines.push( '#define _POISSON_PCF' );
	                defines.push( '#define _PCFx16' );
	                break;
	            case '25Poisson(100texFetch)':
	                defines.push( '#define _POISSON_PCF' );
	                defines.push( '#define _PCFx25' );
	                break;
	            case '32Poisson(128texFetch)':
	                defines.push( '#define _POISSON_PCF' );
	                defines.push( '#define _PCFx32' );
	                break;
	            case '1Band(1texFetch)':
	                defines.push( '#define _NONE' );
	                defines.push( '#define _PCFx1' );
	                break;
	            case '4Band(4texFetch)':
	                defines.push( '#define _BAND_PCF' );
	                defines.push( '#define _PCFx4' );
	                break;
	            case '9Band(9texFetch)':
	                defines.push( '#define _BAND_PCF' );
	                defines.push( '#define _PCFx9' );
	                break;
	            case '16Band(16texFetch)':
	                defines.push( '#define _BAND_PCF' );
	                defines.push( '#define _PCFx16' );
	                break;
	            case '4Tap(16texFetch)':
	                defines.push( '#define _TAP_PCF' );
	                defines.push( '#define _PCFx4' );
	                break;
	            case '9Tap(36texFetch)':
	                defines.push( '#define _TAP_PCF' );
	                defines.push( '#define _PCFx9' );
	                break;
	            case '16Tap(64texFetch)':
	                defines.push( '#define _TAP_PCF' );
	                defines.push( '#define _PCFx25' );
	                break;
	            default:
	            case '1Tap(4texFetch)':
	                defines.push( '#define _TAP_PCF' );
	                defines.push( '#define _PCFx1' );
	                break;
	            }
	        } else if ( algo === 'VSM' ) {
	            defines.push( '#define _VSM' );
	        } else if ( algo === 'EVSM' ) {
	            defines.push( '#define _EVSM' );
	        }
	
	        if ( isFloat ) {
	            defines.push( '#define _FLOATTEX' );
	        }
	
	        if ( isLinearFloat ) {
	            defines.push( '#define _FLOATLINEAR' );
	        }
	
	        if ( this.getRotateOffset() ) {
	            defines.push( '#define _ROTATE_OFFSET' );
	        }
	
	        return defines;
	    },
	
	    apply: function () {
	
	        if ( !this._enable ) return;
	
	        var uniformMap = this.getOrCreateUniforms();
	
	        uniformMap.bias.setFloat( this._bias );
	        uniformMap.exponent0.setFloat( this._exponent0 );
	        uniformMap.exponent1.setFloat( this._exponent1 );
	        uniformMap.epsilonVSM.setFloat( this._epsilonVSM );
	
	    },
	
	    // need a isEnabled to let the ShaderGenerator to filter
	    // StateAttribute from the shader compilation
	    isEnabled: function () {
	        return this._enable;
	    },
	
	    // Deprecated methods, should be removed in the future
	    isEnable: function () {
	        Notify.log( 'ShadowAttribute.isEnable() is deprecated, use isEnabled() instead' );
	        return this.isEnabled();
	    },
	
	    getHash: function () {
	        return this.getTypeMember() + '_' + this.getAlgorithm() + '_' + this.getKernelSizePCF() + '_' + this.getFakePCF() + '_' + this.getRotateOffset();
	
	    }
	
	} ), 'osgShadow', 'ShadowReceiveAttribute' );
	
	MACROUTILS.setTypeID( ShadowReceiveAttribute );
	
	module.exports = ShadowReceiveAttribute;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Notify = __webpack_require__( 10 );
	var Object = __webpack_require__( 13 );
	var MACROUTILS = __webpack_require__( 6 );
	
	/**
	 *  ShadowTechnique provides an implementation interface of shadow techniques.
	 *  @class ShadowTechnique
	 */
	var ShadowTechnique = function () {
	    Object.call( this );
	
	    this._shadowedScene = undefined;
	    this._dirty = false;
	    // need to be computed
	    this._enabled = true;
	    // since dirtied, handy for static shadow map
	    this._filledOnce = false;
	};
	
	/** @lends ShadowTechnique.prototype */
	ShadowTechnique.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {
	
	    dirty: function () {
	        this._dirty = true;
	    },
	
	    getShadowedScene: function () {
	        return this._shadowedScene;
	    },
	
	    setEnabled: function ( enabled ) {
	        this._enabled = enabled;
	    },
	
	    isEnabled: function () {
	        return this._enabled;
	    },
	    // Deprecated methods, should be removed in the future
	    getEnable: function () {
	        Notify.log( 'ShadowTechnique.getEnable() is deprecated, use isEnabled instead' );
	        return this.isEnabled();
	    },
	    setEnable: function ( enabled ) {
	        Notify.log( 'ShadowTechnique.setEnable() is deprecated, use setEnabled instead' );
	        this.setEnabled( enabled );
	    },
	    isFilledOnce: function () {
	        return this._filledOnce;
	    },
	
	    requestRedraw: function () {
	        this._filledOnce = false;
	    },
	
	    setShadowedScene: function ( shadowedScene ) {
	        this._shadowedScene = shadowedScene;
	    },
	
	    init: function () {
	        // well shouldn't be called
	        Notify.log( 'No ShadowTechnique activated: normal rendering activated' );
	    },
	
	    valid: function () {
	        // make sure abstract class not used.
	        return false;
	    },
	
	
	    // update the technic
	    updateShadowTechnique: function ( /*nodeVisitor*/) {},
	
	    cullShadowCasting: function ( /*cullVisitor*/) {},
	
	    cleanSceneGraph: function () {
	        // well shouldn't be called
	        Notify.log( 'No ShadowTechnique activated: normal rendering activated' );
	    }
	
	} ), 'osgShadow', 'ShadowTechnique' );
	
	
	MACROUTILS.setTypeID( ShadowTechnique );
	
	module.exports = ShadowTechnique;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Map = __webpack_require__( 20 );
	var Notify = __webpack_require__( 10 );
	var Texture = __webpack_require__( 34 );
	var Uniform = __webpack_require__( 35 );
	var MACROUTILS = __webpack_require__( 6 );
	var Vec4 = __webpack_require__( 25 );
	
	
	/**
	 * ShadowTexture Attribute encapsulate Texture webgl object
	 * with Shadow specificities (no need of texcoord,fragtexcoord)
	 * trigger hash change when changing texture precision from float to byt
	 * shadowSettings.js header for param explanations
	 * @class ShadowTexture
	 * @inherits StateAttribute
	 */
	var ShadowTexture = function () {
	    Texture.call( this );
	    this._uniforms = {};
	    this._mapSize = Vec4.create();
	    this._lightUnit = -1; // default for a valid cloneType
	};
	
	ShadowTexture.uniforms = {};
	/** @lends Texture.prototype */
	ShadowTexture.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Texture.prototype, {
	
	    cloneType: function () {
	        return new ShadowTexture();
	    },
	
	    setLightUnit: function ( lun ) {
	        this._lightUnit = lun;
	    },
	    getLightUnit: function () {
	        return this._lightUnit;
	    },
	
	    getUniformName: function ( name ) {
	        var prefix = 'Shadow_' + this.getType() + this._lightUnit.toString();
	        return prefix + '_uniform_' + name;
	    },
	
	    getVaryingName: function ( name ) {
	        var prefix = this.getType() + this._lightUnit.toString();
	        return prefix + '_varying_' + name;
	    },
	
	    getOrCreateUniforms: function ( unit ) {
	        // uniform are once per CLASS attribute, not per instance
	        var obj = ShadowTexture;
	
	        Notify.assert( unit !== undefined );
	        Notify.assert( this._lightUnit !== -1 );
	
	        if ( obj.uniforms[ unit ] !== undefined ) return obj.uniforms[ unit ];
	
	        var uniformList = {
	            'ViewMatrix': 'createMat4',
	            'ProjectionMatrix': 'createMat4',
	            'DepthRange': 'createFloat4',
	            'MapSize': 'createFloat4'
	        };
	
	        var uniforms = {};
	
	        window.Object.keys( uniformList ).forEach( function ( key ) {
	
	            var type = uniformList[ key ];
	            var func = Uniform[ type ];
	            uniforms[ key ] = func( this.getUniformName( key ) );
	
	        }.bind( this ) );
	
	        // Dual Uniform of texture, needs:
	        // - Sampler (type of texture)
	        // - Int (texture unit)
	        // tells Shader Program where to find it
	        var name = 'Texture' + unit;
	        var uniform = Uniform.createInt1( unit, name );
	        uniforms[ name ] = uniform;
	
	        // Per Class Uniform Cache
	        obj.uniforms[ unit ] = new Map( uniforms );
	
	        return obj.uniforms[ unit ];
	    },
	    setViewMatrix: function ( viewMatrix ) {
	        this._viewMatrix = viewMatrix;
	    },
	
	    setProjectionMatrix: function ( projectionMatrix ) {
	        this._projectionMatrix = projectionMatrix;
	    },
	
	    setDepthRange: function ( depthRange ) {
	        this._depthRange = depthRange;
	    },
	
	    setTextureSize: function ( w, h ) {
	        Texture.prototype.setTextureSize.call( this, w, h );
	        this.dirty();
	        this._mapSize[ 0 ] = w;
	        this._mapSize[ 1 ] = h;
	        this._mapSize[ 2 ] = 1.0 / w;
	        this._mapSize[ 3 ] = 1.0 / h;
	    },
	
	    apply: function ( state, texUnit ) {
	
	        // Texture stuff: call parent class method
	        Texture.prototype.apply.call( this, state, texUnit );
	
	        if ( this._lightUnit === -1 )
	            return;
	
	        // update Uniforms
	        var uniformMap = this.getOrCreateUniforms( texUnit );
	        uniformMap.ViewMatrix.setMatrix4( this._viewMatrix );
	        uniformMap.ProjectionMatrix.setMatrix4( this._projectionMatrix );
	        uniformMap.DepthRange.setFloat4( this._depthRange );
	        uniformMap.MapSize.setFloat4( this._mapSize );
	
	    },
	
	    getHash: function () {
	        return this.getTypeMember() + '_' + this._lightUnit + '_' + this._type;
	    }
	
	} ), 'osgShadow', 'ShadowTexture' );
	
	MACROUTILS.setTypeID( ShadowTexture );
	
	module.exports = ShadowTexture;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MACROUTILS = __webpack_require__( 6 );
	var Texture = __webpack_require__( 34 );
	
	var kernelSizeList = [ '1Band(1texFetch)', '4Band(4texFetch)', '9Band(9texFetch)', '16Band(16texFetch)', '1Tap(4texFetch)', '4Tap(16texFetch)', '9Tap(36texFetch)', '16Tap(64texFetch)', '4Poisson(16texFetch)', '8Poisson(32texFetch)', '16Poisson(64texFetch)', '25Poisson(100texFetch)', '32Poisson(128texFetch)' ];
	
	/**
	 *  ShadowSettings provides the parameters that the ShadowTechnique should use as a guide for setting up shadowing
	 *  @class ShadowSettings
	 */
	var ShadowSettings = function ( options ) {
	
	    this.castsShadowDrawTraversalMask = 0xffffffff;
	    this.castsShadowBoundsTraversalMask = 0xffffffff;
	
	    this.textureSize = 1024;
	
	    // important note:
	    // comparison shadow is: DepthShadow > DephFragment => shadowed
	    // which is d<z
	    // and
	    // Average( (d < z) ) != (Average( z ) < d)
	    // so PCF/NONE technique cannot be prefiltered (bilinear, etc..) with HW filter
	    // on gl/dx desktop there is a sampler2DShadow that allows that taking z in third param
	    // we emulate that with texture2DShadowLerp
	    // which is why some techniques have more texfetch than advertized.
	    // http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html
	
	    // texture precision. (and bandwith implication)
	    this.textureType = 'UNSIGNED_BYTE';
	
	    this.textureFormat = Texture.RGBA;
	
	    // either orthogonal (non-fov) or perpsective (fov)
	    this.shadowProjection = 'fov';
	    // fov size: can be infered from spotlight angle
	    this.fov = 50;
	
	    // PCF algo and kernel size
	    // Band kernelsize gives nxn texFetch
	    // others a n*n*4 (emulating the HW shadowSampler)
	    // '4Band(4texFetch)', '9Band(9texFetch)', '16Band(16texFetch)', '4Tap(16texFetch)', '9Tap(36texFetch)', '16Tap(64texFetch)', '4Poisson(16texFetch)', '8Poisson(32texFetch)', '16Poisson(64texFetch)', '25Poisson(100texFetch)', '32Poisson(128texFetch)'
	    this.kernelSizePCF = '4Band(4texFetch)';
	    // ensure that we don't linearly interpolate between shadowmap
	    // but do use the fake Texture2DShadow
	    // http://codeflow.org/entries/2013/feb/15/soft-shadow-mapping/#interpolated-shadowing
	    this._fakePCF = false;
	    //
	    this._rotateOffset = false;
	    // for prefilterable technique (ESM/VSM/EVSM)
	    this.superSample = 0;
	    this.blur = false;
	    this.blurKernelSize = 4.0;
	    this.blurTextureSize = 256;
	
	    // VSM bias
	    this.epsilonVSM = 0.0008;
	
	    // depth offset (shadow acne / peter panning)
	    this.bias = 0.005;
	
	
	    // Impact on shadow aliasing by better coverage
	    // algo for shadow
	    //'Variance Shadow Map (VSM)': 'VSM',
	    //'Exponential Variance Shadow Map (EVSM)': 'EVSM',
	    //'Exponential Shadow Map (ESM)': 'ESM',
	    //'Shadow Map': 'NONE',
	    //'Shadow Map Percentage Close Filtering (PCF)': 'PCF'
	    // nice overview here
	    // http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf
	    // ALGO alllowing filtering
	    //
	    // ESM http://research.edm.uhasselt.be/tmertens/papers/gi_08_esm.pdf
	    // http://pixelstoomany.wordpress.com/2008/06/12/a-conceptually-simpler-way-to-derive-exponential-shadow-maps-sample-code/
	    // VSM: http://www.punkuser.net/vsm/
	    // http://lousodrome.net/blog/light/tag/evsm
	    this.algorithm = 'PCF';
	
	    // Exponential techniques variales
	    this.exponent = 40;
	    this.exponent1 = 10;
	
	    // defaut shader generator name for shadow casting
	    this.shadowCastShaderGeneratorName = 'ShadowCast';
	
	    // if url options override url options
	    MACROUTILS.objectMix( this, options );
	};
	
	ShadowSettings.kernelSizeList = kernelSizeList;
	
	ShadowSettings.prototype = {
	
	    setCastsShadowDrawTraversalMask: function ( mask ) {
	        this.castsShadowDrawTraversalMask = mask;
	    },
	    getCastsShadowDrawTraversalMask: function () {
	        return this.castsDrawShadowTraversalMask;
	    },
	
	    setCastsShadowBoundsTraversalMask: function ( mask ) {
	        this.castsShadowBoundsTraversalMask = mask;
	    },
	    getCastsShadowBoundsTraversalMask: function () {
	        return this.castsShadowBoundsTraversalMask;
	    },
	
	    setLight: function ( light ) {
	        this.light = light;
	    },
	    getLight: function () {
	        return this.light;
	    },
	
	    setTextureSize: function ( textureSize ) {
	        this.textureSize = textureSize;
	    },
	    getTextureSize: function () {
	        return this.textureSize;
	    },
	    setTextureType: function ( tt ) {
	        this.textureType = tt;
	    },
	    getTextureType: function () {
	        return this.textureType;
	    },
	    setTextureFormat: function ( tf ) {
	        this.textureFormat = tf;
	    },
	    getTextureFormat: function () {
	        return this.textureFormat;
	    },
	    setAlgorithm: function ( alg ) {
	        this.algorithm = alg;
	    },
	    getAlgorithm: function () {
	        return this.algorithm;
	    },
	    setShadowCastShaderGeneratorName: function ( n ) {
	        this.shadowCastShaderGeneratorName = n;
	    },
	    getShadowCastShaderGeneratorName: function () {
	        return this.shadowCastShaderGeneratorName;
	    }
	
	};
	
	module.exports = ShadowSettings;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var CullVisitor = __webpack_require__( 63 );
	var Matrix = __webpack_require__( 23 );
	var Node = __webpack_require__( 12 );
	var NodeVisitor = __webpack_require__( 22 );
	var StateSet = __webpack_require__( 19 );
	var MACROUTILS = __webpack_require__( 6 );
	var Vec4 = __webpack_require__( 25 );
	
	
	/**
	 *  ShadowedScene provides a mechanism for decorating a scene that the needs to have shadows cast upon it.
	 *  @class ShadowedScene
	 *  @{@link [http://trac.openscenegraph.org/projects/osg//wiki/Support/ProgrammingGuide/osgShadow]}
	 *  @{@link [http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf]};
	 */
	var ShadowedScene = function () {
	    Node.call( this );
	
	    // TODO: all  techniques (stencil/projTex/map/vol)
	    this._shadowTechniques = [];
	
	    this._optimizedFrustum = false;
	
	    this._frustumReceivers = [ Vec4.create(), Vec4.create(), Vec4.create(), Vec4.create(), Vec4.create(), Vec4.create() ];
	
	    this._tmpMat = Matrix.create();
	
	    this._receivingStateset = new StateSet();
	
	};
	
	/** @lends ShadowedScene.prototype */
	ShadowedScene.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {
	
	    getReceivingStateSet: function () {
	
	        return this._receivingStateset;
	
	    },
	
	    getShadowTechniques: function () {
	        return this._shadowTechniques;
	    },
	
	    addShadowTechnique: function ( technique ) {
	        if ( this._shadowTechniques.length > 0 ) {
	            if ( this._shadowTechniques.indexOf( technique ) !== -1 ) return;
	        }
	
	        this._shadowTechniques.push( technique );
	
	        if ( technique.valid() ) {
	            technique.setShadowedScene( this );
	            technique.dirty();
	        }
	    },
	    removeShadowTechnique: function ( technique ) {
	
	        if ( this._shadowTechniques.length > 0 ) {
	            var idx = this._shadowTechniques.indexOf( technique );
	            if ( idx !== -1 ) {
	
	                if ( this._shadowTechniques[ idx ].valid() ) {
	                    this._shadowTechniques[ idx ].cleanSceneGraph();
	                }
	                this._shadowTechniques.splice( idx, 1 );
	            }
	        }
	    },
	    /** Clean scene graph from any shadow technique specific nodes, state and drawables.*/
	    cleanSceneGraph: function () {
	        for ( var i = 0, lt = this._shadowTechniques.length; i < lt; i++ ) {
	            if ( this._shadowTechniques[ i ] && this._shadowTechniques[ i ].valid() ) {
	                this._shadowTechniques[ i ].cleanSceneGraph();
	            }
	        }
	    },
	
	    /** Dirty any cache data structures held in the attached ShadowTechnique.*/
	    dirty: function () {
	        for ( var i = 0; i < this._shadowTechniques.length; i++ )
	            this._shadowTechniques[ i ].dirty();
	    },
	
	    nodeTraverse: function ( /*nv*/) {
	        Node.prototype.traverse.apply( this, arguments );
	    },
	    traverse: function ( nv ) {
	
	
	        if ( nv.getVisitorType() === NodeVisitor.UPDATE_VISITOR ) {
	
	            // update the scene
	            this.nodeTraverse( nv );
	
	        } else if ( nv.getVisitorType() === NodeVisitor.CULL_VISITOR ) {
	
	            // cull Shadowed Scene
	            this.cullShadowReceivingScene( nv );
	
	            var i, st, lt = this._shadowTechniques.length;
	            // cull Casters
	            for ( i = 0; i < lt; i++ ) {
	                st = this._shadowTechniques[ i ];
	                // dirty check for user playing with shadows inside update traverse
	                if ( st && st.valid() ) {
	
	                    // those two checks
	                    // here
	                    // in case people update it from
	                    // any update/cull/callback
	                    if ( st.isDirty() )
	                        st.init();
	
	                    if ( st.isEnabled() || !st.isFilledOnce() ) {
	                        st.updateShadowTechnique( nv );
	                        st.cullShadowCasting( nv );
	                    }
	                }
	            }
	
	        } else {
	            this.nodeTraverse( nv );
	        }
	    },
	
	    /*receiving shadows, cull normally, but with receiving shader/state set/texture*/
	    cullShadowReceivingScene: function ( cullVisitor ) {
	
	        // What to do here... we want to draw all scene object, not only receivers ?
	        // so no mask for now
	        //var traversalMask = cullVisitor.getTraversalMask();
	        //cullVisitor.setTraversalMask( this.getReceivesShadowTraversalMask() );
	
	        cullVisitor.pushStateSet( this._receivingStateset );
	        this.nodeTraverse( cullVisitor );
	        cullVisitor.popStateSet();
	
	    }
	
	
	} ), 'osgShadow', 'ShadowedScene' );
	MACROUTILS.setTypeID( ShadowedScene );
	
	// same code like Node
	CullVisitor.prototype[ ShadowedScene.typeID ] = CullVisitor.prototype[ Node.typeID ];
	
	module.exports = ShadowedScene;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Text = __webpack_require__( 129 );
	
	var osgText = {};
	osgText.Text = Text;
	
	module.exports = osgText;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var osg = __webpack_require__( 126 );
	var osgAnimation = __webpack_require__( 127 );
	var osgText = __webpack_require__( 128 );
	
	var osgWrappers = {};
	
	osgWrappers.osg = osg;
	osgWrappers.osgAnimation = osgAnimation;
	osgWrappers.osgText = osgText;
	
	module.exports = osgWrappers;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	
	// add missing class for phantom js execution context
	if ( window.HTMLVideoElement === undefined ) {
	    // dummy class
	    window.HTMLVideoElement = function () {};
	}
	
	var OSG = __webpack_require__( 1 );
	var osgBenchmarks = __webpack_require__( 240 );
	OSG.osg.setNotifyLevel( OSG.osg.ERROR );
	
	// hack because of osgPool
	OSG.osg.init();
	
	osgBenchmarks();


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var MainPerformance = __webpack_require__( 241 );
	var Geometry = __webpack_require__( 285 );
	var Visitor = __webpack_require__( 286 );
	
	
	module.exports = function () {
	
	    suite( 'MainPerformance' );
	    MainPerformance();
	
	    suite( 'Visitor' );
	    Visitor();
	
	    suite( 'Geometry' );
	    Geometry();
	
	};


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var mockup = __webpack_require__( 242 );
	var Matrix = __webpack_require__( 23 );
	var Node = __webpack_require__( 12 );
	var Timer = __webpack_require__( 9 );
	var Viewer = __webpack_require__( 215 );
	var reportStats = __webpack_require__( 283 );
	var mockupBench = __webpack_require__( 284 );
	
	module.exports = function () {
	
	    test( 'CullVisitor Heavy Static Scene', function () {
	
	        var canvas = mockup.createCanvas( true );
	        var viewer = new Viewer( canvas );
	        viewer.setupManipulator();
	        viewer.init();
	        viewer.frame();
	        var cullVisitor = viewer.getCamera().getRenderer().getCullVisitor();
	        var root = new Node();
	
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	
	        mockupBench.addScene( root, 20, false, false );
	
	        var fake = Matrix.create();
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	
	        console.profile();
	        console.time( 'time' );
	        var timed = Timer.instance().tick();
	
	        var nCount = 10;
	        for ( var n = 0; n < nCount; n++ ) {
	
	            cullVisitor.apply( root );
	        }
	
	        timed = Timer.instance().tick() - timed;
	        console.timeEnd( 'time' );
	        console.profileEnd();
	
	
	        reportStats( timed, 'Main CullVisitor Loop scene' );
	
	    } );
	
	    test( 'CullVisitor Heavy Static Scene with Frustum culling (Worst Cases as Scene is Flat) ', function () {
	
	        var canvas = mockup.createCanvas( true );
	        var viewer = new Viewer( canvas );
	        viewer.setupManipulator();
	        viewer.init();
	        viewer.frame();
	        var cullVisitor = viewer.getCamera().getRenderer().getCullVisitor();
	        var root = new Node();
	
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	
	        mockupBench.addScene( root, 20, false, true );
	
	        var fake = Matrix.create();
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	
	        console.profile();
	        console.time( 'time' );
	        var timed = Timer.instance().tick();
	
	        var nCount = 10;
	        for ( var n = 0; n < nCount; n++ ) {
	            //
	            cullVisitor.apply( root );
	        }
	
	
	        timed = Timer.instance().tick() - timed;
	        console.timeEnd( 'time' );
	        console.profileEnd();
	
	        reportStats( timed, 'Main CullVisitor Loop scene + culling' );
	
	    } );
	
	    test( 'CullVisitor Heavy Static Scene with 1 light And Shadows ', function () {
	
	        var canvas = mockup.createCanvas( true );
	        var viewer = new Viewer( canvas );
	        viewer.setupManipulator();
	        viewer.init();
	        viewer.frame();
	        var cullVisitor = viewer.getCamera().getRenderer().getCullVisitor();
	        var root = new Node();
	
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	
	        mockupBench.addScene( root, 20, true, true );
	
	        var fake = Matrix.create();
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	        //            viewer.setSceneData( root );
	        //          viewer.getCamera().addChild( root );
	        // dreaded camera no modelview end
	
	
	        console.profile();
	        console.time( 'time' );
	        var timed = Timer.instance().tick();
	
	        var nCount = 10;
	        for ( var n = 0; n < nCount; n++ ) {
	            //
	            cullVisitor.apply( root );
	        }
	
	        timed = Timer.instance().tick() - timed;
	        console.timeEnd( 'time' );
	        console.profileEnd();
	
	
	        reportStats( timed, 'Main CullVisitor Loop scene + shadow Loop' );
	
	    } );
	
	    test( 'Draw Pass ', function () {
	
	        var canvas = mockup.createCanvas( true );
	        var viewer = new Viewer( canvas );
	        viewer.setupManipulator();
	        viewer.init();
	        viewer.frame();
	        var cullVisitor = viewer.getCamera().getRenderer().getCullVisitor();
	        var root = new Node();
	
	
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	
	        mockupBench.addScene( root, 20, true, true );
	
	        viewer.setSceneData( root );
	
	        var fake = Matrix.create();
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	
	        // first frame for warm start
	        // shadercompil and averaged stuff
	        for ( var k = 0; k < 10; k++ ) {
	            viewer.frame();
	        }
	
	        viewer.beginFrame();
	
	        viewer.advance();
	        viewer._updateVisitor.setFrameStamp( viewer.getFrameStamp() );
	
	        viewer.getCamera().getRenderer().cull();
	
	        console.profile();
	        console.time( 'time' );
	        var timed = Timer.instance().tick();
	
	
	        var nCount = 20;
	        for ( var n = 0; n < nCount; n++ ) {
	            viewer.getCamera().getRenderer().draw();
	        }
	
	        timed = Timer.instance().tick() - timed;
	        console.timeEnd( 'time' );
	        console.profileEnd();
	
	        reportStats( timed, 'Draw' );
	    } );
	
	    test( 'Full Frame ', function () {
	
	        var canvas = mockup.createCanvas( true );
	        var viewer = new Viewer( canvas );
	        viewer.setupManipulator();
	        viewer.init();
	        viewer.frame();
	        var cullVisitor = viewer.getCamera().getRenderer().getCullVisitor();
	        var root = new Node();
	
	
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	        cullVisitor.pushModelViewMatrix( Matrix.create() );
	
	        mockupBench.addScene( root, 20, true, true );
	
	        viewer.setSceneData( root );
	
	        var fake = Matrix.create();
	        // dreaded camera no modelview
	        cullVisitor.pushProjectionMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	        cullVisitor.pushModelViewMatrix( fake );
	
	        // first frame for warm start
	        // shadercompil and averaged stuff
	        for ( var k = 0; k < 10; k++ ) {
	            viewer.frame();
	        }
	
	        console.profile();
	        console.time( 'time' );
	
	        var nCount = 20;
	        var s = Timer.instance().tick();
	        for ( var n = 0; n < nCount; n++ ) {
	            viewer.frame();
	        }
	        var result = Timer.instance().tick() - s;
	
	        console.timeEnd( 'time' );
	        console.profileEnd();
	
	        reportStats( result, 'perf Frame' );
	
	    } );
	};


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var chai = __webpack_require__( 243 );
	
	var getScene = __webpack_require__( 281 );
	var getBoxScene = __webpack_require__( 282 );
	var Channel = __webpack_require__( 111 );
	var Animation = __webpack_require__( 110 );
	var UpdateMatrixTransform = __webpack_require__( 76 );
	var StackedRotateAxis = __webpack_require__( 121 );
	var StackedScale = __webpack_require__( 122 );
	var StackedQuaternion = __webpack_require__( 120 );
	var StackedTranslate = __webpack_require__( 123 );
	var StackedMatrix = __webpack_require__( 119 );
	
	
	var isNumber = function ( a ) {
	    return typeof a === 'number';
	};
	
	chai.assert.equalVector = function ( actual, expected, message, thresh ) {
	
	    var threshold = thresh;
	    var msg = message;
	
	    if ( isNumber( message ) ) threshold = message;
	    if ( typeof thresh === 'string' ) msg = thresh;
	
	    if ( threshold === undefined ) threshold = 1e-5;
	
	    var obj = new chai.Assertion( actual );
	    var a = actual;
	    var e = expected;
	    var bool = true;
	
	    var diff = [];
	    for ( var i = 0; i < a.length; ++i ) {
	        var number = isNumber( a[ i ] ) && isNumber( e[ i ] );
	        var val = Math.abs( a[ i ] - e[ i ] );
	        diff[ i ] = val;
	        if ( val > threshold || number === false ) {
	            bool = false;
	        }
	    }
	
	    obj.assert( bool,
	        msg + '\nexpected [ ' + actual + '] approximate to [ ' + expected + ' ]\ndiff > threshold ' + threshold + '\n' + diff.join( '\n' ) );
	    return bool;
	};
	
	var checkNear = function ( a, b, threshold ) {
	    return chai.assert.equalVector( a, b, '', threshold );
	};
	
	
	var createFakeRenderer = function () {
	    return {
	        TEXTURE0: 10,
	        DEPTH_TEST: 1,
	        CULL_FACE: 0,
	        UNSIGNED_SHORT: 0,
	        HIGH_FLOAT: 0,
	        FRAGMENT_SHADER: 0,
	        TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
	        TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
	        TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
	        TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
	        TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
	        TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
	        MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,
	        UNPACK_FLIP_Y_WEBGL: 0,
	        drawElements: function () {},
	        createBuffer: function () {},
	        deleteBuffer: function () {},
	
	
	        blendColor: function () {},
	        enable: function () {},
	        disable: function () {},
	        depthFunc: function () {},
	        pixelStorei: function () {},
	        depthRange: function () {},
	        depthMask: function () {},
	        deleteTexture: function () {},
	        activeTexture: function () {},
	        bindTexture: function () {},
	        bufferData: function () {},
	        bindBuffer: function () {},
	        blendFunc: function () {},
	        getExtension: function () {},
	        getShaderPrecisionFormat: function () {
	            return {
	                precision: 1
	            };
	        },
	        getSupportedExtensions: function () {
	            return {};
	        },
	        enableVertexAttribArray: function () {},
	        vertexAttribPointer: function () {},
	        createTexture: function () {},
	        createFramebuffer: function () {
	            return 1;
	        },
	        deleteFramebuffer: function () {},
	        bindFramebuffer: function () {},
	        framebufferTexture2D: function () {},
	        checkFramebufferStatus: function () {
	            return 0x8CD5;
	        },
	        createRenderbuffer: function () {
	            return 1;
	        },
	        deleteRenderbuffer: function () {},
	        bindRenderbuffer: function () {},
	        renderbufferStorage: function () {},
	        framebufferRenderbuffer: function () {},
	        clear: function () {},
	        viewport: function () {},
	        cullFace: function () {},
	        texImage2D: function () {},
	        texParameteri: function () {},
	        createShader: function () {
	            return 1;
	        },
	        deleteShader: function () {},
	        shaderSource: function () {},
	        compileShader: function () {},
	        getShaderParameter: function () {
	            return true;
	        },
	        isContextLost: function () {
	            return false;
	        },
	        getShaderInfoLog: function () {},
	        createProgram: function () {
	            return {};
	        },
	        deleteProgram: function () {},
	        attachShader: function () {},
	        validateProgram: function () {},
	        linkProgram: function () {},
	        getParameter: function () {},
	        getProgramParameter: function () {
	            return true;
	        },
	        getProgramInfoLog: function () {},
	        getUniformLocation: function () {
	            return 0;
	        },
	        getAttribLocation: function () {
	            return 0;
	        },
	        useProgram: function () {},
	        uniformMatrix4fv: function () {},
	        uniform1fv: function () {},
	        uniform4fv: function () {},
	        uniform3fv: function () {},
	        uniform1iv: function () {},
	        canvas: {
	            clientWidth: 300,
	            clientHeight: 300
	        }
	
	    };
	};
	
	var createFakeWebGLCanvas = function () {
	    var obj = {
	        addEventListener: function () {},
	        getContext: function () {
	            return createFakeRenderer();
	        },
	        style: {
	            width: 300
	        },
	        getAttribute: function () {
	            return 0;
	        }
	    };
	    return obj;
	};
	
	var createVec3Keyframes = function () {
	    var keys = [
	        1, 1, 1,
	        0, 0, 0,
	        3, 3, 3
	    ];
	    var times = [ 0, 1, 2 ];
	    return Channel.createVec3Channel( keys, times );
	};
	
	var createFloatKeyframes = function () {
	    var keys = [
	        1, 0, 3
	    ];
	
	    var start = 0;
	    if ( arguments.length > 0 ) // offset time keyframes
	        start = arguments[ 0 ];
	
	    var times = [ start + 0, start + 1, start + 2 ];
	    return Channel.createFloatChannel( keys, times );
	};
	
	var createFloatCubicBezierKeyframes = function () {
	    var keys = [
	        1, 2, 3,
	        0, 1, 3,
	        3, 4, 5
	    ];
	    var times = [ 0, 1, 2 ];
	    return Channel.createFloatCubicBezierChannel( keys, times );
	};
	
	var createVec3CubicBezierKeyframes = function () {
	    var keys = [
	        1, 1, 1,
	        2, 2, 2,
	        5, 5, 5,
	
	        6, 6, 6,
	        9, 9, 9,
	        8, 8, 8,
	
	        6, 6, 6,
	        6, 6, 6,
	        6, 6, 6
	    ];
	    var times = [ 0, 1, 2 ];
	    return Channel.createVec3CubicBezierChannel( keys, times );
	};
	
	var createQuatLerpKeyFrames = function () {
	    var keys = [ 1.22465e-16, 1.22465e-16, 1.22465e-16, -1,
	        0.300706, 7.99708e-17, 1.53623e-16, -0.953717,
	        0.382683, 6.62774e-17, 1.60008e-16, -0.92388,
	        0.382683, 6.62774e-17, 1.60008e-16, -0.92388,
	        0.126911, -0.0991929, 0.119115, -0.979727
	    ];
	
	    var times = [ 0, 0.202899, 0.456522, 1.21739, 1.47101 ];
	    return Channel.createQuatChannel( keys, times );
	};
	
	
	var createAnimation = function ( name, target1, target2 ) {
	
	    var a = createFloatKeyframes();
	    a.target = target1 || 'a';
	    a.name = 'rotateX';
	
	    var b = createFloatKeyframes( 2 );
	    b.target = target2 || 'b';
	    b.name = 'rotateY';
	
	    return Animation.createAnimation( [ a, b ], name );
	};
	
	var createAnimationWithNegativeKey = function ( name, target1, target2 ) {
	
	    var a = createFloatKeyframes( -10 );
	    a.target = target1 || 'a';
	    a.name = 'rotateX';
	
	    var b = createFloatKeyframes( 10 );
	    b.target = target2 || 'b';
	    b.name = 'rotateY';
	
	    return Animation.createAnimation( [ a, b ], name );
	};
	
	var stackedElement = {
	    translate: StackedTranslate,
	    rotate: StackedRotateAxis,
	    rotateX: StackedRotateAxis,
	    rotateY: StackedRotateAxis,
	    rotateZ: StackedRotateAxis,
	    matrix: StackedMatrix,
	    scale: StackedScale,
	    quat: StackedQuaternion
	};
	
	var createAnimationUpdateCallback = function ( animations ) {
	    var cbMap = {};
	
	    for ( var a = 0; a < animations.length; a++ ) {
	        var animation = animations[ a ];
	        for ( var i = 0; i < animation.channels.length; i++ ) {
	            var channel = animation.channels[ i ];
	
	            var target = channel.target;
	            var name = channel.name;
	
	            var ucb = cbMap[ target ];
	            if ( !ucb ) {
	                cbMap[ target ] = new UpdateMatrixTransform();
	                ucb = cbMap[ target ];
	                ucb.setName( target );
	            }
	            var stacked = ucb.getStackedTransforms();
	            var st = new stackedElement[ name ]( name );
	            stacked.push( st );
	        }
	    }
	    return cbMap;
	};
	
	var createCanvas = function ( noGL ) {
	
	    // mockup for phantomjs or benchmarks
	    if ( noGL || navigator.userAgent.indexOf( 'PhantomJS' ) !== -1 ) {
	        return createFakeWebGLCanvas();
	    }
	
	    var parent = document.body;
	
	    var t = '' + ( new Date() ).getTime();
	    var cnv = '<canvas id=\'' + t + '\'></canvas>';
	
	    var mydiv = document.createElement( 'div' );
	    mydiv.setAttribute( 'id', 'div_' + t );
	    mydiv.innerHTML = cnv;
	    parent.appendChild( mydiv );
	    return document.getElementById( t );
	};
	
	var removeCanvas = function ( canvas ) {
	    if ( !canvas ) return;
	    var id = canvas.getAttribute( 'id' );
	    var parent = document.getElementById( 'div_' + id );
	    if ( !parent )
	        return;
	    parent.removeChild( canvas );
	};
	
	module.exports = {
	    checkNear: checkNear,
	    createFakeRenderer: createFakeRenderer,
	    removeCanvas: removeCanvas,
	    createCanvas: createCanvas,
	    createVec3Keyframes: createVec3Keyframes,
	    createFloatKeyframes: createFloatKeyframes,
	    createFloatCubicBezierKeyframes: createFloatCubicBezierKeyframes,
	    createVec3CubicBezierKeyframes: createVec3CubicBezierKeyframes,
	    createQuatLerpKeyFrames: createQuatLerpKeyFrames,
	    createAnimation: createAnimation,
	    createAnimationWithNegativeKey: createAnimationWithNegativeKey,
	    createAnimationUpdateCallback: createAnimationUpdateCallback,
	    getBoxScene: getBoxScene,
	    getScene: getScene
	};


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(244);


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	var used = []
	  , exports = module.exports = {};
	
	/*!
	 * Chai version
	 */
	
	exports.version = '3.5.0';
	
	/*!
	 * Assertion Error
	 */
	
	exports.AssertionError = __webpack_require__(245);
	
	/*!
	 * Utils for plugins (not exported)
	 */
	
	var util = __webpack_require__(246);
	
	/**
	 * # .use(function)
	 *
	 * Provides a way to extend the internals of Chai
	 *
	 * @param {Function}
	 * @returns {this} for chaining
	 * @api public
	 */
	
	exports.use = function (fn) {
	  if (!~used.indexOf(fn)) {
	    fn(this, util);
	    used.push(fn);
	  }
	
	  return this;
	};
	
	/*!
	 * Utility Functions
	 */
	
	exports.util = util;
	
	/*!
	 * Configuration
	 */
	
	var config = __webpack_require__(259);
	exports.config = config;
	
	/*!
	 * Primary `Assertion` prototype
	 */
	
	var assertion = __webpack_require__(276);
	exports.use(assertion);
	
	/*!
	 * Core Assertions
	 */
	
	var core = __webpack_require__(277);
	exports.use(core);
	
	/*!
	 * Expect interface
	 */
	
	var expect = __webpack_require__(278);
	exports.use(expect);
	
	/*!
	 * Should interface
	 */
	
	var should = __webpack_require__(279);
	exports.use(should);
	
	/*!
	 * Assert interface
	 */
	
	var assert = __webpack_require__(280);
	exports.use(assert);


/***/ }),
/* 245 */
/***/ (function(module, exports) {

	/*!
	 * assertion-error
	 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Return a function that will copy properties from
	 * one object to another excluding any originally
	 * listed. Returned function will create a new `{}`.
	 *
	 * @param {String} excluded properties ...
	 * @return {Function}
	 */
	
	function exclude () {
	  var excludes = [].slice.call(arguments);
	
	  function excludeProps (res, obj) {
	    Object.keys(obj).forEach(function (key) {
	      if (!~excludes.indexOf(key)) res[key] = obj[key];
	    });
	  }
	
	  return function extendExclude () {
	    var args = [].slice.call(arguments)
	      , i = 0
	      , res = {};
	
	    for (; i < args.length; i++) {
	      excludeProps(res, args[i]);
	    }
	
	    return res;
	  };
	};
	
	/*!
	 * Primary Exports
	 */
	
	module.exports = AssertionError;
	
	/**
	 * ### AssertionError
	 *
	 * An extension of the JavaScript `Error` constructor for
	 * assertion and validation scenarios.
	 *
	 * @param {String} message
	 * @param {Object} properties to include (optional)
	 * @param {callee} start stack function (optional)
	 */
	
	function AssertionError (message, _props, ssf) {
	  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
	    , props = extend(_props || {});
	
	  // default values
	  this.message = message || 'Unspecified AssertionError';
	  this.showDiff = false;
	
	  // copy from properties
	  for (var key in props) {
	    this[key] = props[key];
	  }
	
	  // capture stack trace
	  ssf = ssf || arguments.callee;
	  if (ssf && Error.captureStackTrace) {
	    Error.captureStackTrace(this, ssf);
	  } else {
	    try {
	      throw new Error();
	    } catch(e) {
	      this.stack = e.stack;
	    }
	  }
	}
	
	/*!
	 * Inherit from Error.prototype
	 */
	
	AssertionError.prototype = Object.create(Error.prototype);
	
	/*!
	 * Statically set name
	 */
	
	AssertionError.prototype.name = 'AssertionError';
	
	/*!
	 * Ensure correct constructor
	 */
	
	AssertionError.prototype.constructor = AssertionError;
	
	/**
	 * Allow errors to be converted to JSON for static transfer.
	 *
	 * @param {Boolean} include stack (default: `true`)
	 * @return {Object} object that can be `JSON.stringify`
	 */
	
	AssertionError.prototype.toJSON = function (stack) {
	  var extend = exclude('constructor', 'toJSON', 'stack')
	    , props = extend({ name: this.name }, this);
	
	  // include stack if exists and not turned off
	  if (false !== stack && this.stack) {
	    props.stack = this.stack;
	  }
	
	  return props;
	};


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Main exports
	 */
	
	var exports = module.exports = {};
	
	/*!
	 * test utility
	 */
	
	exports.test = __webpack_require__(247);
	
	/*!
	 * type utility
	 */
	
	exports.type = __webpack_require__(249);
	
	/*!
	 * expectTypes utility
	 */
	exports.expectTypes = __webpack_require__(251);
	
	/*!
	 * message utility
	 */
	
	exports.getMessage = __webpack_require__(252);
	
	/*!
	 * actual utility
	 */
	
	exports.getActual = __webpack_require__(253);
	
	/*!
	 * Inspect util
	 */
	
	exports.inspect = __webpack_require__(254);
	
	/*!
	 * Object Display util
	 */
	
	exports.objDisplay = __webpack_require__(258);
	
	/*!
	 * Flag utility
	 */
	
	exports.flag = __webpack_require__(248);
	
	/*!
	 * Flag transferring utility
	 */
	
	exports.transferFlags = __webpack_require__(260);
	
	/*!
	 * Deep equal utility
	 */
	
	exports.eql = __webpack_require__(261);
	
	/*!
	 * Deep path value
	 */
	
	exports.getPathValue = __webpack_require__(267);
	
	/*!
	 * Deep path info
	 */
	
	exports.getPathInfo = __webpack_require__(268);
	
	/*!
	 * Check if a property exists
	 */
	
	exports.hasProperty = __webpack_require__(269);
	
	/*!
	 * Function name
	 */
	
	exports.getName = __webpack_require__(255);
	
	/*!
	 * add Property
	 */
	
	exports.addProperty = __webpack_require__(270);
	
	/*!
	 * add Method
	 */
	
	exports.addMethod = __webpack_require__(271);
	
	/*!
	 * overwrite Property
	 */
	
	exports.overwriteProperty = __webpack_require__(272);
	
	/*!
	 * overwrite Method
	 */
	
	exports.overwriteMethod = __webpack_require__(273);
	
	/*!
	 * Add a chainable method
	 */
	
	exports.addChainableMethod = __webpack_require__(274);
	
	/*!
	 * Overwrite chainable method
	 */
	
	exports.overwriteChainableMethod = __webpack_require__(275);


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - test utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Module dependancies
	 */
	
	var flag = __webpack_require__(248);
	
	/**
	 * # test(object, expression)
	 *
	 * Test and object for expression.
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @namespace Utils
	 * @name test
	 */
	
	module.exports = function (obj, args) {
	  var negate = flag(obj, 'negate')
	    , expr = args[0];
	  return negate ? !expr : expr;
	};


/***/ }),
/* 248 */
/***/ (function(module, exports) {

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### flag(object, key, [value])
	 *
	 * Get or set a flag value on an object. If a
	 * value is provided it will be set, else it will
	 * return the currently set value or `undefined` if
	 * the value is not set.
	 *
	 *     utils.flag(this, 'foo', 'bar'); // setter
	 *     utils.flag(this, 'foo'); // getter, returns `bar`
	 *
	 * @param {Object} object constructed Assertion
	 * @param {String} key
	 * @param {Mixed} value (optional)
	 * @namespace Utils
	 * @name flag
	 * @api private
	 */
	
	module.exports = function (obj, key, value) {
	  var flags = obj.__flags || (obj.__flags = Object.create(null));
	  if (arguments.length === 3) {
	    flags[key] = value;
	  } else {
	    return flags[key];
	  }
	};


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(250);


/***/ }),
/* 250 */
/***/ (function(module, exports) {

	/*!
	 * type-detect
	 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Primary Exports
	 */
	
	var exports = module.exports = getType;
	
	/**
	 * ### typeOf (obj)
	 *
	 * Use several different techniques to determine
	 * the type of object being tested.
	 *
	 *
	 * @param {Mixed} object
	 * @return {String} object type
	 * @api public
	 */
	var objectTypeRegexp = /^\[object (.*)\]$/;
	
	function getType(obj) {
	  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
	  // Let "new String('')" return 'object'
	  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';
	  // PhantomJS has type "DOMWindow" for null
	  if (obj === null) return 'null';
	  // PhantomJS has type "DOMWindow" for undefined
	  if (obj === undefined) return 'undefined';
	  return type;
	}
	
	exports.Library = Library;
	
	/**
	 * ### Library
	 *
	 * Create a repository for custom type detection.
	 *
	 * ```js
	 * var lib = new type.Library;
	 * ```
	 *
	 */
	
	function Library() {
	  if (!(this instanceof Library)) return new Library();
	  this.tests = {};
	}
	
	/**
	 * #### .of (obj)
	 *
	 * Expose replacement `typeof` detection to the library.
	 *
	 * ```js
	 * if ('string' === lib.of('hello world')) {
	 *   // ...
	 * }
	 * ```
	 *
	 * @param {Mixed} object to test
	 * @return {String} type
	 */
	
	Library.prototype.of = getType;
	
	/**
	 * #### .define (type, test)
	 *
	 * Add a test to for the `.test()` assertion.
	 *
	 * Can be defined as a regular expression:
	 *
	 * ```js
	 * lib.define('int', /^[0-9]+$/);
	 * ```
	 *
	 * ... or as a function:
	 *
	 * ```js
	 * lib.define('bln', function (obj) {
	 *   if ('boolean' === lib.of(obj)) return true;
	 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
	 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
	 *   return !! ~blns.indexOf(obj);
	 * });
	 * ```
	 *
	 * @param {String} type
	 * @param {RegExp|Function} test
	 * @api public
	 */
	
	Library.prototype.define = function(type, test) {
	  if (arguments.length === 1) return this.tests[type];
	  this.tests[type] = test;
	  return this;
	};
	
	/**
	 * #### .test (obj, test)
	 *
	 * Assert that an object is of type. Will first
	 * check natives, and if that does not pass it will
	 * use the user defined custom tests.
	 *
	 * ```js
	 * assert(lib.test('1', 'int'));
	 * assert(lib.test('yes', 'bln'));
	 * ```
	 *
	 * @param {Mixed} object
	 * @param {String} type
	 * @return {Boolean} result
	 * @api public
	 */
	
	Library.prototype.test = function(obj, type) {
	  if (type === getType(obj)) return true;
	  var test = this.tests[type];
	
	  if (test && 'regexp' === getType(test)) {
	    return test.test(obj);
	  } else if (test && 'function' === getType(test)) {
	    return test(obj);
	  } else {
	    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
	  }
	};


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - expectTypes utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### expectTypes(obj, types)
	 *
	 * Ensures that the object being tested against is of a valid type.
	 *
	 *     utils.expectTypes(this, ['array', 'object', 'string']);
	 *
	 * @param {Mixed} obj constructed Assertion
	 * @param {Array} type A list of allowed types for this assertion
	 * @namespace Utils
	 * @name expectTypes
	 * @api public
	 */
	
	var AssertionError = __webpack_require__(245);
	var flag = __webpack_require__(248);
	var type = __webpack_require__(249);
	
	module.exports = function (obj, types) {
	  var obj = flag(obj, 'object');
	  types = types.map(function (t) { return t.toLowerCase(); });
	  types.sort();
	
	  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'
	  var str = types.map(function (t, index) {
	    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
	    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
	    return or + art + ' ' + t;
	  }).join(', ');
	
	  if (!types.some(function (expected) { return type(obj) === expected; })) {
	    throw new AssertionError(
	      'object tested must be ' + str + ', but ' + type(obj) + ' given'
	    );
	  }
	};


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - message composition utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Module dependancies
	 */
	
	var flag = __webpack_require__(248)
	  , getActual = __webpack_require__(253)
	  , inspect = __webpack_require__(254)
	  , objDisplay = __webpack_require__(258);
	
	/**
	 * ### .getMessage(object, message, negateMessage)
	 *
	 * Construct the error message based on flags
	 * and template tags. Template tags will return
	 * a stringified inspection of the object referenced.
	 *
	 * Message template tags:
	 * - `#{this}` current asserted object
	 * - `#{act}` actual value
	 * - `#{exp}` expected value
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @namespace Utils
	 * @name getMessage
	 * @api public
	 */
	
	module.exports = function (obj, args) {
	  var negate = flag(obj, 'negate')
	    , val = flag(obj, 'object')
	    , expected = args[3]
	    , actual = getActual(obj, args)
	    , msg = negate ? args[2] : args[1]
	    , flagMsg = flag(obj, 'message');
	
	  if(typeof msg === "function") msg = msg();
	  msg = msg || '';
	  msg = msg
	    .replace(/#\{this\}/g, function () { return objDisplay(val); })
	    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
	    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });
	
	  return flagMsg ? flagMsg + ': ' + msg : msg;
	};


/***/ }),
/* 253 */
/***/ (function(module, exports) {

	/*!
	 * Chai - getActual utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * # getActual(object, [actual])
	 *
	 * Returns the `actual` value for an Assertion
	 *
	 * @param {Object} object (constructed Assertion)
	 * @param {Arguments} chai.Assertion.prototype.assert arguments
	 * @namespace Utils
	 * @name getActual
	 */
	
	module.exports = function (obj, args) {
	  return args.length > 4 ? args[4] : obj._obj;
	};


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	// This is (almost) directly from Node.js utils
	// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js
	
	var getName = __webpack_require__(255);
	var getProperties = __webpack_require__(256);
	var getEnumerableProperties = __webpack_require__(257);
	
	module.exports = inspect;
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
	 *    properties of objects.
	 * @param {Number} depth Depth in which to descend in object. Default is 2.
	 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
	 *    output. Default is false (no coloring).
	 * @namespace Utils
	 * @name inspect
	 */
	function inspect(obj, showHidden, depth, colors) {
	  var ctx = {
	    showHidden: showHidden,
	    seen: [],
	    stylize: function (str) { return str; }
	  };
	  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
	}
	
	// Returns true if object is a DOM element.
	var isDOMElement = function (object) {
	  if (typeof HTMLElement === 'object') {
	    return object instanceof HTMLElement;
	  } else {
	    return object &&
	      typeof object === 'object' &&
	      object.nodeType === 1 &&
	      typeof object.nodeName === 'string';
	  }
	};
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (value && typeof value.inspect === 'function' &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes);
	    if (typeof ret !== 'string') {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // If this is a DOM element, try to get the outer HTML.
	  if (isDOMElement(value)) {
	    if ('outerHTML' in value) {
	      return value.outerHTML;
	      // This value does not have an outerHTML attribute,
	      //   it could still be an XML element
	    } else {
	      // Attempt to serialize it
	      try {
	        if (document.xmlVersion) {
	          var xmlSerializer = new XMLSerializer();
	          return xmlSerializer.serializeToString(value);
	        } else {
	          // Firefox 11- do not support outerHTML
	          //   It does, however, support innerHTML
	          //   Use the following to render the element
	          var ns = "http://www.w3.org/1999/xhtml";
	          var container = document.createElementNS(ns, '_');
	
	          container.appendChild(value.cloneNode(false));
	          html = container.innerHTML
	            .replace('><', '>' + value.innerHTML + '<');
	          container.innerHTML = '';
	          return html;
	        }
	      } catch (err) {
	        // This could be a non-native DOM implementation,
	        //   continue with the normal flow:
	        //   printing the element as if it is an object.
	      }
	    }
	  }
	
	  // Look up the keys of the object.
	  var visibleKeys = getEnumerableProperties(value);
	  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
	
	  // Some type of object without properties can be shortcutted.
	  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
	  // a `stack` plus `description` property; ignore those for consistency.
	  if (keys.length === 0 || (isError(value) && (
	      (keys.length === 1 && keys[0] === 'stack') ||
	      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
	     ))) {
	    if (typeof value === 'function') {
	      var name = getName(value);
	      var nameSuffix = name ? ': ' + name : '';
	      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (typeof value === 'function') {
	    var name = getName(value);
	    var nameSuffix = name ? ': ' + name : '';
	    base = ' [Function' + nameSuffix + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    return formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  switch (typeof value) {
	    case 'undefined':
	      return ctx.stylize('undefined', 'undefined');
	
	    case 'string':
	      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                               .replace(/'/g, "\\'")
	                                               .replace(/\\"/g, '"') + '\'';
	      return ctx.stylize(simple, 'string');
	
	    case 'number':
	      if (value === 0 && (1/value) === -Infinity) {
	        return ctx.stylize('-0', 'number');
	      }
	      return ctx.stylize('' + value, 'number');
	
	    case 'boolean':
	      return ctx.stylize('' + value, 'boolean');
	  }
	  // For some reason typeof null is "object", so special case here.
	  if (value === null) {
	    return ctx.stylize('null', 'null');
	  }
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str;
	  if (value.__lookupGetter__) {
	    if (value.__lookupGetter__(key)) {
	      if (value.__lookupSetter__(key)) {
	        str = ctx.stylize('[Getter/Setter]', 'special');
	      } else {
	        str = ctx.stylize('[Getter]', 'special');
	      }
	    } else {
	      if (value.__lookupSetter__(key)) {
	        str = ctx.stylize('[Setter]', 'special');
	      }
	    }
	  }
	  if (visibleKeys.indexOf(key) < 0) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(value[key]) < 0) {
	      if (recurseTimes === null) {
	        str = formatValue(ctx, value[key], null);
	      } else {
	        str = formatValue(ctx, value[key], recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (typeof name === 'undefined') {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	function isArray(ar) {
	  return Array.isArray(ar) ||
	         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
	}
	
	function isRegExp(re) {
	  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
	}
	
	function isDate(d) {
	  return typeof d === 'object' && objectToString(d) === '[object Date]';
	}
	
	function isError(e) {
	  return typeof e === 'object' && objectToString(e) === '[object Error]';
	}
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


/***/ }),
/* 255 */
/***/ (function(module, exports) {

	/*!
	 * Chai - getName utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * # getName(func)
	 *
	 * Gets the name of a function, in a cross-browser way.
	 *
	 * @param {Function} a function (usually a constructor)
	 * @namespace Utils
	 * @name getName
	 */
	
	module.exports = function (func) {
	  if (func.name) return func.name;
	
	  var match = /^\s?function ([^(]*)\(/.exec(func);
	  return match && match[1] ? match[1] : "";
	};


/***/ }),
/* 256 */
/***/ (function(module, exports) {

	/*!
	 * Chai - getProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### .getProperties(object)
	 *
	 * This allows the retrieval of property names of an object, enumerable or not,
	 * inherited or not.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @namespace Utils
	 * @name getProperties
	 * @api public
	 */
	
	module.exports = function getProperties(object) {
	  var result = Object.getOwnPropertyNames(object);
	
	  function addProperty(property) {
	    if (result.indexOf(property) === -1) {
	      result.push(property);
	    }
	  }
	
	  var proto = Object.getPrototypeOf(object);
	  while (proto !== null) {
	    Object.getOwnPropertyNames(proto).forEach(addProperty);
	    proto = Object.getPrototypeOf(proto);
	  }
	
	  return result;
	};


/***/ }),
/* 257 */
/***/ (function(module, exports) {

	/*!
	 * Chai - getEnumerableProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### .getEnumerableProperties(object)
	 *
	 * This allows the retrieval of enumerable property names of an object,
	 * inherited or not.
	 *
	 * @param {Object} object
	 * @returns {Array}
	 * @namespace Utils
	 * @name getEnumerableProperties
	 * @api public
	 */
	
	module.exports = function getEnumerableProperties(object) {
	  var result = [];
	  for (var name in object) {
	    result.push(name);
	  }
	  return result;
	};


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Module dependancies
	 */
	
	var inspect = __webpack_require__(254);
	var config = __webpack_require__(259);
	
	/**
	 * ### .objDisplay (object)
	 *
	 * Determines if an object or an array matches
	 * criteria to be inspected in-line for error
	 * messages or should be truncated.
	 *
	 * @param {Mixed} javascript object to inspect
	 * @name objDisplay
	 * @namespace Utils
	 * @api public
	 */
	
	module.exports = function (obj) {
	  var str = inspect(obj)
	    , type = Object.prototype.toString.call(obj);
	
	  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
	    if (type === '[object Function]') {
	      return !obj.name || obj.name === ''
	        ? '[Function]'
	        : '[Function: ' + obj.name + ']';
	    } else if (type === '[object Array]') {
	      return '[ Array(' + obj.length + ') ]';
	    } else if (type === '[object Object]') {
	      var keys = Object.keys(obj)
	        , kstr = keys.length > 2
	          ? keys.splice(0, 2).join(', ') + ', ...'
	          : keys.join(', ');
	      return '{ Object (' + kstr + ') }';
	    } else {
	      return str;
	    }
	  } else {
	    return str;
	  }
	};


/***/ }),
/* 259 */
/***/ (function(module, exports) {

	module.exports = {
	
	  /**
	   * ### config.includeStack
	   *
	   * User configurable property, influences whether stack trace
	   * is included in Assertion error message. Default of false
	   * suppresses stack trace in the error message.
	   *
	   *     chai.config.includeStack = true;  // enable stack on error
	   *
	   * @param {Boolean}
	   * @api public
	   */
	
	   includeStack: false,
	
	  /**
	   * ### config.showDiff
	   *
	   * User configurable property, influences whether or not
	   * the `showDiff` flag should be included in the thrown
	   * AssertionErrors. `false` will always be `false`; `true`
	   * will be true when the assertion has requested a diff
	   * be shown.
	   *
	   * @param {Boolean}
	   * @api public
	   */
	
	  showDiff: true,
	
	  /**
	   * ### config.truncateThreshold
	   *
	   * User configurable property, sets length threshold for actual and
	   * expected values in assertion errors. If this threshold is exceeded, for
	   * example for large data structures, the value is replaced with something
	   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
	   *
	   * Set it to zero if you want to disable truncating altogether.
	   *
	   * This is especially userful when doing assertions on arrays: having this
	   * set to a reasonable large value makes the failure messages readily
	   * inspectable.
	   *
	   *     chai.config.truncateThreshold = 0;  // disable truncating
	   *
	   * @param {Number}
	   * @api public
	   */
	
	  truncateThreshold: 40
	
	};


/***/ }),
/* 260 */
/***/ (function(module, exports) {

	/*!
	 * Chai - transferFlags utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### transferFlags(assertion, object, includeAll = true)
	 *
	 * Transfer all the flags for `assertion` to `object`. If
	 * `includeAll` is set to `false`, then the base Chai
	 * assertion flags (namely `object`, `ssfi`, and `message`)
	 * will not be transferred.
	 *
	 *
	 *     var newAssertion = new Assertion();
	 *     utils.transferFlags(assertion, newAssertion);
	 *
	 *     var anotherAsseriton = new Assertion(myObj);
	 *     utils.transferFlags(assertion, anotherAssertion, false);
	 *
	 * @param {Assertion} assertion the assertion to transfer the flags from
	 * @param {Object} object the object to transfer the flags to; usually a new assertion
	 * @param {Boolean} includeAll
	 * @namespace Utils
	 * @name transferFlags
	 * @api private
	 */
	
	module.exports = function (assertion, object, includeAll) {
	  var flags = assertion.__flags || (assertion.__flags = Object.create(null));
	
	  if (!object.__flags) {
	    object.__flags = Object.create(null);
	  }
	
	  includeAll = arguments.length === 3 ? includeAll : true;
	
	  for (var flag in flags) {
	    if (includeAll ||
	        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
	      object.__flags[flag] = flags[flag];
	    }
	  }
	};


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(262);


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * deep-eql
	 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Module dependencies
	 */
	
	var type = __webpack_require__(249);
	
	/*!
	 * Buffer.isBuffer browser shim
	 */
	
	var Buffer;
	try { Buffer = __webpack_require__(263).Buffer; }
	catch(ex) {
	  Buffer = {};
	  Buffer.isBuffer = function() { return false; }
	}
	
	/*!
	 * Primary Export
	 */
	
	module.exports = deepEqual;
	
	/**
	 * Assert super-strict (egal) equality between
	 * two objects of any type.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @param {Array} memoised (optional)
	 * @return {Boolean} equal match
	 */
	
	function deepEqual(a, b, m) {
	  if (sameValue(a, b)) {
	    return true;
	  } else if ('date' === type(a)) {
	    return dateEqual(a, b);
	  } else if ('regexp' === type(a)) {
	    return regexpEqual(a, b);
	  } else if (Buffer.isBuffer(a)) {
	    return bufferEqual(a, b);
	  } else if ('arguments' === type(a)) {
	    return argumentsEqual(a, b, m);
	  } else if (!typeEqual(a, b)) {
	    return false;
	  } else if (('object' !== type(a) && 'object' !== type(b))
	  && ('array' !== type(a) && 'array' !== type(b))) {
	    return sameValue(a, b);
	  } else {
	    return objectEqual(a, b, m);
	  }
	}
	
	/*!
	 * Strict (egal) equality test. Ensures that NaN always
	 * equals NaN and `-0` does not equal `+0`.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} equal match
	 */
	
	function sameValue(a, b) {
	  if (a === b) return a !== 0 || 1 / a === 1 / b;
	  return a !== a && b !== b;
	}
	
	/*!
	 * Compare the types of two given objects and
	 * return if they are equal. Note that an Array
	 * has a type of `array` (not `object`) and arguments
	 * have a type of `arguments` (not `array`/`object`).
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */
	
	function typeEqual(a, b) {
	  return type(a) === type(b);
	}
	
	/*!
	 * Compare two Date objects by asserting that
	 * the time values are equal using `saveValue`.
	 *
	 * @param {Date} a
	 * @param {Date} b
	 * @return {Boolean} result
	 */
	
	function dateEqual(a, b) {
	  if ('date' !== type(b)) return false;
	  return sameValue(a.getTime(), b.getTime());
	}
	
	/*!
	 * Compare two regular expressions by converting them
	 * to string and checking for `sameValue`.
	 *
	 * @param {RegExp} a
	 * @param {RegExp} b
	 * @return {Boolean} result
	 */
	
	function regexpEqual(a, b) {
	  if ('regexp' !== type(b)) return false;
	  return sameValue(a.toString(), b.toString());
	}
	
	/*!
	 * Assert deep equality of two `arguments` objects.
	 * Unfortunately, these must be sliced to arrays
	 * prior to test to ensure no bad behavior.
	 *
	 * @param {Arguments} a
	 * @param {Arguments} b
	 * @param {Array} memoize (optional)
	 * @return {Boolean} result
	 */
	
	function argumentsEqual(a, b, m) {
	  if ('arguments' !== type(b)) return false;
	  a = [].slice.call(a);
	  b = [].slice.call(b);
	  return deepEqual(a, b, m);
	}
	
	/*!
	 * Get enumerable properties of a given object.
	 *
	 * @param {Object} a
	 * @return {Array} property names
	 */
	
	function enumerable(a) {
	  var res = [];
	  for (var key in a) res.push(key);
	  return res;
	}
	
	/*!
	 * Simple equality for flat iterable objects
	 * such as Arrays or Node.js buffers.
	 *
	 * @param {Iterable} a
	 * @param {Iterable} b
	 * @return {Boolean} result
	 */
	
	function iterableEqual(a, b) {
	  if (a.length !==  b.length) return false;
	
	  var i = 0;
	  var match = true;
	
	  for (; i < a.length; i++) {
	    if (a[i] !== b[i]) {
	      match = false;
	      break;
	    }
	  }
	
	  return match;
	}
	
	/*!
	 * Extension to `iterableEqual` specifically
	 * for Node.js Buffers.
	 *
	 * @param {Buffer} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */
	
	function bufferEqual(a, b) {
	  if (!Buffer.isBuffer(b)) return false;
	  return iterableEqual(a, b);
	}
	
	/*!
	 * Block for `objectEqual` ensuring non-existing
	 * values don't get in.
	 *
	 * @param {Mixed} object
	 * @return {Boolean} result
	 */
	
	function isValue(a) {
	  return a !== null && a !== undefined;
	}
	
	/*!
	 * Recursively check the equality of two objects.
	 * Once basic sameness has been established it will
	 * defer to `deepEqual` for each enumerable key
	 * in the object.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */
	
	function objectEqual(a, b, m) {
	  if (!isValue(a) || !isValue(b)) {
	    return false;
	  }
	
	  if (a.prototype !== b.prototype) {
	    return false;
	  }
	
	  var i;
	  if (m) {
	    for (i = 0; i < m.length; i++) {
	      if ((m[i][0] === a && m[i][1] === b)
	      ||  (m[i][0] === b && m[i][1] === a)) {
	        return true;
	      }
	    }
	  } else {
	    m = [];
	  }
	
	  try {
	    var ka = enumerable(a);
	    var kb = enumerable(b);
	  } catch (ex) {
	    return false;
	  }
	
	  ka.sort();
	  kb.sort();
	
	  if (!iterableEqual(ka, kb)) {
	    return false;
	  }
	
	  m.push([ a, b ]);
	
	  var key;
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], m)) {
	      return false;
	    }
	  }
	
	  return true;
	}


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(264)
	var ieee754 = __webpack_require__(265)
	var isArray = __webpack_require__(266)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 264 */
/***/ (function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return (b64.length * 3 / 4) - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr((len * 3 / 4) - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0; i < l; i += 4) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ }),
/* 265 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 266 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - getPathValue utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * @see https://github.com/logicalparadox/filtr
	 * MIT Licensed
	 */
	
	var getPathInfo = __webpack_require__(268);
	
	/**
	 * ### .getPathValue(path, object)
	 *
	 * This allows the retrieval of values in an
	 * object given a string path.
	 *
	 *     var obj = {
	 *         prop1: {
	 *             arr: ['a', 'b', 'c']
	 *           , str: 'Hello'
	 *         }
	 *       , prop2: {
	 *             arr: [ { nested: 'Universe' } ]
	 *           , str: 'Hello again!'
	 *         }
	 *     }
	 *
	 * The following would be the results.
	 *
	 *     getPathValue('prop1.str', obj); // Hello
	 *     getPathValue('prop1.att[2]', obj); // b
	 *     getPathValue('prop2.arr[0].nested', obj); // Universe
	 *
	 * @param {String} path
	 * @param {Object} object
	 * @returns {Object} value or `undefined`
	 * @namespace Utils
	 * @name getPathValue
	 * @api public
	 */
	module.exports = function(path, obj) {
	  var info = getPathInfo(path, obj);
	  return info.value;
	};


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - getPathInfo utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	var hasProperty = __webpack_require__(269);
	
	/**
	 * ### .getPathInfo(path, object)
	 *
	 * This allows the retrieval of property info in an
	 * object given a string path.
	 *
	 * The path info consists of an object with the
	 * following properties:
	 *
	 * * parent - The parent object of the property referenced by `path`
	 * * name - The name of the final property, a number if it was an array indexer
	 * * value - The value of the property, if it exists, otherwise `undefined`
	 * * exists - Whether the property exists or not
	 *
	 * @param {String} path
	 * @param {Object} object
	 * @returns {Object} info
	 * @namespace Utils
	 * @name getPathInfo
	 * @api public
	 */
	
	module.exports = function getPathInfo(path, obj) {
	  var parsed = parsePath(path),
	      last = parsed[parsed.length - 1];
	
	  var info = {
	    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
	    name: last.p || last.i,
	    value: _getPathValue(parsed, obj)
	  };
	  info.exists = hasProperty(info.name, info.parent);
	
	  return info;
	};
	
	
	/*!
	 * ## parsePath(path)
	 *
	 * Helper function used to parse string object
	 * paths. Use in conjunction with `_getPathValue`.
	 *
	 *      var parsed = parsePath('myobject.property.subprop');
	 *
	 * ### Paths:
	 *
	 * * Can be as near infinitely deep and nested
	 * * Arrays are also valid using the formal `myobject.document[3].property`.
	 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
	 *
	 * @param {String} path
	 * @returns {Object} parsed
	 * @api private
	 */
	
	function parsePath (path) {
	  var str = path.replace(/([^\\])\[/g, '$1.[')
	    , parts = str.match(/(\\\.|[^.]+?)+/g);
	  return parts.map(function (value) {
	    var re = /^\[(\d+)\]$/
	      , mArr = re.exec(value);
	    if (mArr) return { i: parseFloat(mArr[1]) };
	    else return { p: value.replace(/\\([.\[\]])/g, '$1') };
	  });
	}
	
	
	/*!
	 * ## _getPathValue(parsed, obj)
	 *
	 * Helper companion function for `.parsePath` that returns
	 * the value located at the parsed address.
	 *
	 *      var value = getPathValue(parsed, obj);
	 *
	 * @param {Object} parsed definition from `parsePath`.
	 * @param {Object} object to search against
	 * @param {Number} object to search against
	 * @returns {Object|Undefined} value
	 * @api private
	 */
	
	function _getPathValue (parsed, obj, index) {
	  var tmp = obj
	    , res;
	
	  index = (index === undefined ? parsed.length : index);
	
	  for (var i = 0, l = index; i < l; i++) {
	    var part = parsed[i];
	    if (tmp) {
	      if ('undefined' !== typeof part.p)
	        tmp = tmp[part.p];
	      else if ('undefined' !== typeof part.i)
	        tmp = tmp[part.i];
	      if (i == (l - 1)) res = tmp;
	    } else {
	      res = undefined;
	    }
	  }
	  return res;
	}


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - hasProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	var type = __webpack_require__(249);
	
	/**
	 * ### .hasProperty(object, name)
	 *
	 * This allows checking whether an object has
	 * named property or numeric array index.
	 *
	 * Basically does the same thing as the `in`
	 * operator but works properly with natives
	 * and null/undefined values.
	 *
	 *     var obj = {
	 *         arr: ['a', 'b', 'c']
	 *       , str: 'Hello'
	 *     }
	 *
	 * The following would be the results.
	 *
	 *     hasProperty('str', obj);  // true
	 *     hasProperty('constructor', obj);  // true
	 *     hasProperty('bar', obj);  // false
	 *
	 *     hasProperty('length', obj.str); // true
	 *     hasProperty(1, obj.str);  // true
	 *     hasProperty(5, obj.str);  // false
	 *
	 *     hasProperty('length', obj.arr);  // true
	 *     hasProperty(2, obj.arr);  // true
	 *     hasProperty(3, obj.arr);  // false
	 *
	 * @param {Objuect} object
	 * @param {String|Number} name
	 * @returns {Boolean} whether it exists
	 * @namespace Utils
	 * @name getPathInfo
	 * @api public
	 */
	
	var literals = {
	    'number': Number
	  , 'string': String
	};
	
	module.exports = function hasProperty(name, obj) {
	  var ot = type(obj);
	
	  // Bad Object, obviously no props at all
	  if(ot === 'null' || ot === 'undefined')
	    return false;
	
	  // The `in` operator does not work with certain literals
	  // box these before the check
	  if(literals[ot] && typeof obj !== 'object')
	    obj = new literals[ot](obj);
	
	  return name in obj;
	};


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - addProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	var config = __webpack_require__(259);
	var flag = __webpack_require__(248);
	
	/**
	 * ### addProperty (ctx, name, getter)
	 *
	 * Adds a property to the prototype of an object.
	 *
	 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.instanceof(Foo);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addProperty('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.be.foo;
	 *
	 * @param {Object} ctx object to which the property is added
	 * @param {String} name of property to add
	 * @param {Function} getter function to be used for name
	 * @namespace Utils
	 * @name addProperty
	 * @api public
	 */
	
	module.exports = function (ctx, name, getter) {
	  Object.defineProperty(ctx, name,
	    { get: function addProperty() {
	        var old_ssfi = flag(this, 'ssfi');
	        if (old_ssfi && config.includeStack === false)
	          flag(this, 'ssfi', addProperty);
	
	        var result = getter.call(this);
	        return result === undefined ? this : result;
	      }
	    , configurable: true
	  });
	};


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - addMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	var config = __webpack_require__(259);
	
	/**
	 * ### .addMethod (ctx, name, method)
	 *
	 * Adds a method to the prototype of an object.
	 *
	 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.equal(str);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addMethod('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(fooStr).to.be.foo('bar');
	 *
	 * @param {Object} ctx object to which the method is added
	 * @param {String} name of method to add
	 * @param {Function} method function to be used for name
	 * @namespace Utils
	 * @name addMethod
	 * @api public
	 */
	var flag = __webpack_require__(248);
	
	module.exports = function (ctx, name, method) {
	  ctx[name] = function () {
	    var old_ssfi = flag(this, 'ssfi');
	    if (old_ssfi && config.includeStack === false)
	      flag(this, 'ssfi', ctx[name]);
	    var result = method.apply(this, arguments);
	    return result === undefined ? this : result;
	  };
	};


/***/ }),
/* 272 */
/***/ (function(module, exports) {

	/*!
	 * Chai - overwriteProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### overwriteProperty (ctx, name, fn)
	 *
	 * Overwites an already existing property getter and provides
	 * access to previous value. Must return function to use as getter.
	 *
	 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
	 *       return function () {
	 *         var obj = utils.flag(this, 'object');
	 *         if (obj instanceof Foo) {
	 *           new chai.Assertion(obj.name).to.equal('bar');
	 *         } else {
	 *           _super.call(this);
	 *         }
	 *       }
	 *     });
	 *
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteProperty('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.be.ok;
	 *
	 * @param {Object} ctx object whose property is to be overwritten
	 * @param {String} name of property to overwrite
	 * @param {Function} getter function that returns a getter function to be used for name
	 * @namespace Utils
	 * @name overwriteProperty
	 * @api public
	 */
	
	module.exports = function (ctx, name, getter) {
	  var _get = Object.getOwnPropertyDescriptor(ctx, name)
	    , _super = function () {};
	
	  if (_get && 'function' === typeof _get.get)
	    _super = _get.get
	
	  Object.defineProperty(ctx, name,
	    { get: function () {
	        var result = getter(_super).call(this);
	        return result === undefined ? this : result;
	      }
	    , configurable: true
	  });
	};


/***/ }),
/* 273 */
/***/ (function(module, exports) {

	/*!
	 * Chai - overwriteMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### overwriteMethod (ctx, name, fn)
	 *
	 * Overwites an already existing method and provides
	 * access to previous function. Must return function
	 * to be used for name.
	 *
	 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
	 *       return function (str) {
	 *         var obj = utils.flag(this, 'object');
	 *         if (obj instanceof Foo) {
	 *           new chai.Assertion(obj.value).to.equal(str);
	 *         } else {
	 *           _super.apply(this, arguments);
	 *         }
	 *       }
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteMethod('foo', fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.equal('bar');
	 *
	 * @param {Object} ctx object whose method is to be overwritten
	 * @param {String} name of method to overwrite
	 * @param {Function} method function that returns a function to be used for name
	 * @namespace Utils
	 * @name overwriteMethod
	 * @api public
	 */
	
	module.exports = function (ctx, name, method) {
	  var _method = ctx[name]
	    , _super = function () { return this; };
	
	  if (_method && 'function' === typeof _method)
	    _super = _method;
	
	  ctx[name] = function () {
	    var result = method(_super).apply(this, arguments);
	    return result === undefined ? this : result;
	  }
	};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Chai - addChainingMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/*!
	 * Module dependencies
	 */
	
	var transferFlags = __webpack_require__(260);
	var flag = __webpack_require__(248);
	var config = __webpack_require__(259);
	
	/*!
	 * Module variables
	 */
	
	// Check whether `__proto__` is supported
	var hasProtoSupport = '__proto__' in Object;
	
	// Without `__proto__` support, this module will need to add properties to a function.
	// However, some Function.prototype methods cannot be overwritten,
	// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
	var excludeNames = /^(?:length|name|arguments|caller)$/;
	
	// Cache `Function` properties
	var call  = Function.prototype.call,
	    apply = Function.prototype.apply;
	
	/**
	 * ### addChainableMethod (ctx, name, method, chainingBehavior)
	 *
	 * Adds a method to an object, such that the method can also be chained.
	 *
	 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
	 *       var obj = utils.flag(this, 'object');
	 *       new chai.Assertion(obj).to.be.equal(str);
	 *     });
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
	 *
	 * The result can then be used as both a method assertion, executing both `method` and
	 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
	 *
	 *     expect(fooStr).to.be.foo('bar');
	 *     expect(fooStr).to.be.foo.equal('foo');
	 *
	 * @param {Object} ctx object to which the method is added
	 * @param {String} name of method to add
	 * @param {Function} method function to be used for `name`, when called
	 * @param {Function} chainingBehavior function to be called every time the property is accessed
	 * @namespace Utils
	 * @name addChainableMethod
	 * @api public
	 */
	
	module.exports = function (ctx, name, method, chainingBehavior) {
	  if (typeof chainingBehavior !== 'function') {
	    chainingBehavior = function () { };
	  }
	
	  var chainableBehavior = {
	      method: method
	    , chainingBehavior: chainingBehavior
	  };
	
	  // save the methods so we can overwrite them later, if we need to.
	  if (!ctx.__methods) {
	    ctx.__methods = {};
	  }
	  ctx.__methods[name] = chainableBehavior;
	
	  Object.defineProperty(ctx, name,
	    { get: function () {
	        chainableBehavior.chainingBehavior.call(this);
	
	        var assert = function assert() {
	          var old_ssfi = flag(this, 'ssfi');
	          if (old_ssfi && config.includeStack === false)
	            flag(this, 'ssfi', assert);
	          var result = chainableBehavior.method.apply(this, arguments);
	          return result === undefined ? this : result;
	        };
	
	        // Use `__proto__` if available
	        if (hasProtoSupport) {
	          // Inherit all properties from the object by replacing the `Function` prototype
	          var prototype = assert.__proto__ = Object.create(this);
	          // Restore the `call` and `apply` methods from `Function`
	          prototype.call = call;
	          prototype.apply = apply;
	        }
	        // Otherwise, redefine all properties (slow!)
	        else {
	          var asserterNames = Object.getOwnPropertyNames(ctx);
	          asserterNames.forEach(function (asserterName) {
	            if (!excludeNames.test(asserterName)) {
	              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
	              Object.defineProperty(assert, asserterName, pd);
	            }
	          });
	        }
	
	        transferFlags(this, assert);
	        return assert;
	      }
	    , configurable: true
	  });
	};


/***/ }),
/* 275 */
/***/ (function(module, exports) {

	/*!
	 * Chai - overwriteChainableMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	/**
	 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
	 *
	 * Overwites an already existing chainable method
	 * and provides access to the previous function or
	 * property.  Must return functions to be used for
	 * name.
	 *
	 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
	 *       function (_super) {
	 *       }
	 *     , function (_super) {
	 *       }
	 *     );
	 *
	 * Can also be accessed directly from `chai.Assertion`.
	 *
	 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
	 *
	 * Then can be used as any other assertion.
	 *
	 *     expect(myFoo).to.have.length(3);
	 *     expect(myFoo).to.have.length.above(3);
	 *
	 * @param {Object} ctx object whose method / property is to be overwritten
	 * @param {String} name of method / property to overwrite
	 * @param {Function} method function that returns a function to be used for name
	 * @param {Function} chainingBehavior function that returns a function to be used for property
	 * @namespace Utils
	 * @name overwriteChainableMethod
	 * @api public
	 */
	
	module.exports = function (ctx, name, method, chainingBehavior) {
	  var chainableBehavior = ctx.__methods[name];
	
	  var _chainingBehavior = chainableBehavior.chainingBehavior;
	  chainableBehavior.chainingBehavior = function () {
	    var result = chainingBehavior(_chainingBehavior).call(this);
	    return result === undefined ? this : result;
	  };
	
	  var _method = chainableBehavior.method;
	  chainableBehavior.method = function () {
	    var result = method(_method).apply(this, arguments);
	    return result === undefined ? this : result;
	  };
	};


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	var config = __webpack_require__(259);
	
	module.exports = function (_chai, util) {
	  /*!
	   * Module dependencies.
	   */
	
	  var AssertionError = _chai.AssertionError
	    , flag = util.flag;
	
	  /*!
	   * Module export.
	   */
	
	  _chai.Assertion = Assertion;
	
	  /*!
	   * Assertion Constructor
	   *
	   * Creates object for chaining.
	   *
	   * @api private
	   */
	
	  function Assertion (obj, msg, stack) {
	    flag(this, 'ssfi', stack || arguments.callee);
	    flag(this, 'object', obj);
	    flag(this, 'message', msg);
	  }
	
	  Object.defineProperty(Assertion, 'includeStack', {
	    get: function() {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      return config.includeStack;
	    },
	    set: function(value) {
	      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
	      config.includeStack = value;
	    }
	  });
	
	  Object.defineProperty(Assertion, 'showDiff', {
	    get: function() {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      return config.showDiff;
	    },
	    set: function(value) {
	      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
	      config.showDiff = value;
	    }
	  });
	
	  Assertion.addProperty = function (name, fn) {
	    util.addProperty(this.prototype, name, fn);
	  };
	
	  Assertion.addMethod = function (name, fn) {
	    util.addMethod(this.prototype, name, fn);
	  };
	
	  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
	    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };
	
	  Assertion.overwriteProperty = function (name, fn) {
	    util.overwriteProperty(this.prototype, name, fn);
	  };
	
	  Assertion.overwriteMethod = function (name, fn) {
	    util.overwriteMethod(this.prototype, name, fn);
	  };
	
	  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
	    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
	  };
	
	  /**
	   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
	   *
	   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
	   *
	   * @name assert
	   * @param {Philosophical} expression to be tested
	   * @param {String|Function} message or function that returns message to display if expression fails
	   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
	   * @param {Mixed} expected value (remember to check for negation)
	   * @param {Mixed} actual (optional) will default to `this.obj`
	   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
	   * @api private
	   */
	
	  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
	    var ok = util.test(this, arguments);
	    if (true !== showDiff) showDiff = false;
	    if (true !== config.showDiff) showDiff = false;
	
	    if (!ok) {
	      var msg = util.getMessage(this, arguments)
	        , actual = util.getActual(this, arguments);
	      throw new AssertionError(msg, {
	          actual: actual
	        , expected: expected
	        , showDiff: showDiff
	      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
	    }
	  };
	
	  /*!
	   * ### ._obj
	   *
	   * Quick reference to stored `actual` value for plugin developers.
	   *
	   * @api private
	   */
	
	  Object.defineProperty(Assertion.prototype, '_obj',
	    { get: function () {
	        return flag(this, 'object');
	      }
	    , set: function (val) {
	        flag(this, 'object', val);
	      }
	  });
	};


/***/ }),
/* 277 */
/***/ (function(module, exports) {

	/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	module.exports = function (chai, _) {
	  var Assertion = chai.Assertion
	    , toString = Object.prototype.toString
	    , flag = _.flag;
	
	  /**
	   * ### Language Chains
	   *
	   * The following are provided as chainable getters to
	   * improve the readability of your assertions. They
	   * do not provide testing capabilities unless they
	   * have been overwritten by a plugin.
	   *
	   * **Chains**
	   *
	   * - to
	   * - be
	   * - been
	   * - is
	   * - that
	   * - which
	   * - and
	   * - has
	   * - have
	   * - with
	   * - at
	   * - of
	   * - same
	   *
	   * @name language chains
	   * @namespace BDD
	   * @api public
	   */
	
	  [ 'to', 'be', 'been'
	  , 'is', 'and', 'has', 'have'
	  , 'with', 'that', 'which', 'at'
	  , 'of', 'same' ].forEach(function (chain) {
	    Assertion.addProperty(chain, function () {
	      return this;
	    });
	  });
	
	  /**
	   * ### .not
	   *
	   * Negates any of assertions following in the chain.
	   *
	   *     expect(foo).to.not.equal('bar');
	   *     expect(goodFn).to.not.throw(Error);
	   *     expect({ foo: 'baz' }).to.have.property('foo')
	   *       .and.not.equal('bar');
	   *
	   * @name not
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('not', function () {
	    flag(this, 'negate', true);
	  });
	
	  /**
	   * ### .deep
	   *
	   * Sets the `deep` flag, later used by the `equal` and
	   * `property` assertions.
	   *
	   *     expect(foo).to.deep.equal({ bar: 'baz' });
	   *     expect({ foo: { bar: { baz: 'quux' } } })
	   *       .to.have.deep.property('foo.bar.baz', 'quux');
	   *
	   * `.deep.property` special characters can be escaped
	   * by adding two slashes before the `.` or `[]`.
	   *
	   *     var deepCss = { '.link': { '[target]': 42 }};
	   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
	   *
	   * @name deep
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('deep', function () {
	    flag(this, 'deep', true);
	  });
	
	  /**
	   * ### .any
	   *
	   * Sets the `any` flag, (opposite of the `all` flag)
	   * later used in the `keys` assertion.
	   *
	   *     expect(foo).to.have.any.keys('bar', 'baz');
	   *
	   * @name any
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('any', function () {
	    flag(this, 'any', true);
	    flag(this, 'all', false)
	  });
	
	
	  /**
	   * ### .all
	   *
	   * Sets the `all` flag (opposite of the `any` flag)
	   * later used by the `keys` assertion.
	   *
	   *     expect(foo).to.have.all.keys('bar', 'baz');
	   *
	   * @name all
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('all', function () {
	    flag(this, 'all', true);
	    flag(this, 'any', false);
	  });
	
	  /**
	   * ### .a(type)
	   *
	   * The `a` and `an` assertions are aliases that can be
	   * used either as language chains or to assert a value's
	   * type.
	   *
	   *     // typeof
	   *     expect('test').to.be.a('string');
	   *     expect({ foo: 'bar' }).to.be.an('object');
	   *     expect(null).to.be.a('null');
	   *     expect(undefined).to.be.an('undefined');
	   *     expect(new Error).to.be.an('error');
	   *     expect(new Promise).to.be.a('promise');
	   *     expect(new Float32Array()).to.be.a('float32array');
	   *     expect(Symbol()).to.be.a('symbol');
	   *
	   *     // es6 overrides
	   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
	   *
	   *     // language chain
	   *     expect(foo).to.be.an.instanceof(Foo);
	   *
	   * @name a
	   * @alias an
	   * @param {String} type
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function an (type, msg) {
	    if (msg) flag(this, 'message', msg);
	    type = type.toLowerCase();
	    var obj = flag(this, 'object')
	      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';
	
	    this.assert(
	        type === _.type(obj)
	      , 'expected #{this} to be ' + article + type
	      , 'expected #{this} not to be ' + article + type
	    );
	  }
	
	  Assertion.addChainableMethod('an', an);
	  Assertion.addChainableMethod('a', an);
	
	  /**
	   * ### .include(value)
	   *
	   * The `include` and `contain` assertions can be used as either property
	   * based language chains or as methods to assert the inclusion of an object
	   * in an array or a substring in a string. When used as language chains,
	   * they toggle the `contains` flag for the `keys` assertion.
	   *
	   *     expect([1,2,3]).to.include(2);
	   *     expect('foobar').to.contain('foo');
	   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
	   *
	   * @name include
	   * @alias contain
	   * @alias includes
	   * @alias contains
	   * @param {Object|String|Number} obj
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function includeChainingBehavior () {
	    flag(this, 'contains', true);
	  }
	
	  function include (val, msg) {
	    _.expectTypes(this, ['array', 'object', 'string']);
	
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var expected = false;
	
	    if (_.type(obj) === 'array' && _.type(val) === 'object') {
	      for (var i in obj) {
	        if (_.eql(obj[i], val)) {
	          expected = true;
	          break;
	        }
	      }
	    } else if (_.type(val) === 'object') {
	      if (!flag(this, 'negate')) {
	        for (var k in val) new Assertion(obj).property(k, val[k]);
	        return;
	      }
	      var subset = {};
	      for (var k in val) subset[k] = obj[k];
	      expected = _.eql(subset, val);
	    } else {
	      expected = (obj != undefined) && ~obj.indexOf(val);
	    }
	    this.assert(
	        expected
	      , 'expected #{this} to include ' + _.inspect(val)
	      , 'expected #{this} to not include ' + _.inspect(val));
	  }
	
	  Assertion.addChainableMethod('include', include, includeChainingBehavior);
	  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
	  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
	  Assertion.addChainableMethod('includes', include, includeChainingBehavior);
	
	  /**
	   * ### .ok
	   *
	   * Asserts that the target is truthy.
	   *
	   *     expect('everything').to.be.ok;
	   *     expect(1).to.be.ok;
	   *     expect(false).to.not.be.ok;
	   *     expect(undefined).to.not.be.ok;
	   *     expect(null).to.not.be.ok;
	   *
	   * @name ok
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('ok', function () {
	    this.assert(
	        flag(this, 'object')
	      , 'expected #{this} to be truthy'
	      , 'expected #{this} to be falsy');
	  });
	
	  /**
	   * ### .true
	   *
	   * Asserts that the target is `true`.
	   *
	   *     expect(true).to.be.true;
	   *     expect(1).to.not.be.true;
	   *
	   * @name true
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('true', function () {
	    this.assert(
	        true === flag(this, 'object')
	      , 'expected #{this} to be true'
	      , 'expected #{this} to be false'
	      , this.negate ? false : true
	    );
	  });
	
	  /**
	   * ### .false
	   *
	   * Asserts that the target is `false`.
	   *
	   *     expect(false).to.be.false;
	   *     expect(0).to.not.be.false;
	   *
	   * @name false
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('false', function () {
	    this.assert(
	        false === flag(this, 'object')
	      , 'expected #{this} to be false'
	      , 'expected #{this} to be true'
	      , this.negate ? true : false
	    );
	  });
	
	  /**
	   * ### .null
	   *
	   * Asserts that the target is `null`.
	   *
	   *     expect(null).to.be.null;
	   *     expect(undefined).to.not.be.null;
	   *
	   * @name null
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('null', function () {
	    this.assert(
	        null === flag(this, 'object')
	      , 'expected #{this} to be null'
	      , 'expected #{this} not to be null'
	    );
	  });
	
	  /**
	   * ### .undefined
	   *
	   * Asserts that the target is `undefined`.
	   *
	   *     expect(undefined).to.be.undefined;
	   *     expect(null).to.not.be.undefined;
	   *
	   * @name undefined
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('undefined', function () {
	    this.assert(
	        undefined === flag(this, 'object')
	      , 'expected #{this} to be undefined'
	      , 'expected #{this} not to be undefined'
	    );
	  });
	
	  /**
	   * ### .NaN
	   * Asserts that the target is `NaN`.
	   *
	   *     expect('foo').to.be.NaN;
	   *     expect(4).not.to.be.NaN;
	   *
	   * @name NaN
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('NaN', function () {
	    this.assert(
	        isNaN(flag(this, 'object'))
	        , 'expected #{this} to be NaN'
	        , 'expected #{this} not to be NaN'
	    );
	  });
	
	  /**
	   * ### .exist
	   *
	   * Asserts that the target is neither `null` nor `undefined`.
	   *
	   *     var foo = 'hi'
	   *       , bar = null
	   *       , baz;
	   *
	   *     expect(foo).to.exist;
	   *     expect(bar).to.not.exist;
	   *     expect(baz).to.not.exist;
	   *
	   * @name exist
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('exist', function () {
	    this.assert(
	        null != flag(this, 'object')
	      , 'expected #{this} to exist'
	      , 'expected #{this} to not exist'
	    );
	  });
	
	
	  /**
	   * ### .empty
	   *
	   * Asserts that the target's length is `0`. For arrays and strings, it checks
	   * the `length` property. For objects, it gets the count of
	   * enumerable keys.
	   *
	   *     expect([]).to.be.empty;
	   *     expect('').to.be.empty;
	   *     expect({}).to.be.empty;
	   *
	   * @name empty
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('empty', function () {
	    var obj = flag(this, 'object')
	      , expected = obj;
	
	    if (Array.isArray(obj) || 'string' === typeof object) {
	      expected = obj.length;
	    } else if (typeof obj === 'object') {
	      expected = Object.keys(obj).length;
	    }
	
	    this.assert(
	        !expected
	      , 'expected #{this} to be empty'
	      , 'expected #{this} not to be empty'
	    );
	  });
	
	  /**
	   * ### .arguments
	   *
	   * Asserts that the target is an arguments object.
	   *
	   *     function test () {
	   *       expect(arguments).to.be.arguments;
	   *     }
	   *
	   * @name arguments
	   * @alias Arguments
	   * @namespace BDD
	   * @api public
	   */
	
	  function checkArguments () {
	    var obj = flag(this, 'object')
	      , type = Object.prototype.toString.call(obj);
	    this.assert(
	        '[object Arguments]' === type
	      , 'expected #{this} to be arguments but got ' + type
	      , 'expected #{this} to not be arguments'
	    );
	  }
	
	  Assertion.addProperty('arguments', checkArguments);
	  Assertion.addProperty('Arguments', checkArguments);
	
	  /**
	   * ### .equal(value)
	   *
	   * Asserts that the target is strictly equal (`===`) to `value`.
	   * Alternately, if the `deep` flag is set, asserts that
	   * the target is deeply equal to `value`.
	   *
	   *     expect('hello').to.equal('hello');
	   *     expect(42).to.equal(42);
	   *     expect(1).to.not.equal(true);
	   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
	   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
	   *
	   * @name equal
	   * @alias equals
	   * @alias eq
	   * @alias deep.equal
	   * @param {Mixed} value
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertEqual (val, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'deep')) {
	      return this.eql(val);
	    } else {
	      this.assert(
	          val === obj
	        , 'expected #{this} to equal #{exp}'
	        , 'expected #{this} to not equal #{exp}'
	        , val
	        , this._obj
	        , true
	      );
	    }
	  }
	
	  Assertion.addMethod('equal', assertEqual);
	  Assertion.addMethod('equals', assertEqual);
	  Assertion.addMethod('eq', assertEqual);
	
	  /**
	   * ### .eql(value)
	   *
	   * Asserts that the target is deeply equal to `value`.
	   *
	   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
	   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
	   *
	   * @name eql
	   * @alias eqls
	   * @param {Mixed} value
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertEql(obj, msg) {
	    if (msg) flag(this, 'message', msg);
	    this.assert(
	        _.eql(obj, flag(this, 'object'))
	      , 'expected #{this} to deeply equal #{exp}'
	      , 'expected #{this} to not deeply equal #{exp}'
	      , obj
	      , this._obj
	      , true
	    );
	  }
	
	  Assertion.addMethod('eql', assertEql);
	  Assertion.addMethod('eqls', assertEql);
	
	  /**
	   * ### .above(value)
	   *
	   * Asserts that the target is greater than `value`.
	   *
	   *     expect(10).to.be.above(5);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a minimum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.above(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
	   *
	   * @name above
	   * @alias gt
	   * @alias greaterThan
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertAbove (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len > n
	        , 'expected #{this} to have a length above #{exp} but got #{act}'
	        , 'expected #{this} to not have a length above #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj > n
	        , 'expected #{this} to be above ' + n
	        , 'expected #{this} to be at most ' + n
	      );
	    }
	  }
	
	  Assertion.addMethod('above', assertAbove);
	  Assertion.addMethod('gt', assertAbove);
	  Assertion.addMethod('greaterThan', assertAbove);
	
	  /**
	   * ### .least(value)
	   *
	   * Asserts that the target is greater than or equal to `value`.
	   *
	   *     expect(10).to.be.at.least(10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a minimum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.of.at.least(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
	   *
	   * @name least
	   * @alias gte
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertLeast (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len >= n
	        , 'expected #{this} to have a length at least #{exp} but got #{act}'
	        , 'expected #{this} to have a length below #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj >= n
	        , 'expected #{this} to be at least ' + n
	        , 'expected #{this} to be below ' + n
	      );
	    }
	  }
	
	  Assertion.addMethod('least', assertLeast);
	  Assertion.addMethod('gte', assertLeast);
	
	  /**
	   * ### .below(value)
	   *
	   * Asserts that the target is less than `value`.
	   *
	   *     expect(5).to.be.below(10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a maximum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.below(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
	   *
	   * @name below
	   * @alias lt
	   * @alias lessThan
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertBelow (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len < n
	        , 'expected #{this} to have a length below #{exp} but got #{act}'
	        , 'expected #{this} to not have a length below #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj < n
	        , 'expected #{this} to be below ' + n
	        , 'expected #{this} to be at least ' + n
	      );
	    }
	  }
	
	  Assertion.addMethod('below', assertBelow);
	  Assertion.addMethod('lt', assertBelow);
	  Assertion.addMethod('lessThan', assertBelow);
	
	  /**
	   * ### .most(value)
	   *
	   * Asserts that the target is less than or equal to `value`.
	   *
	   *     expect(5).to.be.at.most(5);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a maximum length. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.of.at.most(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
	   *
	   * @name most
	   * @alias lte
	   * @param {Number} value
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertMost (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len <= n
	        , 'expected #{this} to have a length at most #{exp} but got #{act}'
	        , 'expected #{this} to have a length above #{exp}'
	        , n
	        , len
	      );
	    } else {
	      this.assert(
	          obj <= n
	        , 'expected #{this} to be at most ' + n
	        , 'expected #{this} to be above ' + n
	      );
	    }
	  }
	
	  Assertion.addMethod('most', assertMost);
	  Assertion.addMethod('lte', assertMost);
	
	  /**
	   * ### .within(start, finish)
	   *
	   * Asserts that the target is within a range.
	   *
	   *     expect(7).to.be.within(5,10);
	   *
	   * Can also be used in conjunction with `length` to
	   * assert a length range. The benefit being a
	   * more informative error message than if the length
	   * was supplied directly.
	   *
	   *     expect('foo').to.have.length.within(2,4);
	   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
	   *
	   * @name within
	   * @param {Number} start lowerbound inclusive
	   * @param {Number} finish upperbound inclusive
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addMethod('within', function (start, finish, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , range = start + '..' + finish;
	    if (flag(this, 'doLength')) {
	      new Assertion(obj, msg).to.have.property('length');
	      var len = obj.length;
	      this.assert(
	          len >= start && len <= finish
	        , 'expected #{this} to have a length within ' + range
	        , 'expected #{this} to not have a length within ' + range
	      );
	    } else {
	      this.assert(
	          obj >= start && obj <= finish
	        , 'expected #{this} to be within ' + range
	        , 'expected #{this} to not be within ' + range
	      );
	    }
	  });
	
	  /**
	   * ### .instanceof(constructor)
	   *
	   * Asserts that the target is an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , Chai = new Tea('chai');
	   *
	   *     expect(Chai).to.be.an.instanceof(Tea);
	   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
	   *
	   * @name instanceof
	   * @param {Constructor} constructor
	   * @param {String} message _optional_
	   * @alias instanceOf
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertInstanceOf (constructor, msg) {
	    if (msg) flag(this, 'message', msg);
	    var name = _.getName(constructor);
	    this.assert(
	        flag(this, 'object') instanceof constructor
	      , 'expected #{this} to be an instance of ' + name
	      , 'expected #{this} to not be an instance of ' + name
	    );
	  };
	
	  Assertion.addMethod('instanceof', assertInstanceOf);
	  Assertion.addMethod('instanceOf', assertInstanceOf);
	
	  /**
	   * ### .property(name, [value])
	   *
	   * Asserts that the target has a property `name`, optionally asserting that
	   * the value of that property is strictly equal to  `value`.
	   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
	   * references into objects and arrays.
	   *
	   *     // simple referencing
	   *     var obj = { foo: 'bar' };
	   *     expect(obj).to.have.property('foo');
	   *     expect(obj).to.have.property('foo', 'bar');
	   *
	   *     // deep referencing
	   *     var deepObj = {
	   *         green: { tea: 'matcha' }
	   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
	   *     };
	   *
	   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
	   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
	   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
	   *
	   * You can also use an array as the starting point of a `deep.property`
	   * assertion, or traverse nested arrays.
	   *
	   *     var arr = [
	   *         [ 'chai', 'matcha', 'konacha' ]
	   *       , [ { tea: 'chai' }
	   *         , { tea: 'matcha' }
	   *         , { tea: 'konacha' } ]
	   *     ];
	   *
	   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
	   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
	   *
	   * Furthermore, `property` changes the subject of the assertion
	   * to be the value of that property from the original object. This
	   * permits for further chainable assertions on that property.
	   *
	   *     expect(obj).to.have.property('foo')
	   *       .that.is.a('string');
	   *     expect(deepObj).to.have.property('green')
	   *       .that.is.an('object')
	   *       .that.deep.equals({ tea: 'matcha' });
	   *     expect(deepObj).to.have.property('teas')
	   *       .that.is.an('array')
	   *       .with.deep.property('[2]')
	   *         .that.deep.equals({ tea: 'konacha' });
	   *
	   * Note that dots and bracket in `name` must be backslash-escaped when
	   * the `deep` flag is set, while they must NOT be escaped when the `deep`
	   * flag is not set.
	   *
	   *     // simple referencing
	   *     var css = { '.link[target]': 42 };
	   *     expect(css).to.have.property('.link[target]', 42);
	   *
	   *     // deep referencing
	   *     var deepCss = { '.link': { '[target]': 42 }};
	   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
	   *
	   * @name property
	   * @alias deep.property
	   * @param {String} name
	   * @param {Mixed} value (optional)
	   * @param {String} message _optional_
	   * @returns value of property for chaining
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addMethod('property', function (name, val, msg) {
	    if (msg) flag(this, 'message', msg);
	
	    var isDeep = !!flag(this, 'deep')
	      , descriptor = isDeep ? 'deep property ' : 'property '
	      , negate = flag(this, 'negate')
	      , obj = flag(this, 'object')
	      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
	      , hasProperty = isDeep
	        ? pathInfo.exists
	        : _.hasProperty(name, obj)
	      , value = isDeep
	        ? pathInfo.value
	        : obj[name];
	
	    if (negate && arguments.length > 1) {
	      if (undefined === value) {
	        msg = (msg != null) ? msg + ': ' : '';
	        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
	      }
	    } else {
	      this.assert(
	          hasProperty
	        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
	        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
	    }
	
	    if (arguments.length > 1) {
	      this.assert(
	          val === value
	        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
	        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
	        , val
	        , value
	      );
	    }
	
	    flag(this, 'object', value);
	  });
	
	
	  /**
	   * ### .ownProperty(name)
	   *
	   * Asserts that the target has an own property `name`.
	   *
	   *     expect('test').to.have.ownProperty('length');
	   *
	   * @name ownProperty
	   * @alias haveOwnProperty
	   * @param {String} name
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertOwnProperty (name, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    this.assert(
	        obj.hasOwnProperty(name)
	      , 'expected #{this} to have own property ' + _.inspect(name)
	      , 'expected #{this} to not have own property ' + _.inspect(name)
	    );
	  }
	
	  Assertion.addMethod('ownProperty', assertOwnProperty);
	  Assertion.addMethod('haveOwnProperty', assertOwnProperty);
	
	  /**
	   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
	   *
	   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
	   *
	   *     expect('test').to.have.ownPropertyDescriptor('length');
	   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
	   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
	   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
	   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
	   *
	   * @name ownPropertyDescriptor
	   * @alias haveOwnPropertyDescriptor
	   * @param {String} name
	   * @param {Object} descriptor _optional_
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertOwnPropertyDescriptor (name, descriptor, msg) {
	    if (typeof descriptor === 'string') {
	      msg = descriptor;
	      descriptor = null;
	    }
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
	    if (actualDescriptor && descriptor) {
	      this.assert(
	          _.eql(descriptor, actualDescriptor)
	        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
	        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
	        , descriptor
	        , actualDescriptor
	        , true
	      );
	    } else {
	      this.assert(
	          actualDescriptor
	        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
	        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
	      );
	    }
	    flag(this, 'object', actualDescriptor);
	  }
	
	  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
	  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);
	
	  /**
	   * ### .length
	   *
	   * Sets the `doLength` flag later used as a chain precursor to a value
	   * comparison for the `length` property.
	   *
	   *     expect('foo').to.have.length.above(2);
	   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
	   *     expect('foo').to.have.length.below(4);
	   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
	   *     expect('foo').to.have.length.within(2,4);
	   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
	   *
	   * *Deprecation notice:* Using `length` as an assertion will be deprecated
	   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
	   * asserting for `length` property value using `length(value)` should be
	   * switched to use `lengthOf(value)` instead.
	   *
	   * @name length
	   * @namespace BDD
	   * @api public
	   */
	
	  /**
	   * ### .lengthOf(value[, message])
	   *
	   * Asserts that the target's `length` property has
	   * the expected value.
	   *
	   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
	   *     expect('foobar').to.have.lengthOf(6);
	   *
	   * @name lengthOf
	   * @param {Number} length
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertLengthChain () {
	    flag(this, 'doLength', true);
	  }
	
	  function assertLength (n, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).to.have.property('length');
	    var len = obj.length;
	
	    this.assert(
	        len == n
	      , 'expected #{this} to have a length of #{exp} but got #{act}'
	      , 'expected #{this} to not have a length of #{act}'
	      , n
	      , len
	    );
	  }
	
	  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
	  Assertion.addMethod('lengthOf', assertLength);
	
	  /**
	   * ### .match(regexp)
	   *
	   * Asserts that the target matches a regular expression.
	   *
	   *     expect('foobar').to.match(/^foo/);
	   *
	   * @name match
	   * @alias matches
	   * @param {RegExp} RegularExpression
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	  function assertMatch(re, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    this.assert(
	        re.exec(obj)
	      , 'expected #{this} to match ' + re
	      , 'expected #{this} not to match ' + re
	    );
	  }
	
	  Assertion.addMethod('match', assertMatch);
	  Assertion.addMethod('matches', assertMatch);
	
	  /**
	   * ### .string(string)
	   *
	   * Asserts that the string target contains another string.
	   *
	   *     expect('foobar').to.have.string('bar');
	   *
	   * @name string
	   * @param {String} string
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addMethod('string', function (str, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).is.a('string');
	
	    this.assert(
	        ~obj.indexOf(str)
	      , 'expected #{this} to contain ' + _.inspect(str)
	      , 'expected #{this} to not contain ' + _.inspect(str)
	    );
	  });
	
	
	  /**
	   * ### .keys(key1, [key2], [...])
	   *
	   * Asserts that the target contains any or all of the passed-in keys.
	   * Use in combination with `any`, `all`, `contains`, or `have` will affect
	   * what will pass.
	   *
	   * When used in conjunction with `any`, at least one key that is passed
	   * in must exist in the target object. This is regardless whether or not
	   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
	   * should be used in the assertion. If neither are used, the assertion is
	   * defaulted to `all`.
	   *
	   * When both `all` and `contain` are used, the target object must have at
	   * least all of the passed-in keys but may have more keys not listed.
	   *
	   * When both `all` and `have` are used, the target object must both contain
	   * all of the passed-in keys AND the number of keys in the target object must
	   * match the number of keys passed in (in other words, a target object must
	   * have all and only all of the passed-in keys).
	   *
	   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
	   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
	   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
	   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
	   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
	   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
	   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
	   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
	   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
	   *
	   *
	   * @name keys
	   * @alias key
	   * @param {...String|Array|Object} keys
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertKeys (keys) {
	    var obj = flag(this, 'object')
	      , str
	      , ok = true
	      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';
	
	    switch (_.type(keys)) {
	      case "array":
	        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
	        break;
	      case "object":
	        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
	        keys = Object.keys(keys);
	        break;
	      default:
	        keys = Array.prototype.slice.call(arguments);
	    }
	
	    if (!keys.length) throw new Error('keys required');
	
	    var actual = Object.keys(obj)
	      , expected = keys
	      , len = keys.length
	      , any = flag(this, 'any')
	      , all = flag(this, 'all');
	
	    if (!any && !all) {
	      all = true;
	    }
	
	    // Has any
	    if (any) {
	      var intersection = expected.filter(function(key) {
	        return ~actual.indexOf(key);
	      });
	      ok = intersection.length > 0;
	    }
	
	    // Has all
	    if (all) {
	      ok = keys.every(function(key){
	        return ~actual.indexOf(key);
	      });
	      if (!flag(this, 'negate') && !flag(this, 'contains')) {
	        ok = ok && keys.length == actual.length;
	      }
	    }
	
	    // Key string
	    if (len > 1) {
	      keys = keys.map(function(key){
	        return _.inspect(key);
	      });
	      var last = keys.pop();
	      if (all) {
	        str = keys.join(', ') + ', and ' + last;
	      }
	      if (any) {
	        str = keys.join(', ') + ', or ' + last;
	      }
	    } else {
	      str = _.inspect(keys[0]);
	    }
	
	    // Form
	    str = (len > 1 ? 'keys ' : 'key ') + str;
	
	    // Have / include
	    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;
	
	    // Assertion
	    this.assert(
	        ok
	      , 'expected #{this} to ' + str
	      , 'expected #{this} to not ' + str
	      , expected.slice(0).sort()
	      , actual.sort()
	      , true
	    );
	  }
	
	  Assertion.addMethod('keys', assertKeys);
	  Assertion.addMethod('key', assertKeys);
	
	  /**
	   * ### .throw(constructor)
	   *
	   * Asserts that the function target will throw a specific error, or specific type of error
	   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
	   * for the error's message.
	   *
	   *     var err = new ReferenceError('This is a bad function.');
	   *     var fn = function () { throw err; }
	   *     expect(fn).to.throw(ReferenceError);
	   *     expect(fn).to.throw(Error);
	   *     expect(fn).to.throw(/bad function/);
	   *     expect(fn).to.not.throw('good function');
	   *     expect(fn).to.throw(ReferenceError, /bad function/);
	   *     expect(fn).to.throw(err);
	   *
	   * Please note that when a throw expectation is negated, it will check each
	   * parameter independently, starting with error constructor type. The appropriate way
	   * to check for the existence of a type of error but for a message that does not match
	   * is to use `and`.
	   *
	   *     expect(fn).to.throw(ReferenceError)
	   *        .and.not.throw(/good function/);
	   *
	   * @name throw
	   * @alias throws
	   * @alias Throw
	   * @param {ErrorConstructor} constructor
	   * @param {String|RegExp} expected error message
	   * @param {String} message _optional_
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @returns error for chaining (null if no error)
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertThrows (constructor, errMsg, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    new Assertion(obj, msg).is.a('function');
	
	    var thrown = false
	      , desiredError = null
	      , name = null
	      , thrownError = null;
	
	    if (arguments.length === 0) {
	      errMsg = null;
	      constructor = null;
	    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
	      errMsg = constructor;
	      constructor = null;
	    } else if (constructor && constructor instanceof Error) {
	      desiredError = constructor;
	      constructor = null;
	      errMsg = null;
	    } else if (typeof constructor === 'function') {
	      name = constructor.prototype.name;
	      if (!name || (name === 'Error' && constructor !== Error)) {
	        name = constructor.name || (new constructor()).name;
	      }
	    } else {
	      constructor = null;
	    }
	
	    try {
	      obj();
	    } catch (err) {
	      // first, check desired error
	      if (desiredError) {
	        this.assert(
	            err === desiredError
	          , 'expected #{this} to throw #{exp} but #{act} was thrown'
	          , 'expected #{this} to not throw #{exp}'
	          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
	          , (err instanceof Error ? err.toString() : err)
	        );
	
	        flag(this, 'object', err);
	        return this;
	      }
	
	      // next, check constructor
	      if (constructor) {
	        this.assert(
	            err instanceof constructor
	          , 'expected #{this} to throw #{exp} but #{act} was thrown'
	          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
	          , name
	          , (err instanceof Error ? err.toString() : err)
	        );
	
	        if (!errMsg) {
	          flag(this, 'object', err);
	          return this;
	        }
	      }
	
	      // next, check message
	      var message = 'error' === _.type(err) && "message" in err
	        ? err.message
	        : '' + err;
	
	      if ((message != null) && errMsg && errMsg instanceof RegExp) {
	        this.assert(
	            errMsg.exec(message)
	          , 'expected #{this} to throw error matching #{exp} but got #{act}'
	          , 'expected #{this} to throw error not matching #{exp}'
	          , errMsg
	          , message
	        );
	
	        flag(this, 'object', err);
	        return this;
	      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
	        this.assert(
	            ~message.indexOf(errMsg)
	          , 'expected #{this} to throw error including #{exp} but got #{act}'
	          , 'expected #{this} to throw error not including #{act}'
	          , errMsg
	          , message
	        );
	
	        flag(this, 'object', err);
	        return this;
	      } else {
	        thrown = true;
	        thrownError = err;
	      }
	    }
	
	    var actuallyGot = ''
	      , expectedThrown = name !== null
	        ? name
	        : desiredError
	          ? '#{exp}' //_.inspect(desiredError)
	          : 'an error';
	
	    if (thrown) {
	      actuallyGot = ' but #{act} was thrown'
	    }
	
	    this.assert(
	        thrown === true
	      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
	      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
	      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
	      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
	    );
	
	    flag(this, 'object', thrownError);
	  };
	
	  Assertion.addMethod('throw', assertThrows);
	  Assertion.addMethod('throws', assertThrows);
	  Assertion.addMethod('Throw', assertThrows);
	
	  /**
	   * ### .respondTo(method)
	   *
	   * Asserts that the object or class target will respond to a method.
	   *
	   *     Klass.prototype.bar = function(){};
	   *     expect(Klass).to.respondTo('bar');
	   *     expect(obj).to.respondTo('bar');
	   *
	   * To check if a constructor will respond to a static function,
	   * set the `itself` flag.
	   *
	   *     Klass.baz = function(){};
	   *     expect(Klass).itself.to.respondTo('baz');
	   *
	   * @name respondTo
	   * @alias respondsTo
	   * @param {String} method
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function respondTo (method, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object')
	      , itself = flag(this, 'itself')
	      , context = ('function' === _.type(obj) && !itself)
	        ? obj.prototype[method]
	        : obj[method];
	
	    this.assert(
	        'function' === typeof context
	      , 'expected #{this} to respond to ' + _.inspect(method)
	      , 'expected #{this} to not respond to ' + _.inspect(method)
	    );
	  }
	
	  Assertion.addMethod('respondTo', respondTo);
	  Assertion.addMethod('respondsTo', respondTo);
	
	  /**
	   * ### .itself
	   *
	   * Sets the `itself` flag, later used by the `respondTo` assertion.
	   *
	   *     function Foo() {}
	   *     Foo.bar = function() {}
	   *     Foo.prototype.baz = function() {}
	   *
	   *     expect(Foo).itself.to.respondTo('bar');
	   *     expect(Foo).itself.not.to.respondTo('baz');
	   *
	   * @name itself
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('itself', function () {
	    flag(this, 'itself', true);
	  });
	
	  /**
	   * ### .satisfy(method)
	   *
	   * Asserts that the target passes a given truth test.
	   *
	   *     expect(1).to.satisfy(function(num) { return num > 0; });
	   *
	   * @name satisfy
	   * @alias satisfies
	   * @param {Function} matcher
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function satisfy (matcher, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	    var result = matcher(obj);
	    this.assert(
	        result
	      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
	      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
	      , this.negate ? false : true
	      , result
	    );
	  }
	
	  Assertion.addMethod('satisfy', satisfy);
	  Assertion.addMethod('satisfies', satisfy);
	
	  /**
	   * ### .closeTo(expected, delta)
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     expect(1.5).to.be.closeTo(1, 0.5);
	   *
	   * @name closeTo
	   * @alias approximately
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function closeTo(expected, delta, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	
	    new Assertion(obj, msg).is.a('number');
	    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
	      throw new Error('the arguments to closeTo or approximately must be numbers');
	    }
	
	    this.assert(
	        Math.abs(obj - expected) <= delta
	      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
	      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
	    );
	  }
	
	  Assertion.addMethod('closeTo', closeTo);
	  Assertion.addMethod('approximately', closeTo);
	
	  function isSubsetOf(subset, superset, cmp) {
	    return subset.every(function(elem) {
	      if (!cmp) return superset.indexOf(elem) !== -1;
	
	      return superset.some(function(elem2) {
	        return cmp(elem, elem2);
	      });
	    })
	  }
	
	  /**
	   * ### .members(set)
	   *
	   * Asserts that the target is a superset of `set`,
	   * or that the target and `set` have the same strictly-equal (===) members.
	   * Alternately, if the `deep` flag is set, set members are compared for deep
	   * equality.
	   *
	   *     expect([1, 2, 3]).to.include.members([3, 2]);
	   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
	   *
	   *     expect([4, 2]).to.have.members([2, 4]);
	   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
	   *
	   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
	   *
	   * @name members
	   * @param {Array} set
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addMethod('members', function (subset, msg) {
	    if (msg) flag(this, 'message', msg);
	    var obj = flag(this, 'object');
	
	    new Assertion(obj).to.be.an('array');
	    new Assertion(subset).to.be.an('array');
	
	    var cmp = flag(this, 'deep') ? _.eql : undefined;
	
	    if (flag(this, 'contains')) {
	      return this.assert(
	          isSubsetOf(subset, obj, cmp)
	        , 'expected #{this} to be a superset of #{act}'
	        , 'expected #{this} to not be a superset of #{act}'
	        , obj
	        , subset
	      );
	    }
	
	    this.assert(
	        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
	        , 'expected #{this} to have the same members as #{act}'
	        , 'expected #{this} to not have the same members as #{act}'
	        , obj
	        , subset
	    );
	  });
	
	  /**
	   * ### .oneOf(list)
	   *
	   * Assert that a value appears somewhere in the top level of array `list`.
	   *
	   *     expect('a').to.be.oneOf(['a', 'b', 'c']);
	   *     expect(9).to.not.be.oneOf(['z']);
	   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);
	   *
	   *     var three = [3];
	   *     // for object-types, contents are not compared
	   *     expect(three).to.not.be.oneOf([1, 2, [3]]);
	   *     // comparing references works
	   *     expect(three).to.be.oneOf([1, 2, three]);
	   *
	   * @name oneOf
	   * @param {Array<*>} list
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function oneOf (list, msg) {
	    if (msg) flag(this, 'message', msg);
	    var expected = flag(this, 'object');
	    new Assertion(list).to.be.an('array');
	
	    this.assert(
	        list.indexOf(expected) > -1
	      , 'expected #{this} to be one of #{exp}'
	      , 'expected #{this} to not be one of #{exp}'
	      , list
	      , expected
	    );
	  }
	
	  Assertion.addMethod('oneOf', oneOf);
	
	
	  /**
	   * ### .change(function)
	   *
	   * Asserts that a function changes an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val += 3 };
	   *     var noChangeFn = function() { return 'foo' + 'bar'; }
	   *     expect(fn).to.change(obj, 'val');
	   *     expect(noChangeFn).to.not.change(obj, 'val')
	   *
	   * @name change
	   * @alias changes
	   * @alias Change
	   * @param {String} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertChanges (object, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object');
	    new Assertion(object, msg).to.have.property(prop);
	    new Assertion(fn).is.a('function');
	
	    var initial = object[prop];
	    fn();
	
	    this.assert(
	      initial !== object[prop]
	      , 'expected .' + prop + ' to change'
	      , 'expected .' + prop + ' to not change'
	    );
	  }
	
	  Assertion.addChainableMethod('change', assertChanges);
	  Assertion.addChainableMethod('changes', assertChanges);
	
	  /**
	   * ### .increase(function)
	   *
	   * Asserts that a function increases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 15 };
	   *     expect(fn).to.increase(obj, 'val');
	   *
	   * @name increase
	   * @alias increases
	   * @alias Increase
	   * @param {String} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertIncreases (object, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object');
	    new Assertion(object, msg).to.have.property(prop);
	    new Assertion(fn).is.a('function');
	
	    var initial = object[prop];
	    fn();
	
	    this.assert(
	      object[prop] - initial > 0
	      , 'expected .' + prop + ' to increase'
	      , 'expected .' + prop + ' to not increase'
	    );
	  }
	
	  Assertion.addChainableMethod('increase', assertIncreases);
	  Assertion.addChainableMethod('increases', assertIncreases);
	
	  /**
	   * ### .decrease(function)
	   *
	   * Asserts that a function decreases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 5 };
	   *     expect(fn).to.decrease(obj, 'val');
	   *
	   * @name decrease
	   * @alias decreases
	   * @alias Decrease
	   * @param {String} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace BDD
	   * @api public
	   */
	
	  function assertDecreases (object, prop, msg) {
	    if (msg) flag(this, 'message', msg);
	    var fn = flag(this, 'object');
	    new Assertion(object, msg).to.have.property(prop);
	    new Assertion(fn).is.a('function');
	
	    var initial = object[prop];
	    fn();
	
	    this.assert(
	      object[prop] - initial < 0
	      , 'expected .' + prop + ' to decrease'
	      , 'expected .' + prop + ' to not decrease'
	    );
	  }
	
	  Assertion.addChainableMethod('decrease', assertDecreases);
	  Assertion.addChainableMethod('decreases', assertDecreases);
	
	  /**
	   * ### .extensible
	   *
	   * Asserts that the target is extensible (can have new properties added to
	   * it).
	   *
	   *     var nonExtensibleObject = Object.preventExtensions({});
	   *     var sealedObject = Object.seal({});
	   *     var frozenObject = Object.freeze({});
	   *
	   *     expect({}).to.be.extensible;
	   *     expect(nonExtensibleObject).to.not.be.extensible;
	   *     expect(sealedObject).to.not.be.extensible;
	   *     expect(frozenObject).to.not.be.extensible;
	   *
	   * @name extensible
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('extensible', function() {
	    var obj = flag(this, 'object');
	
	    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
	    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
	    // The following provides ES6 behavior when a TypeError is thrown under ES5.
	
	    var isExtensible;
	
	    try {
	      isExtensible = Object.isExtensible(obj);
	    } catch (err) {
	      if (err instanceof TypeError) isExtensible = false;
	      else throw err;
	    }
	
	    this.assert(
	      isExtensible
	      , 'expected #{this} to be extensible'
	      , 'expected #{this} to not be extensible'
	    );
	  });
	
	  /**
	   * ### .sealed
	   *
	   * Asserts that the target is sealed (cannot have new properties added to it
	   * and its existing properties cannot be removed).
	   *
	   *     var sealedObject = Object.seal({});
	   *     var frozenObject = Object.freeze({});
	   *
	   *     expect(sealedObject).to.be.sealed;
	   *     expect(frozenObject).to.be.sealed;
	   *     expect({}).to.not.be.sealed;
	   *
	   * @name sealed
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('sealed', function() {
	    var obj = flag(this, 'object');
	
	    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
	    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
	    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
	    // The following provides ES6 behavior when a TypeError is thrown under ES5.
	
	    var isSealed;
	
	    try {
	      isSealed = Object.isSealed(obj);
	    } catch (err) {
	      if (err instanceof TypeError) isSealed = true;
	      else throw err;
	    }
	
	    this.assert(
	      isSealed
	      , 'expected #{this} to be sealed'
	      , 'expected #{this} to not be sealed'
	    );
	  });
	
	  /**
	   * ### .frozen
	   *
	   * Asserts that the target is frozen (cannot have new properties added to it
	   * and its existing properties cannot be modified).
	   *
	   *     var frozenObject = Object.freeze({});
	   *
	   *     expect(frozenObject).to.be.frozen;
	   *     expect({}).to.not.be.frozen;
	   *
	   * @name frozen
	   * @namespace BDD
	   * @api public
	   */
	
	  Assertion.addProperty('frozen', function() {
	    var obj = flag(this, 'object');
	
	    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
	    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
	    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
	    // The following provides ES6 behavior when a TypeError is thrown under ES5.
	
	    var isFrozen;
	
	    try {
	      isFrozen = Object.isFrozen(obj);
	    } catch (err) {
	      if (err instanceof TypeError) isFrozen = true;
	      else throw err;
	    }
	
	    this.assert(
	      isFrozen
	      , 'expected #{this} to be frozen'
	      , 'expected #{this} to not be frozen'
	    );
	  });
	};


/***/ }),
/* 278 */
/***/ (function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	module.exports = function (chai, util) {
	  chai.expect = function (val, message) {
	    return new chai.Assertion(val, message);
	  };
	
	  /**
	   * ### .fail(actual, expected, [message], [operator])
	   *
	   * Throw a failure.
	   *
	   * @name fail
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @param {String} operator
	   * @namespace Expect
	   * @api public
	   */
	
	  chai.expect.fail = function (actual, expected, message, operator) {
	    message = message || 'expect.fail()';
	    throw new chai.AssertionError(message, {
	        actual: actual
	      , expected: expected
	      , operator: operator
	    }, chai.expect.fail);
	  };
	};


/***/ }),
/* 279 */
/***/ (function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	module.exports = function (chai, util) {
	  var Assertion = chai.Assertion;
	
	  function loadShould () {
	    // explicitly define this method as function as to have it's name to include as `ssfi`
	    function shouldGetter() {
	      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
	        return new Assertion(this.valueOf(), null, shouldGetter);
	      }
	      return new Assertion(this, null, shouldGetter);
	    }
	    function shouldSetter(value) {
	      // See https://github.com/chaijs/chai/issues/86: this makes
	      // `whatever.should = someValue` actually set `someValue`, which is
	      // especially useful for `global.should = require('chai').should()`.
	      //
	      // Note that we have to use [[DefineProperty]] instead of [[Put]]
	      // since otherwise we would trigger this very setter!
	      Object.defineProperty(this, 'should', {
	        value: value,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    }
	    // modify Object.prototype to have `should`
	    Object.defineProperty(Object.prototype, 'should', {
	      set: shouldSetter
	      , get: shouldGetter
	      , configurable: true
	    });
	
	    var should = {};
	
	    /**
	     * ### .fail(actual, expected, [message], [operator])
	     *
	     * Throw a failure.
	     *
	     * @name fail
	     * @param {Mixed} actual
	     * @param {Mixed} expected
	     * @param {String} message
	     * @param {String} operator
	     * @namespace Should
	     * @api public
	     */
	
	    should.fail = function (actual, expected, message, operator) {
	      message = message || 'should.fail()';
	      throw new chai.AssertionError(message, {
	          actual: actual
	        , expected: expected
	        , operator: operator
	      }, should.fail);
	    };
	
	    /**
	     * ### .equal(actual, expected, [message])
	     *
	     * Asserts non-strict equality (`==`) of `actual` and `expected`.
	     *
	     *     should.equal(3, '3', '== coerces values to strings');
	     *
	     * @name equal
	     * @param {Mixed} actual
	     * @param {Mixed} expected
	     * @param {String} message
	     * @namespace Should
	     * @api public
	     */
	
	    should.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.equal(val2);
	    };
	
	    /**
	     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
	     *
	     * Asserts that `function` will throw an error that is an instance of
	     * `constructor`, or alternately that it will throw an error with message
	     * matching `regexp`.
	     *
	     *     should.throw(fn, 'function throws a reference error');
	     *     should.throw(fn, /function throws a reference error/);
	     *     should.throw(fn, ReferenceError);
	     *     should.throw(fn, ReferenceError, 'function throws a reference error');
	     *     should.throw(fn, ReferenceError, /function throws a reference error/);
	     *
	     * @name throw
	     * @alias Throw
	     * @param {Function} function
	     * @param {ErrorConstructor} constructor
	     * @param {RegExp} regexp
	     * @param {String} message
	     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	     * @namespace Should
	     * @api public
	     */
	
	    should.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.Throw(errt, errs);
	    };
	
	    /**
	     * ### .exist
	     *
	     * Asserts that the target is neither `null` nor `undefined`.
	     *
	     *     var foo = 'hi';
	     *
	     *     should.exist(foo, 'foo exists');
	     *
	     * @name exist
	     * @namespace Should
	     * @api public
	     */
	
	    should.exist = function (val, msg) {
	      new Assertion(val, msg).to.exist;
	    }
	
	    // negation
	    should.not = {}
	
	    /**
	     * ### .not.equal(actual, expected, [message])
	     *
	     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
	     *
	     *     should.not.equal(3, 4, 'these numbers are not equal');
	     *
	     * @name not.equal
	     * @param {Mixed} actual
	     * @param {Mixed} expected
	     * @param {String} message
	     * @namespace Should
	     * @api public
	     */
	
	    should.not.equal = function (val1, val2, msg) {
	      new Assertion(val1, msg).to.not.equal(val2);
	    };
	
	    /**
	     * ### .throw(function, [constructor/regexp], [message])
	     *
	     * Asserts that `function` will _not_ throw an error that is an instance of
	     * `constructor`, or alternately that it will not throw an error with message
	     * matching `regexp`.
	     *
	     *     should.not.throw(fn, Error, 'function does not throw');
	     *
	     * @name not.throw
	     * @alias not.Throw
	     * @param {Function} function
	     * @param {ErrorConstructor} constructor
	     * @param {RegExp} regexp
	     * @param {String} message
	     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	     * @namespace Should
	     * @api public
	     */
	
	    should.not.Throw = function (fn, errt, errs, msg) {
	      new Assertion(fn, msg).to.not.Throw(errt, errs);
	    };
	
	    /**
	     * ### .not.exist
	     *
	     * Asserts that the target is neither `null` nor `undefined`.
	     *
	     *     var bar = null;
	     *
	     *     should.not.exist(bar, 'bar does not exist');
	     *
	     * @name not.exist
	     * @namespace Should
	     * @api public
	     */
	
	    should.not.exist = function (val, msg) {
	      new Assertion(val, msg).to.not.exist;
	    }
	
	    should['throw'] = should['Throw'];
	    should.not['throw'] = should.not['Throw'];
	
	    return should;
	  };
	
	  chai.should = loadShould;
	  chai.Should = loadShould;
	};


/***/ }),
/* 280 */
/***/ (function(module, exports) {

	/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	
	
	module.exports = function (chai, util) {
	
	  /*!
	   * Chai dependencies.
	   */
	
	  var Assertion = chai.Assertion
	    , flag = util.flag;
	
	  /*!
	   * Module export.
	   */
	
	  /**
	   * ### assert(expression, message)
	   *
	   * Write your own test expressions.
	   *
	   *     assert('foo' !== 'bar', 'foo is not bar');
	   *     assert(Array.isArray([]), 'empty arrays are arrays');
	   *
	   * @param {Mixed} expression to test for truthiness
	   * @param {String} message to display on error
	   * @name assert
	   * @namespace Assert
	   * @api public
	   */
	
	  var assert = chai.assert = function (express, errmsg) {
	    var test = new Assertion(null, null, chai.assert);
	    test.assert(
	        express
	      , errmsg
	      , '[ negation message unavailable ]'
	    );
	  };
	
	  /**
	   * ### .fail(actual, expected, [message], [operator])
	   *
	   * Throw a failure. Node.js `assert` module-compatible.
	   *
	   * @name fail
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @param {String} operator
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.fail = function (actual, expected, message, operator) {
	    message = message || 'assert.fail()';
	    throw new chai.AssertionError(message, {
	        actual: actual
	      , expected: expected
	      , operator: operator
	    }, assert.fail);
	  };
	
	  /**
	   * ### .isOk(object, [message])
	   *
	   * Asserts that `object` is truthy.
	   *
	   *     assert.isOk('everything', 'everything is ok');
	   *     assert.isOk(false, 'this will fail');
	   *
	   * @name isOk
	   * @alias ok
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isOk = function (val, msg) {
	    new Assertion(val, msg).is.ok;
	  };
	
	  /**
	   * ### .isNotOk(object, [message])
	   *
	   * Asserts that `object` is falsy.
	   *
	   *     assert.isNotOk('everything', 'this will fail');
	   *     assert.isNotOk(false, 'this will pass');
	   *
	   * @name isNotOk
	   * @alias notOk
	   * @param {Mixed} object to test
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotOk = function (val, msg) {
	    new Assertion(val, msg).is.not.ok;
	  };
	
	  /**
	   * ### .equal(actual, expected, [message])
	   *
	   * Asserts non-strict equality (`==`) of `actual` and `expected`.
	   *
	   *     assert.equal(3, '3', '== coerces values to strings');
	   *
	   * @name equal
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.equal = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.equal);
	
	    test.assert(
	        exp == flag(test, 'object')
	      , 'expected #{this} to equal #{exp}'
	      , 'expected #{this} to not equal #{act}'
	      , exp
	      , act
	    );
	  };
	
	  /**
	   * ### .notEqual(actual, expected, [message])
	   *
	   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
	   *
	   *     assert.notEqual(3, 4, 'these numbers are not equal');
	   *
	   * @name notEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notEqual = function (act, exp, msg) {
	    var test = new Assertion(act, msg, assert.notEqual);
	
	    test.assert(
	        exp != flag(test, 'object')
	      , 'expected #{this} to not equal #{exp}'
	      , 'expected #{this} to equal #{act}'
	      , exp
	      , act
	    );
	  };
	
	  /**
	   * ### .strictEqual(actual, expected, [message])
	   *
	   * Asserts strict equality (`===`) of `actual` and `expected`.
	   *
	   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
	   *
	   * @name strictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.strictEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.equal(exp);
	  };
	
	  /**
	   * ### .notStrictEqual(actual, expected, [message])
	   *
	   * Asserts strict inequality (`!==`) of `actual` and `expected`.
	   *
	   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
	   *
	   * @name notStrictEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notStrictEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.not.equal(exp);
	  };
	
	  /**
	   * ### .deepEqual(actual, expected, [message])
	   *
	   * Asserts that `actual` is deeply equal to `expected`.
	   *
	   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
	   *
	   * @name deepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.deepEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.eql(exp);
	  };
	
	  /**
	   * ### .notDeepEqual(actual, expected, [message])
	   *
	   * Assert that `actual` is not deeply equal to `expected`.
	   *
	   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
	   *
	   * @name notDeepEqual
	   * @param {Mixed} actual
	   * @param {Mixed} expected
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notDeepEqual = function (act, exp, msg) {
	    new Assertion(act, msg).to.not.eql(exp);
	  };
	
	   /**
	   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
	   *
	   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
	   *
	   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
	   *
	   * @name isAbove
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeAbove
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isAbove = function (val, abv, msg) {
	    new Assertion(val, msg).to.be.above(abv);
	  };
	
	   /**
	   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
	   *
	   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`
	   *
	   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
	   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
	   *
	   * @name isAtLeast
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeAtLeast
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isAtLeast = function (val, atlst, msg) {
	    new Assertion(val, msg).to.be.least(atlst);
	  };
	
	   /**
	   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
	   *
	   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
	   *
	   *     assert.isBelow(3, 6, '3 is strictly less than 6');
	   *
	   * @name isBelow
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeBelow
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isBelow = function (val, blw, msg) {
	    new Assertion(val, msg).to.be.below(blw);
	  };
	
	   /**
	   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
	   *
	   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`
	   *
	   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
	   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
	   *
	   * @name isAtMost
	   * @param {Mixed} valueToCheck
	   * @param {Mixed} valueToBeAtMost
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isAtMost = function (val, atmst, msg) {
	    new Assertion(val, msg).to.be.most(atmst);
	  };
	
	  /**
	   * ### .isTrue(value, [message])
	   *
	   * Asserts that `value` is true.
	   *
	   *     var teaServed = true;
	   *     assert.isTrue(teaServed, 'the tea has been served');
	   *
	   * @name isTrue
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isTrue = function (val, msg) {
	    new Assertion(val, msg).is['true'];
	  };
	
	  /**
	   * ### .isNotTrue(value, [message])
	   *
	   * Asserts that `value` is not true.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotTrue(tea, 'great, time for tea!');
	   *
	   * @name isNotTrue
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotTrue = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(true);
	  };
	
	  /**
	   * ### .isFalse(value, [message])
	   *
	   * Asserts that `value` is false.
	   *
	   *     var teaServed = false;
	   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
	   *
	   * @name isFalse
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isFalse = function (val, msg) {
	    new Assertion(val, msg).is['false'];
	  };
	
	  /**
	   * ### .isNotFalse(value, [message])
	   *
	   * Asserts that `value` is not false.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotFalse(tea, 'great, time for tea!');
	   *
	   * @name isNotFalse
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotFalse = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(false);
	  };
	
	  /**
	   * ### .isNull(value, [message])
	   *
	   * Asserts that `value` is null.
	   *
	   *     assert.isNull(err, 'there was no error');
	   *
	   * @name isNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNull = function (val, msg) {
	    new Assertion(val, msg).to.equal(null);
	  };
	
	  /**
	   * ### .isNotNull(value, [message])
	   *
	   * Asserts that `value` is not null.
	   *
	   *     var tea = 'tasty chai';
	   *     assert.isNotNull(tea, 'great, time for tea!');
	   *
	   * @name isNotNull
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotNull = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(null);
	  };
	
	  /**
	   * ### .isNaN
	   * Asserts that value is NaN
	   *
	   *    assert.isNaN('foo', 'foo is NaN');
	   *
	   * @name isNaN
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNaN = function (val, msg) {
	    new Assertion(val, msg).to.be.NaN;
	  };
	
	  /**
	   * ### .isNotNaN
	   * Asserts that value is not NaN
	   *
	   *    assert.isNotNaN(4, '4 is not NaN');
	   *
	   * @name isNotNaN
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	  assert.isNotNaN = function (val, msg) {
	    new Assertion(val, msg).not.to.be.NaN;
	  };
	
	  /**
	   * ### .isUndefined(value, [message])
	   *
	   * Asserts that `value` is `undefined`.
	   *
	   *     var tea;
	   *     assert.isUndefined(tea, 'no tea defined');
	   *
	   * @name isUndefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isUndefined = function (val, msg) {
	    new Assertion(val, msg).to.equal(undefined);
	  };
	
	  /**
	   * ### .isDefined(value, [message])
	   *
	   * Asserts that `value` is not `undefined`.
	   *
	   *     var tea = 'cup of chai';
	   *     assert.isDefined(tea, 'tea has been defined');
	   *
	   * @name isDefined
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isDefined = function (val, msg) {
	    new Assertion(val, msg).to.not.equal(undefined);
	  };
	
	  /**
	   * ### .isFunction(value, [message])
	   *
	   * Asserts that `value` is a function.
	   *
	   *     function serveTea() { return 'cup of tea'; };
	   *     assert.isFunction(serveTea, 'great, we can have tea now');
	   *
	   * @name isFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isFunction = function (val, msg) {
	    new Assertion(val, msg).to.be.a('function');
	  };
	
	  /**
	   * ### .isNotFunction(value, [message])
	   *
	   * Asserts that `value` is _not_ a function.
	   *
	   *     var serveTea = [ 'heat', 'pour', 'sip' ];
	   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
	   *
	   * @name isNotFunction
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotFunction = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('function');
	  };
	
	  /**
	   * ### .isObject(value, [message])
	   *
	   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
	   * _The assertion does not match subclassed objects._
	   *
	   *     var selection = { name: 'Chai', serve: 'with spices' };
	   *     assert.isObject(selection, 'tea selection is an object');
	   *
	   * @name isObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isObject = function (val, msg) {
	    new Assertion(val, msg).to.be.a('object');
	  };
	
	  /**
	   * ### .isNotObject(value, [message])
	   *
	   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
	   *
	   *     var selection = 'chai'
	   *     assert.isNotObject(selection, 'tea selection is not an object');
	   *     assert.isNotObject(null, 'null is not an object');
	   *
	   * @name isNotObject
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotObject = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('object');
	  };
	
	  /**
	   * ### .isArray(value, [message])
	   *
	   * Asserts that `value` is an array.
	   *
	   *     var menu = [ 'green', 'chai', 'oolong' ];
	   *     assert.isArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isArray = function (val, msg) {
	    new Assertion(val, msg).to.be.an('array');
	  };
	
	  /**
	   * ### .isNotArray(value, [message])
	   *
	   * Asserts that `value` is _not_ an array.
	   *
	   *     var menu = 'green|chai|oolong';
	   *     assert.isNotArray(menu, 'what kind of tea do we want?');
	   *
	   * @name isNotArray
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotArray = function (val, msg) {
	    new Assertion(val, msg).to.not.be.an('array');
	  };
	
	  /**
	   * ### .isString(value, [message])
	   *
	   * Asserts that `value` is a string.
	   *
	   *     var teaOrder = 'chai';
	   *     assert.isString(teaOrder, 'order placed');
	   *
	   * @name isString
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isString = function (val, msg) {
	    new Assertion(val, msg).to.be.a('string');
	  };
	
	  /**
	   * ### .isNotString(value, [message])
	   *
	   * Asserts that `value` is _not_ a string.
	   *
	   *     var teaOrder = 4;
	   *     assert.isNotString(teaOrder, 'order placed');
	   *
	   * @name isNotString
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotString = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('string');
	  };
	
	  /**
	   * ### .isNumber(value, [message])
	   *
	   * Asserts that `value` is a number.
	   *
	   *     var cups = 2;
	   *     assert.isNumber(cups, 'how many cups');
	   *
	   * @name isNumber
	   * @param {Number} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNumber = function (val, msg) {
	    new Assertion(val, msg).to.be.a('number');
	  };
	
	  /**
	   * ### .isNotNumber(value, [message])
	   *
	   * Asserts that `value` is _not_ a number.
	   *
	   *     var cups = '2 cups please';
	   *     assert.isNotNumber(cups, 'how many cups');
	   *
	   * @name isNotNumber
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotNumber = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('number');
	  };
	
	  /**
	   * ### .isBoolean(value, [message])
	   *
	   * Asserts that `value` is a boolean.
	   *
	   *     var teaReady = true
	   *       , teaServed = false;
	   *
	   *     assert.isBoolean(teaReady, 'is the tea ready');
	   *     assert.isBoolean(teaServed, 'has tea been served');
	   *
	   * @name isBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isBoolean = function (val, msg) {
	    new Assertion(val, msg).to.be.a('boolean');
	  };
	
	  /**
	   * ### .isNotBoolean(value, [message])
	   *
	   * Asserts that `value` is _not_ a boolean.
	   *
	   *     var teaReady = 'yep'
	   *       , teaServed = 'nope';
	   *
	   *     assert.isNotBoolean(teaReady, 'is the tea ready');
	   *     assert.isNotBoolean(teaServed, 'has tea been served');
	   *
	   * @name isNotBoolean
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotBoolean = function (val, msg) {
	    new Assertion(val, msg).to.not.be.a('boolean');
	  };
	
	  /**
	   * ### .typeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
	   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
	   *     assert.typeOf('tea', 'string', 'we have a string');
	   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
	   *     assert.typeOf(null, 'null', 'we have a null');
	   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
	   *
	   * @name typeOf
	   * @param {Mixed} value
	   * @param {String} name
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.typeOf = function (val, type, msg) {
	    new Assertion(val, msg).to.be.a(type);
	  };
	
	  /**
	   * ### .notTypeOf(value, name, [message])
	   *
	   * Asserts that `value`'s type is _not_ `name`, as determined by
	   * `Object.prototype.toString`.
	   *
	   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
	   *
	   * @name notTypeOf
	   * @param {Mixed} value
	   * @param {String} typeof name
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notTypeOf = function (val, type, msg) {
	    new Assertion(val, msg).to.not.be.a(type);
	  };
	
	  /**
	   * ### .instanceOf(object, constructor, [message])
	   *
	   * Asserts that `value` is an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new Tea('chai');
	   *
	   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
	   *
	   * @name instanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.instanceOf = function (val, type, msg) {
	    new Assertion(val, msg).to.be.instanceOf(type);
	  };
	
	  /**
	   * ### .notInstanceOf(object, constructor, [message])
	   *
	   * Asserts `value` is not an instance of `constructor`.
	   *
	   *     var Tea = function (name) { this.name = name; }
	   *       , chai = new String('chai');
	   *
	   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
	   *
	   * @name notInstanceOf
	   * @param {Object} object
	   * @param {Constructor} constructor
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notInstanceOf = function (val, type, msg) {
	    new Assertion(val, msg).to.not.be.instanceOf(type);
	  };
	
	  /**
	   * ### .include(haystack, needle, [message])
	   *
	   * Asserts that `haystack` includes `needle`. Works
	   * for strings and arrays.
	   *
	   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
	   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
	   *
	   * @name include
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.include = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.include).include(inc);
	  };
	
	  /**
	   * ### .notInclude(haystack, needle, [message])
	   *
	   * Asserts that `haystack` does not include `needle`. Works
	   * for strings and arrays.
	   *
	   *     assert.notInclude('foobar', 'baz', 'string not include substring');
	   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
	   *
	   * @name notInclude
	   * @param {Array|String} haystack
	   * @param {Mixed} needle
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notInclude = function (exp, inc, msg) {
	    new Assertion(exp, msg, assert.notInclude).not.include(inc);
	  };
	
	  /**
	   * ### .match(value, regexp, [message])
	   *
	   * Asserts that `value` matches the regular expression `regexp`.
	   *
	   *     assert.match('foobar', /^foo/, 'regexp matches');
	   *
	   * @name match
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.match = function (exp, re, msg) {
	    new Assertion(exp, msg).to.match(re);
	  };
	
	  /**
	   * ### .notMatch(value, regexp, [message])
	   *
	   * Asserts that `value` does not match the regular expression `regexp`.
	   *
	   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
	   *
	   * @name notMatch
	   * @param {Mixed} value
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notMatch = function (exp, re, msg) {
	    new Assertion(exp, msg).to.not.match(re);
	  };
	
	  /**
	   * ### .property(object, property, [message])
	   *
	   * Asserts that `object` has a property named by `property`.
	   *
	   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
	   *
	   * @name property
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.property = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.have.property(prop);
	  };
	
	  /**
	   * ### .notProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property`.
	   *
	   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
	   *
	   * @name notProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.not.have.property(prop);
	  };
	
	  /**
	   * ### .deepProperty(object, property, [message])
	   *
	   * Asserts that `object` has a property named by `property`, which can be a
	   * string using dot- and bracket-notation for deep reference.
	   *
	   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
	   *
	   * @name deepProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.deepProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.have.deep.property(prop);
	  };
	
	  /**
	   * ### .notDeepProperty(object, property, [message])
	   *
	   * Asserts that `object` does _not_ have a property named by `property`, which
	   * can be a string using dot- and bracket-notation for deep reference.
	   *
	   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
	   *
	   * @name notDeepProperty
	   * @param {Object} object
	   * @param {String} property
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.notDeepProperty = function (obj, prop, msg) {
	    new Assertion(obj, msg).to.not.have.deep.property(prop);
	  };
	
	  /**
	   * ### .propertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with value given
	   * by `value`.
	   *
	   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
	   *
	   * @name propertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.propertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.have.property(prop, val);
	  };
	
	  /**
	   * ### .propertyNotVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property`, but with a value
	   * different from that given by `value`.
	   *
	   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
	   *
	   * @name propertyNotVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.propertyNotVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.not.have.property(prop, val);
	  };
	
	  /**
	   * ### .deepPropertyVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property` with value given
	   * by `value`. `property` can use dot- and bracket-notation for deep
	   * reference.
	   *
	   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
	   *
	   * @name deepPropertyVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.deepPropertyVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.have.deep.property(prop, val);
	  };
	
	  /**
	   * ### .deepPropertyNotVal(object, property, value, [message])
	   *
	   * Asserts that `object` has a property named by `property`, but with a value
	   * different from that given by `value`. `property` can use dot- and
	   * bracket-notation for deep reference.
	   *
	   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
	   *
	   * @name deepPropertyNotVal
	   * @param {Object} object
	   * @param {String} property
	   * @param {Mixed} value
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
	    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
	  };
	
	  /**
	   * ### .lengthOf(object, length, [message])
	   *
	   * Asserts that `object` has a `length` property with the expected value.
	   *
	   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
	   *     assert.lengthOf('foobar', 6, 'string has length of 6');
	   *
	   * @name lengthOf
	   * @param {Mixed} object
	   * @param {Number} length
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.lengthOf = function (exp, len, msg) {
	    new Assertion(exp, msg).to.have.length(len);
	  };
	
	  /**
	   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
	   *
	   * Asserts that `function` will throw an error that is an instance of
	   * `constructor`, or alternately that it will throw an error with message
	   * matching `regexp`.
	   *
	   *     assert.throws(fn, 'function throws a reference error');
	   *     assert.throws(fn, /function throws a reference error/);
	   *     assert.throws(fn, ReferenceError);
	   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
	   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
	   *
	   * @name throws
	   * @alias throw
	   * @alias Throw
	   * @param {Function} function
	   * @param {ErrorConstructor} constructor
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.throws = function (fn, errt, errs, msg) {
	    if ('string' === typeof errt || errt instanceof RegExp) {
	      errs = errt;
	      errt = null;
	    }
	
	    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
	    return flag(assertErr, 'object');
	  };
	
	  /**
	   * ### .doesNotThrow(function, [constructor/regexp], [message])
	   *
	   * Asserts that `function` will _not_ throw an error that is an instance of
	   * `constructor`, or alternately that it will not throw an error with message
	   * matching `regexp`.
	   *
	   *     assert.doesNotThrow(fn, Error, 'function does not throw');
	   *
	   * @name doesNotThrow
	   * @param {Function} function
	   * @param {ErrorConstructor} constructor
	   * @param {RegExp} regexp
	   * @param {String} message
	   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.doesNotThrow = function (fn, type, msg) {
	    if ('string' === typeof type) {
	      msg = type;
	      type = null;
	    }
	
	    new Assertion(fn, msg).to.not.Throw(type);
	  };
	
	  /**
	   * ### .operator(val1, operator, val2, [message])
	   *
	   * Compares two values using `operator`.
	   *
	   *     assert.operator(1, '<', 2, 'everything is ok');
	   *     assert.operator(1, '>', 2, 'this will fail');
	   *
	   * @name operator
	   * @param {Mixed} val1
	   * @param {String} operator
	   * @param {Mixed} val2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.operator = function (val, operator, val2, msg) {
	    var ok;
	    switch(operator) {
	      case '==':
	        ok = val == val2;
	        break;
	      case '===':
	        ok = val === val2;
	        break;
	      case '>':
	        ok = val > val2;
	        break;
	      case '>=':
	        ok = val >= val2;
	        break;
	      case '<':
	        ok = val < val2;
	        break;
	      case '<=':
	        ok = val <= val2;
	        break;
	      case '!=':
	        ok = val != val2;
	        break;
	      case '!==':
	        ok = val !== val2;
	        break;
	      default:
	        throw new Error('Invalid operator "' + operator + '"');
	    }
	    var test = new Assertion(ok, msg);
	    test.assert(
	        true === flag(test, 'object')
	      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
	      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
	  };
	
	  /**
	   * ### .closeTo(actual, expected, delta, [message])
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
	   *
	   * @name closeTo
	   * @param {Number} actual
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.closeTo = function (act, exp, delta, msg) {
	    new Assertion(act, msg).to.be.closeTo(exp, delta);
	  };
	
	  /**
	   * ### .approximately(actual, expected, delta, [message])
	   *
	   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
	   *
	   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
	   *
	   * @name approximately
	   * @param {Number} actual
	   * @param {Number} expected
	   * @param {Number} delta
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.approximately = function (act, exp, delta, msg) {
	    new Assertion(act, msg).to.be.approximately(exp, delta);
	  };
	
	  /**
	   * ### .sameMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members.
	   * Order is not taken into account.
	   *
	   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
	   *
	   * @name sameMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.sameMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg).to.have.same.members(set2);
	  }
	
	  /**
	   * ### .sameDeepMembers(set1, set2, [message])
	   *
	   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
	   * Order is not taken into account.
	   *
	   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
	   *
	   * @name sameDeepMembers
	   * @param {Array} set1
	   * @param {Array} set2
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.sameDeepMembers = function (set1, set2, msg) {
	    new Assertion(set1, msg).to.have.same.deep.members(set2);
	  }
	
	  /**
	   * ### .includeMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset`.
	   * Order is not taken into account.
	   *
	   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
	   *
	   * @name includeMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.includeMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg).to.include.members(subset);
	  }
	
	  /**
	   * ### .includeDeepMembers(superset, subset, [message])
	   *
	   * Asserts that `subset` is included in `superset` - using deep equality checking.
	   * Order is not taken into account.
	   * Duplicates are ignored.
	   *
	   *     assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], 'include deep members');
	   *
	   * @name includeDeepMembers
	   * @param {Array} superset
	   * @param {Array} subset
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.includeDeepMembers = function (superset, subset, msg) {
	    new Assertion(superset, msg).to.include.deep.members(subset);
	  }
	
	  /**
	   * ### .oneOf(inList, list, [message])
	   *
	   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
	   *
	   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
	   *
	   * @name oneOf
	   * @param {*} inList
	   * @param {Array<*>} list
	   * @param {String} message
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.oneOf = function (inList, list, msg) {
	    new Assertion(inList, msg).to.be.oneOf(list);
	  }
	
	   /**
	   * ### .changes(function, object, property)
	   *
	   * Asserts that a function changes the value of a property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 22 };
	   *     assert.changes(fn, obj, 'val');
	   *
	   * @name changes
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.changes = function (fn, obj, prop) {
	    new Assertion(fn).to.change(obj, prop);
	  }
	
	   /**
	   * ### .doesNotChange(function, object, property)
	   *
	   * Asserts that a function does not changes the value of a property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { console.log('foo'); };
	   *     assert.doesNotChange(fn, obj, 'val');
	   *
	   * @name doesNotChange
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.doesNotChange = function (fn, obj, prop) {
	    new Assertion(fn).to.not.change(obj, prop);
	  }
	
	   /**
	   * ### .increases(function, object, property)
	   *
	   * Asserts that a function increases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 13 };
	   *     assert.increases(fn, obj, 'val');
	   *
	   * @name increases
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.increases = function (fn, obj, prop) {
	    new Assertion(fn).to.increase(obj, prop);
	  }
	
	   /**
	   * ### .doesNotIncrease(function, object, property)
	   *
	   * Asserts that a function does not increase object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 8 };
	   *     assert.doesNotIncrease(fn, obj, 'val');
	   *
	   * @name doesNotIncrease
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.doesNotIncrease = function (fn, obj, prop) {
	    new Assertion(fn).to.not.increase(obj, prop);
	  }
	
	   /**
	   * ### .decreases(function, object, property)
	   *
	   * Asserts that a function decreases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 5 };
	   *     assert.decreases(fn, obj, 'val');
	   *
	   * @name decreases
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.decreases = function (fn, obj, prop) {
	    new Assertion(fn).to.decrease(obj, prop);
	  }
	
	   /**
	   * ### .doesNotDecrease(function, object, property)
	   *
	   * Asserts that a function does not decreases an object property
	   *
	   *     var obj = { val: 10 };
	   *     var fn = function() { obj.val = 15 };
	   *     assert.doesNotDecrease(fn, obj, 'val');
	   *
	   * @name doesNotDecrease
	   * @param {Function} modifier function
	   * @param {Object} object
	   * @param {String} property name
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.doesNotDecrease = function (fn, obj, prop) {
	    new Assertion(fn).to.not.decrease(obj, prop);
	  }
	
	  /*!
	   * ### .ifError(object)
	   *
	   * Asserts if value is not a false value, and throws if it is a true value.
	   * This is added to allow for chai to be a drop-in replacement for Node's
	   * assert class.
	   *
	   *     var err = new Error('I am a custom error');
	   *     assert.ifError(err); // Rethrows err!
	   *
	   * @name ifError
	   * @param {Object} object
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.ifError = function (val) {
	    if (val) {
	      throw(val);
	    }
	  };
	
	  /**
	   * ### .isExtensible(object)
	   *
	   * Asserts that `object` is extensible (can have new properties added to it).
	   *
	   *     assert.isExtensible({});
	   *
	   * @name isExtensible
	   * @alias extensible
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isExtensible = function (obj, msg) {
	    new Assertion(obj, msg).to.be.extensible;
	  };
	
	  /**
	   * ### .isNotExtensible(object)
	   *
	   * Asserts that `object` is _not_ extensible.
	   *
	   *     var nonExtensibleObject = Object.preventExtensions({});
	   *     var sealedObject = Object.seal({});
	   *     var frozenObject = Object.freese({});
	   *
	   *     assert.isNotExtensible(nonExtensibleObject);
	   *     assert.isNotExtensible(sealedObject);
	   *     assert.isNotExtensible(frozenObject);
	   *
	   * @name isNotExtensible
	   * @alias notExtensible
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotExtensible = function (obj, msg) {
	    new Assertion(obj, msg).to.not.be.extensible;
	  };
	
	  /**
	   * ### .isSealed(object)
	   *
	   * Asserts that `object` is sealed (cannot have new properties added to it
	   * and its existing properties cannot be removed).
	   *
	   *     var sealedObject = Object.seal({});
	   *     var frozenObject = Object.seal({});
	   *
	   *     assert.isSealed(sealedObject);
	   *     assert.isSealed(frozenObject);
	   *
	   * @name isSealed
	   * @alias sealed
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isSealed = function (obj, msg) {
	    new Assertion(obj, msg).to.be.sealed;
	  };
	
	  /**
	   * ### .isNotSealed(object)
	   *
	   * Asserts that `object` is _not_ sealed.
	   *
	   *     assert.isNotSealed({});
	   *
	   * @name isNotSealed
	   * @alias notSealed
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotSealed = function (obj, msg) {
	    new Assertion(obj, msg).to.not.be.sealed;
	  };
	
	  /**
	   * ### .isFrozen(object)
	   *
	   * Asserts that `object` is frozen (cannot have new properties added to it
	   * and its existing properties cannot be modified).
	   *
	   *     var frozenObject = Object.freeze({});
	   *     assert.frozen(frozenObject);
	   *
	   * @name isFrozen
	   * @alias frozen
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isFrozen = function (obj, msg) {
	    new Assertion(obj, msg).to.be.frozen;
	  };
	
	  /**
	   * ### .isNotFrozen(object)
	   *
	   * Asserts that `object` is _not_ frozen.
	   *
	   *     assert.isNotFrozen({});
	   *
	   * @name isNotFrozen
	   * @alias notFrozen
	   * @param {Object} object
	   * @param {String} message _optional_
	   * @namespace Assert
	   * @api public
	   */
	
	  assert.isNotFrozen = function (obj, msg) {
	    new Assertion(obj, msg).to.not.be.frozen;
	  };
	
	  /*!
	   * Aliases.
	   */
	
	  (function alias(name, as){
	    assert[as] = assert[name];
	    return alias;
	  })
	  ('isOk', 'ok')
	  ('isNotOk', 'notOk')
	  ('throws', 'throw')
	  ('throws', 'Throw')
	  ('isExtensible', 'extensible')
	  ('isNotExtensible', 'notExtensible')
	  ('isSealed', 'sealed')
	  ('isNotSealed', 'notSealed')
	  ('isFrozen', 'frozen')
	  ('isNotFrozen', 'notFrozen');
	};


/***/ }),
/* 281 */
/***/ (function(module, exports) {

	'use strict';
	
	var getScene = function () {
	    return {
	        'children': [ {
	            'children': [ {
	                'children': [ {
	                    'children': [ {
	                        'attributes': {
	                            'Normal': {
	                                'elements': [ 0.04907, 0.00483, -0.99878, 0.04907, 0.00483, -0.99878, 0.04907, 0.00483, -0.99878, 0.14671, 0.01445, -0.98907, 0.14671, 0.01445, -0.98907, 0.14671, 0.01445, -0.98907, 0.14671, 0.01445, -0.98907, 0.24291, 0.02392, -0.96975, 0.24291, 0.02392, -0.96975, 0.24291, 0.02392, -0.96975, 0.24291, 0.02392, -0.96975, 0.3367, 0.03316, -0.94103, 0.3367, 0.03316, -0.94103, 0.3367, 0.03316, -0.94103, 0.3367, 0.03316, -0.94103, 0.42718, 0.04207, -0.90319, 0.42718, 0.04207, -0.90319, 0.42718, 0.04207, -0.90319, 0.42718, 0.04207, -0.90319, 0.51345, 0.05057, -0.85663, 0.51345, 0.05057, -0.85663, 0.51345, 0.05057, -0.85663, 0.51345, 0.05057, -0.85663, 0.59468, 0.05857, -0.80183, 0.59468, 0.05857, -0.80183, 0.59468, 0.05857, -0.80183, 0.59468, 0.05857, -0.80183, 0.6701, 0.066, -0.73934, 0.6701, 0.066, -0.73934, 0.6701, 0.066, -0.73934, 0.6701, 0.066, -0.73934, 0.73899, 0.07278, -0.66978, 0.73899, 0.07278, -0.66978, 0.73899, 0.07278, -0.66978, 0.73899, 0.07278, -0.66978, 0.80071, 0.07886, -0.59384, 0.80071, 0.07886, -0.59384, 0.80071, 0.07886, -0.59384, 0.80071, 0.07886, -0.59384, 0.85468, 0.08418, -0.51228, 0.85468, 0.08418, -0.51228, 0.85468, 0.08418, -0.51228, 0.85468, 0.08418, -0.51228, 0.90043, 0.08868, -0.42587, 0.90043, 0.08868, -0.42587, 0.90043, 0.08868, -0.42587, 0.90043, 0.08868, -0.42587, 0.93752, 0.09233, -0.33545, 0.93752, 0.09233, -0.33545, 0.93752, 0.09233, -0.33545, 0.93752, 0.09233, -0.33545, 0.96563, 0.0951, -0.24188, 0.96563, 0.0951, -0.24188, 0.96563, 0.0951, -0.24188, 0.96563, 0.0951, -0.24188, 0.98452, 0.09696, -0.14604, 0.98452, 0.09696, -0.14604, 0.98452, 0.09696, -0.14604, 0.98452, 0.09696, -0.14604, 0.994, 0.0979, -0.04883, 0.994, 0.0979, -0.04883, 0.994, 0.0979, -0.04883, 0.994, 0.0979, -0.04883, 0.994, 0.0979, 0.04883, 0.994, 0.0979, 0.04883, 0.994, 0.0979, 0.04883, 0.994, 0.0979, 0.04883, 0.98452, 0.09696, 0.14604, 0.98452, 0.09696, 0.14604, 0.98452, 0.09696, 0.14604, 0.98452, 0.09696, 0.14604, 0.96563, 0.0951, 0.24188, 0.96563, 0.0951, 0.24188, 0.96563, 0.0951, 0.24188, 0.96563, 0.0951, 0.24188, 0.93752, 0.09233, 0.33545, 0.93752, 0.09233, 0.33545, 0.93752, 0.09233, 0.33545, 0.93752, 0.09233, 0.33545, 0.90043, 0.08868, 0.42587, 0.90043, 0.08868, 0.42587, 0.90043, 0.08868, 0.42587, 0.90043, 0.08868, 0.42587, 0.85468, 0.08418, 0.51228, 0.85468, 0.08418, 0.51228, 0.85468, 0.08418, 0.51228, 0.85468, 0.08418, 0.51228, 0.80071, 0.07886, 0.59384, 0.80071, 0.07886, 0.59384, 0.80071, 0.07886, 0.59384, 0.80071, 0.07886, 0.59384, 0.73899, 0.07278, 0.66978, 0.73899, 0.07278, 0.66978, 0.73899, 0.07278, 0.66978, 0.73899, 0.07278, 0.66978, 0.6701, 0.066, 0.73934, 0.6701, 0.066, 0.73934, 0.6701, 0.066, 0.73934, 0.6701, 0.066, 0.73934, 0.59468, 0.05857, 0.80183, 0.59468, 0.05857, 0.80183, 0.59468, 0.05857, 0.80183, 0.59468, 0.05857, 0.80183, 0.51345, 0.05057, 0.85663, 0.51345, 0.05057, 0.85663, 0.51345, 0.05057, 0.85663, 0.51345, 0.05057, 0.85663, 0.42718, 0.04207, 0.90319, 0.42718, 0.04207, 0.90319, 0.42718, 0.04207, 0.90319, 0.42718, 0.04207, 0.90319, 0.33671, 0.03316, 0.94103, 0.33671, 0.03316, 0.94103, 0.33671, 0.03316, 0.94103, 0.33671, 0.03316, 0.94103, 0.24291, 0.02392, 0.96975, 0.24291, 0.02392, 0.96975, 0.24291, 0.02392, 0.96975, 0.24291, 0.02392, 0.96975, 0.14672, 0.01445, 0.98907, 0.14672, 0.01445, 0.98907, 0.14672, 0.01445, 0.98907, 0.14672, 0.01445, 0.98907, 0.04907, 0.00483, 0.99878, 0.04907, 0.00483, 0.99878, 0.04907, 0.00483, 0.99878, 0.04718, 0.01431, 0.99878, 0.04718, 0.01431, 0.99878, 0.04718, 0.01431, 0.99878, 0.14108, 0.0428, 0.98907, 0.14108, 0.0428, 0.98907, 0.14108, 0.0428, 0.98907, 0.14108, 0.0428, 0.98907, 0.23358, 0.07085, 0.96975, 0.23358, 0.07085, 0.96975, 0.23358, 0.07085, 0.96975, 0.23358, 0.07085, 0.96975, 0.32377, 0.09821, 0.94103, 0.32377, 0.09821, 0.94103, 0.32377, 0.09821, 0.94103, 0.32377, 0.09821, 0.94103, 0.41076, 0.1246, 0.90319, 0.41076, 0.1246, 0.90319, 0.41076, 0.1246, 0.90319, 0.41076, 0.1246, 0.90319, 0.49371, 0.14977, 0.85663, 0.49371, 0.14977, 0.85663, 0.49371, 0.14977, 0.85663, 0.49371, 0.14977, 0.85663, 0.57182, 0.17346, 0.80183, 0.57182, 0.17346, 0.80183, 0.57182, 0.17346, 0.80183, 0.57182, 0.17346, 0.80183, 0.64434, 0.19546, 0.73934, 0.64434, 0.19546, 0.73934, 0.64434, 0.19546, 0.73934, 0.64434, 0.19546, 0.73934, 0.71059, 0.21555, 0.66978, 0.71059, 0.21555, 0.66978, 0.71059, 0.21555, 0.66978, 0.71059, 0.21555, 0.66978, 0.76994, 0.23356, 0.59384, 0.76994, 0.23356, 0.59384, 0.76994, 0.23356, 0.59384, 0.76994, 0.23356, 0.59384, 0.82184, 0.2493, 0.51228, 0.82184, 0.2493, 0.51228, 0.82184, 0.2493, 0.51228, 0.82184, 0.2493, 0.51228, 0.86582, 0.26265, 0.42587, 0.86582, 0.26265, 0.42587, 0.86582, 0.26265, 0.42587, 0.86582, 0.26265, 0.42587, 0.90149, 0.27347, 0.33545, 0.90149, 0.27347, 0.33545, 0.90149, 0.27347, 0.33545, 0.90149, 0.27347, 0.33545, 0.92853, 0.28167, 0.24188, 0.92853, 0.28167, 0.24188, 0.92853, 0.28167, 0.24188, 0.92853, 0.28167, 0.24188, 0.94668, 0.28717, 0.14604, 0.94668, 0.28717, 0.14604, 0.94668, 0.28717, 0.14604, 0.94668, 0.28717, 0.14604, 0.9558, 0.28994, 0.04883, 0.9558, 0.28994, 0.04883, 0.9558, 0.28994, 0.04883, 0.9558, 0.28994, 0.04883, 0.9558, 0.28994, -0.04883, 0.9558, 0.28994, -0.04883, 0.9558, 0.28994, -0.04883, 0.9558, 0.28994, -0.04883, 0.94668, 0.28717, -0.14604, 0.94668, 0.28717, -0.14604, 0.94668, 0.28717, -0.14604, 0.94668, 0.28717, -0.14604, 0.92853, 0.28167, -0.24188, 0.92853, 0.28167, -0.24188, 0.92853, 0.28167, -0.24188, 0.92853, 0.28167, -0.24188, 0.90149, 0.27347, -0.33545, 0.90149, 0.27347, -0.33545, 0.90149, 0.27347, -0.33545, 0.90149, 0.27347, -0.33545, 0.86582, 0.26265, -0.42587, 0.86582, 0.26265, -0.42587, 0.86582, 0.26265, -0.42587, 0.86582, 0.26265, -0.42587, 0.82184, 0.2493, -0.51228, 0.82184, 0.2493, -0.51228, 0.82184, 0.2493, -0.51228, 0.82184, 0.2493, -0.51228, 0.76993, 0.23356, -0.59384, 0.76993, 0.23356, -0.59384, 0.76993, 0.23356, -0.59384, 0.76993, 0.23356, -0.59384, 0.71059, 0.21555, -0.66978, 0.71059, 0.21555, -0.66978, 0.71059, 0.21555, -0.66978, 0.71059, 0.21555, -0.66978, 0.64434, 0.19546, -0.73934, 0.64434, 0.19546, -0.73934, 0.64434, 0.19546, -0.73934, 0.64434, 0.19546, -0.73934, 0.57182, 0.17346, -0.80183, 0.57182, 0.17346, -0.80183, 0.57182, 0.17346, -0.80183, 0.57182, 0.17346, -0.80183, 0.49371, 0.14977, -0.85663, 0.49371, 0.14977, -0.85663, 0.49371, 0.14977, -0.85663, 0.49371, 0.14977, -0.85663, 0.41076, 0.1246, -0.90319, 0.41076, 0.1246, -0.90319, 0.41076, 0.1246, -0.90319, 0.41076, 0.1246, -0.90319, 0.32376, 0.09821, -0.94103, 0.32376, 0.09821, -0.94103, 0.32376, 0.09821, -0.94103, 0.32376, 0.09821, -0.94103, 0.23357, 0.07085, -0.96975, 0.23357, 0.07085, -0.96975, 0.23357, 0.07085, -0.96975, 0.23357, 0.07085, -0.96975, 0.14108, 0.0428, -0.98907, 0.14108, 0.0428, -0.98907, 0.14108, 0.0428, -0.98907, 0.14108, 0.0428, -0.98907, 0.04718, 0.01431, -0.99878, 0.04718, 0.01431, -0.99878, 0.04718, 0.01431, -0.99878, 0.04348, 0.02324, -0.99878, 0.04348, 0.02324, -0.99878, 0.04348, 0.02324, -0.99878, 0.13002, 0.0695, -0.98907, 0.13002, 0.0695, -0.98907, 0.13002, 0.0695, -0.98907, 0.13002, 0.0695, -0.98907, 0.21526, 0.11506, -0.96975, 0.21526, 0.11506, -0.96975, 0.21526, 0.11506, -0.96975, 0.21526, 0.11506, -0.96975, 0.29838, 0.15949, -0.94103, 0.29838, 0.15949, -0.94103, 0.29838, 0.15949, -0.94103, 0.29838, 0.15949, -0.94103, 0.37856, 0.20234, -0.90319, 0.37856, 0.20234, -0.90319, 0.37856, 0.20234, -0.90319, 0.37856, 0.20234, -0.90319, 0.45501, 0.24321, -0.85663, 0.45501, 0.24321, -0.85663, 0.45501, 0.24321, -0.85663, 0.45501, 0.24321, -0.85663, 0.527, 0.28168, -0.80183, 0.527, 0.28168, -0.80183, 0.527, 0.28168, -0.80183, 0.527, 0.28168, -0.80183, 0.59383, 0.31741, -0.73934, 0.59383, 0.31741, -0.73934, 0.59383, 0.31741, -0.73934, 0.59383, 0.31741, -0.73934, 0.65488, 0.35004, -0.66978, 0.65488, 0.35004, -0.66978, 0.65488, 0.35004, -0.66978, 0.65488, 0.35004, -0.66978, 0.70958, 0.37928, -0.59384, 0.70958, 0.37928, -0.59384, 0.70958, 0.37928, -0.59384, 0.70958, 0.37928, -0.59384, 0.75741, 0.40484, -0.51228, 0.75741, 0.40484, -0.51228, 0.75741, 0.40484, -0.51228, 0.75741, 0.40484, -0.51228, 0.79795, 0.42651, -0.42587, 0.79795, 0.42651, -0.42587, 0.79795, 0.42651, -0.42587, 0.79795, 0.42651, -0.42587, 0.83082, 0.44408, -0.33545, 0.83082, 0.44408, -0.33545, 0.83082, 0.44408, -0.33545, 0.83082, 0.44408, -0.33545, 0.85573, 0.4574, -0.24188, 0.85573, 0.4574, -0.24188, 0.85573, 0.4574, -0.24188, 0.85573, 0.4574, -0.24188, 0.87247, 0.46634, -0.14604, 0.87247, 0.46634, -0.14604, 0.87247, 0.46634, -0.14604, 0.87247, 0.46634, -0.14604, 0.88087, 0.47083, -0.04883, 0.88087, 0.47083, -0.04883, 0.88087, 0.47083, -0.04883, 0.88087, 0.47083, -0.04883, 0.88087, 0.47083, 0.04883, 0.88087, 0.47083, 0.04883, 0.88087, 0.47083, 0.04883, 0.88087, 0.47083, 0.04883, 0.87247, 0.46634, 0.14604, 0.87247, 0.46634, 0.14604, 0.87247, 0.46634, 0.14604, 0.87247, 0.46634, 0.14604, 0.85573, 0.4574, 0.24188, 0.85573, 0.4574, 0.24188, 0.85573, 0.4574, 0.24188, 0.85573, 0.4574, 0.24188, 0.83082, 0.44408, 0.33545, 0.83082, 0.44408, 0.33545, 0.83082, 0.44408, 0.33545, 0.83082, 0.44408, 0.33545, 0.79795, 0.42651, 0.42587, 0.79795, 0.42651, 0.42587, 0.79795, 0.42651, 0.42587, 0.79795, 0.42651, 0.42587, 0.75741, 0.40484, 0.51228, 0.75741, 0.40484, 0.51228, 0.75741, 0.40484, 0.51228, 0.75741, 0.40484, 0.51228, 0.70958, 0.37928, 0.59384, 0.70958, 0.37928, 0.59384, 0.70958, 0.37928, 0.59384, 0.70958, 0.37928, 0.59384, 0.65488, 0.35004, 0.66978, 0.65488, 0.35004, 0.66978, 0.65488, 0.35004, 0.66978, 0.65488, 0.35004, 0.66978, 0.59383, 0.31741, 0.73934, 0.59383, 0.31741, 0.73934, 0.59383, 0.31741, 0.73934, 0.59383, 0.31741, 0.73934, 0.527, 0.28169, 0.80183, 0.527, 0.28169, 0.80183, 0.527, 0.28169, 0.80183, 0.527, 0.28169, 0.80183, 0.45501, 0.24321, 0.85663, 0.45501, 0.24321, 0.85663, 0.45501, 0.24321, 0.85663, 0.45501, 0.24321, 0.85663, 0.37856, 0.20234, 0.90319, 0.37856, 0.20234, 0.90319, 0.37856, 0.20234, 0.90319, 0.37856, 0.20234, 0.90319, 0.29838, 0.15949, 0.94103, 0.29838, 0.15949, 0.94103, 0.29838, 0.15949, 0.94103, 0.29838, 0.15949, 0.94103, 0.21526, 0.11506, 0.96975, 0.21526, 0.11506, 0.96975, 0.21526, 0.11506, 0.96975, 0.21526, 0.11506, 0.96975, 0.13002, 0.0695, 0.98907, 0.13002, 0.0695, 0.98907, 0.13002, 0.0695, 0.98907, 0.13002, 0.0695, 0.98907, 0.04348, 0.02324, 0.99878, 0.04348, 0.02324, 0.99878, 0.04348, 0.02324, 0.99878, 0.03811, 0.03128, 0.99878, 0.03811, 0.03128, 0.99878, 0.03811, 0.03128, 0.99878, 0.11396, 0.09353, 0.98907, 0.11396, 0.09353, 0.98907, 0.11396, 0.09353, 0.98907, 0.11396, 0.09353, 0.98907, 0.18868, 0.15485, 0.96975, 0.18868, 0.15485, 0.96975, 0.18868, 0.15485, 0.96975, 0.18868, 0.15485, 0.96975, 0.26154, 0.21464, 0.94103, 0.26154, 0.21464, 0.94103, 0.26154, 0.21464, 0.94103, 0.26154, 0.21464, 0.94103, 0.33181, 0.27231, 0.90319, 0.33181, 0.27231, 0.90319, 0.33181, 0.27231, 0.90319, 0.33181, 0.27231, 0.90319, 0.39882, 0.3273, 0.85663, 0.39882, 0.3273, 0.85663, 0.39882, 0.3273, 0.85663, 0.39882, 0.3273, 0.85663, 0.46192, 0.37908, 0.80183, 0.46192, 0.37908, 0.80183, 0.46192, 0.37908, 0.80183, 0.46192, 0.37908, 0.80183, 0.5205, 0.42716, 0.73934, 0.5205, 0.42716, 0.73934, 0.5205, 0.42716, 0.73934, 0.5205, 0.42716, 0.73934, 0.57401, 0.47108, 0.66978, 0.57401, 0.47108, 0.66978, 0.57401, 0.47108, 0.66978, 0.57401, 0.47108, 0.66978, 0.62195, 0.51042, 0.59384, 0.62195, 0.51042, 0.59384, 0.62195, 0.51042, 0.59384, 0.62195, 0.51042, 0.59384, 0.66388, 0.54483, 0.51228, 0.66388, 0.54483, 0.51228, 0.66388, 0.54483, 0.51228, 0.66388, 0.54483, 0.51228, 0.69941, 0.57399, 0.42587, 0.69941, 0.57399, 0.42587, 0.69941, 0.57399, 0.42587, 0.69941, 0.57399, 0.42587, 0.72822, 0.59764, 0.33545, 0.72822, 0.59764, 0.33545, 0.72822, 0.59764, 0.33545, 0.72822, 0.59764, 0.33545, 0.75006, 0.61556, 0.24188, 0.75006, 0.61556, 0.24188, 0.75006, 0.61556, 0.24188, 0.75006, 0.61556, 0.24188, 0.76472, 0.62759, 0.14604, 0.76472, 0.62759, 0.14604, 0.76472, 0.62759, 0.14604, 0.76472, 0.62759, 0.14604, 0.77209, 0.63364, 0.04883, 0.77209, 0.63364, 0.04883, 0.77209, 0.63364, 0.04883, 0.77209, 0.63364, 0.04883, 0.77209, 0.63364, -0.04883, 0.77209, 0.63364, -0.04883, 0.77209, 0.63364, -0.04883, 0.77209, 0.63364, -0.04883, 0.76472, 0.62759, -0.14604, 0.76472, 0.62759, -0.14604, 0.76472, 0.62759, -0.14604, 0.76472, 0.62759, -0.14604, 0.75006, 0.61556, -0.24188, 0.75006, 0.61556, -0.24188, 0.75006, 0.61556, -0.24188, 0.75006, 0.61556, -0.24188, 0.72822, 0.59764, -0.33545, 0.72822, 0.59764, -0.33545, 0.72822, 0.59764, -0.33545, 0.72822, 0.59764, -0.33545, 0.69941, 0.57399, -0.42587, 0.69941, 0.57399, -0.42587, 0.69941, 0.57399, -0.42587, 0.69941, 0.57399, -0.42587, 0.66388, 0.54483, -0.51228, 0.66388, 0.54483, -0.51228, 0.66388, 0.54483, -0.51228, 0.66388, 0.54483, -0.51228, 0.62195, 0.51042, -0.59384, 0.62195, 0.51042, -0.59384, 0.62195, 0.51042, -0.59384, 0.62195, 0.51042, -0.59384, 0.57401, 0.47108, -0.66978, 0.57401, 0.47108, -0.66978, 0.57401, 0.47108, -0.66978, 0.57401, 0.47108, -0.66978, 0.5205, 0.42716, -0.73934, 0.5205, 0.42716, -0.73934, 0.5205, 0.42716, -0.73934, 0.5205, 0.42716, -0.73934, 0.46192, 0.37908, -0.80183, 0.46192, 0.37908, -0.80183, 0.46192, 0.37908, -0.80183, 0.46192, 0.37908, -0.80183, 0.39882, 0.3273, -0.85663, 0.39882, 0.3273, -0.85663, 0.39882, 0.3273, -0.85663, 0.39882, 0.3273, -0.85663, 0.33181, 0.27231, -0.90319, 0.33181, 0.27231, -0.90319, 0.33181, 0.27231, -0.90319, 0.33181, 0.27231, -0.90319, 0.26154, 0.21464, -0.94103, 0.26154, 0.21464, -0.94103, 0.26154, 0.21464, -0.94103, 0.26154, 0.21464, -0.94103, 0.18868, 0.15485, -0.96975, 0.18868, 0.15485, -0.96975, 0.18868, 0.15485, -0.96975, 0.18868, 0.15485, -0.96975, 0.11396, 0.09353, -0.98907, 0.11396, 0.09353, -0.98907, 0.11396, 0.09353, -0.98907, 0.11396, 0.09353, -0.98907, 0.03811, 0.03128, -0.99878, 0.03811, 0.03128, -0.99878, 0.03811, 0.03128, -0.99878, 0.03128, 0.03811, -0.99878, 0.03128, 0.03811, -0.99878, 0.03128, 0.03811, -0.99878, 0.09353, 0.11396, -0.98907, 0.09353, 0.11396, -0.98907, 0.09353, 0.11396, -0.98907, 0.09353, 0.11396, -0.98907, 0.15485, 0.18868, -0.96975, 0.15485, 0.18868, -0.96975, 0.15485, 0.18868, -0.96975, 0.15485, 0.18868, -0.96975, 0.21464, 0.26154, -0.94103, 0.21464, 0.26154, -0.94103, 0.21464, 0.26154, -0.94103, 0.21464, 0.26154, -0.94103, 0.27231, 0.33181, -0.90319, 0.27231, 0.33181, -0.90319, 0.27231, 0.33181, -0.90319, 0.27231, 0.33181, -0.90319, 0.3273, 0.39882, -0.85663, 0.3273, 0.39882, -0.85663, 0.3273, 0.39882, -0.85663, 0.3273, 0.39882, -0.85663, 0.37908, 0.46192, -0.80183, 0.37908, 0.46192, -0.80183, 0.37908, 0.46192, -0.80183, 0.37908, 0.46192, -0.80183, 0.42716, 0.5205, -0.73934, 0.42716, 0.5205, -0.73934, 0.42716, 0.5205, -0.73934, 0.42716, 0.5205, -0.73934, 0.47108, 0.57401, -0.66978, 0.47108, 0.57401, -0.66978, 0.47108, 0.57401, -0.66978, 0.47108, 0.57401, -0.66978, 0.51042, 0.62195, -0.59384, 0.51042, 0.62195, -0.59384, 0.51042, 0.62195, -0.59384, 0.51042, 0.62195, -0.59384, 0.54483, 0.66388, -0.51228, 0.54483, 0.66388, -0.51228, 0.54483, 0.66388, -0.51228, 0.54483, 0.66388, -0.51228, 0.57399, 0.69941, -0.42587, 0.57399, 0.69941, -0.42587, 0.57399, 0.69941, -0.42587, 0.57399, 0.69941, -0.42587, 0.59764, 0.72822, -0.33545, 0.59764, 0.72822, -0.33545, 0.59764, 0.72822, -0.33545, 0.59764, 0.72822, -0.33545, 0.61556, 0.75006, -0.24188, 0.61556, 0.75006, -0.24188, 0.61556, 0.75006, -0.24188, 0.61556, 0.75006, -0.24188, 0.62759, 0.76472, -0.14604, 0.62759, 0.76472, -0.14604, 0.62759, 0.76472, -0.14604, 0.62759, 0.76472, -0.14604, 0.63364, 0.77209, -0.04883, 0.63364, 0.77209, -0.04883, 0.63364, 0.77209, -0.04883, 0.63364, 0.77209, -0.04883, 0.63364, 0.77209, 0.04883, 0.63364, 0.77209, 0.04883, 0.63364, 0.77209, 0.04883, 0.63364, 0.77209, 0.04883, 0.62759, 0.76472, 0.14604, 0.62759, 0.76472, 0.14604, 0.62759, 0.76472, 0.14604, 0.62759, 0.76472, 0.14604, 0.61556, 0.75006, 0.24188, 0.61556, 0.75006, 0.24188, 0.61556, 0.75006, 0.24188, 0.61556, 0.75006, 0.24188, 0.59763, 0.72822, 0.33545, 0.59763, 0.72822, 0.33545, 0.59763, 0.72822, 0.33545, 0.59763, 0.72822, 0.33545, 0.57399, 0.69941, 0.42587, 0.57399, 0.69941, 0.42587, 0.57399, 0.69941, 0.42587, 0.57399, 0.69941, 0.42587, 0.54483, 0.66388, 0.51228, 0.54483, 0.66388, 0.51228, 0.54483, 0.66388, 0.51228, 0.54483, 0.66388, 0.51228, 0.51042, 0.62195, 0.59384, 0.51042, 0.62195, 0.59384, 0.51042, 0.62195, 0.59384, 0.51042, 0.62195, 0.59384, 0.47108, 0.57401, 0.66978, 0.47108, 0.57401, 0.66978, 0.47108, 0.57401, 0.66978, 0.47108, 0.57401, 0.66978, 0.42716, 0.5205, 0.73934, 0.42716, 0.5205, 0.73934, 0.42716, 0.5205, 0.73934, 0.42716, 0.5205, 0.73934, 0.37908, 0.46192, 0.80183, 0.37908, 0.46192, 0.80183, 0.37908, 0.46192, 0.80183, 0.37908, 0.46192, 0.80183, 0.3273, 0.39882, 0.85663, 0.3273, 0.39882, 0.85663, 0.3273, 0.39882, 0.85663, 0.3273, 0.39882, 0.85663, 0.27231, 0.33181, 0.90319, 0.27231, 0.33181, 0.90319, 0.27231, 0.33181, 0.90319, 0.27231, 0.33181, 0.90319, 0.21464, 0.26154, 0.94103, 0.21464, 0.26154, 0.94103, 0.21464, 0.26154, 0.94103, 0.21464, 0.26154, 0.94103, 0.15485, 0.18868, 0.96975, 0.15485, 0.18868, 0.96975, 0.15485, 0.18868, 0.96975, 0.15485, 0.18868, 0.96975, 0.09353, 0.11396, 0.98907, 0.09353, 0.11396, 0.98907, 0.09353, 0.11396, 0.98907, 0.09353, 0.11396, 0.98907, 0.03128, 0.03811, 0.99878, 0.03128, 0.03811, 0.99878, 0.03128, 0.03811, 0.99878, 0.02324, 0.04348, 0.99878, 0.02324, 0.04348, 0.99878, 0.02324, 0.04348, 0.99878, 0.0695, 0.13002, 0.98907, 0.0695, 0.13002, 0.98907, 0.0695, 0.13002, 0.98907, 0.0695, 0.13002, 0.98907, 0.11506, 0.21526, 0.96975, 0.11506, 0.21526, 0.96975, 0.11506, 0.21526, 0.96975, 0.11506, 0.21526, 0.96975, 0.15949, 0.29838, 0.94103, 0.15949, 0.29838, 0.94103, 0.15949, 0.29838, 0.94103, 0.15949, 0.29838, 0.94103, 0.20234, 0.37856, 0.90319, 0.20234, 0.37856, 0.90319, 0.20234, 0.37856, 0.90319, 0.20234, 0.37856, 0.90319, 0.24321, 0.45501, 0.85663, 0.24321, 0.45501, 0.85663, 0.24321, 0.45501, 0.85663, 0.24321, 0.45501, 0.85663, 0.28168, 0.527, 0.80183, 0.28168, 0.527, 0.80183, 0.28168, 0.527, 0.80183, 0.28168, 0.527, 0.80183, 0.31741, 0.59383, 0.73934, 0.31741, 0.59383, 0.73934, 0.31741, 0.59383, 0.73934, 0.31741, 0.59383, 0.73934, 0.35004, 0.65488, 0.66978, 0.35004, 0.65488, 0.66978, 0.35004, 0.65488, 0.66978, 0.35004, 0.65488, 0.66978, 0.37928, 0.70958, 0.59384, 0.37928, 0.70958, 0.59384, 0.37928, 0.70958, 0.59384, 0.37928, 0.70958, 0.59384, 0.40484, 0.75741, 0.51228, 0.40484, 0.75741, 0.51228, 0.40484, 0.75741, 0.51228, 0.40484, 0.75741, 0.51228, 0.42651, 0.79795, 0.42587, 0.42651, 0.79795, 0.42587, 0.42651, 0.79795, 0.42587, 0.42651, 0.79795, 0.42587, 0.44408, 0.83082, 0.33545, 0.44408, 0.83082, 0.33545, 0.44408, 0.83082, 0.33545, 0.44408, 0.83082, 0.33545, 0.4574, 0.85573, 0.24188, 0.4574, 0.85573, 0.24188, 0.4574, 0.85573, 0.24188, 0.4574, 0.85573, 0.24188, 0.46634, 0.87247, 0.14604, 0.46634, 0.87247, 0.14604, 0.46634, 0.87247, 0.14604, 0.46634, 0.87247, 0.14604, 0.47083, 0.88087, 0.04883, 0.47083, 0.88087, 0.04883, 0.47083, 0.88087, 0.04883, 0.47083, 0.88087, 0.04883, 0.47083, 0.88087, -0.04883, 0.47083, 0.88087, -0.04883, 0.47083, 0.88087, -0.04883, 0.47083, 0.88087, -0.04883, 0.46634, 0.87247, -0.14604, 0.46634, 0.87247, -0.14604, 0.46634, 0.87247, -0.14604, 0.46634, 0.87247, -0.14604, 0.4574, 0.85573, -0.24188, 0.4574, 0.85573, -0.24188, 0.4574, 0.85573, -0.24188, 0.4574, 0.85573, -0.24188, 0.44408, 0.83082, -0.33545, 0.44408, 0.83082, -0.33545, 0.44408, 0.83082, -0.33545, 0.44408, 0.83082, -0.33545, 0.42651, 0.79795, -0.42587, 0.42651, 0.79795, -0.42587, 0.42651, 0.79795, -0.42587, 0.42651, 0.79795, -0.42587, 0.40484, 0.75741, -0.51228, 0.40484, 0.75741, -0.51228, 0.40484, 0.75741, -0.51228, 0.40484, 0.75741, -0.51228, 0.37928, 0.70958, -0.59384, 0.37928, 0.70958, -0.59384, 0.37928, 0.70958, -0.59384, 0.37928, 0.70958, -0.59384, 0.35004, 0.65488, -0.66978, 0.35004, 0.65488, -0.66978, 0.35004, 0.65488, -0.66978, 0.35004, 0.65488, -0.66978, 0.31741, 0.59383, -0.73934, 0.31741, 0.59383, -0.73934, 0.31741, 0.59383, -0.73934, 0.31741, 0.59383, -0.73934, 0.28168, 0.527, -0.80183, 0.28168, 0.527, -0.80183, 0.28168, 0.527, -0.80183, 0.28168, 0.527, -0.80183, 0.24321, 0.45501, -0.85663, 0.24321, 0.45501, -0.85663, 0.24321, 0.45501, -0.85663, 0.24321, 0.45501, -0.85663, 0.20234, 0.37856, -0.90319, 0.20234, 0.37856, -0.90319, 0.20234, 0.37856, -0.90319, 0.20234, 0.37856, -0.90319, 0.15949, 0.29838, -0.94103, 0.15949, 0.29838, -0.94103, 0.15949, 0.29838, -0.94103, 0.15949, 0.29838, -0.94103, 0.11506, 0.21526, -0.96975, 0.11506, 0.21526, -0.96975, 0.11506, 0.21526, -0.96975, 0.11506, 0.21526, -0.96975, 0.0695, 0.13002, -0.98907, 0.0695, 0.13002, -0.98907, 0.0695, 0.13002, -0.98907, 0.0695, 0.13002, -0.98907, 0.02324, 0.04348, -0.99878, 0.02324, 0.04348, -0.99878, 0.02324, 0.04348, -0.99878, 0.01431, 0.04718, -0.99878, 0.01431, 0.04718, -0.99878, 0.01431, 0.04718, -0.99878, 0.0428, 0.14108, -0.98907, 0.0428, 0.14108, -0.98907, 0.0428, 0.14108, -0.98907, 0.0428, 0.14108, -0.98907, 0.07085, 0.23357, -0.96975, 0.07085, 0.23357, -0.96975, 0.07085, 0.23357, -0.96975, 0.07085, 0.23357, -0.96975, 0.09821, 0.32377, -0.94103, 0.09821, 0.32377, -0.94103, 0.09821, 0.32377, -0.94103, 0.09821, 0.32377, -0.94103, 0.1246, 0.41076, -0.90319, 0.1246, 0.41076, -0.90319, 0.1246, 0.41076, -0.90319, 0.1246, 0.41076, -0.90319, 0.14977, 0.49371, -0.85663, 0.14977, 0.49371, -0.85663, 0.14977, 0.49371, -0.85663, 0.14977, 0.49371, -0.85663, 0.17346, 0.57182, -0.80183, 0.17346, 0.57182, -0.80183, 0.17346, 0.57182, -0.80183, 0.17346, 0.57182, -0.80183, 0.19546, 0.64434, -0.73934, 0.19546, 0.64434, -0.73934, 0.19546, 0.64434, -0.73934, 0.19546, 0.64434, -0.73934, 0.21555, 0.71059, -0.66978, 0.21555, 0.71059, -0.66978, 0.21555, 0.71059, -0.66978, 0.21555, 0.71059, -0.66978, 0.23356, 0.76993, -0.59384, 0.23356, 0.76993, -0.59384, 0.23356, 0.76993, -0.59384, 0.23356, 0.76993, -0.59384, 0.2493, 0.82184, -0.51228, 0.2493, 0.82184, -0.51228, 0.2493, 0.82184, -0.51228, 0.2493, 0.82184, -0.51228, 0.26264, 0.86582, -0.42587, 0.26264, 0.86582, -0.42587, 0.26264, 0.86582, -0.42587, 0.26264, 0.86582, -0.42587, 0.27346, 0.90149, -0.33545, 0.27346, 0.90149, -0.33545, 0.27346, 0.90149, -0.33545, 0.27346, 0.90149, -0.33545, 0.28166, 0.92853, -0.24188, 0.28166, 0.92853, -0.24188, 0.28166, 0.92853, -0.24188, 0.28166, 0.92853, -0.24188, 0.28717, 0.94668, -0.14604, 0.28717, 0.94668, -0.14604, 0.28717, 0.94668, -0.14604, 0.28717, 0.94668, -0.14604, 0.28994, 0.9558, -0.04883, 0.28994, 0.9558, -0.04883, 0.28994, 0.9558, -0.04883, 0.28994, 0.9558, -0.04883, 0.28994, 0.9558, 0.04883, 0.28994, 0.9558, 0.04883, 0.28994, 0.9558, 0.04883, 0.28994, 0.9558, 0.04883, 0.28717, 0.94668, 0.14604, 0.28717, 0.94668, 0.14604, 0.28717, 0.94668, 0.14604, 0.28717, 0.94668, 0.14604, 0.28166, 0.92853, 0.24188, 0.28166, 0.92853, 0.24188, 0.28166, 0.92853, 0.24188, 0.28166, 0.92853, 0.24188, 0.27346, 0.90149, 0.33545, 0.27346, 0.90149, 0.33545, 0.27346, 0.90149, 0.33545, 0.27346, 0.90149, 0.33545, 0.26264, 0.86582, 0.42587, 0.26264, 0.86582, 0.42587, 0.26264, 0.86582, 0.42587, 0.26264, 0.86582, 0.42587, 0.2493, 0.82184, 0.51228, 0.2493, 0.82184, 0.51228, 0.2493, 0.82184, 0.51228, 0.2493, 0.82184, 0.51228, 0.23356, 0.76994, 0.59384, 0.23356, 0.76994, 0.59384, 0.23356, 0.76994, 0.59384, 0.23356, 0.76994, 0.59384, 0.21555, 0.71059, 0.66978, 0.21555, 0.71059, 0.66978, 0.21555, 0.71059, 0.66978, 0.21555, 0.71059, 0.66978, 0.19546, 0.64434, 0.73934, 0.19546, 0.64434, 0.73934, 0.19546, 0.64434, 0.73934, 0.19546, 0.64434, 0.73934, 0.17346, 0.57182, 0.80183, 0.17346, 0.57182, 0.80183, 0.17346, 0.57182, 0.80183, 0.17346, 0.57182, 0.80183, 0.14977, 0.49371, 0.85663, 0.14977, 0.49371, 0.85663, 0.14977, 0.49371, 0.85663, 0.14977, 0.49371, 0.85663, 0.1246, 0.41076, 0.90319, 0.1246, 0.41076, 0.90319, 0.1246, 0.41076, 0.90319, 0.1246, 0.41076, 0.90319, 0.09821, 0.32377, 0.94103, 0.09821, 0.32377, 0.94103, 0.09821, 0.32377, 0.94103, 0.09821, 0.32377, 0.94103, 0.07085, 0.23358, 0.96975, 0.07085, 0.23358, 0.96975, 0.07085, 0.23358, 0.96975, 0.07085, 0.23358, 0.96975, 0.0428, 0.14108, 0.98907, 0.0428, 0.14108, 0.98907, 0.0428, 0.14108, 0.98907, 0.0428, 0.14108, 0.98907, 0.01431, 0.04718, 0.99878, 0.01431, 0.04718, 0.99878, 0.01431, 0.04718, 0.99878, 0.00483, 0.04907, 0.99878, 0.00483, 0.04907, 0.99878, 0.00483, 0.04907, 0.99878, 0.01445, 0.14672, 0.98907, 0.01445, 0.14672, 0.98907, 0.01445, 0.14672, 0.98907, 0.01445, 0.14672, 0.98907, 0.02392, 0.24291, 0.96975, 0.02392, 0.24291, 0.96975, 0.02392, 0.24291, 0.96975, 0.02392, 0.24291, 0.96975, 0.03316, 0.33671, 0.94103, 0.03316, 0.33671, 0.94103, 0.03316, 0.33671, 0.94103, 0.03316, 0.33671, 0.94103, 0.04207, 0.42718, 0.90319, 0.04207, 0.42718, 0.90319, 0.04207, 0.42718, 0.90319, 0.04207, 0.42718, 0.90319, 0.05057, 0.51344, 0.85663, 0.05057, 0.51344, 0.85663, 0.05057, 0.51344, 0.85663, 0.05057, 0.51344, 0.85663, 0.05857, 0.59468, 0.80183, 0.05857, 0.59468, 0.80183, 0.05857, 0.59468, 0.80183, 0.05857, 0.59468, 0.80183, 0.066, 0.67009, 0.73934, 0.066, 0.67009, 0.73934, 0.066, 0.67009, 0.73934, 0.066, 0.67009, 0.73934, 0.07278, 0.73899, 0.66978, 0.07278, 0.73899, 0.66978, 0.07278, 0.73899, 0.66978, 0.07278, 0.73899, 0.66978, 0.07886, 0.80071, 0.59384, 0.07886, 0.80071, 0.59384, 0.07886, 0.80071, 0.59384, 0.07886, 0.80071, 0.59384, 0.08418, 0.85468, 0.51228, 0.08418, 0.85468, 0.51228, 0.08418, 0.85468, 0.51228, 0.08418, 0.85468, 0.51228, 0.08868, 0.90043, 0.42587, 0.08868, 0.90043, 0.42587, 0.08868, 0.90043, 0.42587, 0.08868, 0.90043, 0.42587, 0.09234, 0.93752, 0.33545, 0.09234, 0.93752, 0.33545, 0.09234, 0.93752, 0.33545, 0.09234, 0.93752, 0.33545, 0.09511, 0.96563, 0.24188, 0.09511, 0.96563, 0.24188, 0.09511, 0.96563, 0.24188, 0.09511, 0.96563, 0.24188, 0.09697, 0.98452, 0.14604, 0.09697, 0.98452, 0.14604, 0.09697, 0.98452, 0.14604, 0.09697, 0.98452, 0.14604, 0.0979, 0.994, 0.04883, 0.0979, 0.994, 0.04883, 0.0979, 0.994, 0.04883, 0.0979, 0.994, 0.04883, 0.0979, 0.994, -0.04883, 0.0979, 0.994, -0.04883, 0.0979, 0.994, -0.04883, 0.0979, 0.994, -0.04883, 0.09697, 0.98452, -0.14604, 0.09697, 0.98452, -0.14604, 0.09697, 0.98452, -0.14604, 0.09697, 0.98452, -0.14604, 0.09511, 0.96563, -0.24188, 0.09511, 0.96563, -0.24188, 0.09511, 0.96563, -0.24188, 0.09511, 0.96563, -0.24188, 0.09234, 0.93752, -0.33545, 0.09234, 0.93752, -0.33545, 0.09234, 0.93752, -0.33545, 0.09234, 0.93752, -0.33545, 0.08868, 0.90043, -0.42587, 0.08868, 0.90043, -0.42587, 0.08868, 0.90043, -0.42587, 0.08868, 0.90043, -0.42587, 0.08418, 0.85468, -0.51228, 0.08418, 0.85468, -0.51228, 0.08418, 0.85468, -0.51228, 0.08418, 0.85468, -0.51228, 0.07886, 0.80071, -0.59384, 0.07886, 0.80071, -0.59384, 0.07886, 0.80071, -0.59384, 0.07886, 0.80071, -0.59384, 0.07278, 0.73899, -0.66978, 0.07278, 0.73899, -0.66978, 0.07278, 0.73899, -0.66978, 0.07278, 0.73899, -0.66978, 0.066, 0.67009, -0.73934, 0.066, 0.67009, -0.73934, 0.066, 0.67009, -0.73934, 0.066, 0.67009, -0.73934, 0.05857, 0.59468, -0.80183, 0.05857, 0.59468, -0.80183, 0.05857, 0.59468, -0.80183, 0.05857, 0.59468, -0.80183, 0.05057, 0.51344, -0.85663, 0.05057, 0.51344, -0.85663, 0.05057, 0.51344, -0.85663, 0.05057, 0.51344, -0.85663, 0.04207, 0.42718, -0.90319, 0.04207, 0.42718, -0.90319, 0.04207, 0.42718, -0.90319, 0.04207, 0.42718, -0.90319, 0.03316, 0.3367, -0.94103, 0.03316, 0.3367, -0.94103, 0.03316, 0.3367, -0.94103, 0.03316, 0.3367, -0.94103, 0.02392, 0.24291, -0.96975, 0.02392, 0.24291, -0.96975, 0.02392, 0.24291, -0.96975, 0.02392, 0.24291, -0.96975, 0.01445, 0.14671, -0.98907, 0.01445, 0.14671, -0.98907, 0.01445, 0.14671, -0.98907, 0.01445, 0.14671, -0.98907, 0.00483, 0.04907, -0.99878, 0.00483, 0.04907, -0.99878, 0.00483, 0.04907, -0.99878, -0.00483, 0.04907, -0.99878, -0.00483, 0.04907, -0.99878, -0.00483, 0.04907, -0.99878, -0.01445, 0.14671, -0.98907, -0.01445, 0.14671, -0.98907, -0.01445, 0.14671, -0.98907, -0.01445, 0.14671, -0.98907, -0.02392, 0.24291, -0.96975, -0.02392, 0.24291, -0.96975, -0.02392, 0.24291, -0.96975, -0.02392, 0.24291, -0.96975, -0.03316, 0.3367, -0.94103, -0.03316, 0.3367, -0.94103, -0.03316, 0.3367, -0.94103, -0.03316, 0.3367, -0.94103, -0.04207, 0.42718, -0.90319, -0.04207, 0.42718, -0.90319, -0.04207, 0.42718, -0.90319, -0.04207, 0.42718, -0.90319, -0.05057, 0.51344, -0.85663, -0.05057, 0.51344, -0.85663, -0.05057, 0.51344, -0.85663, -0.05057, 0.51344, -0.85663, -0.05857, 0.59468, -0.80183, -0.05857, 0.59468, -0.80183, -0.05857, 0.59468, -0.80183, -0.05857, 0.59468, -0.80183, -0.066, 0.67009, -0.73934, -0.066, 0.67009, -0.73934, -0.066, 0.67009, -0.73934, -0.066, 0.67009, -0.73934, -0.07278, 0.73899, -0.66978, -0.07278, 0.73899, -0.66978, -0.07278, 0.73899, -0.66978, -0.07278, 0.73899, -0.66978, -0.07886, 0.80071, -0.59384, -0.07886, 0.80071, -0.59384, -0.07886, 0.80071, -0.59384, -0.07886, 0.80071, -0.59384, -0.08418, 0.85468, -0.51228, -0.08418, 0.85468, -0.51228, -0.08418, 0.85468, -0.51228, -0.08418, 0.85468, -0.51228, -0.08868, 0.90043, -0.42587, -0.08868, 0.90043, -0.42587, -0.08868, 0.90043, -0.42587, -0.08868, 0.90043, -0.42587, -0.09234, 0.93752, -0.33545, -0.09234, 0.93752, -0.33545, -0.09234, 0.93752, -0.33545, -0.09234, 0.93752, -0.33545, -0.09511, 0.96563, -0.24188, -0.09511, 0.96563, -0.24188, -0.09511, 0.96563, -0.24188, -0.09511, 0.96563, -0.24188, -0.09697, 0.98451, -0.14604, -0.09697, 0.98451, -0.14604, -0.09697, 0.98451, -0.14604, -0.09697, 0.98451, -0.14604, -0.0979, 0.994, -0.04883, -0.0979, 0.994, -0.04883, -0.0979, 0.994, -0.04883, -0.0979, 0.994, -0.04883, -0.0979, 0.994, 0.04883, -0.0979, 0.994, 0.04883, -0.0979, 0.994, 0.04883, -0.0979, 0.994, 0.04883, -0.09697, 0.98452, 0.14604, -0.09697, 0.98452, 0.14604, -0.09697, 0.98452, 0.14604, -0.09697, 0.98452, 0.14604, -0.09511, 0.96563, 0.24188, -0.09511, 0.96563, 0.24188, -0.09511, 0.96563, 0.24188, -0.09511, 0.96563, 0.24188, -0.09234, 0.93752, 0.33545, -0.09234, 0.93752, 0.33545, -0.09234, 0.93752, 0.33545, -0.09234, 0.93752, 0.33545, -0.08868, 0.90043, 0.42587, -0.08868, 0.90043, 0.42587, -0.08868, 0.90043, 0.42587, -0.08868, 0.90043, 0.42587, -0.08418, 0.85468, 0.51228, -0.08418, 0.85468, 0.51228, -0.08418, 0.85468, 0.51228, -0.08418, 0.85468, 0.51228, -0.07886, 0.80071, 0.59384, -0.07886, 0.80071, 0.59384, -0.07886, 0.80071, 0.59384, -0.07886, 0.80071, 0.59384, -0.07278, 0.73899, 0.66978, -0.07278, 0.73899, 0.66978, -0.07278, 0.73899, 0.66978, -0.07278, 0.73899, 0.66978, -0.066, 0.67009, 0.73934, -0.066, 0.67009, 0.73934, -0.066, 0.67009, 0.73934, -0.066, 0.67009, 0.73934, -0.05857, 0.59468, 0.80183, -0.05857, 0.59468, 0.80183, -0.05857, 0.59468, 0.80183, -0.05857, 0.59468, 0.80183, -0.05057, 0.51344, 0.85663, -0.05057, 0.51344, 0.85663, -0.05057, 0.51344, 0.85663, -0.05057, 0.51344, 0.85663, -0.04207, 0.42718, 0.90319, -0.04207, 0.42718, 0.90319, -0.04207, 0.42718, 0.90319, -0.04207, 0.42718, 0.90319, -0.03316, 0.33671, 0.94103, -0.03316, 0.33671, 0.94103, -0.03316, 0.33671, 0.94103, -0.03316, 0.33671, 0.94103, -0.02392, 0.24291, 0.96975, -0.02392, 0.24291, 0.96975, -0.02392, 0.24291, 0.96975, -0.02392, 0.24291, 0.96975, -0.01445, 0.14672, 0.98907, -0.01445, 0.14672, 0.98907, -0.01445, 0.14672, 0.98907, -0.01445, 0.14672, 0.98907, -0.00483, 0.04907, 0.99878, -0.00483, 0.04907, 0.99878, -0.00483, 0.04907, 0.99878, -0.01431, 0.04718, 0.99878, -0.01431, 0.04718, 0.99878, -0.01431, 0.04718, 0.99878, -0.0428, 0.14108, 0.98907, -0.0428, 0.14108, 0.98907, -0.0428, 0.14108, 0.98907, -0.0428, 0.14108, 0.98907, -0.07085, 0.23358, 0.96975, -0.07085, 0.23358, 0.96975, -0.07085, 0.23358, 0.96975, -0.07085, 0.23358, 0.96975, -0.09821, 0.32377, 0.94103, -0.09821, 0.32377, 0.94103, -0.09821, 0.32377, 0.94103, -0.09821, 0.32377, 0.94103, -0.1246, 0.41076, 0.90319, -0.1246, 0.41076, 0.90319, -0.1246, 0.41076, 0.90319, -0.1246, 0.41076, 0.90319, -0.14977, 0.49371, 0.85663, -0.14977, 0.49371, 0.85663, -0.14977, 0.49371, 0.85663, -0.14977, 0.49371, 0.85663, -0.17346, 0.57182, 0.80183, -0.17346, 0.57182, 0.80183, -0.17346, 0.57182, 0.80183, -0.17346, 0.57182, 0.80183, -0.19546, 0.64434, 0.73934, -0.19546, 0.64434, 0.73934, -0.19546, 0.64434, 0.73934, -0.19546, 0.64434, 0.73934, -0.21555, 0.71059, 0.66978, -0.21555, 0.71059, 0.66978, -0.21555, 0.71059, 0.66978, -0.21555, 0.71059, 0.66978, -0.23356, 0.76994, 0.59384, -0.23356, 0.76994, 0.59384, -0.23356, 0.76994, 0.59384, -0.23356, 0.76994, 0.59384, -0.2493, 0.82184, 0.51228, -0.2493, 0.82184, 0.51228, -0.2493, 0.82184, 0.51228, -0.2493, 0.82184, 0.51228, -0.26265, 0.86582, 0.42587, -0.26265, 0.86582, 0.42587, -0.26265, 0.86582, 0.42587, -0.26265, 0.86582, 0.42587, -0.27347, 0.90149, 0.33545, -0.27347, 0.90149, 0.33545, -0.27347, 0.90149, 0.33545, -0.27347, 0.90149, 0.33545, -0.28167, 0.92853, 0.24188, -0.28167, 0.92853, 0.24188, -0.28167, 0.92853, 0.24188, -0.28167, 0.92853, 0.24188, -0.28717, 0.94668, 0.14604, -0.28717, 0.94668, 0.14604, -0.28717, 0.94668, 0.14604, -0.28717, 0.94668, 0.14604, -0.28994, 0.9558, 0.04883, -0.28994, 0.9558, 0.04883, -0.28994, 0.9558, 0.04883, -0.28994, 0.9558, 0.04883, -0.28994, 0.9558, -0.04883, -0.28994, 0.9558, -0.04883, -0.28994, 0.9558, -0.04883, -0.28994, 0.9558, -0.04883, -0.28717, 0.94668, -0.14604, -0.28717, 0.94668, -0.14604, -0.28717, 0.94668, -0.14604, -0.28717, 0.94668, -0.14604, -0.28167, 0.92853, -0.24188, -0.28167, 0.92853, -0.24188, -0.28167, 0.92853, -0.24188, -0.28167, 0.92853, -0.24188, -0.27347, 0.90149, -0.33545, -0.27347, 0.90149, -0.33545, -0.27347, 0.90149, -0.33545, -0.27347, 0.90149, -0.33545, -0.26265, 0.86582, -0.42587, -0.26265, 0.86582, -0.42587, -0.26265, 0.86582, -0.42587, -0.26265, 0.86582, -0.42587, -0.2493, 0.82184, -0.51228, -0.2493, 0.82184, -0.51228, -0.2493, 0.82184, -0.51228, -0.2493, 0.82184, -0.51228, -0.23356, 0.76993, -0.59384, -0.23356, 0.76993, -0.59384, -0.23356, 0.76993, -0.59384, -0.23356, 0.76993, -0.59384, -0.21555, 0.71059, -0.66978, -0.21555, 0.71059, -0.66978, -0.21555, 0.71059, -0.66978, -0.21555, 0.71059, -0.66978, -0.19546, 0.64434, -0.73934, -0.19546, 0.64434, -0.73934, -0.19546, 0.64434, -0.73934, -0.19546, 0.64434, -0.73934, -0.17346, 0.57182, -0.80183, -0.17346, 0.57182, -0.80183, -0.17346, 0.57182, -0.80183, -0.17346, 0.57182, -0.80183, -0.14977, 0.49371, -0.85663, -0.14977, 0.49371, -0.85663, -0.14977, 0.49371, -0.85663, -0.14977, 0.49371, -0.85663, -0.1246, 0.41076, -0.90319, -0.1246, 0.41076, -0.90319, -0.1246, 0.41076, -0.90319, -0.1246, 0.41076, -0.90319, -0.09821, 0.32377, -0.94103, -0.09821, 0.32377, -0.94103, -0.09821, 0.32377, -0.94103, -0.09821, 0.32377, -0.94103, -0.07085, 0.23357, -0.96975, -0.07085, 0.23357, -0.96975, -0.07085, 0.23357, -0.96975, -0.07085, 0.23357, -0.96975, -0.0428, 0.14108, -0.98907, -0.0428, 0.14108, -0.98907, -0.0428, 0.14108, -0.98907, -0.0428, 0.14108, -0.98907, -0.01431, 0.04718, -0.99878, -0.01431, 0.04718, -0.99878, -0.01431, 0.04718, -0.99878, -0.02324, 0.04348, -0.99878, -0.02324, 0.04348, -0.99878, -0.02324, 0.04348, -0.99878, -0.0695, 0.13002, -0.98907, -0.0695, 0.13002, -0.98907, -0.0695, 0.13002, -0.98907, -0.0695, 0.13002, -0.98907, -0.11506, 0.21526, -0.96975, -0.11506, 0.21526, -0.96975, -0.11506, 0.21526, -0.96975, -0.11506, 0.21526, -0.96975, -0.15949, 0.29838, -0.94103, -0.15949, 0.29838, -0.94103, -0.15949, 0.29838, -0.94103, -0.15949, 0.29838, -0.94103, -0.20234, 0.37856, -0.90319, -0.20234, 0.37856, -0.90319, -0.20234, 0.37856, -0.90319, -0.20234, 0.37856, -0.90319, -0.24321, 0.45501, -0.85663, -0.24321, 0.45501, -0.85663, -0.24321, 0.45501, -0.85663, -0.24321, 0.45501, -0.85663, -0.28168, 0.527, -0.80183, -0.28168, 0.527, -0.80183, -0.28168, 0.527, -0.80183, -0.28168, 0.527, -0.80183, -0.31741, 0.59383, -0.73934, -0.31741, 0.59383, -0.73934, -0.31741, 0.59383, -0.73934, -0.31741, 0.59383, -0.73934, -0.35004, 0.65488, -0.66978, -0.35004, 0.65488, -0.66978, -0.35004, 0.65488, -0.66978, -0.35004, 0.65488, -0.66978, -0.37928, 0.70958, -0.59384, -0.37928, 0.70958, -0.59384, -0.37928, 0.70958, -0.59384, -0.37928, 0.70958, -0.59384, -0.40484, 0.75741, -0.51228, -0.40484, 0.75741, -0.51228, -0.40484, 0.75741, -0.51228, -0.40484, 0.75741, -0.51228, -0.42651, 0.79795, -0.42587, -0.42651, 0.79795, -0.42587, -0.42651, 0.79795, -0.42587, -0.42651, 0.79795, -0.42587, -0.44408, 0.83082, -0.33545, -0.44408, 0.83082, -0.33545, -0.44408, 0.83082, -0.33545, -0.44408, 0.83082, -0.33545, -0.4574, 0.85573, -0.24188, -0.4574, 0.85573, -0.24188, -0.4574, 0.85573, -0.24188, -0.4574, 0.85573, -0.24188, -0.46634, 0.87247, -0.14604, -0.46634, 0.87247, -0.14604, -0.46634, 0.87247, -0.14604, -0.46634, 0.87247, -0.14604, -0.47083, 0.88087, -0.04883, -0.47083, 0.88087, -0.04883, -0.47083, 0.88087, -0.04883, -0.47083, 0.88087, -0.04883, -0.47083, 0.88087, 0.04883, -0.47083, 0.88087, 0.04883, -0.47083, 0.88087, 0.04883, -0.47083, 0.88087, 0.04883, -0.46634, 0.87247, 0.14604, -0.46634, 0.87247, 0.14604, -0.46634, 0.87247, 0.14604, -0.46634, 0.87247, 0.14604, -0.4574, 0.85573, 0.24188, -0.4574, 0.85573, 0.24188, -0.4574, 0.85573, 0.24188, -0.4574, 0.85573, 0.24188, -0.44408, 0.83082, 0.33545, -0.44408, 0.83082, 0.33545, -0.44408, 0.83082, 0.33545, -0.44408, 0.83082, 0.33545, -0.42651, 0.79795, 0.42587, -0.42651, 0.79795, 0.42587, -0.42651, 0.79795, 0.42587, -0.42651, 0.79795, 0.42587, -0.40484, 0.75741, 0.51228, -0.40484, 0.75741, 0.51228, -0.40484, 0.75741, 0.51228, -0.40484, 0.75741, 0.51228, -0.37928, 0.70958, 0.59384, -0.37928, 0.70958, 0.59384, -0.37928, 0.70958, 0.59384, -0.37928, 0.70958, 0.59384, -0.35004, 0.65488, 0.66978, -0.35004, 0.65488, 0.66978, -0.35004, 0.65488, 0.66978, -0.35004, 0.65488, 0.66978, -0.31741, 0.59383, 0.73934, -0.31741, 0.59383, 0.73934, -0.31741, 0.59383, 0.73934, -0.31741, 0.59383, 0.73934, -0.28169, 0.527, 0.80183, -0.28169, 0.527, 0.80183, -0.28169, 0.527, 0.80183, -0.28169, 0.527, 0.80183, -0.24321, 0.45501, 0.85663, -0.24321, 0.45501, 0.85663, -0.24321, 0.45501, 0.85663, -0.24321, 0.45501, 0.85663, -0.20234, 0.37856, 0.90319, -0.20234, 0.37856, 0.90319, -0.20234, 0.37856, 0.90319, -0.20234, 0.37856, 0.90319, -0.15949, 0.29838, 0.94103, -0.15949, 0.29838, 0.94103, -0.15949, 0.29838, 0.94103, -0.15949, 0.29838, 0.94103, -0.11506, 0.21526, 0.96975, -0.11506, 0.21526, 0.96975, -0.11506, 0.21526, 0.96975, -0.11506, 0.21526, 0.96975, -0.0695, 0.13002, 0.98907, -0.0695, 0.13002, 0.98907, -0.0695, 0.13002, 0.98907, -0.0695, 0.13002, 0.98907, -0.02324, 0.04348, 0.99878, -0.02324, 0.04348, 0.99878, -0.02324, 0.04348, 0.99878, -0.03128, 0.03811, 0.99878, -0.03128, 0.03811, 0.99878, -0.03128, 0.03811, 0.99878, -0.09353, 0.11396, 0.98907, -0.09353, 0.11396, 0.98907, -0.09353, 0.11396, 0.98907, -0.09353, 0.11396, 0.98907, -0.15485, 0.18868, 0.96975, -0.15485, 0.18868, 0.96975, -0.15485, 0.18868, 0.96975, -0.15485, 0.18868, 0.96975, -0.21464, 0.26154, 0.94103, -0.21464, 0.26154, 0.94103, -0.21464, 0.26154, 0.94103, -0.21464, 0.26154, 0.94103, -0.27231, 0.33181, 0.90319, -0.27231, 0.33181, 0.90319, -0.27231, 0.33181, 0.90319, -0.27231, 0.33181, 0.90319, -0.3273, 0.39882, 0.85663, -0.3273, 0.39882, 0.85663, -0.3273, 0.39882, 0.85663, -0.3273, 0.39882, 0.85663, -0.37908, 0.46192, 0.80183, -0.37908, 0.46192, 0.80183, -0.37908, 0.46192, 0.80183, -0.37908, 0.46192, 0.80183, -0.42716, 0.5205, 0.73934, -0.42716, 0.5205, 0.73934, -0.42716, 0.5205, 0.73934, -0.42716, 0.5205, 0.73934, -0.47108, 0.57401, 0.66978, -0.47108, 0.57401, 0.66978, -0.47108, 0.57401, 0.66978, -0.47108, 0.57401, 0.66978, -0.51042, 0.62195, 0.59384, -0.51042, 0.62195, 0.59384, -0.51042, 0.62195, 0.59384, -0.51042, 0.62195, 0.59384, -0.54483, 0.66388, 0.51228, -0.54483, 0.66388, 0.51228, -0.54483, 0.66388, 0.51228, -0.54483, 0.66388, 0.51228, -0.57399, 0.69941, 0.42587, -0.57399, 0.69941, 0.42587, -0.57399, 0.69941, 0.42587, -0.57399, 0.69941, 0.42587, -0.59764, 0.72822, 0.33545, -0.59764, 0.72822, 0.33545, -0.59764, 0.72822, 0.33545, -0.59764, 0.72822, 0.33545, -0.61556, 0.75006, 0.24188, -0.61556, 0.75006, 0.24188, -0.61556, 0.75006, 0.24188, -0.61556, 0.75006, 0.24188, -0.62759, 0.76472, 0.14604, -0.62759, 0.76472, 0.14604, -0.62759, 0.76472, 0.14604, -0.62759, 0.76472, 0.14604, -0.63364, 0.77209, 0.04883, -0.63364, 0.77209, 0.04883, -0.63364, 0.77209, 0.04883, -0.63364, 0.77209, 0.04883, -0.63364, 0.77209, -0.04883, -0.63364, 0.77209, -0.04883, -0.63364, 0.77209, -0.04883, -0.63364, 0.77209, -0.04883, -0.62759, 0.76472, -0.14604, -0.62759, 0.76472, -0.14604, -0.62759, 0.76472, -0.14604, -0.62759, 0.76472, -0.14604, -0.61556, 0.75006, -0.24188, -0.61556, 0.75006, -0.24188, -0.61556, 0.75006, -0.24188, -0.61556, 0.75006, -0.24188, -0.59764, 0.72822, -0.33545, -0.59764, 0.72822, -0.33545, -0.59764, 0.72822, -0.33545, -0.59764, 0.72822, -0.33545, -0.57399, 0.69941, -0.42587, -0.57399, 0.69941, -0.42587, -0.57399, 0.69941, -0.42587, -0.57399, 0.69941, -0.42587, -0.54483, 0.66388, -0.51228, -0.54483, 0.66388, -0.51228, -0.54483, 0.66388, -0.51228, -0.54483, 0.66388, -0.51228, -0.51042, 0.62195, -0.59384, -0.51042, 0.62195, -0.59384, -0.51042, 0.62195, -0.59384, -0.51042, 0.62195, -0.59384, -0.47108, 0.57401, -0.66978, -0.47108, 0.57401, -0.66978, -0.47108, 0.57401, -0.66978, -0.47108, 0.57401, -0.66978, -0.42716, 0.5205, -0.73934, -0.42716, 0.5205, -0.73934, -0.42716, 0.5205, -0.73934, -0.42716, 0.5205, -0.73934, -0.37908, 0.46192, -0.80183, -0.37908, 0.46192, -0.80183, -0.37908, 0.46192, -0.80183, -0.37908, 0.46192, -0.80183, -0.3273, 0.39882, -0.85663, -0.3273, 0.39882, -0.85663, -0.3273, 0.39882, -0.85663, -0.3273, 0.39882, -0.85663, -0.27231, 0.33181, -0.90319, -0.27231, 0.33181, -0.90319, -0.27231, 0.33181, -0.90319, -0.27231, 0.33181, -0.90319, -0.21464, 0.26154, -0.94103, -0.21464, 0.26154, -0.94103, -0.21464, 0.26154, -0.94103, -0.21464, 0.26154, -0.94103, -0.15485, 0.18868, -0.96975, -0.15485, 0.18868, -0.96975, -0.15485, 0.18868, -0.96975, -0.15485, 0.18868, -0.96975, -0.09353, 0.11396, -0.98907, -0.09353, 0.11396, -0.98907, -0.09353, 0.11396, -0.98907, -0.09353, 0.11396, -0.98907, -0.03128, 0.03811, -0.99878, -0.03128, 0.03811, -0.99878, -0.03128, 0.03811, -0.99878, -0.03811, 0.03128, -0.99878, -0.03811, 0.03128, -0.99878, -0.03811, 0.03128, -0.99878, -0.11396, 0.09353, -0.98907, -0.11396, 0.09353, -0.98907, -0.11396, 0.09353, -0.98907, -0.11396, 0.09353, -0.98907, -0.18868, 0.15485, -0.96975, -0.18868, 0.15485, -0.96975, -0.18868, 0.15485, -0.96975, -0.18868, 0.15485, -0.96975, -0.26154, 0.21464, -0.94103, -0.26154, 0.21464, -0.94103, -0.26154, 0.21464, -0.94103, -0.26154, 0.21464, -0.94103, -0.33181, 0.27231, -0.90319, -0.33181, 0.27231, -0.90319, -0.33181, 0.27231, -0.90319, -0.33181, 0.27231, -0.90319, -0.39882, 0.3273, -0.85663, -0.39882, 0.3273, -0.85663, -0.39882, 0.3273, -0.85663, -0.39882, 0.3273, -0.85663, -0.46192, 0.37908, -0.80183, -0.46192, 0.37908, -0.80183, -0.46192, 0.37908, -0.80183, -0.46192, 0.37908, -0.80183, -0.5205, 0.42716, -0.73934, -0.5205, 0.42716, -0.73934, -0.5205, 0.42716, -0.73934, -0.5205, 0.42716, -0.73934, -0.57401, 0.47108, -0.66978, -0.57401, 0.47108, -0.66978, -0.57401, 0.47108, -0.66978, -0.57401, 0.47108, -0.66978, -0.62195, 0.51042, -0.59384, -0.62195, 0.51042, -0.59384, -0.62195, 0.51042, -0.59384, -0.62195, 0.51042, -0.59384, -0.66388, 0.54483, -0.51228, -0.66388, 0.54483, -0.51228, -0.66388, 0.54483, -0.51228, -0.66388, 0.54483, -0.51228, -0.69941, 0.57399, -0.42587, -0.69941, 0.57399, -0.42587, -0.69941, 0.57399, -0.42587, -0.69941, 0.57399, -0.42587, -0.72822, 0.59763, -0.33545, -0.72822, 0.59763, -0.33545, -0.72822, 0.59763, -0.33545, -0.72822, 0.59763, -0.33545, -0.75006, 0.61556, -0.24188, -0.75006, 0.61556, -0.24188, -0.75006, 0.61556, -0.24188, -0.75006, 0.61556, -0.24188, -0.76472, 0.62759, -0.14604, -0.76472, 0.62759, -0.14604, -0.76472, 0.62759, -0.14604, -0.76472, 0.62759, -0.14604, -0.77209, 0.63364, -0.04883, -0.77209, 0.63364, -0.04883, -0.77209, 0.63364, -0.04883, -0.77209, 0.63364, -0.04883, -0.77209, 0.63364, 0.04883, -0.77209, 0.63364, 0.04883, -0.77209, 0.63364, 0.04883, -0.77209, 0.63364, 0.04883, -0.76472, 0.62759, 0.14604, -0.76472, 0.62759, 0.14604, -0.76472, 0.62759, 0.14604, -0.76472, 0.62759, 0.14604, -0.75006, 0.61556, 0.24188, -0.75006, 0.61556, 0.24188, -0.75006, 0.61556, 0.24188, -0.75006, 0.61556, 0.24188, -0.72822, 0.59763, 0.33545, -0.72822, 0.59763, 0.33545, -0.72822, 0.59763, 0.33545, -0.72822, 0.59763, 0.33545, -0.69941, 0.57399, 0.42587, -0.69941, 0.57399, 0.42587, -0.69941, 0.57399, 0.42587, -0.69941, 0.57399, 0.42587, -0.66388, 0.54483, 0.51228, -0.66388, 0.54483, 0.51228, -0.66388, 0.54483, 0.51228, -0.66388, 0.54483, 0.51228, -0.62195, 0.51042, 0.59384, -0.62195, 0.51042, 0.59384, -0.62195, 0.51042, 0.59384, -0.62195, 0.51042, 0.59384, -0.57401, 0.47108, 0.66978, -0.57401, 0.47108, 0.66978, -0.57401, 0.47108, 0.66978, -0.57401, 0.47108, 0.66978, -0.5205, 0.42716, 0.73934, -0.5205, 0.42716, 0.73934, -0.5205, 0.42716, 0.73934, -0.5205, 0.42716, 0.73934, -0.46192, 0.37908, 0.80183, -0.46192, 0.37908, 0.80183, -0.46192, 0.37908, 0.80183, -0.46192, 0.37908, 0.80183, -0.39882, 0.3273, 0.85663, -0.39882, 0.3273, 0.85663, -0.39882, 0.3273, 0.85663, -0.39882, 0.3273, 0.85663, -0.33181, 0.27231, 0.90319, -0.33181, 0.27231, 0.90319, -0.33181, 0.27231, 0.90319, -0.33181, 0.27231, 0.90319, -0.26154, 0.21464, 0.94103, -0.26154, 0.21464, 0.94103, -0.26154, 0.21464, 0.94103, -0.26154, 0.21464, 0.94103, -0.18868, 0.15485, 0.96975, -0.18868, 0.15485, 0.96975, -0.18868, 0.15485, 0.96975, -0.18868, 0.15485, 0.96975, -0.11396, 0.09353, 0.98907, -0.11396, 0.09353, 0.98907, -0.11396, 0.09353, 0.98907, -0.11396, 0.09353, 0.98907, -0.03811, 0.03128, 0.99878, -0.03811, 0.03128, 0.99878, -0.03811, 0.03128, 0.99878, -0.04348, 0.02324, 0.99878, -0.04348, 0.02324, 0.99878, -0.04348, 0.02324, 0.99878, -0.13002, 0.0695, 0.98907, -0.13002, 0.0695, 0.98907, -0.13002, 0.0695, 0.98907, -0.13002, 0.0695, 0.98907, -0.21526, 0.11506, 0.96975, -0.21526, 0.11506, 0.96975, -0.21526, 0.11506, 0.96975, -0.21526, 0.11506, 0.96975, -0.29838, 0.15949, 0.94103, -0.29838, 0.15949, 0.94103, -0.29838, 0.15949, 0.94103, -0.29838, 0.15949, 0.94103, -0.37856, 0.20234, 0.90319, -0.37856, 0.20234, 0.90319, -0.37856, 0.20234, 0.90319, -0.37856, 0.20234, 0.90319, -0.45501, 0.24321, 0.85663, -0.45501, 0.24321, 0.85663, -0.45501, 0.24321, 0.85663, -0.45501, 0.24321, 0.85663, -0.527, 0.28168, 0.80183, -0.527, 0.28168, 0.80183, -0.527, 0.28168, 0.80183, -0.527, 0.28168, 0.80183, -0.59383, 0.31741, 0.73934, -0.59383, 0.31741, 0.73934, -0.59383, 0.31741, 0.73934, -0.59383, 0.31741, 0.73934, -0.65488, 0.35004, 0.66978, -0.65488, 0.35004, 0.66978, -0.65488, 0.35004, 0.66978, -0.65488, 0.35004, 0.66978, -0.70958, 0.37928, 0.59384, -0.70958, 0.37928, 0.59384, -0.70958, 0.37928, 0.59384, -0.70958, 0.37928, 0.59384, -0.75741, 0.40484, 0.51228, -0.75741, 0.40484, 0.51228, -0.75741, 0.40484, 0.51228, -0.75741, 0.40484, 0.51228, -0.79795, 0.42651, 0.42587, -0.79795, 0.42651, 0.42587, -0.79795, 0.42651, 0.42587, -0.79795, 0.42651, 0.42587, -0.83082, 0.44408, 0.33545, -0.83082, 0.44408, 0.33545, -0.83082, 0.44408, 0.33545, -0.83082, 0.44408, 0.33545, -0.85573, 0.4574, 0.24188, -0.85573, 0.4574, 0.24188, -0.85573, 0.4574, 0.24188, -0.85573, 0.4574, 0.24188, -0.87247, 0.46634, 0.14604, -0.87247, 0.46634, 0.14604, -0.87247, 0.46634, 0.14604, -0.87247, 0.46634, 0.14604, -0.88087, 0.47083, 0.04883, -0.88087, 0.47083, 0.04883, -0.88087, 0.47083, 0.04883, -0.88087, 0.47083, 0.04883, -0.88087, 0.47083, -0.04883, -0.88087, 0.47083, -0.04883, -0.88087, 0.47083, -0.04883, -0.88087, 0.47083, -0.04883, -0.87247, 0.46634, -0.14604, -0.87247, 0.46634, -0.14604, -0.87247, 0.46634, -0.14604, -0.87247, 0.46634, -0.14604, -0.85573, 0.4574, -0.24188, -0.85573, 0.4574, -0.24188, -0.85573, 0.4574, -0.24188, -0.85573, 0.4574, -0.24188, -0.83082, 0.44408, -0.33545, -0.83082, 0.44408, -0.33545, -0.83082, 0.44408, -0.33545, -0.83082, 0.44408, -0.33545, -0.79795, 0.42651, -0.42587, -0.79795, 0.42651, -0.42587, -0.79795, 0.42651, -0.42587, -0.79795, 0.42651, -0.42587, -0.75741, 0.40484, -0.51228, -0.75741, 0.40484, -0.51228, -0.75741, 0.40484, -0.51228, -0.75741, 0.40484, -0.51228, -0.70958, 0.37928, -0.59384, -0.70958, 0.37928, -0.59384, -0.70958, 0.37928, -0.59384, -0.70958, 0.37928, -0.59384, -0.65488, 0.35004, -0.66978, -0.65488, 0.35004, -0.66978, -0.65488, 0.35004, -0.66978, -0.65488, 0.35004, -0.66978, -0.59383, 0.31741, -0.73934, -0.59383, 0.31741, -0.73934, -0.59383, 0.31741, -0.73934, -0.59383, 0.31741, -0.73934, -0.527, 0.28168, -0.80183, -0.527, 0.28168, -0.80183, -0.527, 0.28168, -0.80183, -0.527, 0.28168, -0.80183, -0.45501, 0.24321, -0.85663, -0.45501, 0.24321, -0.85663, -0.45501, 0.24321, -0.85663, -0.45501, 0.24321, -0.85663, -0.37856, 0.20234, -0.90319, -0.37856, 0.20234, -0.90319, -0.37856, 0.20234, -0.90319, -0.37856, 0.20234, -0.90319, -0.29838, 0.15949, -0.94103, -0.29838, 0.15949, -0.94103, -0.29838, 0.15949, -0.94103, -0.29838, 0.15949, -0.94103, -0.21526, 0.11506, -0.96975, -0.21526, 0.11506, -0.96975, -0.21526, 0.11506, -0.96975, -0.21526, 0.11506, -0.96975, -0.13002, 0.0695, -0.98907, -0.13002, 0.0695, -0.98907, -0.13002, 0.0695, -0.98907, -0.13002, 0.0695, -0.98907, -0.04348, 0.02324, -0.99878, -0.04348, 0.02324, -0.99878, -0.04348, 0.02324, -0.99878, -0.04718, 0.01431, -0.99878, -0.04718, 0.01431, -0.99878, -0.04718, 0.01431, -0.99878, -0.14108, 0.0428, -0.98907, -0.14108, 0.0428, -0.98907, -0.14108, 0.0428, -0.98907, -0.14108, 0.0428, -0.98907, -0.23357, 0.07085, -0.96975, -0.23357, 0.07085, -0.96975, -0.23357, 0.07085, -0.96975, -0.23357, 0.07085, -0.96975, -0.32377, 0.09821, -0.94103, -0.32377, 0.09821, -0.94103, -0.32377, 0.09821, -0.94103, -0.32377, 0.09821, -0.94103, -0.41076, 0.1246, -0.90319, -0.41076, 0.1246, -0.90319, -0.41076, 0.1246, -0.90319, -0.41076, 0.1246, -0.90319, -0.49371, 0.14977, -0.85663, -0.49371, 0.14977, -0.85663, -0.49371, 0.14977, -0.85663, -0.49371, 0.14977, -0.85663, -0.57182, 0.17346, -0.80183, -0.57182, 0.17346, -0.80183, -0.57182, 0.17346, -0.80183, -0.57182, 0.17346, -0.80183, -0.64434, 0.19546, -0.73934, -0.64434, 0.19546, -0.73934, -0.64434, 0.19546, -0.73934, -0.64434, 0.19546, -0.73934, -0.71059, 0.21555, -0.66978, -0.71059, 0.21555, -0.66978, -0.71059, 0.21555, -0.66978, -0.71059, 0.21555, -0.66978, -0.76993, 0.23356, -0.59384, -0.76993, 0.23356, -0.59384, -0.76993, 0.23356, -0.59384, -0.76993, 0.23356, -0.59384, -0.82184, 0.2493, -0.51228, -0.82184, 0.2493, -0.51228, -0.82184, 0.2493, -0.51228, -0.82184, 0.2493, -0.51228, -0.86582, 0.26264, -0.42587, -0.86582, 0.26264, -0.42587, -0.86582, 0.26264, -0.42587, -0.86582, 0.26264, -0.42587, -0.90149, 0.27346, -0.33545, -0.90149, 0.27346, -0.33545, -0.90149, 0.27346, -0.33545, -0.90149, 0.27346, -0.33545, -0.92853, 0.28166, -0.24188, -0.92853, 0.28166, -0.24188, -0.92853, 0.28166, -0.24188, -0.92853, 0.28166, -0.24188, -0.94668, 0.28717, -0.14604, -0.94668, 0.28717, -0.14604, -0.94668, 0.28717, -0.14604, -0.94668, 0.28717, -0.14604, -0.9558, 0.28994, -0.04883, -0.9558, 0.28994, -0.04883, -0.9558, 0.28994, -0.04883, -0.9558, 0.28994, -0.04883, -0.9558, 0.28994, 0.04883, -0.9558, 0.28994, 0.04883, -0.9558, 0.28994, 0.04883, -0.9558, 0.28994, 0.04883, -0.94668, 0.28717, 0.14604, -0.94668, 0.28717, 0.14604, -0.94668, 0.28717, 0.14604, -0.94668, 0.28717, 0.14604, -0.92853, 0.28166, 0.24188, -0.92853, 0.28166, 0.24188, -0.92853, 0.28166, 0.24188, -0.92853, 0.28166, 0.24188, -0.90149, 0.27346, 0.33545, -0.90149, 0.27346, 0.33545, -0.90149, 0.27346, 0.33545, -0.90149, 0.27346, 0.33545, -0.86583, 0.26264, 0.42587, -0.86583, 0.26264, 0.42587, -0.86583, 0.26264, 0.42587, -0.86583, 0.26264, 0.42587, -0.82184, 0.2493, 0.51228, -0.82184, 0.2493, 0.51228, -0.82184, 0.2493, 0.51228, -0.82184, 0.2493, 0.51228, -0.76994, 0.23356, 0.59384, -0.76994, 0.23356, 0.59384, -0.76994, 0.23356, 0.59384, -0.76994, 0.23356, 0.59384, -0.71059, 0.21555, 0.66978, -0.71059, 0.21555, 0.66978, -0.71059, 0.21555, 0.66978, -0.71059, 0.21555, 0.66978, -0.64434, 0.19546, 0.73934, -0.64434, 0.19546, 0.73934, -0.64434, 0.19546, 0.73934, -0.64434, 0.19546, 0.73934, -0.57182, 0.17346, 0.80183, -0.57182, 0.17346, 0.80183, -0.57182, 0.17346, 0.80183, -0.57182, 0.17346, 0.80183, -0.49371, 0.14977, 0.85663, -0.49371, 0.14977, 0.85663, -0.49371, 0.14977, 0.85663, -0.49371, 0.14977, 0.85663, -0.41076, 0.1246, 0.90319, -0.41076, 0.1246, 0.90319, -0.41076, 0.1246, 0.90319, -0.41076, 0.1246, 0.90319, -0.32377, 0.09821, 0.94103, -0.32377, 0.09821, 0.94103, -0.32377, 0.09821, 0.94103, -0.32377, 0.09821, 0.94103, -0.23358, 0.07085, 0.96975, -0.23358, 0.07085, 0.96975, -0.23358, 0.07085, 0.96975, -0.23358, 0.07085, 0.96975, -0.14108, 0.0428, 0.98907, -0.14108, 0.0428, 0.98907, -0.14108, 0.0428, 0.98907, -0.14108, 0.0428, 0.98907, -0.04718, 0.01431, 0.99878, -0.04718, 0.01431, 0.99878, -0.04718, 0.01431, 0.99878, -0.04907, 0.00483, 0.99878, -0.04907, 0.00483, 0.99878, -0.04907, 0.00483, 0.99878, -0.14672, 0.01445, 0.98907, -0.14672, 0.01445, 0.98907, -0.14672, 0.01445, 0.98907, -0.14672, 0.01445, 0.98907, -0.24291, 0.02392, 0.96975, -0.24291, 0.02392, 0.96975, -0.24291, 0.02392, 0.96975, -0.24291, 0.02392, 0.96975, -0.33671, 0.03316, 0.94103, -0.33671, 0.03316, 0.94103, -0.33671, 0.03316, 0.94103, -0.33671, 0.03316, 0.94103, -0.42718, 0.04207, 0.90319, -0.42718, 0.04207, 0.90319, -0.42718, 0.04207, 0.90319, -0.42718, 0.04207, 0.90319, -0.51345, 0.05057, 0.85663, -0.51345, 0.05057, 0.85663, -0.51345, 0.05057, 0.85663, -0.51345, 0.05057, 0.85663, -0.59468, 0.05857, 0.80183, -0.59468, 0.05857, 0.80183, -0.59468, 0.05857, 0.80183, -0.59468, 0.05857, 0.80183, -0.67009, 0.066, 0.73934, -0.67009, 0.066, 0.73934, -0.67009, 0.066, 0.73934, -0.67009, 0.066, 0.73934, -0.73899, 0.07278, 0.66978, -0.73899, 0.07278, 0.66978, -0.73899, 0.07278, 0.66978, -0.73899, 0.07278, 0.66978, -0.80071, 0.07886, 0.59384, -0.80071, 0.07886, 0.59384, -0.80071, 0.07886, 0.59384, -0.80071, 0.07886, 0.59384, -0.85468, 0.08418, 0.51228, -0.85468, 0.08418, 0.51228, -0.85468, 0.08418, 0.51228, -0.85468, 0.08418, 0.51228, -0.90043, 0.08868, 0.42587, -0.90043, 0.08868, 0.42587, -0.90043, 0.08868, 0.42587, -0.90043, 0.08868, 0.42587, -0.93752, 0.09234, 0.33545, -0.93752, 0.09234, 0.33545, -0.93752, 0.09234, 0.33545, -0.93752, 0.09234, 0.33545, -0.96563, 0.09511, 0.24188, -0.96563, 0.09511, 0.24188, -0.96563, 0.09511, 0.24188, -0.96563, 0.09511, 0.24188, -0.98452, 0.09697, 0.14604, -0.98452, 0.09697, 0.14604, -0.98452, 0.09697, 0.14604, -0.98452, 0.09697, 0.14604, -0.994, 0.0979, 0.04883, -0.994, 0.0979, 0.04883, -0.994, 0.0979, 0.04883, -0.994, 0.0979, 0.04883, -0.994, 0.0979, -0.04883, -0.994, 0.0979, -0.04883, -0.994, 0.0979, -0.04883, -0.994, 0.0979, -0.04883, -0.98452, 0.09697, -0.14604, -0.98452, 0.09697, -0.14604, -0.98452, 0.09697, -0.14604, -0.98452, 0.09697, -0.14604, -0.96563, 0.09511, -0.24188, -0.96563, 0.09511, -0.24188, -0.96563, 0.09511, -0.24188, -0.96563, 0.09511, -0.24188, -0.93752, 0.09234, -0.33545, -0.93752, 0.09234, -0.33545, -0.93752, 0.09234, -0.33545, -0.93752, 0.09234, -0.33545, -0.90043, 0.08868, -0.42587, -0.90043, 0.08868, -0.42587, -0.90043, 0.08868, -0.42587, -0.90043, 0.08868, -0.42587, -0.85468, 0.08418, -0.51228, -0.85468, 0.08418, -0.51228, -0.85468, 0.08418, -0.51228, -0.85468, 0.08418, -0.51228, -0.80071, 0.07886, -0.59384, -0.80071, 0.07886, -0.59384, -0.80071, 0.07886, -0.59384, -0.80071, 0.07886, -0.59384, -0.73899, 0.07278, -0.66978, -0.73899, 0.07278, -0.66978, -0.73899, 0.07278, -0.66978, -0.73899, 0.07278, -0.66978, -0.67009, 0.066, -0.73934, -0.67009, 0.066, -0.73934, -0.67009, 0.066, -0.73934, -0.67009, 0.066, -0.73934, -0.59468, 0.05857, -0.80183, -0.59468, 0.05857, -0.80183, -0.59468, 0.05857, -0.80183, -0.59468, 0.05857, -0.80183, -0.51345, 0.05057, -0.85663, -0.51345, 0.05057, -0.85663, -0.51345, 0.05057, -0.85663, -0.51345, 0.05057, -0.85663, -0.42718, 0.04207, -0.90319, -0.42718, 0.04207, -0.90319, -0.42718, 0.04207, -0.90319, -0.42718, 0.04207, -0.90319, -0.3367, 0.03316, -0.94103, -0.3367, 0.03316, -0.94103, -0.3367, 0.03316, -0.94103, -0.3367, 0.03316, -0.94103, -0.24291, 0.02392, -0.96975, -0.24291, 0.02392, -0.96975, -0.24291, 0.02392, -0.96975, -0.24291, 0.02392, -0.96975, -0.14671, 0.01445, -0.98907, -0.14671, 0.01445, -0.98907, -0.14671, 0.01445, -0.98907, -0.14671, 0.01445, -0.98907, -0.04907, 0.00483, -0.99878, -0.04907, 0.00483, -0.99878, -0.04907, 0.00483, -0.99878, -0.04907, -0.00483, -0.99878, -0.04907, -0.00483, -0.99878, -0.04907, -0.00483, -0.99878, -0.14671, -0.01445, -0.98907, -0.14671, -0.01445, -0.98907, -0.14671, -0.01445, -0.98907, -0.14671, -0.01445, -0.98907, -0.24291, -0.02392, -0.96975, -0.24291, -0.02392, -0.96975, -0.24291, -0.02392, -0.96975, -0.24291, -0.02392, -0.96975, -0.3367, -0.03316, -0.94103, -0.3367, -0.03316, -0.94103, -0.3367, -0.03316, -0.94103, -0.3367, -0.03316, -0.94103, -0.42718, -0.04207, -0.90319, -0.42718, -0.04207, -0.90319, -0.42718, -0.04207, -0.90319, -0.42718, -0.04207, -0.90319, -0.51345, -0.05057, -0.85663, -0.51345, -0.05057, -0.85663, -0.51345, -0.05057, -0.85663, -0.51345, -0.05057, -0.85663, -0.59468, -0.05857, -0.80183, -0.59468, -0.05857, -0.80183, -0.59468, -0.05857, -0.80183, -0.59468, -0.05857, -0.80183, -0.67009, -0.066, -0.73934, -0.67009, -0.066, -0.73934, -0.67009, -0.066, -0.73934, -0.67009, -0.066, -0.73934, -0.73899, -0.07278, -0.66978, -0.73899, -0.07278, -0.66978, -0.73899, -0.07278, -0.66978, -0.73899, -0.07278, -0.66978, -0.80071, -0.07886, -0.59384, -0.80071, -0.07886, -0.59384, -0.80071, -0.07886, -0.59384, -0.80071, -0.07886, -0.59384, -0.85468, -0.08418, -0.51228, -0.85468, -0.08418, -0.51228, -0.85468, -0.08418, -0.51228, -0.85468, -0.08418, -0.51228, -0.90043, -0.08868, -0.42587, -0.90043, -0.08868, -0.42587, -0.90043, -0.08868, -0.42587, -0.90043, -0.08868, -0.42587, -0.93752, -0.09234, -0.33545, -0.93752, -0.09234, -0.33545, -0.93752, -0.09234, -0.33545, -0.93752, -0.09234, -0.33545, -0.96563, -0.09511, -0.24188, -0.96563, -0.09511, -0.24188, -0.96563, -0.09511, -0.24188, -0.96563, -0.09511, -0.24188, -0.98452, -0.09697, -0.14604, -0.98452, -0.09697, -0.14604, -0.98452, -0.09697, -0.14604, -0.98452, -0.09697, -0.14604, -0.994, -0.0979, -0.04883, -0.994, -0.0979, -0.04883, -0.994, -0.0979, -0.04883, -0.994, -0.0979, -0.04883, -0.994, -0.0979, 0.04883, -0.994, -0.0979, 0.04883, -0.994, -0.0979, 0.04883, -0.994, -0.0979, 0.04883, -0.98452, -0.09697, 0.14604, -0.98452, -0.09697, 0.14604, -0.98452, -0.09697, 0.14604, -0.98452, -0.09697, 0.14604, -0.96563, -0.09511, 0.24188, -0.96563, -0.09511, 0.24188, -0.96563, -0.09511, 0.24188, -0.96563, -0.09511, 0.24188, -0.93752, -0.09234, 0.33545, -0.93752, -0.09234, 0.33545, -0.93752, -0.09234, 0.33545, -0.93752, -0.09234, 0.33545, -0.90043, -0.08868, 0.42587, -0.90043, -0.08868, 0.42587, -0.90043, -0.08868, 0.42587, -0.90043, -0.08868, 0.42587, -0.85468, -0.08418, 0.51228, -0.85468, -0.08418, 0.51228, -0.85468, -0.08418, 0.51228, -0.85468, -0.08418, 0.51228, -0.80071, -0.07886, 0.59384, -0.80071, -0.07886, 0.59384, -0.80071, -0.07886, 0.59384, -0.80071, -0.07886, 0.59384, -0.73899, -0.07278, 0.66978, -0.73899, -0.07278, 0.66978, -0.73899, -0.07278, 0.66978, -0.73899, -0.07278, 0.66978, -0.67009, -0.066, 0.73934, -0.67009, -0.066, 0.73934, -0.67009, -0.066, 0.73934, -0.67009, -0.066, 0.73934, -0.59468, -0.05857, 0.80183, -0.59468, -0.05857, 0.80183, -0.59468, -0.05857, 0.80183, -0.59468, -0.05857, 0.80183, -0.51345, -0.05057, 0.85663, -0.51345, -0.05057, 0.85663, -0.51345, -0.05057, 0.85663, -0.51345, -0.05057, 0.85663, -0.42718, -0.04207, 0.90319, -0.42718, -0.04207, 0.90319, -0.42718, -0.04207, 0.90319, -0.42718, -0.04207, 0.90319, -0.33671, -0.03316, 0.94103, -0.33671, -0.03316, 0.94103, -0.33671, -0.03316, 0.94103, -0.33671, -0.03316, 0.94103, -0.24291, -0.02392, 0.96975, -0.24291, -0.02392, 0.96975, -0.24291, -0.02392, 0.96975, -0.24291, -0.02392, 0.96975, -0.14672, -0.01445, 0.98907, -0.14672, -0.01445, 0.98907, -0.14672, -0.01445, 0.98907, -0.14672, -0.01445, 0.98907, -0.04907, -0.00483, 0.99878, -0.04907, -0.00483, 0.99878, -0.04907, -0.00483, 0.99878, -0.04718, -0.01431, 0.99878, -0.04718, -0.01431, 0.99878, -0.04718, -0.01431, 0.99878, -0.14108, -0.0428, 0.98907, -0.14108, -0.0428, 0.98907, -0.14108, -0.0428, 0.98907, -0.14108, -0.0428, 0.98907, -0.23358, -0.07085, 0.96975, -0.23358, -0.07085, 0.96975, -0.23358, -0.07085, 0.96975, -0.23358, -0.07085, 0.96975, -0.32377, -0.09821, 0.94103, -0.32377, -0.09821, 0.94103, -0.32377, -0.09821, 0.94103, -0.32377, -0.09821, 0.94103, -0.41076, -0.1246, 0.90319, -0.41076, -0.1246, 0.90319, -0.41076, -0.1246, 0.90319, -0.41076, -0.1246, 0.90319, -0.49371, -0.14977, 0.85663, -0.49371, -0.14977, 0.85663, -0.49371, -0.14977, 0.85663, -0.49371, -0.14977, 0.85663, -0.57182, -0.17346, 0.80183, -0.57182, -0.17346, 0.80183, -0.57182, -0.17346, 0.80183, -0.57182, -0.17346, 0.80183, -0.64434, -0.19546, 0.73934, -0.64434, -0.19546, 0.73934, -0.64434, -0.19546, 0.73934, -0.64434, -0.19546, 0.73934, -0.71059, -0.21555, 0.66978, -0.71059, -0.21555, 0.66978, -0.71059, -0.21555, 0.66978, -0.71059, -0.21555, 0.66978, -0.76994, -0.23356, 0.59384, -0.76994, -0.23356, 0.59384, -0.76994, -0.23356, 0.59384, -0.76994, -0.23356, 0.59384, -0.82184, -0.2493, 0.51228, -0.82184, -0.2493, 0.51228, -0.82184, -0.2493, 0.51228, -0.82184, -0.2493, 0.51228, -0.86582, -0.26265, 0.42587, -0.86582, -0.26265, 0.42587, -0.86582, -0.26265, 0.42587, -0.86582, -0.26265, 0.42587, -0.90149, -0.27347, 0.33545, -0.90149, -0.27347, 0.33545, -0.90149, -0.27347, 0.33545, -0.90149, -0.27347, 0.33545, -0.92853, -0.28167, 0.24188, -0.92853, -0.28167, 0.24188, -0.92853, -0.28167, 0.24188, -0.92853, -0.28167, 0.24188, -0.94668, -0.28717, 0.14604, -0.94668, -0.28717, 0.14604, -0.94668, -0.28717, 0.14604, -0.94668, -0.28717, 0.14604, -0.9558, -0.28994, 0.04883, -0.9558, -0.28994, 0.04883, -0.9558, -0.28994, 0.04883, -0.9558, -0.28994, 0.04883, -0.9558, -0.28994, -0.04883, -0.9558, -0.28994, -0.04883, -0.9558, -0.28994, -0.04883, -0.9558, -0.28994, -0.04883, -0.94668, -0.28717, -0.14604, -0.94668, -0.28717, -0.14604, -0.94668, -0.28717, -0.14604, -0.94668, -0.28717, -0.14604, -0.92853, -0.28167, -0.24188, -0.92853, -0.28167, -0.24188, -0.92853, -0.28167, -0.24188, -0.92853, -0.28167, -0.24188, -0.90149, -0.27347, -0.33545, -0.90149, -0.27347, -0.33545, -0.90149, -0.27347, -0.33545, -0.90149, -0.27347, -0.33545, -0.86582, -0.26265, -0.42587, -0.86582, -0.26265, -0.42587, -0.86582, -0.26265, -0.42587, -0.86582, -0.26265, -0.42587, -0.82184, -0.2493, -0.51228, -0.82184, -0.2493, -0.51228, -0.82184, -0.2493, -0.51228, -0.82184, -0.2493, -0.51228, -0.76993, -0.23356, -0.59384, -0.76993, -0.23356, -0.59384, -0.76993, -0.23356, -0.59384, -0.76993, -0.23356, -0.59384, -0.71059, -0.21555, -0.66978, -0.71059, -0.21555, -0.66978, -0.71059, -0.21555, -0.66978, -0.71059, -0.21555, -0.66978, -0.64434, -0.19546, -0.73934, -0.64434, -0.19546, -0.73934, -0.64434, -0.19546, -0.73934, -0.64434, -0.19546, -0.73934, -0.57182, -0.17346, -0.80183, -0.57182, -0.17346, -0.80183, -0.57182, -0.17346, -0.80183, -0.57182, -0.17346, -0.80183, -0.49371, -0.14977, -0.85663, -0.49371, -0.14977, -0.85663, -0.49371, -0.14977, -0.85663, -0.49371, -0.14977, -0.85663, -0.41076, -0.1246, -0.90319, -0.41076, -0.1246, -0.90319, -0.41076, -0.1246, -0.90319, -0.41076, -0.1246, -0.90319, -0.32377, -0.09821, -0.94103, -0.32377, -0.09821, -0.94103, -0.32377, -0.09821, -0.94103, -0.32377, -0.09821, -0.94103, -0.23357, -0.07085, -0.96975, -0.23357, -0.07085, -0.96975, -0.23357, -0.07085, -0.96975, -0.23357, -0.07085, -0.96975, -0.14108, -0.0428, -0.98907, -0.14108, -0.0428, -0.98907, -0.14108, -0.0428, -0.98907, -0.14108, -0.0428, -0.98907, -0.04718, -0.01431, -0.99878, -0.04718, -0.01431, -0.99878, -0.04718, -0.01431, -0.99878, -0.04348, -0.02324, -0.99878, -0.04348, -0.02324, -0.99878, -0.04348, -0.02324, -0.99878, -0.13002, -0.0695, -0.98907, -0.13002, -0.0695, -0.98907, -0.13002, -0.0695, -0.98907, -0.13002, -0.0695, -0.98907, -0.21526, -0.11506, -0.96975, -0.21526, -0.11506, -0.96975, -0.21526, -0.11506, -0.96975, -0.21526, -0.11506, -0.96975, -0.29838, -0.15949, -0.94103, -0.29838, -0.15949, -0.94103, -0.29838, -0.15949, -0.94103, -0.29838, -0.15949, -0.94103, -0.37856, -0.20234, -0.90319, -0.37856, -0.20234, -0.90319, -0.37856, -0.20234, -0.90319, -0.37856, -0.20234, -0.90319, -0.45501, -0.24321, -0.85663, -0.45501, -0.24321, -0.85663, -0.45501, -0.24321, -0.85663, -0.45501, -0.24321, -0.85663, -0.527, -0.28169, -0.80183, -0.527, -0.28169, -0.80183, -0.527, -0.28169, -0.80183, -0.527, -0.28169, -0.80183, -0.59383, -0.31741, -0.73934, -0.59383, -0.31741, -0.73934, -0.59383, -0.31741, -0.73934, -0.59383, -0.31741, -0.73934, -0.65488, -0.35004, -0.66978, -0.65488, -0.35004, -0.66978, -0.65488, -0.35004, -0.66978, -0.65488, -0.35004, -0.66978, -0.70958, -0.37928, -0.59384, -0.70958, -0.37928, -0.59384, -0.70958, -0.37928, -0.59384, -0.70958, -0.37928, -0.59384, -0.75741, -0.40484, -0.51228, -0.75741, -0.40484, -0.51228, -0.75741, -0.40484, -0.51228, -0.75741, -0.40484, -0.51228, -0.79795, -0.42651, -0.42587, -0.79795, -0.42651, -0.42587, -0.79795, -0.42651, -0.42587, -0.79795, -0.42651, -0.42587, -0.83082, -0.44408, -0.33545, -0.83082, -0.44408, -0.33545, -0.83082, -0.44408, -0.33545, -0.83082, -0.44408, -0.33545, -0.85573, -0.4574, -0.24188, -0.85573, -0.4574, -0.24188, -0.85573, -0.4574, -0.24188, -0.85573, -0.4574, -0.24188, -0.87247, -0.46634, -0.14604, -0.87247, -0.46634, -0.14604, -0.87247, -0.46634, -0.14604, -0.87247, -0.46634, -0.14604, -0.88087, -0.47083, -0.04883, -0.88087, -0.47083, -0.04883, -0.88087, -0.47083, -0.04883, -0.88087, -0.47083, -0.04883, -0.88087, -0.47083, 0.04883, -0.88087, -0.47083, 0.04883, -0.88087, -0.47083, 0.04883, -0.88087, -0.47083, 0.04883, -0.87247, -0.46634, 0.14604, -0.87247, -0.46634, 0.14604, -0.87247, -0.46634, 0.14604, -0.87247, -0.46634, 0.14604, -0.85573, -0.4574, 0.24188, -0.85573, -0.4574, 0.24188, -0.85573, -0.4574, 0.24188, -0.85573, -0.4574, 0.24188, -0.83082, -0.44408, 0.33545, -0.83082, -0.44408, 0.33545, -0.83082, -0.44408, 0.33545, -0.83082, -0.44408, 0.33545, -0.79795, -0.42651, 0.42587, -0.79795, -0.42651, 0.42587, -0.79795, -0.42651, 0.42587, -0.79795, -0.42651, 0.42587, -0.75741, -0.40484, 0.51228, -0.75741, -0.40484, 0.51228, -0.75741, -0.40484, 0.51228, -0.75741, -0.40484, 0.51228, -0.70958, -0.37928, 0.59384, -0.70958, -0.37928, 0.59384, -0.70958, -0.37928, 0.59384, -0.70958, -0.37928, 0.59384, -0.65488, -0.35004, 0.66978, -0.65488, -0.35004, 0.66978, -0.65488, -0.35004, 0.66978, -0.65488, -0.35004, 0.66978, -0.59383, -0.31741, 0.73934, -0.59383, -0.31741, 0.73934, -0.59383, -0.31741, 0.73934, -0.59383, -0.31741, 0.73934, -0.527, -0.28169, 0.80183, -0.527, -0.28169, 0.80183, -0.527, -0.28169, 0.80183, -0.527, -0.28169, 0.80183, -0.45501, -0.24321, 0.85663, -0.45501, -0.24321, 0.85663, -0.45501, -0.24321, 0.85663, -0.45501, -0.24321, 0.85663, -0.37856, -0.20234, 0.90319, -0.37856, -0.20234, 0.90319, -0.37856, -0.20234, 0.90319, -0.37856, -0.20234, 0.90319, -0.29838, -0.15949, 0.94103, -0.29838, -0.15949, 0.94103, -0.29838, -0.15949, 0.94103, -0.29838, -0.15949, 0.94103, -0.21526, -0.11506, 0.96975, -0.21526, -0.11506, 0.96975, -0.21526, -0.11506, 0.96975, -0.21526, -0.11506, 0.96975, -0.13002, -0.0695, 0.98907, -0.13002, -0.0695, 0.98907, -0.13002, -0.0695, 0.98907, -0.13002, -0.0695, 0.98907, -0.04348, -0.02324, 0.99878, -0.04348, -0.02324, 0.99878, -0.04348, -0.02324, 0.99878, -0.03811, -0.03128, 0.99878, -0.03811, -0.03128, 0.99878, -0.03811, -0.03128, 0.99878, -0.11396, -0.09353, 0.98907, -0.11396, -0.09353, 0.98907, -0.11396, -0.09353, 0.98907, -0.11396, -0.09353, 0.98907, -0.18868, -0.15485, 0.96975, -0.18868, -0.15485, 0.96975, -0.18868, -0.15485, 0.96975, -0.18868, -0.15485, 0.96975, -0.26154, -0.21464, 0.94103, -0.26154, -0.21464, 0.94103, -0.26154, -0.21464, 0.94103, -0.26154, -0.21464, 0.94103, -0.33181, -0.27231, 0.90319, -0.33181, -0.27231, 0.90319, -0.33181, -0.27231, 0.90319, -0.33181, -0.27231, 0.90319, -0.39882, -0.3273, 0.85663, -0.39882, -0.3273, 0.85663, -0.39882, -0.3273, 0.85663, -0.39882, -0.3273, 0.85663, -0.46192, -0.37908, 0.80183, -0.46192, -0.37908, 0.80183, -0.46192, -0.37908, 0.80183, -0.46192, -0.37908, 0.80183, -0.5205, -0.42716, 0.73934, -0.5205, -0.42716, 0.73934, -0.5205, -0.42716, 0.73934, -0.5205, -0.42716, 0.73934, -0.57401, -0.47108, 0.66978, -0.57401, -0.47108, 0.66978, -0.57401, -0.47108, 0.66978, -0.57401, -0.47108, 0.66978, -0.62195, -0.51042, 0.59384, -0.62195, -0.51042, 0.59384, -0.62195, -0.51042, 0.59384, -0.62195, -0.51042, 0.59384, -0.66388, -0.54483, 0.51228, -0.66388, -0.54483, 0.51228, -0.66388, -0.54483, 0.51228, -0.66388, -0.54483, 0.51228, -0.69941, -0.57399, 0.42587, -0.69941, -0.57399, 0.42587, -0.69941, -0.57399, 0.42587, -0.69941, -0.57399, 0.42587, -0.72822, -0.59764, 0.33545, -0.72822, -0.59764, 0.33545, -0.72822, -0.59764, 0.33545, -0.72822, -0.59764, 0.33545, -0.75006, -0.61556, 0.24188, -0.75006, -0.61556, 0.24188, -0.75006, -0.61556, 0.24188, -0.75006, -0.61556, 0.24188, -0.76472, -0.62759, 0.14604, -0.76472, -0.62759, 0.14604, -0.76472, -0.62759, 0.14604, -0.76472, -0.62759, 0.14604, -0.77209, -0.63364, 0.04883, -0.77209, -0.63364, 0.04883, -0.77209, -0.63364, 0.04883, -0.77209, -0.63364, 0.04883, -0.77209, -0.63364, -0.04883, -0.77209, -0.63364, -0.04883, -0.77209, -0.63364, -0.04883, -0.77209, -0.63364, -0.04883, -0.76472, -0.62759, -0.14604, -0.76472, -0.62759, -0.14604, -0.76472, -0.62759, -0.14604, -0.76472, -0.62759, -0.14604, -0.75006, -0.61556, -0.24188, -0.75006, -0.61556, -0.24188, -0.75006, -0.61556, -0.24188, -0.75006, -0.61556, -0.24188, -0.72822, -0.59764, -0.33545, -0.72822, -0.59764, -0.33545, -0.72822, -0.59764, -0.33545, -0.72822, -0.59764, -0.33545, -0.69941, -0.57399, -0.42587, -0.69941, -0.57399, -0.42587, -0.69941, -0.57399, -0.42587, -0.69941, -0.57399, -0.42587, -0.66388, -0.54483, -0.51228, -0.66388, -0.54483, -0.51228, -0.66388, -0.54483, -0.51228, -0.66388, -0.54483, -0.51228, -0.62195, -0.51042, -0.59384, -0.62195, -0.51042, -0.59384, -0.62195, -0.51042, -0.59384, -0.62195, -0.51042, -0.59384, -0.57401, -0.47108, -0.66978, -0.57401, -0.47108, -0.66978, -0.57401, -0.47108, -0.66978, -0.57401, -0.47108, -0.66978, -0.5205, -0.42716, -0.73934, -0.5205, -0.42716, -0.73934, -0.5205, -0.42716, -0.73934, -0.5205, -0.42716, -0.73934, -0.46192, -0.37908, -0.80183, -0.46192, -0.37908, -0.80183, -0.46192, -0.37908, -0.80183, -0.46192, -0.37908, -0.80183, -0.39882, -0.3273, -0.85663, -0.39882, -0.3273, -0.85663, -0.39882, -0.3273, -0.85663, -0.39882, -0.3273, -0.85663, -0.33181, -0.27231, -0.90319, -0.33181, -0.27231, -0.90319, -0.33181, -0.27231, -0.90319, -0.33181, -0.27231, -0.90319, -0.26154, -0.21464, -0.94103, -0.26154, -0.21464, -0.94103, -0.26154, -0.21464, -0.94103, -0.26154, -0.21464, -0.94103, -0.18868, -0.15485, -0.96975, -0.18868, -0.15485, -0.96975, -0.18868, -0.15485, -0.96975, -0.18868, -0.15485, -0.96975, -0.11396, -0.09353, -0.98907, -0.11396, -0.09353, -0.98907, -0.11396, -0.09353, -0.98907, -0.11396, -0.09353, -0.98907, -0.03811, -0.03128, -0.99878, -0.03811, -0.03128, -0.99878, -0.03811, -0.03128, -0.99878, -0.03128, -0.03811, -0.99878, -0.03128, -0.03811, -0.99878, -0.03128, -0.03811, -0.99878, -0.09353, -0.11396, -0.98907, -0.09353, -0.11396, -0.98907, -0.09353, -0.11396, -0.98907, -0.09353, -0.11396, -0.98907, -0.15485, -0.18868, -0.96975, -0.15485, -0.18868, -0.96975, -0.15485, -0.18868, -0.96975, -0.15485, -0.18868, -0.96975, -0.21464, -0.26154, -0.94103, -0.21464, -0.26154, -0.94103, -0.21464, -0.26154, -0.94103, -0.21464, -0.26154, -0.94103, -0.27231, -0.33181, -0.90319, -0.27231, -0.33181, -0.90319, -0.27231, -0.33181, -0.90319, -0.27231, -0.33181, -0.90319, -0.3273, -0.39882, -0.85663, -0.3273, -0.39882, -0.85663, -0.3273, -0.39882, -0.85663, -0.3273, -0.39882, -0.85663, -0.37908, -0.46192, -0.80183, -0.37908, -0.46192, -0.80183, -0.37908, -0.46192, -0.80183, -0.37908, -0.46192, -0.80183, -0.42716, -0.5205, -0.73934, -0.42716, -0.5205, -0.73934, -0.42716, -0.5205, -0.73934, -0.42716, -0.5205, -0.73934, -0.47108, -0.57401, -0.66978, -0.47108, -0.57401, -0.66978, -0.47108, -0.57401, -0.66978, -0.47108, -0.57401, -0.66978, -0.51042, -0.62195, -0.59384, -0.51042, -0.62195, -0.59384, -0.51042, -0.62195, -0.59384, -0.51042, -0.62195, -0.59384, -0.54483, -0.66388, -0.51228, -0.54483, -0.66388, -0.51228, -0.54483, -0.66388, -0.51228, -0.54483, -0.66388, -0.51228, -0.57399, -0.69941, -0.42587, -0.57399, -0.69941, -0.42587, -0.57399, -0.69941, -0.42587, -0.57399, -0.69941, -0.42587, -0.59763, -0.72822, -0.33545, -0.59763, -0.72822, -0.33545, -0.59763, -0.72822, -0.33545, -0.59763, -0.72822, -0.33545, -0.61556, -0.75006, -0.24188, -0.61556, -0.75006, -0.24188, -0.61556, -0.75006, -0.24188, -0.61556, -0.75006, -0.24188, -0.62759, -0.76472, -0.14604, -0.62759, -0.76472, -0.14604, -0.62759, -0.76472, -0.14604, -0.62759, -0.76472, -0.14604, -0.63364, -0.77209, -0.04883, -0.63364, -0.77209, -0.04883, -0.63364, -0.77209, -0.04883, -0.63364, -0.77209, -0.04883, -0.63364, -0.77209, 0.04883, -0.63364, -0.77209, 0.04883, -0.63364, -0.77209, 0.04883, -0.63364, -0.77209, 0.04883, -0.62759, -0.76472, 0.14604, -0.62759, -0.76472, 0.14604, -0.62759, -0.76472, 0.14604, -0.62759, -0.76472, 0.14604, -0.61556, -0.75006, 0.24188, -0.61556, -0.75006, 0.24188, -0.61556, -0.75006, 0.24188, -0.61556, -0.75006, 0.24188, -0.59764, -0.72822, 0.33545, -0.59764, -0.72822, 0.33545, -0.59764, -0.72822, 0.33545, -0.59764, -0.72822, 0.33545, -0.57399, -0.69941, 0.42587, -0.57399, -0.69941, 0.42587, -0.57399, -0.69941, 0.42587, -0.57399, -0.69941, 0.42587, -0.54483, -0.66388, 0.51228, -0.54483, -0.66388, 0.51228, -0.54483, -0.66388, 0.51228, -0.54483, -0.66388, 0.51228, -0.51042, -0.62195, 0.59384, -0.51042, -0.62195, 0.59384, -0.51042, -0.62195, 0.59384, -0.51042, -0.62195, 0.59384, -0.47108, -0.57401, 0.66978, -0.47108, -0.57401, 0.66978, -0.47108, -0.57401, 0.66978, -0.47108, -0.57401, 0.66978, -0.42716, -0.5205, 0.73934, -0.42716, -0.5205, 0.73934, -0.42716, -0.5205, 0.73934, -0.42716, -0.5205, 0.73934, -0.37908, -0.46192, 0.80183, -0.37908, -0.46192, 0.80183, -0.37908, -0.46192, 0.80183, -0.37908, -0.46192, 0.80183, -0.3273, -0.39882, 0.85663, -0.3273, -0.39882, 0.85663, -0.3273, -0.39882, 0.85663, -0.3273, -0.39882, 0.85663, -0.27231, -0.33181, 0.90319, -0.27231, -0.33181, 0.90319, -0.27231, -0.33181, 0.90319, -0.27231, -0.33181, 0.90319, -0.21464, -0.26154, 0.94103, -0.21464, -0.26154, 0.94103, -0.21464, -0.26154, 0.94103, -0.21464, -0.26154, 0.94103, -0.15485, -0.18868, 0.96975, -0.15485, -0.18868, 0.96975, -0.15485, -0.18868, 0.96975, -0.15485, -0.18868, 0.96975, -0.09353, -0.11396, 0.98907, -0.09353, -0.11396, 0.98907, -0.09353, -0.11396, 0.98907, -0.09353, -0.11396, 0.98907, -0.03128, -0.03811, 0.99878, -0.03128, -0.03811, 0.99878, -0.03128, -0.03811, 0.99878, -0.02324, -0.04348, 0.99878, -0.02324, -0.04348, 0.99878, -0.02324, -0.04348, 0.99878, -0.0695, -0.13002, 0.98907, -0.0695, -0.13002, 0.98907, -0.0695, -0.13002, 0.98907, -0.0695, -0.13002, 0.98907, -0.11506, -0.21526, 0.96975, -0.11506, -0.21526, 0.96975, -0.11506, -0.21526, 0.96975, -0.11506, -0.21526, 0.96975, -0.15949, -0.29838, 0.94103, -0.15949, -0.29838, 0.94103, -0.15949, -0.29838, 0.94103, -0.15949, -0.29838, 0.94103, -0.20234, -0.37856, 0.90319, -0.20234, -0.37856, 0.90319, -0.20234, -0.37856, 0.90319, -0.20234, -0.37856, 0.90319, -0.24321, -0.45501, 0.85663, -0.24321, -0.45501, 0.85663, -0.24321, -0.45501, 0.85663, -0.24321, -0.45501, 0.85663, -0.28168, -0.527, 0.80183, -0.28168, -0.527, 0.80183, -0.28168, -0.527, 0.80183, -0.28168, -0.527, 0.80183, -0.31741, -0.59383, 0.73934, -0.31741, -0.59383, 0.73934, -0.31741, -0.59383, 0.73934, -0.31741, -0.59383, 0.73934, -0.35004, -0.65488, 0.66978, -0.35004, -0.65488, 0.66978, -0.35004, -0.65488, 0.66978, -0.35004, -0.65488, 0.66978, -0.37928, -0.70958, 0.59384, -0.37928, -0.70958, 0.59384, -0.37928, -0.70958, 0.59384, -0.37928, -0.70958, 0.59384, -0.40484, -0.75741, 0.51228, -0.40484, -0.75741, 0.51228, -0.40484, -0.75741, 0.51228, -0.40484, -0.75741, 0.51228, -0.42651, -0.79795, 0.42587, -0.42651, -0.79795, 0.42587, -0.42651, -0.79795, 0.42587, -0.42651, -0.79795, 0.42587, -0.44408, -0.83082, 0.33545, -0.44408, -0.83082, 0.33545, -0.44408, -0.83082, 0.33545, -0.44408, -0.83082, 0.33545, -0.4574, -0.85573, 0.24188, -0.4574, -0.85573, 0.24188, -0.4574, -0.85573, 0.24188, -0.4574, -0.85573, 0.24188, -0.46634, -0.87247, 0.14604, -0.46634, -0.87247, 0.14604, -0.46634, -0.87247, 0.14604, -0.46634, -0.87247, 0.14604, -0.47083, -0.88087, 0.04883, -0.47083, -0.88087, 0.04883, -0.47083, -0.88087, 0.04883, -0.47083, -0.88087, 0.04883, -0.47083, -0.88087, -0.04883, -0.47083, -0.88087, -0.04883, -0.47083, -0.88087, -0.04883, -0.47083, -0.88087, -0.04883, -0.46634, -0.87247, -0.14604, -0.46634, -0.87247, -0.14604, -0.46634, -0.87247, -0.14604, -0.46634, -0.87247, -0.14604, -0.4574, -0.85573, -0.24188, -0.4574, -0.85573, -0.24188, -0.4574, -0.85573, -0.24188, -0.4574, -0.85573, -0.24188, -0.44408, -0.83082, -0.33545, -0.44408, -0.83082, -0.33545, -0.44408, -0.83082, -0.33545, -0.44408, -0.83082, -0.33545, -0.42651, -0.79795, -0.42587, -0.42651, -0.79795, -0.42587, -0.42651, -0.79795, -0.42587, -0.42651, -0.79795, -0.42587, -0.40484, -0.75741, -0.51228, -0.40484, -0.75741, -0.51228, -0.40484, -0.75741, -0.51228, -0.40484, -0.75741, -0.51228, -0.37928, -0.70958, -0.59384, -0.37928, -0.70958, -0.59384, -0.37928, -0.70958, -0.59384, -0.37928, -0.70958, -0.59384, -0.35004, -0.65488, -0.66978, -0.35004, -0.65488, -0.66978, -0.35004, -0.65488, -0.66978, -0.35004, -0.65488, -0.66978, -0.31741, -0.59383, -0.73934, -0.31741, -0.59383, -0.73934, -0.31741, -0.59383, -0.73934, -0.31741, -0.59383, -0.73934, -0.28168, -0.527, -0.80183, -0.28168, -0.527, -0.80183, -0.28168, -0.527, -0.80183, -0.28168, -0.527, -0.80183, -0.24321, -0.45501, -0.85663, -0.24321, -0.45501, -0.85663, -0.24321, -0.45501, -0.85663, -0.24321, -0.45501, -0.85663, -0.20234, -0.37856, -0.90319, -0.20234, -0.37856, -0.90319, -0.20234, -0.37856, -0.90319, -0.20234, -0.37856, -0.90319, -0.15949, -0.29838, -0.94103, -0.15949, -0.29838, -0.94103, -0.15949, -0.29838, -0.94103, -0.15949, -0.29838, -0.94103, -0.11506, -0.21526, -0.96975, -0.11506, -0.21526, -0.96975, -0.11506, -0.21526, -0.96975, -0.11506, -0.21526, -0.96975, -0.0695, -0.13002, -0.98907, -0.0695, -0.13002, -0.98907, -0.0695, -0.13002, -0.98907, -0.0695, -0.13002, -0.98907, -0.02324, -0.04348, -0.99878, -0.02324, -0.04348, -0.99878, -0.02324, -0.04348, -0.99878, -0.01431, -0.04718, -0.99878, -0.01431, -0.04718, -0.99878, -0.01431, -0.04718, -0.99878, -0.0428, -0.14108, -0.98907, -0.0428, -0.14108, -0.98907, -0.0428, -0.14108, -0.98907, -0.0428, -0.14108, -0.98907, -0.07085, -0.23357, -0.96975, -0.07085, -0.23357, -0.96975, -0.07085, -0.23357, -0.96975, -0.07085, -0.23357, -0.96975, -0.09821, -0.32377, -0.94103, -0.09821, -0.32377, -0.94103, -0.09821, -0.32377, -0.94103, -0.09821, -0.32377, -0.94103, -0.1246, -0.41076, -0.90319, -0.1246, -0.41076, -0.90319, -0.1246, -0.41076, -0.90319, -0.1246, -0.41076, -0.90319, -0.14977, -0.49371, -0.85663, -0.14977, -0.49371, -0.85663, -0.14977, -0.49371, -0.85663, -0.14977, -0.49371, -0.85663, -0.17346, -0.57182, -0.80183, -0.17346, -0.57182, -0.80183, -0.17346, -0.57182, -0.80183, -0.17346, -0.57182, -0.80183, -0.19546, -0.64434, -0.73934, -0.19546, -0.64434, -0.73934, -0.19546, -0.64434, -0.73934, -0.19546, -0.64434, -0.73934, -0.21555, -0.71059, -0.66978, -0.21555, -0.71059, -0.66978, -0.21555, -0.71059, -0.66978, -0.21555, -0.71059, -0.66978, -0.23356, -0.76994, -0.59384, -0.23356, -0.76994, -0.59384, -0.23356, -0.76994, -0.59384, -0.23356, -0.76994, -0.59384, -0.2493, -0.82184, -0.51228, -0.2493, -0.82184, -0.51228, -0.2493, -0.82184, -0.51228, -0.2493, -0.82184, -0.51228, -0.26264, -0.86583, -0.42587, -0.26264, -0.86583, -0.42587, -0.26264, -0.86583, -0.42587, -0.26264, -0.86583, -0.42587, -0.27346, -0.90149, -0.33545, -0.27346, -0.90149, -0.33545, -0.27346, -0.90149, -0.33545, -0.27346, -0.90149, -0.33545, -0.28166, -0.92853, -0.24188, -0.28166, -0.92853, -0.24188, -0.28166, -0.92853, -0.24188, -0.28166, -0.92853, -0.24188, -0.28717, -0.94668, -0.14604, -0.28717, -0.94668, -0.14604, -0.28717, -0.94668, -0.14604, -0.28717, -0.94668, -0.14604, -0.28994, -0.9558, -0.04883, -0.28994, -0.9558, -0.04883, -0.28994, -0.9558, -0.04883, -0.28994, -0.9558, -0.04883, -0.28994, -0.9558, 0.04883, -0.28994, -0.9558, 0.04883, -0.28994, -0.9558, 0.04883, -0.28994, -0.9558, 0.04883, -0.28717, -0.94668, 0.14604, -0.28717, -0.94668, 0.14604, -0.28717, -0.94668, 0.14604, -0.28717, -0.94668, 0.14604, -0.28167, -0.92853, 0.24188, -0.28167, -0.92853, 0.24188, -0.28167, -0.92853, 0.24188, -0.28167, -0.92853, 0.24188, -0.27346, -0.90149, 0.33545, -0.27346, -0.90149, 0.33545, -0.27346, -0.90149, 0.33545, -0.27346, -0.90149, 0.33545, -0.26264, -0.86582, 0.42587, -0.26264, -0.86582, 0.42587, -0.26264, -0.86582, 0.42587, -0.26264, -0.86582, 0.42587, -0.2493, -0.82184, 0.51228, -0.2493, -0.82184, 0.51228, -0.2493, -0.82184, 0.51228, -0.2493, -0.82184, 0.51228, -0.23356, -0.76994, 0.59384, -0.23356, -0.76994, 0.59384, -0.23356, -0.76994, 0.59384, -0.23356, -0.76994, 0.59384, -0.21555, -0.71059, 0.66978, -0.21555, -0.71059, 0.66978, -0.21555, -0.71059, 0.66978, -0.21555, -0.71059, 0.66978, -0.19546, -0.64434, 0.73934, -0.19546, -0.64434, 0.73934, -0.19546, -0.64434, 0.73934, -0.19546, -0.64434, 0.73934, -0.17346, -0.57182, 0.80183, -0.17346, -0.57182, 0.80183, -0.17346, -0.57182, 0.80183, -0.17346, -0.57182, 0.80183, -0.14977, -0.49371, 0.85663, -0.14977, -0.49371, 0.85663, -0.14977, -0.49371, 0.85663, -0.14977, -0.49371, 0.85663, -0.1246, -0.41076, 0.90319, -0.1246, -0.41076, 0.90319, -0.1246, -0.41076, 0.90319, -0.1246, -0.41076, 0.90319, -0.09821, -0.32377, 0.94103, -0.09821, -0.32377, 0.94103, -0.09821, -0.32377, 0.94103, -0.09821, -0.32377, 0.94103, -0.07085, -0.23358, 0.96975, -0.07085, -0.23358, 0.96975, -0.07085, -0.23358, 0.96975, -0.07085, -0.23358, 0.96975, -0.0428, -0.14108, 0.98907, -0.0428, -0.14108, 0.98907, -0.0428, -0.14108, 0.98907, -0.0428, -0.14108, 0.98907, -0.01431, -0.04718, 0.99878, -0.01431, -0.04718, 0.99878, -0.01431, -0.04718, 0.99878, -0.00483, -0.04907, 0.99878, -0.00483, -0.04907, 0.99878, -0.00483, -0.04907, 0.99878, -0.01445, -0.14672, 0.98907, -0.01445, -0.14672, 0.98907, -0.01445, -0.14672, 0.98907, -0.01445, -0.14672, 0.98907, -0.02392, -0.24291, 0.96975, -0.02392, -0.24291, 0.96975, -0.02392, -0.24291, 0.96975, -0.02392, -0.24291, 0.96975, -0.03316, -0.33671, 0.94103, -0.03316, -0.33671, 0.94103, -0.03316, -0.33671, 0.94103, -0.03316, -0.33671, 0.94103, -0.04207, -0.42718, 0.90319, -0.04207, -0.42718, 0.90319, -0.04207, -0.42718, 0.90319, -0.04207, -0.42718, 0.90319, -0.05057, -0.51345, 0.85663, -0.05057, -0.51345, 0.85663, -0.05057, -0.51345, 0.85663, -0.05057, -0.51345, 0.85663, -0.05857, -0.59468, 0.80183, -0.05857, -0.59468, 0.80183, -0.05857, -0.59468, 0.80183, -0.05857, -0.59468, 0.80183, -0.066, -0.67009, 0.73934, -0.066, -0.67009, 0.73934, -0.066, -0.67009, 0.73934, -0.066, -0.67009, 0.73934, -0.07278, -0.73899, 0.66978, -0.07278, -0.73899, 0.66978, -0.07278, -0.73899, 0.66978, -0.07278, -0.73899, 0.66978, -0.07886, -0.80071, 0.59384, -0.07886, -0.80071, 0.59384, -0.07886, -0.80071, 0.59384, -0.07886, -0.80071, 0.59384, -0.08418, -0.85468, 0.51228, -0.08418, -0.85468, 0.51228, -0.08418, -0.85468, 0.51228, -0.08418, -0.85468, 0.51228, -0.08868, -0.90043, 0.42587, -0.08868, -0.90043, 0.42587, -0.08868, -0.90043, 0.42587, -0.08868, -0.90043, 0.42587, -0.09234, -0.93752, 0.33545, -0.09234, -0.93752, 0.33545, -0.09234, -0.93752, 0.33545, -0.09234, -0.93752, 0.33545, -0.09511, -0.96563, 0.24188, -0.09511, -0.96563, 0.24188, -0.09511, -0.96563, 0.24188, -0.09511, -0.96563, 0.24188, -0.09697, -0.98452, 0.14604, -0.09697, -0.98452, 0.14604, -0.09697, -0.98452, 0.14604, -0.09697, -0.98452, 0.14604, -0.0979, -0.994, 0.04883, -0.0979, -0.994, 0.04883, -0.0979, -0.994, 0.04883, -0.0979, -0.994, 0.04883, -0.0979, -0.994, -0.04883, -0.0979, -0.994, -0.04883, -0.0979, -0.994, -0.04883, -0.0979, -0.994, -0.04883, -0.09697, -0.98452, -0.14604, -0.09697, -0.98452, -0.14604, -0.09697, -0.98452, -0.14604, -0.09697, -0.98452, -0.14604, -0.09511, -0.96563, -0.24188, -0.09511, -0.96563, -0.24188, -0.09511, -0.96563, -0.24188, -0.09511, -0.96563, -0.24188, -0.09234, -0.93752, -0.33545, -0.09234, -0.93752, -0.33545, -0.09234, -0.93752, -0.33545, -0.09234, -0.93752, -0.33545, -0.08868, -0.90043, -0.42587, -0.08868, -0.90043, -0.42587, -0.08868, -0.90043, -0.42587, -0.08868, -0.90043, -0.42587, -0.08418, -0.85468, -0.51228, -0.08418, -0.85468, -0.51228, -0.08418, -0.85468, -0.51228, -0.08418, -0.85468, -0.51228, -0.07886, -0.80071, -0.59384, -0.07886, -0.80071, -0.59384, -0.07886, -0.80071, -0.59384, -0.07886, -0.80071, -0.59384, -0.07278, -0.73899, -0.66978, -0.07278, -0.73899, -0.66978, -0.07278, -0.73899, -0.66978, -0.07278, -0.73899, -0.66978, -0.066, -0.6701, -0.73934, -0.066, -0.6701, -0.73934, -0.066, -0.6701, -0.73934, -0.066, -0.6701, -0.73934, -0.05857, -0.59468, -0.80183, -0.05857, -0.59468, -0.80183, -0.05857, -0.59468, -0.80183, -0.05857, -0.59468, -0.80183, -0.05057, -0.51345, -0.85663, -0.05057, -0.51345, -0.85663, -0.05057, -0.51345, -0.85663, -0.05057, -0.51345, -0.85663, -0.04207, -0.42718, -0.90319, -0.04207, -0.42718, -0.90319, -0.04207, -0.42718, -0.90319, -0.04207, -0.42718, -0.90319, -0.03316, -0.3367, -0.94103, -0.03316, -0.3367, -0.94103, -0.03316, -0.3367, -0.94103, -0.03316, -0.3367, -0.94103, -0.02392, -0.24291, -0.96975, -0.02392, -0.24291, -0.96975, -0.02392, -0.24291, -0.96975, -0.02392, -0.24291, -0.96975, -0.01445, -0.14671, -0.98907, -0.01445, -0.14671, -0.98907, -0.01445, -0.14671, -0.98907, -0.01445, -0.14671, -0.98907, -0.00483, -0.04907, -0.99878, -0.00483, -0.04907, -0.99878, -0.00483, -0.04907, -0.99878, 0.00483, -0.04907, -0.99878, 0.00483, -0.04907, -0.99878, 0.00483, -0.04907, -0.99878, 0.01445, -0.14671, -0.98907, 0.01445, -0.14671, -0.98907, 0.01445, -0.14671, -0.98907, 0.01445, -0.14671, -0.98907, 0.02392, -0.24291, -0.96975, 0.02392, -0.24291, -0.96975, 0.02392, -0.24291, -0.96975, 0.02392, -0.24291, -0.96975, 0.03316, -0.3367, -0.94103, 0.03316, -0.3367, -0.94103, 0.03316, -0.3367, -0.94103, 0.03316, -0.3367, -0.94103, 0.04207, -0.42718, -0.90319, 0.04207, -0.42718, -0.90319, 0.04207, -0.42718, -0.90319, 0.04207, -0.42718, -0.90319, 0.05057, -0.51345, -0.85663, 0.05057, -0.51345, -0.85663, 0.05057, -0.51345, -0.85663, 0.05057, -0.51345, -0.85663, 0.05857, -0.59468, -0.80183, 0.05857, -0.59468, -0.80183, 0.05857, -0.59468, -0.80183, 0.05857, -0.59468, -0.80183, 0.066, -0.6701, -0.73934, 0.066, -0.6701, -0.73934, 0.066, -0.6701, -0.73934, 0.066, -0.6701, -0.73934, 0.07278, -0.73899, -0.66978, 0.07278, -0.73899, -0.66978, 0.07278, -0.73899, -0.66978, 0.07278, -0.73899, -0.66978, 0.07886, -0.80071, -0.59384, 0.07886, -0.80071, -0.59384, 0.07886, -0.80071, -0.59384, 0.07886, -0.80071, -0.59384, 0.08418, -0.85468, -0.51228, 0.08418, -0.85468, -0.51228, 0.08418, -0.85468, -0.51228, 0.08418, -0.85468, -0.51228, 0.08868, -0.90043, -0.42587, 0.08868, -0.90043, -0.42587, 0.08868, -0.90043, -0.42587, 0.08868, -0.90043, -0.42587, 0.09234, -0.93752, -0.33545, 0.09234, -0.93752, -0.33545, 0.09234, -0.93752, -0.33545, 0.09234, -0.93752, -0.33545, 0.09511, -0.96563, -0.24188, 0.09511, -0.96563, -0.24188, 0.09511, -0.96563, -0.24188, 0.09511, -0.96563, -0.24188, 0.09697, -0.98452, -0.14604, 0.09697, -0.98452, -0.14604, 0.09697, -0.98452, -0.14604, 0.09697, -0.98452, -0.14604, 0.0979, -0.994, -0.04883, 0.0979, -0.994, -0.04883, 0.0979, -0.994, -0.04883, 0.0979, -0.994, -0.04883, 0.0979, -0.994, 0.04883, 0.0979, -0.994, 0.04883, 0.0979, -0.994, 0.04883, 0.0979, -0.994, 0.04883, 0.09697, -0.98452, 0.14604, 0.09697, -0.98452, 0.14604, 0.09697, -0.98452, 0.14604, 0.09697, -0.98452, 0.14604, 0.09511, -0.96563, 0.24188, 0.09511, -0.96563, 0.24188, 0.09511, -0.96563, 0.24188, 0.09511, -0.96563, 0.24188, 0.09234, -0.93752, 0.33545, 0.09234, -0.93752, 0.33545, 0.09234, -0.93752, 0.33545, 0.09234, -0.93752, 0.33545, 0.08868, -0.90043, 0.42587, 0.08868, -0.90043, 0.42587, 0.08868, -0.90043, 0.42587, 0.08868, -0.90043, 0.42587, 0.08418, -0.85468, 0.51228, 0.08418, -0.85468, 0.51228, 0.08418, -0.85468, 0.51228, 0.08418, -0.85468, 0.51228, 0.07886, -0.80071, 0.59384, 0.07886, -0.80071, 0.59384, 0.07886, -0.80071, 0.59384, 0.07886, -0.80071, 0.59384, 0.07278, -0.73899, 0.66978, 0.07278, -0.73899, 0.66978, 0.07278, -0.73899, 0.66978, 0.07278, -0.73899, 0.66978, 0.066, -0.67009, 0.73934, 0.066, -0.67009, 0.73934, 0.066, -0.67009, 0.73934, 0.066, -0.67009, 0.73934, 0.05857, -0.59468, 0.80183, 0.05857, -0.59468, 0.80183, 0.05857, -0.59468, 0.80183, 0.05857, -0.59468, 0.80183, 0.05057, -0.51345, 0.85663, 0.05057, -0.51345, 0.85663, 0.05057, -0.51345, 0.85663, 0.05057, -0.51345, 0.85663, 0.04207, -0.42718, 0.90319, 0.04207, -0.42718, 0.90319, 0.04207, -0.42718, 0.90319, 0.04207, -0.42718, 0.90319, 0.03316, -0.33671, 0.94103, 0.03316, -0.33671, 0.94103, 0.03316, -0.33671, 0.94103, 0.03316, -0.33671, 0.94103, 0.02392, -0.24291, 0.96975, 0.02392, -0.24291, 0.96975, 0.02392, -0.24291, 0.96975, 0.02392, -0.24291, 0.96975, 0.01445, -0.14672, 0.98907, 0.01445, -0.14672, 0.98907, 0.01445, -0.14672, 0.98907, 0.01445, -0.14672, 0.98907, 0.00483, -0.04907, 0.99878, 0.00483, -0.04907, 0.99878, 0.00483, -0.04907, 0.99878, 0.01431, -0.04718, 0.99878, 0.01431, -0.04718, 0.99878, 0.01431, -0.04718, 0.99878, 0.0428, -0.14108, 0.98907, 0.0428, -0.14108, 0.98907, 0.0428, -0.14108, 0.98907, 0.0428, -0.14108, 0.98907, 0.07085, -0.23358, 0.96975, 0.07085, -0.23358, 0.96975, 0.07085, -0.23358, 0.96975, 0.07085, -0.23358, 0.96975, 0.09821, -0.32377, 0.94103, 0.09821, -0.32377, 0.94103, 0.09821, -0.32377, 0.94103, 0.09821, -0.32377, 0.94103, 0.1246, -0.41076, 0.90319, 0.1246, -0.41076, 0.90319, 0.1246, -0.41076, 0.90319, 0.1246, -0.41076, 0.90319, 0.14977, -0.49371, 0.85663, 0.14977, -0.49371, 0.85663, 0.14977, -0.49371, 0.85663, 0.14977, -0.49371, 0.85663, 0.17346, -0.57182, 0.80183, 0.17346, -0.57182, 0.80183, 0.17346, -0.57182, 0.80183, 0.17346, -0.57182, 0.80183, 0.19546, -0.64434, 0.73934, 0.19546, -0.64434, 0.73934, 0.19546, -0.64434, 0.73934, 0.19546, -0.64434, 0.73934, 0.21555, -0.71059, 0.66978, 0.21555, -0.71059, 0.66978, 0.21555, -0.71059, 0.66978, 0.21555, -0.71059, 0.66978, 0.23356, -0.76994, 0.59384, 0.23356, -0.76994, 0.59384, 0.23356, -0.76994, 0.59384, 0.23356, -0.76994, 0.59384, 0.2493, -0.82184, 0.51228, 0.2493, -0.82184, 0.51228, 0.2493, -0.82184, 0.51228, 0.2493, -0.82184, 0.51228, 0.26265, -0.86583, 0.42587, 0.26265, -0.86583, 0.42587, 0.26265, -0.86583, 0.42587, 0.26265, -0.86583, 0.42587, 0.27347, -0.90149, 0.33545, 0.27347, -0.90149, 0.33545, 0.27347, -0.90149, 0.33545, 0.27347, -0.90149, 0.33545, 0.28167, -0.92853, 0.24188, 0.28167, -0.92853, 0.24188, 0.28167, -0.92853, 0.24188, 0.28167, -0.92853, 0.24188, 0.28717, -0.94668, 0.14604, 0.28717, -0.94668, 0.14604, 0.28717, -0.94668, 0.14604, 0.28717, -0.94668, 0.14604, 0.28994, -0.9558, 0.04883, 0.28994, -0.9558, 0.04883, 0.28994, -0.9558, 0.04883, 0.28994, -0.9558, 0.04883, 0.28994, -0.9558, -0.04883, 0.28994, -0.9558, -0.04883, 0.28994, -0.9558, -0.04883, 0.28994, -0.9558, -0.04883, 0.28717, -0.94668, -0.14604, 0.28717, -0.94668, -0.14604, 0.28717, -0.94668, -0.14604, 0.28717, -0.94668, -0.14604, 0.28167, -0.92853, -0.24188, 0.28167, -0.92853, -0.24188, 0.28167, -0.92853, -0.24188, 0.28167, -0.92853, -0.24188, 0.27347, -0.90149, -0.33545, 0.27347, -0.90149, -0.33545, 0.27347, -0.90149, -0.33545, 0.27347, -0.90149, -0.33545, 0.26265, -0.86583, -0.42587, 0.26265, -0.86583, -0.42587, 0.26265, -0.86583, -0.42587, 0.26265, -0.86583, -0.42587, 0.2493, -0.82184, -0.51228, 0.2493, -0.82184, -0.51228, 0.2493, -0.82184, -0.51228, 0.2493, -0.82184, -0.51228, 0.23356, -0.76994, -0.59384, 0.23356, -0.76994, -0.59384, 0.23356, -0.76994, -0.59384, 0.23356, -0.76994, -0.59384, 0.21555, -0.71059, -0.66978, 0.21555, -0.71059, -0.66978, 0.21555, -0.71059, -0.66978, 0.21555, -0.71059, -0.66978, 0.19546, -0.64434, -0.73934, 0.19546, -0.64434, -0.73934, 0.19546, -0.64434, -0.73934, 0.19546, -0.64434, -0.73934, 0.17346, -0.57182, -0.80183, 0.17346, -0.57182, -0.80183, 0.17346, -0.57182, -0.80183, 0.17346, -0.57182, -0.80183, 0.14977, -0.49371, -0.85663, 0.14977, -0.49371, -0.85663, 0.14977, -0.49371, -0.85663, 0.14977, -0.49371, -0.85663, 0.1246, -0.41076, -0.90319, 0.1246, -0.41076, -0.90319, 0.1246, -0.41076, -0.90319, 0.1246, -0.41076, -0.90319, 0.09821, -0.32377, -0.94103, 0.09821, -0.32377, -0.94103, 0.09821, -0.32377, -0.94103, 0.09821, -0.32377, -0.94103, 0.07085, -0.23357, -0.96975, 0.07085, -0.23357, -0.96975, 0.07085, -0.23357, -0.96975, 0.07085, -0.23357, -0.96975, 0.0428, -0.14108, -0.98907, 0.0428, -0.14108, -0.98907, 0.0428, -0.14108, -0.98907, 0.0428, -0.14108, -0.98907, 0.01431, -0.04718, -0.99878, 0.01431, -0.04718, -0.99878, 0.01431, -0.04718, -0.99878, 0.02324, -0.04348, -0.99878, 0.02324, -0.04348, -0.99878, 0.02324, -0.04348, -0.99878, 0.0695, -0.13002, -0.98907, 0.0695, -0.13002, -0.98907, 0.0695, -0.13002, -0.98907, 0.0695, -0.13002, -0.98907, 0.11506, -0.21526, -0.96975, 0.11506, -0.21526, -0.96975, 0.11506, -0.21526, -0.96975, 0.11506, -0.21526, -0.96975, 0.15949, -0.29838, -0.94103, 0.15949, -0.29838, -0.94103, 0.15949, -0.29838, -0.94103, 0.15949, -0.29838, -0.94103, 0.20234, -0.37856, -0.90319, 0.20234, -0.37856, -0.90319, 0.20234, -0.37856, -0.90319, 0.20234, -0.37856, -0.90319, 0.24321, -0.45501, -0.85663, 0.24321, -0.45501, -0.85663, 0.24321, -0.45501, -0.85663, 0.24321, -0.45501, -0.85663, 0.28169, -0.527, -0.80183, 0.28169, -0.527, -0.80183, 0.28169, -0.527, -0.80183, 0.28169, -0.527, -0.80183, 0.31741, -0.59383, -0.73934, 0.31741, -0.59383, -0.73934, 0.31741, -0.59383, -0.73934, 0.31741, -0.59383, -0.73934, 0.35004, -0.65488, -0.66978, 0.35004, -0.65488, -0.66978, 0.35004, -0.65488, -0.66978, 0.35004, -0.65488, -0.66978, 0.37928, -0.70958, -0.59384, 0.37928, -0.70958, -0.59384, 0.37928, -0.70958, -0.59384, 0.37928, -0.70958, -0.59384, 0.40484, -0.75741, -0.51228, 0.40484, -0.75741, -0.51228, 0.40484, -0.75741, -0.51228, 0.40484, -0.75741, -0.51228, 0.42651, -0.79795, -0.42587, 0.42651, -0.79795, -0.42587, 0.42651, -0.79795, -0.42587, 0.42651, -0.79795, -0.42587, 0.44408, -0.83082, -0.33545, 0.44408, -0.83082, -0.33545, 0.44408, -0.83082, -0.33545, 0.44408, -0.83082, -0.33545, 0.4574, -0.85573, -0.24188, 0.4574, -0.85573, -0.24188, 0.4574, -0.85573, -0.24188, 0.4574, -0.85573, -0.24188, 0.46634, -0.87247, -0.14604, 0.46634, -0.87247, -0.14604, 0.46634, -0.87247, -0.14604, 0.46634, -0.87247, -0.14604, 0.47083, -0.88087, -0.04883, 0.47083, -0.88087, -0.04883, 0.47083, -0.88087, -0.04883, 0.47083, -0.88087, -0.04883, 0.47083, -0.88087, 0.04883, 0.47083, -0.88087, 0.04883, 0.47083, -0.88087, 0.04883, 0.47083, -0.88087, 0.04883, 0.46634, -0.87247, 0.14604, 0.46634, -0.87247, 0.14604, 0.46634, -0.87247, 0.14604, 0.46634, -0.87247, 0.14604, 0.4574, -0.85573, 0.24188, 0.4574, -0.85573, 0.24188, 0.4574, -0.85573, 0.24188, 0.4574, -0.85573, 0.24188, 0.44408, -0.83082, 0.33545, 0.44408, -0.83082, 0.33545, 0.44408, -0.83082, 0.33545, 0.44408, -0.83082, 0.33545, 0.42651, -0.79795, 0.42587, 0.42651, -0.79795, 0.42587, 0.42651, -0.79795, 0.42587, 0.42651, -0.79795, 0.42587, 0.40484, -0.75741, 0.51228, 0.40484, -0.75741, 0.51228, 0.40484, -0.75741, 0.51228, 0.40484, -0.75741, 0.51228, 0.37928, -0.70958, 0.59384, 0.37928, -0.70958, 0.59384, 0.37928, -0.70958, 0.59384, 0.37928, -0.70958, 0.59384, 0.35004, -0.65488, 0.66978, 0.35004, -0.65488, 0.66978, 0.35004, -0.65488, 0.66978, 0.35004, -0.65488, 0.66978, 0.31741, -0.59383, 0.73934, 0.31741, -0.59383, 0.73934, 0.31741, -0.59383, 0.73934, 0.31741, -0.59383, 0.73934, 0.28169, -0.527, 0.80183, 0.28169, -0.527, 0.80183, 0.28169, -0.527, 0.80183, 0.28169, -0.527, 0.80183, 0.24321, -0.45501, 0.85663, 0.24321, -0.45501, 0.85663, 0.24321, -0.45501, 0.85663, 0.24321, -0.45501, 0.85663, 0.20234, -0.37856, 0.90319, 0.20234, -0.37856, 0.90319, 0.20234, -0.37856, 0.90319, 0.20234, -0.37856, 0.90319, 0.15949, -0.29838, 0.94103, 0.15949, -0.29838, 0.94103, 0.15949, -0.29838, 0.94103, 0.15949, -0.29838, 0.94103, 0.11506, -0.21526, 0.96975, 0.11506, -0.21526, 0.96975, 0.11506, -0.21526, 0.96975, 0.11506, -0.21526, 0.96975, 0.0695, -0.13002, 0.98907, 0.0695, -0.13002, 0.98907, 0.0695, -0.13002, 0.98907, 0.0695, -0.13002, 0.98907, 0.02324, -0.04348, 0.99878, 0.02324, -0.04348, 0.99878, 0.02324, -0.04348, 0.99878, 0.03128, -0.03811, 0.99878, 0.03128, -0.03811, 0.99878, 0.03128, -0.03811, 0.99878, 0.09353, -0.11396, 0.98907, 0.09353, -0.11396, 0.98907, 0.09353, -0.11396, 0.98907, 0.09353, -0.11396, 0.98907, 0.15485, -0.18868, 0.96975, 0.15485, -0.18868, 0.96975, 0.15485, -0.18868, 0.96975, 0.15485, -0.18868, 0.96975, 0.21464, -0.26154, 0.94103, 0.21464, -0.26154, 0.94103, 0.21464, -0.26154, 0.94103, 0.21464, -0.26154, 0.94103, 0.27231, -0.33181, 0.90319, 0.27231, -0.33181, 0.90319, 0.27231, -0.33181, 0.90319, 0.27231, -0.33181, 0.90319, 0.3273, -0.39882, 0.85663, 0.3273, -0.39882, 0.85663, 0.3273, -0.39882, 0.85663, 0.3273, -0.39882, 0.85663, 0.37908, -0.46192, 0.80183, 0.37908, -0.46192, 0.80183, 0.37908, -0.46192, 0.80183, 0.37908, -0.46192, 0.80183, 0.42716, -0.5205, 0.73934, 0.42716, -0.5205, 0.73934, 0.42716, -0.5205, 0.73934, 0.42716, -0.5205, 0.73934, 0.47108, -0.57401, 0.66978, 0.47108, -0.57401, 0.66978, 0.47108, -0.57401, 0.66978, 0.47108, -0.57401, 0.66978, 0.51042, -0.62195, 0.59384, 0.51042, -0.62195, 0.59384, 0.51042, -0.62195, 0.59384, 0.51042, -0.62195, 0.59384, 0.54483, -0.66388, 0.51228, 0.54483, -0.66388, 0.51228, 0.54483, -0.66388, 0.51228, 0.54483, -0.66388, 0.51228, 0.57399, -0.69941, 0.42587, 0.57399, -0.69941, 0.42587, 0.57399, -0.69941, 0.42587, 0.57399, -0.69941, 0.42587, 0.59764, -0.72822, 0.33545, 0.59764, -0.72822, 0.33545, 0.59764, -0.72822, 0.33545, 0.59764, -0.72822, 0.33545, 0.61556, -0.75006, 0.24188, 0.61556, -0.75006, 0.24188, 0.61556, -0.75006, 0.24188, 0.61556, -0.75006, 0.24188, 0.62759, -0.76472, 0.14604, 0.62759, -0.76472, 0.14604, 0.62759, -0.76472, 0.14604, 0.62759, -0.76472, 0.14604, 0.63364, -0.77209, 0.04883, 0.63364, -0.77209, 0.04883, 0.63364, -0.77209, 0.04883, 0.63364, -0.77209, 0.04883, 0.63364, -0.77209, -0.04883, 0.63364, -0.77209, -0.04883, 0.63364, -0.77209, -0.04883, 0.63364, -0.77209, -0.04883, 0.62759, -0.76472, -0.14604, 0.62759, -0.76472, -0.14604, 0.62759, -0.76472, -0.14604, 0.62759, -0.76472, -0.14604, 0.61556, -0.75006, -0.24188, 0.61556, -0.75006, -0.24188, 0.61556, -0.75006, -0.24188, 0.61556, -0.75006, -0.24188, 0.59764, -0.72822, -0.33545, 0.59764, -0.72822, -0.33545, 0.59764, -0.72822, -0.33545, 0.59764, -0.72822, -0.33545, 0.57399, -0.69941, -0.42587, 0.57399, -0.69941, -0.42587, 0.57399, -0.69941, -0.42587, 0.57399, -0.69941, -0.42587, 0.54483, -0.66388, -0.51228, 0.54483, -0.66388, -0.51228, 0.54483, -0.66388, -0.51228, 0.54483, -0.66388, -0.51228, 0.51042, -0.62195, -0.59384, 0.51042, -0.62195, -0.59384, 0.51042, -0.62195, -0.59384, 0.51042, -0.62195, -0.59384, 0.47108, -0.57401, -0.66978, 0.47108, -0.57401, -0.66978, 0.47108, -0.57401, -0.66978, 0.47108, -0.57401, -0.66978, 0.42716, -0.5205, -0.73934, 0.42716, -0.5205, -0.73934, 0.42716, -0.5205, -0.73934, 0.42716, -0.5205, -0.73934, 0.37908, -0.46192, -0.80183, 0.37908, -0.46192, -0.80183, 0.37908, -0.46192, -0.80183, 0.37908, -0.46192, -0.80183, 0.3273, -0.39882, -0.85663, 0.3273, -0.39882, -0.85663, 0.3273, -0.39882, -0.85663, 0.3273, -0.39882, -0.85663, 0.27231, -0.33181, -0.90319, 0.27231, -0.33181, -0.90319, 0.27231, -0.33181, -0.90319, 0.27231, -0.33181, -0.90319, 0.21464, -0.26154, -0.94103, 0.21464, -0.26154, -0.94103, 0.21464, -0.26154, -0.94103, 0.21464, -0.26154, -0.94103, 0.15485, -0.18868, -0.96975, 0.15485, -0.18868, -0.96975, 0.15485, -0.18868, -0.96975, 0.15485, -0.18868, -0.96975, 0.09353, -0.11396, -0.98907, 0.09353, -0.11396, -0.98907, 0.09353, -0.11396, -0.98907, 0.09353, -0.11396, -0.98907, 0.03128, -0.03811, -0.99878, 0.03128, -0.03811, -0.99878, 0.03128, -0.03811, -0.99878, 0.03811, -0.03128, -0.99878, 0.03811, -0.03128, -0.99878, 0.03811, -0.03128, -0.99878, 0.11396, -0.09353, -0.98907, 0.11396, -0.09353, -0.98907, 0.11396, -0.09353, -0.98907, 0.11396, -0.09353, -0.98907, 0.18868, -0.15485, -0.96975, 0.18868, -0.15485, -0.96975, 0.18868, -0.15485, -0.96975, 0.18868, -0.15485, -0.96975, 0.26154, -0.21464, -0.94103, 0.26154, -0.21464, -0.94103, 0.26154, -0.21464, -0.94103, 0.26154, -0.21464, -0.94103, 0.33181, -0.27231, -0.90319, 0.33181, -0.27231, -0.90319, 0.33181, -0.27231, -0.90319, 0.33181, -0.27231, -0.90319, 0.39882, -0.3273, -0.85663, 0.39882, -0.3273, -0.85663, 0.39882, -0.3273, -0.85663, 0.39882, -0.3273, -0.85663, 0.46192, -0.37908, -0.80183, 0.46192, -0.37908, -0.80183, 0.46192, -0.37908, -0.80183, 0.46192, -0.37908, -0.80183, 0.5205, -0.42716, -0.73934, 0.5205, -0.42716, -0.73934, 0.5205, -0.42716, -0.73934, 0.5205, -0.42716, -0.73934, 0.57401, -0.47108, -0.66978, 0.57401, -0.47108, -0.66978, 0.57401, -0.47108, -0.66978, 0.57401, -0.47108, -0.66978, 0.62195, -0.51042, -0.59384, 0.62195, -0.51042, -0.59384, 0.62195, -0.51042, -0.59384, 0.62195, -0.51042, -0.59384, 0.66388, -0.54483, -0.51228, 0.66388, -0.54483, -0.51228, 0.66388, -0.54483, -0.51228, 0.66388, -0.54483, -0.51228, 0.69941, -0.57399, -0.42587, 0.69941, -0.57399, -0.42587, 0.69941, -0.57399, -0.42587, 0.69941, -0.57399, -0.42587, 0.72822, -0.59763, -0.33545, 0.72822, -0.59763, -0.33545, 0.72822, -0.59763, -0.33545, 0.72822, -0.59763, -0.33545, 0.75006, -0.61556, -0.24188, 0.75006, -0.61556, -0.24188, 0.75006, -0.61556, -0.24188, 0.75006, -0.61556, -0.24188, 0.76472, -0.62759, -0.14604, 0.76472, -0.62759, -0.14604, 0.76472, -0.62759, -0.14604, 0.76472, -0.62759, -0.14604, 0.77209, -0.63364, -0.04883, 0.77209, -0.63364, -0.04883, 0.77209, -0.63364, -0.04883, 0.77209, -0.63364, -0.04883, 0.77209, -0.63364, 0.04883, 0.77209, -0.63364, 0.04883, 0.77209, -0.63364, 0.04883, 0.77209, -0.63364, 0.04883, 0.76472, -0.62759, 0.14604, 0.76472, -0.62759, 0.14604, 0.76472, -0.62759, 0.14604, 0.76472, -0.62759, 0.14604, 0.75006, -0.61556, 0.24188, 0.75006, -0.61556, 0.24188, 0.75006, -0.61556, 0.24188, 0.75006, -0.61556, 0.24188, 0.72822, -0.59763, 0.33545, 0.72822, -0.59763, 0.33545, 0.72822, -0.59763, 0.33545, 0.72822, -0.59763, 0.33545, 0.69941, -0.57399, 0.42587, 0.69941, -0.57399, 0.42587, 0.69941, -0.57399, 0.42587, 0.69941, -0.57399, 0.42587, 0.66388, -0.54483, 0.51228, 0.66388, -0.54483, 0.51228, 0.66388, -0.54483, 0.51228, 0.66388, -0.54483, 0.51228, 0.62195, -0.51042, 0.59384, 0.62195, -0.51042, 0.59384, 0.62195, -0.51042, 0.59384, 0.62195, -0.51042, 0.59384, 0.57401, -0.47108, 0.66978, 0.57401, -0.47108, 0.66978, 0.57401, -0.47108, 0.66978, 0.57401, -0.47108, 0.66978, 0.5205, -0.42716, 0.73934, 0.5205, -0.42716, 0.73934, 0.5205, -0.42716, 0.73934, 0.5205, -0.42716, 0.73934, 0.46192, -0.37908, 0.80183, 0.46192, -0.37908, 0.80183, 0.46192, -0.37908, 0.80183, 0.46192, -0.37908, 0.80183, 0.39882, -0.3273, 0.85663, 0.39882, -0.3273, 0.85663, 0.39882, -0.3273, 0.85663, 0.39882, -0.3273, 0.85663, 0.33181, -0.27231, 0.90319, 0.33181, -0.27231, 0.90319, 0.33181, -0.27231, 0.90319, 0.33181, -0.27231, 0.90319, 0.26154, -0.21464, 0.94103, 0.26154, -0.21464, 0.94103, 0.26154, -0.21464, 0.94103, 0.26154, -0.21464, 0.94103, 0.18868, -0.15485, 0.96975, 0.18868, -0.15485, 0.96975, 0.18868, -0.15485, 0.96975, 0.18868, -0.15485, 0.96975, 0.11396, -0.09353, 0.98907, 0.11396, -0.09353, 0.98907, 0.11396, -0.09353, 0.98907, 0.11396, -0.09353, 0.98907, 0.03811, -0.03128, 0.99878, 0.03811, -0.03128, 0.99878, 0.03811, -0.03128, 0.99878, 0.04348, -0.02324, 0.99878, 0.04348, -0.02324, 0.99878, 0.04348, -0.02324, 0.99878, 0.13002, -0.0695, 0.98907, 0.13002, -0.0695, 0.98907, 0.13002, -0.0695, 0.98907, 0.13002, -0.0695, 0.98907, 0.21526, -0.11506, 0.96975, 0.21526, -0.11506, 0.96975, 0.21526, -0.11506, 0.96975, 0.21526, -0.11506, 0.96975, 0.29838, -0.15949, 0.94103, 0.29838, -0.15949, 0.94103, 0.29838, -0.15949, 0.94103, 0.29838, -0.15949, 0.94103, 0.37856, -0.20234, 0.90319, 0.37856, -0.20234, 0.90319, 0.37856, -0.20234, 0.90319, 0.37856, -0.20234, 0.90319, 0.45501, -0.24321, 0.85663, 0.45501, -0.24321, 0.85663, 0.45501, -0.24321, 0.85663, 0.45501, -0.24321, 0.85663, 0.527, -0.28168, 0.80183, 0.527, -0.28168, 0.80183, 0.527, -0.28168, 0.80183, 0.527, -0.28168, 0.80183, 0.59383, -0.31741, 0.73934, 0.59383, -0.31741, 0.73934, 0.59383, -0.31741, 0.73934, 0.59383, -0.31741, 0.73934, 0.65488, -0.35004, 0.66978, 0.65488, -0.35004, 0.66978, 0.65488, -0.35004, 0.66978, 0.65488, -0.35004, 0.66978, 0.70958, -0.37928, 0.59384, 0.70958, -0.37928, 0.59384, 0.70958, -0.37928, 0.59384, 0.70958, -0.37928, 0.59384, 0.75741, -0.40484, 0.51228, 0.75741, -0.40484, 0.51228, 0.75741, -0.40484, 0.51228, 0.75741, -0.40484, 0.51228, 0.79795, -0.42651, 0.42587, 0.79795, -0.42651, 0.42587, 0.79795, -0.42651, 0.42587, 0.79795, -0.42651, 0.42587, 0.83082, -0.44408, 0.33545, 0.83082, -0.44408, 0.33545, 0.83082, -0.44408, 0.33545, 0.83082, -0.44408, 0.33545, 0.85573, -0.4574, 0.24188, 0.85573, -0.4574, 0.24188, 0.85573, -0.4574, 0.24188, 0.85573, -0.4574, 0.24188, 0.87247, -0.46634, 0.14604, 0.87247, -0.46634, 0.14604, 0.87247, -0.46634, 0.14604, 0.87247, -0.46634, 0.14604, 0.88087, -0.47083, 0.04883, 0.88087, -0.47083, 0.04883, 0.88087, -0.47083, 0.04883, 0.88087, -0.47083, 0.04883, 0.88087, -0.47083, -0.04883, 0.88087, -0.47083, -0.04883, 0.88087, -0.47083, -0.04883, 0.88087, -0.47083, -0.04883, 0.87247, -0.46634, -0.14604, 0.87247, -0.46634, -0.14604, 0.87247, -0.46634, -0.14604, 0.87247, -0.46634, -0.14604, 0.85573, -0.4574, -0.24188, 0.85573, -0.4574, -0.24188, 0.85573, -0.4574, -0.24188, 0.85573, -0.4574, -0.24188, 0.83082, -0.44408, -0.33545, 0.83082, -0.44408, -0.33545, 0.83082, -0.44408, -0.33545, 0.83082, -0.44408, -0.33545, 0.79795, -0.42651, -0.42587, 0.79795, -0.42651, -0.42587, 0.79795, -0.42651, -0.42587, 0.79795, -0.42651, -0.42587, 0.75741, -0.40484, -0.51228, 0.75741, -0.40484, -0.51228, 0.75741, -0.40484, -0.51228, 0.75741, -0.40484, -0.51228, 0.70958, -0.37928, -0.59384, 0.70958, -0.37928, -0.59384, 0.70958, -0.37928, -0.59384, 0.70958, -0.37928, -0.59384, 0.65488, -0.35004, -0.66978, 0.65488, -0.35004, -0.66978, 0.65488, -0.35004, -0.66978, 0.65488, -0.35004, -0.66978, 0.59383, -0.31741, -0.73934, 0.59383, -0.31741, -0.73934, 0.59383, -0.31741, -0.73934, 0.59383, -0.31741, -0.73934, 0.527, -0.28168, -0.80183, 0.527, -0.28168, -0.80183, 0.527, -0.28168, -0.80183, 0.527, -0.28168, -0.80183, 0.45501, -0.24321, -0.85663, 0.45501, -0.24321, -0.85663, 0.45501, -0.24321, -0.85663, 0.45501, -0.24321, -0.85663, 0.37856, -0.20234, -0.90319, 0.37856, -0.20234, -0.90319, 0.37856, -0.20234, -0.90319, 0.37856, -0.20234, -0.90319, 0.29838, -0.15949, -0.94103, 0.29838, -0.15949, -0.94103, 0.29838, -0.15949, -0.94103, 0.29838, -0.15949, -0.94103, 0.21526, -0.11506, -0.96975, 0.21526, -0.11506, -0.96975, 0.21526, -0.11506, -0.96975, 0.21526, -0.11506, -0.96975, 0.13002, -0.0695, -0.98907, 0.13002, -0.0695, -0.98907, 0.13002, -0.0695, -0.98907, 0.13002, -0.0695, -0.98907, 0.04348, -0.02324, -0.99878, 0.04348, -0.02324, -0.99878, 0.04348, -0.02324, -0.99878, 0.04718, -0.01431, -0.99878, 0.04718, -0.01431, -0.99878, 0.04718, -0.01431, -0.99878, 0.14108, -0.0428, -0.98907, 0.14108, -0.0428, -0.98907, 0.14108, -0.0428, -0.98907, 0.14108, -0.0428, -0.98907, 0.23357, -0.07085, -0.96975, 0.23357, -0.07085, -0.96975, 0.23357, -0.07085, -0.96975, 0.23357, -0.07085, -0.96975, 0.32377, -0.09821, -0.94103, 0.32377, -0.09821, -0.94103, 0.32377, -0.09821, -0.94103, 0.32377, -0.09821, -0.94103, 0.41076, -0.1246, -0.90319, 0.41076, -0.1246, -0.90319, 0.41076, -0.1246, -0.90319, 0.41076, -0.1246, -0.90319, 0.49371, -0.14977, -0.85663, 0.49371, -0.14977, -0.85663, 0.49371, -0.14977, -0.85663, 0.49371, -0.14977, -0.85663, 0.57182, -0.17346, -0.80183, 0.57182, -0.17346, -0.80183, 0.57182, -0.17346, -0.80183, 0.57182, -0.17346, -0.80183, 0.64434, -0.19546, -0.73934, 0.64434, -0.19546, -0.73934, 0.64434, -0.19546, -0.73934, 0.64434, -0.19546, -0.73934, 0.71059, -0.21555, -0.66978, 0.71059, -0.21555, -0.66978, 0.71059, -0.21555, -0.66978, 0.71059, -0.21555, -0.66978, 0.76994, -0.23356, -0.59384, 0.76994, -0.23356, -0.59384, 0.76994, -0.23356, -0.59384, 0.76994, -0.23356, -0.59384, 0.82184, -0.2493, -0.51228, 0.82184, -0.2493, -0.51228, 0.82184, -0.2493, -0.51228, 0.82184, -0.2493, -0.51228, 0.86583, -0.26264, -0.42587, 0.86583, -0.26264, -0.42587, 0.86583, -0.26264, -0.42587, 0.86583, -0.26264, -0.42587, 0.90149, -0.27346, -0.33545, 0.90149, -0.27346, -0.33545, 0.90149, -0.27346, -0.33545, 0.90149, -0.27346, -0.33545, 0.92853, -0.28166, -0.24188, 0.92853, -0.28166, -0.24188, 0.92853, -0.28166, -0.24188, 0.92853, -0.28166, -0.24188, 0.94668, -0.28717, -0.14604, 0.94668, -0.28717, -0.14604, 0.94668, -0.28717, -0.14604, 0.94668, -0.28717, -0.14604, 0.9558, -0.28994, -0.04883, 0.9558, -0.28994, -0.04883, 0.9558, -0.28994, -0.04883, 0.9558, -0.28994, -0.04883, 0.9558, -0.28994, 0.04883, 0.9558, -0.28994, 0.04883, 0.9558, -0.28994, 0.04883, 0.9558, -0.28994, 0.04883, 0.94668, -0.28717, 0.14604, 0.94668, -0.28717, 0.14604, 0.94668, -0.28717, 0.14604, 0.94668, -0.28717, 0.14604, 0.92853, -0.28166, 0.24188, 0.92853, -0.28166, 0.24188, 0.92853, -0.28166, 0.24188, 0.92853, -0.28166, 0.24188, 0.90149, -0.27346, 0.33545, 0.90149, -0.27346, 0.33545, 0.90149, -0.27346, 0.33545, 0.90149, -0.27346, 0.33545, 0.86583, -0.26264, 0.42587, 0.86583, -0.26264, 0.42587, 0.86583, -0.26264, 0.42587, 0.86583, -0.26264, 0.42587, 0.82184, -0.2493, 0.51228, 0.82184, -0.2493, 0.51228, 0.82184, -0.2493, 0.51228, 0.82184, -0.2493, 0.51228, 0.76994, -0.23356, 0.59384, 0.76994, -0.23356, 0.59384, 0.76994, -0.23356, 0.59384, 0.76994, -0.23356, 0.59384, 0.71059, -0.21555, 0.66978, 0.71059, -0.21555, 0.66978, 0.71059, -0.21555, 0.66978, 0.71059, -0.21555, 0.66978, 0.64434, -0.19546, 0.73934, 0.64434, -0.19546, 0.73934, 0.64434, -0.19546, 0.73934, 0.64434, -0.19546, 0.73934, 0.57182, -0.17346, 0.80183, 0.57182, -0.17346, 0.80183, 0.57182, -0.17346, 0.80183, 0.57182, -0.17346, 0.80183, 0.49371, -0.14977, 0.85663, 0.49371, -0.14977, 0.85663, 0.49371, -0.14977, 0.85663, 0.49371, -0.14977, 0.85663, 0.41076, -0.1246, 0.90319, 0.41076, -0.1246, 0.90319, 0.41076, -0.1246, 0.90319, 0.41076, -0.1246, 0.90319, 0.32377, -0.09821, 0.94103, 0.32377, -0.09821, 0.94103, 0.32377, -0.09821, 0.94103, 0.32377, -0.09821, 0.94103, 0.23358, -0.07085, 0.96975, 0.23358, -0.07085, 0.96975, 0.23358, -0.07085, 0.96975, 0.23358, -0.07085, 0.96975, 0.14108, -0.0428, 0.98907, 0.14108, -0.0428, 0.98907, 0.14108, -0.0428, 0.98907, 0.14108, -0.0428, 0.98907, 0.04718, -0.01431, 0.99878, 0.04718, -0.01431, 0.99878, 0.04718, -0.01431, 0.99878, 0.04907, -0.00483, 0.99878, 0.04907, -0.00483, 0.99878, 0.04907, -0.00483, 0.99878, 0.14672, -0.01445, 0.98907, 0.14672, -0.01445, 0.98907, 0.14672, -0.01445, 0.98907, 0.14672, -0.01445, 0.98907, 0.24291, -0.02392, 0.96975, 0.24291, -0.02392, 0.96975, 0.24291, -0.02392, 0.96975, 0.24291, -0.02392, 0.96975, 0.33671, -0.03316, 0.94103, 0.33671, -0.03316, 0.94103, 0.33671, -0.03316, 0.94103, 0.33671, -0.03316, 0.94103, 0.42718, -0.04207, 0.90319, 0.42718, -0.04207, 0.90319, 0.42718, -0.04207, 0.90319, 0.42718, -0.04207, 0.90319, 0.51345, -0.05057, 0.85663, 0.51345, -0.05057, 0.85663, 0.51345, -0.05057, 0.85663, 0.51345, -0.05057, 0.85663, 0.59468, -0.05857, 0.80183, 0.59468, -0.05857, 0.80183, 0.59468, -0.05857, 0.80183, 0.59468, -0.05857, 0.80183, 0.67009, -0.066, 0.73934, 0.67009, -0.066, 0.73934, 0.67009, -0.066, 0.73934, 0.67009, -0.066, 0.73934, 0.73899, -0.07278, 0.66978, 0.73899, -0.07278, 0.66978, 0.73899, -0.07278, 0.66978, 0.73899, -0.07278, 0.66978, 0.80071, -0.07886, 0.59384, 0.80071, -0.07886, 0.59384, 0.80071, -0.07886, 0.59384, 0.80071, -0.07886, 0.59384, 0.85468, -0.08418, 0.51228, 0.85468, -0.08418, 0.51228, 0.85468, -0.08418, 0.51228, 0.85468, -0.08418, 0.51228, 0.90043, -0.08868, 0.42587, 0.90043, -0.08868, 0.42587, 0.90043, -0.08868, 0.42587, 0.90043, -0.08868, 0.42587, 0.93752, -0.09234, 0.33545, 0.93752, -0.09234, 0.33545, 0.93752, -0.09234, 0.33545, 0.93752, -0.09234, 0.33545, 0.96563, -0.09511, 0.24188, 0.96563, -0.09511, 0.24188, 0.96563, -0.09511, 0.24188, 0.96563, -0.09511, 0.24188, 0.98452, -0.09697, 0.14604, 0.98452, -0.09697, 0.14604, 0.98452, -0.09697, 0.14604, 0.98452, -0.09697, 0.14604, 0.994, -0.0979, 0.04883, 0.994, -0.0979, 0.04883, 0.994, -0.0979, 0.04883, 0.994, -0.0979, 0.04883, 0.994, -0.0979, -0.04883, 0.994, -0.0979, -0.04883, 0.994, -0.0979, -0.04883, 0.994, -0.0979, -0.04883, 0.98452, -0.09697, -0.14604, 0.98452, -0.09697, -0.14604, 0.98452, -0.09697, -0.14604, 0.98452, -0.09697, -0.14604, 0.96563, -0.09511, -0.24188, 0.96563, -0.09511, -0.24188, 0.96563, -0.09511, -0.24188, 0.96563, -0.09511, -0.24188, 0.93752, -0.09234, -0.33545, 0.93752, -0.09234, -0.33545, 0.93752, -0.09234, -0.33545, 0.93752, -0.09234, -0.33545, 0.90043, -0.08868, -0.42587, 0.90043, -0.08868, -0.42587, 0.90043, -0.08868, -0.42587, 0.90043, -0.08868, -0.42587, 0.85468, -0.08418, -0.51228, 0.85468, -0.08418, -0.51228, 0.85468, -0.08418, -0.51228, 0.85468, -0.08418, -0.51228, 0.80071, -0.07886, -0.59384, 0.80071, -0.07886, -0.59384, 0.80071, -0.07886, -0.59384, 0.80071, -0.07886, -0.59384, 0.73899, -0.07278, -0.66978, 0.73899, -0.07278, -0.66978, 0.73899, -0.07278, -0.66978, 0.73899, -0.07278, -0.66978, 0.6701, -0.066, -0.73934, 0.6701, -0.066, -0.73934, 0.6701, -0.066, -0.73934, 0.6701, -0.066, -0.73934, 0.59468, -0.05857, -0.80183, 0.59468, -0.05857, -0.80183, 0.59468, -0.05857, -0.80183, 0.59468, -0.05857, -0.80183, 0.51345, -0.05057, -0.85663, 0.51345, -0.05057, -0.85663, 0.51345, -0.05057, -0.85663, 0.51345, -0.05057, -0.85663, 0.42718, -0.04207, -0.90319, 0.42718, -0.04207, -0.90319, 0.42718, -0.04207, -0.90319, 0.42718, -0.04207, -0.90319, 0.3367, -0.03316, -0.94103, 0.3367, -0.03316, -0.94103, 0.3367, -0.03316, -0.94103, 0.3367, -0.03316, -0.94103, 0.24291, -0.02392, -0.96975, 0.24291, -0.02392, -0.96975, 0.24291, -0.02392, -0.96975, 0.24291, -0.02392, -0.96975, 0.14671, -0.01445, -0.98907, 0.14671, -0.01445, -0.98907, 0.14671, -0.01445, -0.98907, 0.14671, -0.01445, -0.98907, 0.04907, -0.00483, -0.99878, 0.04907, -0.00483, -0.99878, 0.04907, -0.00483, -0.99878 ],
	                                'itemSize': 3,
	                                'type': 'ARRAY_BUFFER'
	                            },
	                            'TexCoord0': {
	                                'elements': [ 0.3212, -0, 0.78125, 0.03125, 0.75, 0.03125, 0.75, 0.03125, 0.78125, 0.03125, 0.78125, 0.0625, 0.75, 0.0625, 0.75, 0.0625, 0.78125, 0.0625, 0.78125, 0.09375, 0.75, 0.09375, 0.75, 0.09375, 0.78125, 0.09375, 0.78125, 0.125, 0.75, 0.125, 0.75, 0.125, 0.78125, 0.125, 0.78125, 0.15625, 0.75, 0.15625, 0.75, 0.15625, 0.78125, 0.15625, 0.78125, 0.1875, 0.75, 0.1875, 0.75, 0.1875, 0.78125, 0.1875, 0.78125, 0.21875, 0.75, 0.21875, 0.75, 0.21875, 0.78125, 0.21875, 0.78125, 0.25, 0.75, 0.25, 0.75, 0.25, 0.78125, 0.25, 0.78125, 0.28125, 0.75, 0.28125, 0.75, 0.28125, 0.78125, 0.28125, 0.78125, 0.3125, 0.75, 0.3125, 0.75, 0.3125, 0.78125, 0.3125, 0.78125, 0.34375, 0.75, 0.34375, 0.75, 0.34375, 0.78125, 0.34375, 0.78125, 0.375, 0.75, 0.375, 0.75, 0.375, 0.78125, 0.375, 0.78125, 0.40625, 0.75, 0.40625, 0.75, 0.40625, 0.78125, 0.40625, 0.78125, 0.4375, 0.75, 0.4375, 0.75, 0.4375, 0.78125, 0.4375, 0.78125, 0.46875, 0.75, 0.46875, 0.75, 0.46875, 0.78125, 0.46875, 0.78125, 0.5, 0.75, 0.5, 0.75, 0.5, 0.78125, 0.5, 0.78125, 0.53125, 0.75, 0.53125, 0.75, 0.53125, 0.78125, 0.53125, 0.78125, 0.5625, 0.75, 0.5625, 0.75, 0.5625, 0.78125, 0.5625, 0.78125, 0.59375, 0.75, 0.59375, 0.75, 0.59375, 0.78125, 0.59375, 0.78125, 0.625, 0.75, 0.625, 0.75, 0.625, 0.78125, 0.625, 0.78125, 0.65625, 0.75, 0.65625, 0.75, 0.65625, 0.78125, 0.65625, 0.78125, 0.6875, 0.75, 0.6875, 0.75, 0.6875, 0.78125, 0.6875, 0.78125, 0.71875, 0.75, 0.71875, 0.75, 0.71875, 0.78125, 0.71875, 0.78125, 0.75, 0.75, 0.75, 0.75, 0.75, 0.78125, 0.75, 0.78125, 0.78125, 0.75, 0.78125, 0.75, 0.78125, 0.78125, 0.78125, 0.78125, 0.8125, 0.75, 0.8125, 0.75, 0.8125, 0.78125, 0.8125, 0.78125, 0.84375, 0.75, 0.84375, 0.75, 0.84375, 0.78125, 0.84375, 0.78125, 0.875, 0.75, 0.875, 0.75, 0.875, 0.78125, 0.875, 0.78125, 0.90625, 0.75, 0.90625, 0.75, 0.90625, 0.78125, 0.90625, 0.78125, 0.9375, 0.75, 0.9375, 0.75, 0.9375, 0.78125, 0.9375, 0.78125, 0.96875, 0.75, 0.96875, 0.78125, 0.96875, 0.63412, 1, 0.75, 0.96875, 0.8125, 0.96875, 0.63412, 1, 0.78125, 0.96875, 0.78125, 0.9375, 0.8125, 0.9375, 0.8125, 0.96875, 0.78125, 0.96875, 0.78125, 0.90625, 0.8125, 0.90625, 0.8125, 0.9375, 0.78125, 0.9375, 0.78125, 0.875, 0.8125, 0.875, 0.8125, 0.90625, 0.78125, 0.90625, 0.78125, 0.84375, 0.8125, 0.84375, 0.8125, 0.875, 0.78125, 0.875, 0.78125, 0.8125, 0.8125, 0.8125, 0.8125, 0.84375, 0.78125, 0.84375, 0.78125, 0.78125, 0.8125, 0.78125, 0.8125, 0.8125, 0.78125, 0.8125, 0.78125, 0.75, 0.8125, 0.75, 0.8125, 0.78125, 0.78125, 0.78125, 0.78125, 0.71875, 0.8125, 0.71875, 0.8125, 0.75, 0.78125, 0.75, 0.78125, 0.6875, 0.8125, 0.6875, 0.8125, 0.71875, 0.78125, 0.71875, 0.78125, 0.65625, 0.8125, 0.65625, 0.8125, 0.6875, 0.78125, 0.6875, 0.78125, 0.625, 0.8125, 0.625, 0.8125, 0.65625, 0.78125, 0.65625, 0.78125, 0.59375, 0.8125, 0.59375, 0.8125, 0.625, 0.78125, 0.625, 0.78125, 0.5625, 0.8125, 0.5625, 0.8125, 0.59375, 0.78125, 0.59375, 0.78125, 0.53125, 0.8125, 0.53125, 0.8125, 0.5625, 0.78125, 0.5625, 0.78125, 0.5, 0.8125, 0.5, 0.8125, 0.53125, 0.78125, 0.53125, 0.78125, 0.46875, 0.8125, 0.46875, 0.8125, 0.5, 0.78125, 0.5, 0.78125, 0.4375, 0.8125, 0.4375, 0.8125, 0.46875, 0.78125, 0.46875, 0.78125, 0.40625, 0.8125, 0.40625, 0.8125, 0.4375, 0.78125, 0.4375, 0.78125, 0.375, 0.8125, 0.375, 0.8125, 0.40625, 0.78125, 0.40625, 0.78125, 0.34375, 0.8125, 0.34375, 0.8125, 0.375, 0.78125, 0.375, 0.78125, 0.3125, 0.8125, 0.3125, 0.8125, 0.34375, 0.78125, 0.34375, 0.78125, 0.28125, 0.8125, 0.28125, 0.8125, 0.3125, 0.78125, 0.3125, 0.78125, 0.25, 0.8125, 0.25, 0.8125, 0.28125, 0.78125, 0.28125, 0.78125, 0.21875, 0.8125, 0.21875, 0.8125, 0.25, 0.78125, 0.25, 0.78125, 0.1875, 0.8125, 0.1875, 0.8125, 0.21875, 0.78125, 0.21875, 0.78125, 0.15625, 0.8125, 0.15625, 0.8125, 0.1875, 0.78125, 0.1875, 0.78125, 0.125, 0.8125, 0.125, 0.8125, 0.15625, 0.78125, 0.15625, 0.78125, 0.09375, 0.8125, 0.09375, 0.8125, 0.125, 0.78125, 0.125, 0.78125, 0.0625, 0.8125, 0.0625, 0.8125, 0.09375, 0.78125, 0.09375, 0.78125, 0.03125, 0.8125, 0.03125, 0.8125, 0.0625, 0.78125, 0.0625, 0.3212, -0, 0.8125, 0.03125, 0.78125, 0.03125, 1.3212, -0, 0.84375, 0.03125, 0.8125, 0.03125, 0.8125, 0.03125, 0.84375, 0.03125, 0.84375, 0.0625, 0.8125, 0.0625, 0.8125, 0.0625, 0.84375, 0.0625, 0.84375, 0.09375, 0.8125, 0.09375, 0.8125, 0.09375, 0.84375, 0.09375, 0.84375, 0.125, 0.8125, 0.125, 0.8125, 0.125, 0.84375, 0.125, 0.84375, 0.15625, 0.8125, 0.15625, 0.8125, 0.15625, 0.84375, 0.15625, 0.84375, 0.1875, 0.8125, 0.1875, 0.8125, 0.1875, 0.84375, 0.1875, 0.84375, 0.21875, 0.8125, 0.21875, 0.8125, 0.21875, 0.84375, 0.21875, 0.84375, 0.25, 0.8125, 0.25, 0.8125, 0.25, 0.84375, 0.25, 0.84375, 0.28125, 0.8125, 0.28125, 0.8125, 0.28125, 0.84375, 0.28125, 0.84375, 0.3125, 0.8125, 0.3125, 0.8125, 0.3125, 0.84375, 0.3125, 0.84375, 0.34375, 0.8125, 0.34375, 0.8125, 0.34375, 0.84375, 0.34375, 0.84375, 0.375, 0.8125, 0.375, 0.8125, 0.375, 0.84375, 0.375, 0.84375, 0.40625, 0.8125, 0.40625, 0.8125, 0.40625, 0.84375, 0.40625, 0.84375, 0.4375, 0.8125, 0.4375, 0.8125, 0.4375, 0.84375, 0.4375, 0.84375, 0.46875, 0.8125, 0.46875, 0.8125, 0.46875, 0.84375, 0.46875, 0.84375, 0.5, 0.8125, 0.5, 0.8125, 0.5, 0.84375, 0.5, 0.84375, 0.53125, 0.8125, 0.53125, 0.8125, 0.53125, 0.84375, 0.53125, 0.84375, 0.5625, 0.8125, 0.5625, 0.8125, 0.5625, 0.84375, 0.5625, 0.84375, 0.59375, 0.8125, 0.59375, 0.8125, 0.59375, 0.84375, 0.59375, 0.84375, 0.625, 0.8125, 0.625, 0.8125, 0.625, 0.84375, 0.625, 0.84375, 0.65625, 0.8125, 0.65625, 0.8125, 0.65625, 0.84375, 0.65625, 0.84375, 0.6875, 0.8125, 0.6875, 0.8125, 0.6875, 0.84375, 0.6875, 0.84375, 0.71875, 0.8125, 0.71875, 0.8125, 0.71875, 0.84375, 0.71875, 0.84375, 0.75, 0.8125, 0.75, 0.8125, 0.75, 0.84375, 0.75, 0.84375, 0.78125, 0.8125, 0.78125, 0.8125, 0.78125, 0.84375, 0.78125, 0.84375, 0.8125, 0.8125, 0.8125, 0.8125, 0.8125, 0.84375, 0.8125, 0.84375, 0.84375, 0.8125, 0.84375, 0.8125, 0.84375, 0.84375, 0.84375, 0.84375, 0.875, 0.8125, 0.875, 0.8125, 0.875, 0.84375, 0.875, 0.84375, 0.90625, 0.8125, 0.90625, 0.8125, 0.90625, 0.84375, 0.90625, 0.84375, 0.9375, 0.8125, 0.9375, 0.8125, 0.9375, 0.84375, 0.9375, 0.84375, 0.96875, 0.8125, 0.96875, 0.84375, 0.96875, 0.63412, 1, 0.8125, 0.96875, 0.875, 0.96875, 0.63412, 1, 0.84375, 0.96875, 0.84375, 0.9375, 0.875, 0.9375, 0.875, 0.96875, 0.84375, 0.96875, 0.84375, 0.90625, 0.875, 0.90625, 0.875, 0.9375, 0.84375, 0.9375, 0.84375, 0.875, 0.875, 0.875, 0.875, 0.90625, 0.84375, 0.90625, 0.84375, 0.84375, 0.875, 0.84375, 0.875, 0.875, 0.84375, 0.875, 0.84375, 0.8125, 0.875, 0.8125, 0.875, 0.84375, 0.84375, 0.84375, 0.84375, 0.78125, 0.875, 0.78125, 0.875, 0.8125, 0.84375, 0.8125, 0.84375, 0.75, 0.875, 0.75, 0.875, 0.78125, 0.84375, 0.78125, 0.84375, 0.71875, 0.875, 0.71875, 0.875, 0.75, 0.84375, 0.75, 0.84375, 0.6875, 0.875, 0.6875, 0.875, 0.71875, 0.84375, 0.71875, 0.84375, 0.65625, 0.875, 0.65625, 0.875, 0.6875, 0.84375, 0.6875, 0.84375, 0.625, 0.875, 0.625, 0.875, 0.65625, 0.84375, 0.65625, 0.84375, 0.59375, 0.875, 0.59375, 0.875, 0.625, 0.84375, 0.625, 0.84375, 0.5625, 0.875, 0.5625, 0.875, 0.59375, 0.84375, 0.59375, 0.84375, 0.53125, 0.875, 0.53125, 0.875, 0.5625, 0.84375, 0.5625, 0.84375, 0.5, 0.875, 0.5, 0.875, 0.53125, 0.84375, 0.53125, 0.84375, 0.46875, 0.875, 0.46875, 0.875, 0.5, 0.84375, 0.5, 0.84375, 0.4375, 0.875, 0.4375, 0.875, 0.46875, 0.84375, 0.46875, 0.84375, 0.40625, 0.875, 0.40625, 0.875, 0.4375, 0.84375, 0.4375, 0.84375, 0.375, 0.875, 0.375, 0.875, 0.40625, 0.84375, 0.40625, 0.84375, 0.34375, 0.875, 0.34375, 0.875, 0.375, 0.84375, 0.375, 0.84375, 0.3125, 0.875, 0.3125, 0.875, 0.34375, 0.84375, 0.34375, 0.84375, 0.28125, 0.875, 0.28125, 0.875, 0.3125, 0.84375, 0.3125, 0.84375, 0.25, 0.875, 0.25, 0.875, 0.28125, 0.84375, 0.28125, 0.84375, 0.21875, 0.875, 0.21875, 0.875, 0.25, 0.84375, 0.25, 0.84375, 0.1875, 0.875, 0.1875, 0.875, 0.21875, 0.84375, 0.21875, 0.84375, 0.15625, 0.875, 0.15625, 0.875, 0.1875, 0.84375, 0.1875, 0.84375, 0.125, 0.875, 0.125, 0.875, 0.15625, 0.84375, 0.15625, 0.84375, 0.09375, 0.875, 0.09375, 0.875, 0.125, 0.84375, 0.125, 0.84375, 0.0625, 0.875, 0.0625, 0.875, 0.09375, 0.84375, 0.09375, 0.84375, 0.03125, 0.875, 0.03125, 0.875, 0.0625, 0.84375, 0.0625, 1.3212, -0, 0.875, 0.03125, 0.84375, 0.03125, 1.3212, -0, 0.90625, 0.03125, 0.875, 0.03125, 0.875, 0.03125, 0.90625, 0.03125, 0.90625, 0.0625, 0.875, 0.0625, 0.875, 0.0625, 0.90625, 0.0625, 0.90625, 0.09375, 0.875, 0.09375, 0.875, 0.09375, 0.90625, 0.09375, 0.90625, 0.125, 0.875, 0.125, 0.875, 0.125, 0.90625, 0.125, 0.90625, 0.15625, 0.875, 0.15625, 0.875, 0.15625, 0.90625, 0.15625, 0.90625, 0.1875, 0.875, 0.1875, 0.875, 0.1875, 0.90625, 0.1875, 0.90625, 0.21875, 0.875, 0.21875, 0.875, 0.21875, 0.90625, 0.21875, 0.90625, 0.25, 0.875, 0.25, 0.875, 0.25, 0.90625, 0.25, 0.90625, 0.28125, 0.875, 0.28125, 0.875, 0.28125, 0.90625, 0.28125, 0.90625, 0.3125, 0.875, 0.3125, 0.875, 0.3125, 0.90625, 0.3125, 0.90625, 0.34375, 0.875, 0.34375, 0.875, 0.34375, 0.90625, 0.34375, 0.90625, 0.375, 0.875, 0.375, 0.875, 0.375, 0.90625, 0.375, 0.90625, 0.40625, 0.875, 0.40625, 0.875, 0.40625, 0.90625, 0.40625, 0.90625, 0.4375, 0.875, 0.4375, 0.875, 0.4375, 0.90625, 0.4375, 0.90625, 0.46875, 0.875, 0.46875, 0.875, 0.46875, 0.90625, 0.46875, 0.90625, 0.5, 0.875, 0.5, 0.875, 0.5, 0.90625, 0.5, 0.90625, 0.53125, 0.875, 0.53125, 0.875, 0.53125, 0.90625, 0.53125, 0.90625, 0.5625, 0.875, 0.5625, 0.875, 0.5625, 0.90625, 0.5625, 0.90625, 0.59375, 0.875, 0.59375, 0.875, 0.59375, 0.90625, 0.59375, 0.90625, 0.625, 0.875, 0.625, 0.875, 0.625, 0.90625, 0.625, 0.90625, 0.65625, 0.875, 0.65625, 0.875, 0.65625, 0.90625, 0.65625, 0.90625, 0.6875, 0.875, 0.6875, 0.875, 0.6875, 0.90625, 0.6875, 0.90625, 0.71875, 0.875, 0.71875, 0.875, 0.71875, 0.90625, 0.71875, 0.90625, 0.75, 0.875, 0.75, 0.875, 0.75, 0.90625, 0.75, 0.90625, 0.78125, 0.875, 0.78125, 0.875, 0.78125, 0.90625, 0.78125, 0.90625, 0.8125, 0.875, 0.8125, 0.875, 0.8125, 0.90625, 0.8125, 0.90625, 0.84375, 0.875, 0.84375, 0.875, 0.84375, 0.90625, 0.84375, 0.90625, 0.875, 0.875, 0.875, 0.875, 0.875, 0.90625, 0.875, 0.90625, 0.90625, 0.875, 0.90625, 0.875, 0.90625, 0.90625, 0.90625, 0.90625, 0.9375, 0.875, 0.9375, 0.875, 0.9375, 0.90625, 0.9375, 0.90625, 0.96875, 0.875, 0.96875, 0.90625, 0.96875, 0.63412, 1, 0.875, 0.96875, 0.9375, 0.96875, 0.63412, 1, 0.90625, 0.96875, 0.90625, 0.9375, 0.9375, 0.9375, 0.9375, 0.96875, 0.90625, 0.96875, 0.90625, 0.90625, 0.9375, 0.90625, 0.9375, 0.9375, 0.90625, 0.9375, 0.90625, 0.875, 0.9375, 0.875, 0.9375, 0.90625, 0.90625, 0.90625, 0.90625, 0.84375, 0.9375, 0.84375, 0.9375, 0.875, 0.90625, 0.875, 0.90625, 0.8125, 0.9375, 0.8125, 0.9375, 0.84375, 0.90625, 0.84375, 0.90625, 0.78125, 0.9375, 0.78125, 0.9375, 0.8125, 0.90625, 0.8125, 0.90625, 0.75, 0.9375, 0.75, 0.9375, 0.78125, 0.90625, 0.78125, 0.90625, 0.71875, 0.9375, 0.71875, 0.9375, 0.75, 0.90625, 0.75, 0.90625, 0.6875, 0.9375, 0.6875, 0.9375, 0.71875, 0.90625, 0.71875, 0.90625, 0.65625, 0.9375, 0.65625, 0.9375, 0.6875, 0.90625, 0.6875, 0.90625, 0.625, 0.9375, 0.625, 0.9375, 0.65625, 0.90625, 0.65625, 0.90625, 0.59375, 0.9375, 0.59375, 0.9375, 0.625, 0.90625, 0.625, 0.90625, 0.5625, 0.9375, 0.5625, 0.9375, 0.59375, 0.90625, 0.59375, 0.90625, 0.53125, 0.9375, 0.53125, 0.9375, 0.5625, 0.90625, 0.5625, 0.90625, 0.5, 0.9375, 0.5, 0.9375, 0.53125, 0.90625, 0.53125, 0.90625, 0.46875, 0.9375, 0.46875, 0.9375, 0.5, 0.90625, 0.5, 0.90625, 0.4375, 0.9375, 0.4375, 0.9375, 0.46875, 0.90625, 0.46875, 0.90625, 0.40625, 0.9375, 0.40625, 0.9375, 0.4375, 0.90625, 0.4375, 0.90625, 0.375, 0.9375, 0.375, 0.9375, 0.40625, 0.90625, 0.40625, 0.90625, 0.34375, 0.9375, 0.34375, 0.9375, 0.375, 0.90625, 0.375, 0.90625, 0.3125, 0.9375, 0.3125, 0.9375, 0.34375, 0.90625, 0.34375, 0.90625, 0.28125, 0.9375, 0.28125, 0.9375, 0.3125, 0.90625, 0.3125, 0.90625, 0.25, 0.9375, 0.25, 0.9375, 0.28125, 0.90625, 0.28125, 0.90625, 0.21875, 0.9375, 0.21875, 0.9375, 0.25, 0.90625, 0.25, 0.90625, 0.1875, 0.9375, 0.1875, 0.9375, 0.21875, 0.90625, 0.21875, 0.90625, 0.15625, 0.9375, 0.15625, 0.9375, 0.1875, 0.90625, 0.1875, 0.90625, 0.125, 0.9375, 0.125, 0.9375, 0.15625, 0.90625, 0.15625, 0.90625, 0.09375, 0.9375, 0.09375, 0.9375, 0.125, 0.90625, 0.125, 0.90625, 0.0625, 0.9375, 0.0625, 0.9375, 0.09375, 0.90625, 0.09375, 0.90625, 0.03125, 0.9375, 0.03125, 0.9375, 0.0625, 0.90625, 0.0625, 1.3212, -0, 0.9375, 0.03125, 0.90625, 0.03125, 1.3212, -0, 0.96875, 0.03125, 0.9375, 0.03125, 0.9375, 0.03125, 0.96875, 0.03125, 0.96875, 0.0625, 0.9375, 0.0625, 0.9375, 0.0625, 0.96875, 0.0625, 0.96875, 0.09375, 0.9375, 0.09375, 0.9375, 0.09375, 0.96875, 0.09375, 0.96875, 0.125, 0.9375, 0.125, 0.9375, 0.125, 0.96875, 0.125, 0.96875, 0.15625, 0.9375, 0.15625, 0.9375, 0.15625, 0.96875, 0.15625, 0.96875, 0.1875, 0.9375, 0.1875, 0.9375, 0.1875, 0.96875, 0.1875, 0.96875, 0.21875, 0.9375, 0.21875, 0.9375, 0.21875, 0.96875, 0.21875, 0.96875, 0.25, 0.9375, 0.25, 0.9375, 0.25, 0.96875, 0.25, 0.96875, 0.28125, 0.9375, 0.28125, 0.9375, 0.28125, 0.96875, 0.28125, 0.96875, 0.3125, 0.9375, 0.3125, 0.9375, 0.3125, 0.96875, 0.3125, 0.96875, 0.34375, 0.9375, 0.34375, 0.9375, 0.34375, 0.96875, 0.34375, 0.96875, 0.375, 0.9375, 0.375, 0.9375, 0.375, 0.96875, 0.375, 0.96875, 0.40625, 0.9375, 0.40625, 0.9375, 0.40625, 0.96875, 0.40625, 0.96875, 0.4375, 0.9375, 0.4375, 0.9375, 0.4375, 0.96875, 0.4375, 0.96875, 0.46875, 0.9375, 0.46875, 0.9375, 0.46875, 0.96875, 0.46875, 0.96875, 0.5, 0.9375, 0.5, 0.9375, 0.5, 0.96875, 0.5, 0.96875, 0.53125, 0.9375, 0.53125, 0.9375, 0.53125, 0.96875, 0.53125, 0.96875, 0.5625, 0.9375, 0.5625, 0.9375, 0.5625, 0.96875, 0.5625, 0.96875, 0.59375, 0.9375, 0.59375, 0.9375, 0.59375, 0.96875, 0.59375, 0.96875, 0.625, 0.9375, 0.625, 0.9375, 0.625, 0.96875, 0.625, 0.96875, 0.65625, 0.9375, 0.65625, 0.9375, 0.65625, 0.96875, 0.65625, 0.96875, 0.6875, 0.9375, 0.6875, 0.9375, 0.6875, 0.96875, 0.6875, 0.96875, 0.71875, 0.9375, 0.71875, 0.9375, 0.71875, 0.96875, 0.71875, 0.96875, 0.75, 0.9375, 0.75, 0.9375, 0.75, 0.96875, 0.75, 0.96875, 0.78125, 0.9375, 0.78125, 0.9375, 0.78125, 0.96875, 0.78125, 0.96875, 0.8125, 0.9375, 0.8125, 0.9375, 0.8125, 0.96875, 0.8125, 0.96875, 0.84375, 0.9375, 0.84375, 0.9375, 0.84375, 0.96875, 0.84375, 0.96875, 0.875, 0.9375, 0.875, 0.9375, 0.875, 0.96875, 0.875, 0.96875, 0.90625, 0.9375, 0.90625, 0.9375, 0.90625, 0.96875, 0.90625, 0.96875, 0.9375, 0.9375, 0.9375, 0.9375, 0.9375, 0.96875, 0.9375, 0.96875, 0.96875, 0.9375, 0.96875, 0.96875, 0.96875, 0.63412, 1, 0.9375, 0.96875, 1, 0.96875, 0.63412, 1, 0.96875, 0.96875, 0.96875, 0.9375, 1, 0.9375, 1, 0.96875, 0.96875, 0.96875, 0.96875, 0.90625, 1, 0.90625, 1, 0.9375, 0.96875, 0.9375, 0.96875, 0.875, 1, 0.875, 1, 0.90625, 0.96875, 0.90625, 0.96875, 0.84375, 1, 0.84375, 1, 0.875, 0.96875, 0.875, 0.96875, 0.8125, 1, 0.8125, 1, 0.84375, 0.96875, 0.84375, 0.96875, 0.78125, 1, 0.78125, 1, 0.8125, 0.96875, 0.8125, 0.96875, 0.75, 1, 0.75, 1, 0.78125, 0.96875, 0.78125, 0.96875, 0.71875, 1, 0.71875, 1, 0.75, 0.96875, 0.75, 0.96875, 0.6875, 1, 0.6875, 1, 0.71875, 0.96875, 0.71875, 0.96875, 0.65625, 1, 0.65625, 1, 0.6875, 0.96875, 0.6875, 0.96875, 0.625, 1, 0.625, 1, 0.65625, 0.96875, 0.65625, 0.96875, 0.59375, 1, 0.59375, 1, 0.625, 0.96875, 0.625, 0.96875, 0.5625, 1, 0.5625, 1, 0.59375, 0.96875, 0.59375, 0.96875, 0.53125, 1, 0.53125, 1, 0.5625, 0.96875, 0.5625, 0.96875, 0.5, 1, 0.5, 1, 0.53125, 0.96875, 0.53125, 0.96875, 0.46875, 1, 0.46875, 1, 0.5, 0.96875, 0.5, 0.96875, 0.4375, 1, 0.4375, 1, 0.46875, 0.96875, 0.46875, 0.96875, 0.40625, 1, 0.40625, 1, 0.4375, 0.96875, 0.4375, 0.96875, 0.375, 1, 0.375, 1, 0.40625, 0.96875, 0.40625, 0.96875, 0.34375, 1, 0.34375, 1, 0.375, 0.96875, 0.375, 0.96875, 0.3125, 1, 0.3125, 1, 0.34375, 0.96875, 0.34375, 0.96875, 0.28125, 1, 0.28125, 1, 0.3125, 0.96875, 0.3125, 0.96875, 0.25, 1, 0.25, 1, 0.28125, 0.96875, 0.28125, 0.96875, 0.21875, 1, 0.21875, 1, 0.25, 0.96875, 0.25, 0.96875, 0.1875, 1, 0.1875, 1, 0.21875, 0.96875, 0.21875, 0.96875, 0.15625, 1, 0.15625, 1, 0.1875, 0.96875, 0.1875, 0.96875, 0.125, 1, 0.125, 1, 0.15625, 0.96875, 0.15625, 0.96875, 0.09375, 1, 0.09375, 1, 0.125, 0.96875, 0.125, 0.96875, 0.0625, 1, 0.0625, 1, 0.09375, 0.96875, 0.09375, 0.96875, 0.03125, 1, 0.03125, 1, 0.0625, 0.96875, 0.0625, 1.3212, -0, 1, 0.03125, 0.96875, 0.03125, 0.3212, -0, 0.03125, 0.03125, 0, 0.03125, 0, 0.03125, 0.03125, 0.03125, 0.03125, 0.0625, 0, 0.0625, 0, 0.0625, 0.03125, 0.0625, 0.03125, 0.09375, 0, 0.09375, 0, 0.09375, 0.03125, 0.09375, 0.03125, 0.125, 0, 0.125, 0, 0.125, 0.03125, 0.125, 0.03125, 0.15625, 0, 0.15625, 0, 0.15625, 0.03125, 0.15625, 0.03125, 0.1875, 0, 0.1875, 0, 0.1875, 0.03125, 0.1875, 0.03125, 0.21875, 0, 0.21875, 0, 0.21875, 0.03125, 0.21875, 0.03125, 0.25, 0, 0.25, 0, 0.25, 0.03125, 0.25, 0.03125, 0.28125, 0, 0.28125, 0, 0.28125, 0.03125, 0.28125, 0.03125, 0.3125, 0, 0.3125, 0, 0.3125, 0.03125, 0.3125, 0.03125, 0.34375, 0, 0.34375, 0, 0.34375, 0.03125, 0.34375, 0.03125, 0.375, 0, 0.375, 0, 0.375, 0.03125, 0.375, 0.03125, 0.40625, 0, 0.40625, 0, 0.40625, 0.03125, 0.40625, 0.03125, 0.4375, 0, 0.4375, 0, 0.4375, 0.03125, 0.4375, 0.03125, 0.46875, 0, 0.46875, 0, 0.46875, 0.03125, 0.46875, 0.03125, 0.5, 0, 0.5, 0, 0.5, 0.03125, 0.5, 0.03125, 0.53125, 0, 0.53125, 0, 0.53125, 0.03125, 0.53125, 0.03125, 0.5625, 0, 0.5625, 0, 0.5625, 0.03125, 0.5625, 0.03125, 0.59375, 0, 0.59375, 0, 0.59375, 0.03125, 0.59375, 0.03125, 0.625, 0, 0.625, 0, 0.625, 0.03125, 0.625, 0.03125, 0.65625, 0, 0.65625, 0, 0.65625, 0.03125, 0.65625, 0.03125, 0.6875, 0, 0.6875, 0, 0.6875, 0.03125, 0.6875, 0.03125, 0.71875, 0, 0.71875, 0, 0.71875, 0.03125, 0.71875, 0.03125, 0.75, 0, 0.75, 0, 0.75, 0.03125, 0.75, 0.03125, 0.78125, 0, 0.78125, 0, 0.78125, 0.03125, 0.78125, 0.03125, 0.8125, 0, 0.8125, 0, 0.8125, 0.03125, 0.8125, 0.03125, 0.84375, 0, 0.84375, 0, 0.84375, 0.03125, 0.84375, 0.03125, 0.875, 0, 0.875, 1, 0.875, 1.03125, 0.875, 1.03125, 0.90625, 1, 0.90625, 1, 0.90625, 1.03125, 0.90625, 1.03125, 0.9375, 1, 0.9375, 1, 0.9375, 1.03125, 0.9375, 1.03125, 0.96875, 1, 0.96875, 1.03125, 0.96875, 0.63412, 1, 1, 0.96875, 1.0625, 0.96875, 0.63412, 1, 1.03125, 0.96875, 0.03125, 0.9375, 0.0625, 0.9375, 0.0625, 0.96875, 0.03125, 0.96875, 0.03125, 0.90625, 0.0625, 0.90625, 0.0625, 0.9375, 0.03125, 0.9375, 0.03125, 0.875, 0.0625, 0.875, 0.0625, 0.90625, 0.03125, 0.90625, 0.03125, 0.84375, 0.0625, 0.84375, 0.0625, 0.875, 0.03125, 0.875, 0.03125, 0.8125, 0.0625, 0.8125, 0.0625, 0.84375, 0.03125, 0.84375, 0.03125, 0.78125, 0.0625, 0.78125, 0.0625, 0.8125, 0.03125, 0.8125, 0.03125, 0.75, 0.0625, 0.75, 0.0625, 0.78125, 0.03125, 0.78125, 0.03125, 0.71875, 0.0625, 0.71875, 0.0625, 0.75, 0.03125, 0.75, 0.03125, 0.6875, 0.0625, 0.6875, 0.0625, 0.71875, 0.03125, 0.71875, 0.03125, 0.65625, 0.0625, 0.65625, 0.0625, 0.6875, 0.03125, 0.6875, 0.03125, 0.625, 0.0625, 0.625, 0.0625, 0.65625, 0.03125, 0.65625, 0.03125, 0.59375, 0.0625, 0.59375, 0.0625, 0.625, 0.03125, 0.625, 0.03125, 0.5625, 0.0625, 0.5625, 0.0625, 0.59375, 0.03125, 0.59375, 0.03125, 0.53125, 0.0625, 0.53125, 0.0625, 0.5625, 0.03125, 0.5625, 0.03125, 0.5, 0.0625, 0.5, 0.0625, 0.53125, 0.03125, 0.53125, 0.03125, 0.46875, 0.0625, 0.46875, 0.0625, 0.5, 0.03125, 0.5, 0.03125, 0.4375, 0.0625, 0.4375, 0.0625, 0.46875, 0.03125, 0.46875, 0.03125, 0.40625, 0.0625, 0.40625, 0.0625, 0.4375, 0.03125, 0.4375, 0.03125, 0.375, 0.0625, 0.375, 0.0625, 0.40625, 0.03125, 0.40625, 0.03125, 0.34375, 0.0625, 0.34375, 0.0625, 0.375, 0.03125, 0.375, 0.03125, 0.3125, 0.0625, 0.3125, 0.0625, 0.34375, 0.03125, 0.34375, 0.03125, 0.28125, 0.0625, 0.28125, 0.0625, 0.3125, 0.03125, 0.3125, 0.03125, 0.25, 0.0625, 0.25, 0.0625, 0.28125, 0.03125, 0.28125, 0.03125, 0.21875, 0.0625, 0.21875, 0.0625, 0.25, 0.03125, 0.25, 0.03125, 0.1875, 0.0625, 0.1875, 0.0625, 0.21875, 0.03125, 0.21875, 0.03125, 0.15625, 0.0625, 0.15625, 0.0625, 0.1875, 0.03125, 0.1875, 0.03125, 0.125, 0.0625, 0.125, 0.0625, 0.15625, 0.03125, 0.15625, 0.03125, 0.09375, 0.0625, 0.09375, 0.0625, 0.125, 0.03125, 0.125, 0.03125, 0.0625, 0.0625, 0.0625, 0.0625, 0.09375, 0.03125, 0.09375, 0.03125, 0.03125, 0.0625, 0.03125, 0.0625, 0.0625, 0.03125, 0.0625, 0.3212, -0, 0.0625, 0.03125, 0.03125, 0.03125, 0.3212, -0, 0.09375, 0.03125, 0.0625, 0.03125, 0.0625, 0.03125, 0.09375, 0.03125, 0.09375, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.09375, 0.0625, 0.09375, 0.09375, 0.0625, 0.09375, 0.0625, 0.09375, 0.09375, 0.09375, 0.09375, 0.125, 0.0625, 0.125, 0.0625, 0.125, 0.09375, 0.125, 0.09375, 0.15625, 0.0625, 0.15625, 0.0625, 0.15625, 0.09375, 0.15625, 0.09375, 0.1875, 0.0625, 0.1875, 0.0625, 0.1875, 0.09375, 0.1875, 0.09375, 0.21875, 0.0625, 0.21875, 0.0625, 0.21875, 0.09375, 0.21875, 0.09375, 0.25, 0.0625, 0.25, 0.0625, 0.25, 0.09375, 0.25, 0.09375, 0.28125, 0.0625, 0.28125, 0.0625, 0.28125, 0.09375, 0.28125, 0.09375, 0.3125, 0.0625, 0.3125, 0.0625, 0.3125, 0.09375, 0.3125, 0.09375, 0.34375, 0.0625, 0.34375, 0.0625, 0.34375, 0.09375, 0.34375, 0.09375, 0.375, 0.0625, 0.375, 0.0625, 0.375, 0.09375, 0.375, 0.09375, 0.40625, 0.0625, 0.40625, 0.0625, 0.40625, 0.09375, 0.40625, 0.09375, 0.4375, 0.0625, 0.4375, 0.0625, 0.4375, 0.09375, 0.4375, 0.09375, 0.46875, 0.0625, 0.46875, 0.0625, 0.46875, 0.09375, 0.46875, 0.09375, 0.5, 0.0625, 0.5, 0.0625, 0.5, 0.09375, 0.5, 0.09375, 0.53125, 0.0625, 0.53125, 0.0625, 0.53125, 0.09375, 0.53125, 0.09375, 0.5625, 0.0625, 0.5625, 0.0625, 0.5625, 0.09375, 0.5625, 0.09375, 0.59375, 0.0625, 0.59375, 0.0625, 0.59375, 0.09375, 0.59375, 0.09375, 0.625, 0.0625, 0.625, 0.0625, 0.625, 0.09375, 0.625, 0.09375, 0.65625, 0.0625, 0.65625, 0.0625, 0.65625, 0.09375, 0.65625, 0.09375, 0.6875, 0.0625, 0.6875, 0.0625, 0.6875, 0.09375, 0.6875, 0.09375, 0.71875, 0.0625, 0.71875, 0.0625, 0.71875, 0.09375, 0.71875, 0.09375, 0.75, 0.0625, 0.75, 0.0625, 0.75, 0.09375, 0.75, 0.09375, 0.78125, 0.0625, 0.78125, 0.0625, 0.78125, 0.09375, 0.78125, 0.09375, 0.8125, 0.0625, 0.8125, 0.0625, 0.8125, 0.09375, 0.8125, 0.09375, 0.84375, 0.0625, 0.84375, 0.0625, 0.84375, 0.09375, 0.84375, 0.09375, 0.875, 0.0625, 0.875, 0.0625, 0.875, 0.09375, 0.875, 0.09375, 0.90625, 0.0625, 0.90625, 0.0625, 0.90625, 0.09375, 0.90625, 0.09375, 0.9375, 0.0625, 0.9375, 0.0625, 0.9375, 0.09375, 0.9375, 0.09375, 0.96875, 0.0625, 0.96875, 1.09375, 0.96875, 0.63412, 1, 1.0625, 0.96875, 1.125, 0.96875, 0.63412, 1, 1.09375, 0.96875, 0.09375, 0.9375, 0.125, 0.9375, 0.125, 0.96875, 0.09375, 0.96875, 0.09375, 0.90625, 0.125, 0.90625, 0.125, 0.9375, 0.09375, 0.9375, 0.09375, 0.875, 0.125, 0.875, 0.125, 0.90625, 0.09375, 0.90625, 0.09375, 0.84375, 0.125, 0.84375, 0.125, 0.875, 0.09375, 0.875, 0.09375, 0.8125, 0.125, 0.8125, 0.125, 0.84375, 0.09375, 0.84375, 0.09375, 0.78125, 0.125, 0.78125, 0.125, 0.8125, 0.09375, 0.8125, 0.09375, 0.75, 0.125, 0.75, 0.125, 0.78125, 0.09375, 0.78125, 0.09375, 0.71875, 0.125, 0.71875, 0.125, 0.75, 0.09375, 0.75, 0.09375, 0.6875, 0.125, 0.6875, 0.125, 0.71875, 0.09375, 0.71875, 0.09375, 0.65625, 0.125, 0.65625, 0.125, 0.6875, 0.09375, 0.6875, 0.09375, 0.625, 0.125, 0.625, 0.125, 0.65625, 0.09375, 0.65625, 0.09375, 0.59375, 0.125, 0.59375, 0.125, 0.625, 0.09375, 0.625, 0.09375, 0.5625, 0.125, 0.5625, 0.125, 0.59375, 0.09375, 0.59375, 0.09375, 0.53125, 0.125, 0.53125, 0.125, 0.5625, 0.09375, 0.5625, 0.09375, 0.5, 0.125, 0.5, 0.125, 0.53125, 0.09375, 0.53125, 0.09375, 0.46875, 0.125, 0.46875, 0.125, 0.5, 0.09375, 0.5, 0.09375, 0.4375, 0.125, 0.4375, 0.125, 0.46875, 0.09375, 0.46875, 0.09375, 0.40625, 0.125, 0.40625, 0.125, 0.4375, 0.09375, 0.4375, 0.09375, 0.375, 0.125, 0.375, 0.125, 0.40625, 0.09375, 0.40625, 0.09375, 0.34375, 0.125, 0.34375, 0.125, 0.375, 0.09375, 0.375, 0.09375, 0.3125, 0.125, 0.3125, 0.125, 0.34375, 0.09375, 0.34375, 0.09375, 0.28125, 0.125, 0.28125, 0.125, 0.3125, 0.09375, 0.3125, 0.09375, 0.25, 0.125, 0.25, 0.125, 0.28125, 0.09375, 0.28125, 0.09375, 0.21875, 0.125, 0.21875, 0.125, 0.25, 0.09375, 0.25, 0.09375, 0.1875, 0.125, 0.1875, 0.125, 0.21875, 0.09375, 0.21875, 0.09375, 0.15625, 0.125, 0.15625, 0.125, 0.1875, 0.09375, 0.1875, 0.09375, 0.125, 0.125, 0.125, 0.125, 0.15625, 0.09375, 0.15625, 0.09375, 0.09375, 0.125, 0.09375, 0.125, 0.125, 0.09375, 0.125, 0.09375, 0.0625, 0.125, 0.0625, 0.125, 0.09375, 0.09375, 0.09375, 0.09375, 0.03125, 0.125, 0.03125, 0.125, 0.0625, 0.09375, 0.0625, 0.3212, -0, 0.125, 0.03125, 0.09375, 0.03125, 0.3212, -0, 0.15625, 0.03125, 0.125, 0.03125, 0.125, 0.03125, 0.15625, 0.03125, 0.15625, 0.0625, 0.125, 0.0625, 0.125, 0.0625, 0.15625, 0.0625, 0.15625, 0.09375, 0.125, 0.09375, 0.125, 0.09375, 0.15625, 0.09375, 0.15625, 0.125, 0.125, 0.125, 0.125, 0.125, 0.15625, 0.125, 0.15625, 0.15625, 0.125, 0.15625, 0.125, 0.15625, 0.15625, 0.15625, 0.15625, 0.1875, 0.125, 0.1875, 0.125, 0.1875, 0.15625, 0.1875, 0.15625, 0.21875, 0.125, 0.21875, 0.125, 0.21875, 0.15625, 0.21875, 0.15625, 0.25, 0.125, 0.25, 0.125, 0.25, 0.15625, 0.25, 0.15625, 0.28125, 0.125, 0.28125, 0.125, 0.28125, 0.15625, 0.28125, 0.15625, 0.3125, 0.125, 0.3125, 0.125, 0.3125, 0.15625, 0.3125, 0.15625, 0.34375, 0.125, 0.34375, 0.125, 0.34375, 0.15625, 0.34375, 0.15625, 0.375, 0.125, 0.375, 0.125, 0.375, 0.15625, 0.375, 0.15625, 0.40625, 0.125, 0.40625, 0.125, 0.40625, 0.15625, 0.40625, 0.15625, 0.4375, 0.125, 0.4375, 0.125, 0.4375, 0.15625, 0.4375, 0.15625, 0.46875, 0.125, 0.46875, 0.125, 0.46875, 0.15625, 0.46875, 0.15625, 0.5, 0.125, 0.5, 0.125, 0.5, 0.15625, 0.5, 0.15625, 0.53125, 0.125, 0.53125, 0.125, 0.53125, 0.15625, 0.53125, 0.15625, 0.5625, 0.125, 0.5625, 0.125, 0.5625, 0.15625, 0.5625, 0.15625, 0.59375, 0.125, 0.59375, 0.125, 0.59375, 0.15625, 0.59375, 0.15625, 0.625, 0.125, 0.625, 0.125, 0.625, 0.15625, 0.625, 0.15625, 0.65625, 0.125, 0.65625, 0.125, 0.65625, 0.15625, 0.65625, 0.15625, 0.6875, 0.125, 0.6875, 0.125, 0.6875, 0.15625, 0.6875, 0.15625, 0.71875, 0.125, 0.71875, 0.125, 0.71875, 0.15625, 0.71875, 0.15625, 0.75, 0.125, 0.75, 0.125, 0.75, 0.15625, 0.75, 0.15625, 0.78125, 0.125, 0.78125, 0.125, 0.78125, 0.15625, 0.78125, 0.15625, 0.8125, 0.125, 0.8125, 0.125, 0.8125, 0.15625, 0.8125, 0.15625, 0.84375, 0.125, 0.84375, 0.125, 0.84375, 0.15625, 0.84375, 0.15625, 0.875, 0.125, 0.875, 0.125, 0.875, 0.15625, 0.875, 0.15625, 0.90625, 0.125, 0.90625, 0.125, 0.90625, 0.15625, 0.90625, 0.15625, 0.9375, 0.125, 0.9375, 0.125, 0.9375, 0.15625, 0.9375, 0.15625, 0.96875, 0.125, 0.96875, 0.15625, 0.96875, 0.63412, 1, 1.125, 0.96875, 0.1875, 0.96875, 0.63412, 1, 0.15625, 0.96875, 0.15625, 0.9375, 0.1875, 0.9375, 0.1875, 0.96875, 0.15625, 0.96875, 0.15625, 0.90625, 0.1875, 0.90625, 0.1875, 0.9375, 0.15625, 0.9375, 0.15625, 0.875, 0.1875, 0.875, 0.1875, 0.90625, 0.15625, 0.90625, 0.15625, 0.84375, 0.1875, 0.84375, 0.1875, 0.875, 0.15625, 0.875, 0.15625, 0.8125, 0.1875, 0.8125, 0.1875, 0.84375, 0.15625, 0.84375, 0.15625, 0.78125, 0.1875, 0.78125, 0.1875, 0.8125, 0.15625, 0.8125, 0.15625, 0.75, 0.1875, 0.75, 0.1875, 0.78125, 0.15625, 0.78125, 0.15625, 0.71875, 0.1875, 0.71875, 0.1875, 0.75, 0.15625, 0.75, 0.15625, 0.6875, 0.1875, 0.6875, 0.1875, 0.71875, 0.15625, 0.71875, 0.15625, 0.65625, 0.1875, 0.65625, 0.1875, 0.6875, 0.15625, 0.6875, 0.15625, 0.625, 0.1875, 0.625, 0.1875, 0.65625, 0.15625, 0.65625, 0.15625, 0.59375, 0.1875, 0.59375, 0.1875, 0.625, 0.15625, 0.625, 0.15625, 0.5625, 0.1875, 0.5625, 0.1875, 0.59375, 0.15625, 0.59375, 0.15625, 0.53125, 0.1875, 0.53125, 0.1875, 0.5625, 0.15625, 0.5625, 0.15625, 0.5, 0.1875, 0.5, 0.1875, 0.53125, 0.15625, 0.53125, 0.15625, 0.46875, 0.1875, 0.46875, 0.1875, 0.5, 0.15625, 0.5, 0.15625, 0.4375, 0.1875, 0.4375, 0.1875, 0.46875, 0.15625, 0.46875, 0.15625, 0.40625, 0.1875, 0.40625, 0.1875, 0.4375, 0.15625, 0.4375, 0.15625, 0.375, 0.1875, 0.375, 0.1875, 0.40625, 0.15625, 0.40625, 0.15625, 0.34375, 0.1875, 0.34375, 0.1875, 0.375, 0.15625, 0.375, 0.15625, 0.3125, 0.1875, 0.3125, 0.1875, 0.34375, 0.15625, 0.34375, 0.15625, 0.28125, 0.1875, 0.28125, 0.1875, 0.3125, 0.15625, 0.3125, 0.15625, 0.25, 0.1875, 0.25, 0.1875, 0.28125, 0.15625, 0.28125, 0.15625, 0.21875, 0.1875, 0.21875, 0.1875, 0.25, 0.15625, 0.25, 0.15625, 0.1875, 0.1875, 0.1875, 0.1875, 0.21875, 0.15625, 0.21875, 0.15625, 0.15625, 0.1875, 0.15625, 0.1875, 0.1875, 0.15625, 0.1875, 0.15625, 0.125, 0.1875, 0.125, 0.1875, 0.15625, 0.15625, 0.15625, 0.15625, 0.09375, 0.1875, 0.09375, 0.1875, 0.125, 0.15625, 0.125, 0.15625, 0.0625, 0.1875, 0.0625, 0.1875, 0.09375, 0.15625, 0.09375, 0.15625, 0.03125, 0.1875, 0.03125, 0.1875, 0.0625, 0.15625, 0.0625, 0.3212, -0, 0.1875, 0.03125, 0.15625, 0.03125, 0.3212, -0, 0.21875, 0.03125, 0.1875, 0.03125, 0.1875, 0.03125, 0.21875, 0.03125, 0.21875, 0.0625, 0.1875, 0.0625, 0.1875, 0.0625, 0.21875, 0.0625, 0.21875, 0.09375, 0.1875, 0.09375, 0.1875, 0.09375, 0.21875, 0.09375, 0.21875, 0.125, 0.1875, 0.125, 0.1875, 0.125, 0.21875, 0.125, 0.21875, 0.15625, 0.1875, 0.15625, 0.1875, 0.15625, 0.21875, 0.15625, 0.21875, 0.1875, 0.1875, 0.1875, 0.1875, 0.1875, 0.21875, 0.1875, 0.21875, 0.21875, 0.1875, 0.21875, 0.1875, 0.21875, 0.21875, 0.21875, 0.21875, 0.25, 0.1875, 0.25, 0.1875, 0.25, 0.21875, 0.25, 0.21875, 0.28125, 0.1875, 0.28125, 0.1875, 0.28125, 0.21875, 0.28125, 0.21875, 0.3125, 0.1875, 0.3125, 0.1875, 0.3125, 0.21875, 0.3125, 0.21875, 0.34375, 0.1875, 0.34375, 0.1875, 0.34375, 0.21875, 0.34375, 0.21875, 0.375, 0.1875, 0.375, 0.1875, 0.375, 0.21875, 0.375, 0.21875, 0.40625, 0.1875, 0.40625, 0.1875, 0.40625, 0.21875, 0.40625, 0.21875, 0.4375, 0.1875, 0.4375, 0.1875, 0.4375, 0.21875, 0.4375, 0.21875, 0.46875, 0.1875, 0.46875, 0.1875, 0.46875, 0.21875, 0.46875, 0.21875, 0.5, 0.1875, 0.5, 0.1875, 0.5, 0.21875, 0.5, 0.21875, 0.53125, 0.1875, 0.53125, 0.1875, 0.53125, 0.21875, 0.53125, 0.21875, 0.5625, 0.1875, 0.5625, 0.1875, 0.5625, 0.21875, 0.5625, 0.21875, 0.59375, 0.1875, 0.59375, 0.1875, 0.59375, 0.21875, 0.59375, 0.21875, 0.625, 0.1875, 0.625, 0.1875, 0.625, 0.21875, 0.625, 0.21875, 0.65625, 0.1875, 0.65625, 0.1875, 0.65625, 0.21875, 0.65625, 0.21875, 0.6875, 0.1875, 0.6875, 0.1875, 0.6875, 0.21875, 0.6875, 0.21875, 0.71875, 0.1875, 0.71875, 0.1875, 0.71875, 0.21875, 0.71875, 0.21875, 0.75, 0.1875, 0.75, 0.1875, 0.75, 0.21875, 0.75, 0.21875, 0.78125, 0.1875, 0.78125, 0.1875, 0.78125, 0.21875, 0.78125, 0.21875, 0.8125, 0.1875, 0.8125, 0.1875, 0.8125, 0.21875, 0.8125, 0.21875, 0.84375, 0.1875, 0.84375, 0.1875, 0.84375, 0.21875, 0.84375, 0.21875, 0.875, 0.1875, 0.875, 0.1875, 0.875, 0.21875, 0.875, 0.21875, 0.90625, 0.1875, 0.90625, 0.1875, 0.90625, 0.21875, 0.90625, 0.21875, 0.9375, 0.1875, 0.9375, 0.1875, 0.9375, 0.21875, 0.9375, 0.21875, 0.96875, 0.1875, 0.96875, 0.21875, 0.96875, 0.63412, 1, 0.1875, 0.96875, 0.25, 0.96875, 0.63412, 1, 0.21875, 0.96875, 0.21875, 0.9375, 0.25, 0.9375, 0.25, 0.96875, 0.21875, 0.96875, 0.21875, 0.90625, 0.25, 0.90625, 0.25, 0.9375, 0.21875, 0.9375, 0.21875, 0.875, 0.25, 0.875, 0.25, 0.90625, 0.21875, 0.90625, 0.21875, 0.84375, 0.25, 0.84375, 0.25, 0.875, 0.21875, 0.875, 0.21875, 0.8125, 0.25, 0.8125, 0.25, 0.84375, 0.21875, 0.84375, 0.21875, 0.78125, 0.25, 0.78125, 0.25, 0.8125, 0.21875, 0.8125, 0.21875, 0.75, 0.25, 0.75, 0.25, 0.78125, 0.21875, 0.78125, 0.21875, 0.71875, 0.25, 0.71875, 0.25, 0.75, 0.21875, 0.75, 0.21875, 0.6875, 0.25, 0.6875, 0.25, 0.71875, 0.21875, 0.71875, 0.21875, 0.65625, 0.25, 0.65625, 0.25, 0.6875, 0.21875, 0.6875, 0.21875, 0.625, 0.25, 0.625, 0.25, 0.65625, 0.21875, 0.65625, 0.21875, 0.59375, 0.25, 0.59375, 0.25, 0.625, 0.21875, 0.625, 0.21875, 0.5625, 0.25, 0.5625, 0.25, 0.59375, 0.21875, 0.59375, 0.21875, 0.53125, 0.25, 0.53125, 0.25, 0.5625, 0.21875, 0.5625, 0.21875, 0.5, 0.25, 0.5, 0.25, 0.53125, 0.21875, 0.53125, 0.21875, 0.46875, 0.25, 0.46875, 0.25, 0.5, 0.21875, 0.5, 0.21875, 0.4375, 0.25, 0.4375, 0.25, 0.46875, 0.21875, 0.46875, 0.21875, 0.40625, 0.25, 0.40625, 0.25, 0.4375, 0.21875, 0.4375, 0.21875, 0.375, 0.25, 0.375, 0.25, 0.40625, 0.21875, 0.40625, 0.21875, 0.34375, 0.25, 0.34375, 0.25, 0.375, 0.21875, 0.375, 0.21875, 0.3125, 0.25, 0.3125, 0.25, 0.34375, 0.21875, 0.34375, 0.21875, 0.28125, 0.25, 0.28125, 0.25, 0.3125, 0.21875, 0.3125, 0.21875, 0.25, 0.25, 0.25, 0.25, 0.28125, 0.21875, 0.28125, 0.21875, 0.21875, 0.25, 0.21875, 0.25, 0.25, 0.21875, 0.25, 0.21875, 0.1875, 0.25, 0.1875, 0.25, 0.21875, 0.21875, 0.21875, 0.21875, 0.15625, 0.25, 0.15625, 0.25, 0.1875, 0.21875, 0.1875, 0.21875, 0.125, 0.25, 0.125, 0.25, 0.15625, 0.21875, 0.15625, 0.21875, 0.09375, 0.25, 0.09375, 0.25, 0.125, 0.21875, 0.125, 0.21875, 0.0625, 0.25, 0.0625, 0.25, 0.09375, 0.21875, 0.09375, 0.21875, 0.03125, 0.25, 0.03125, 0.25, 0.0625, 0.21875, 0.0625, 0.3212, -0, 0.25, 0.03125, 0.21875, 0.03125, 0.3212, -0, 0.28125, 0.03125, 0.25, 0.03125, 0.25, 0.03125, 0.28125, 0.03125, 0.28125, 0.0625, 0.25, 0.0625, 0.25, 0.0625, 0.28125, 0.0625, 0.28125, 0.09375, 0.25, 0.09375, 0.25, 0.09375, 0.28125, 0.09375, 0.28125, 0.125, 0.25, 0.125, 0.25, 0.125, 0.28125, 0.125, 0.28125, 0.15625, 0.25, 0.15625, 0.25, 0.15625, 0.28125, 0.15625, 0.28125, 0.1875, 0.25, 0.1875, 0.25, 0.1875, 0.28125, 0.1875, 0.28125, 0.21875, 0.25, 0.21875, 0.25, 0.21875, 0.28125, 0.21875, 0.28125, 0.25, 0.25, 0.25, 0.25, 0.25, 0.28125, 0.25, 0.28125, 0.28125, 0.25, 0.28125, 0.25, 0.28125, 0.28125, 0.28125, 0.28125, 0.3125, 0.25, 0.3125, 0.25, 0.3125, 0.28125, 0.3125, 0.28125, 0.34375, 0.25, 0.34375, 0.25, 0.34375, 0.28125, 0.34375, 0.28125, 0.375, 0.25, 0.375, 0.25, 0.375, 0.28125, 0.375, 0.28125, 0.40625, 0.25, 0.40625, 0.25, 0.40625, 0.28125, 0.40625, 0.28125, 0.4375, 0.25, 0.4375, 0.25, 0.4375, 0.28125, 0.4375, 0.28125, 0.46875, 0.25, 0.46875, 0.25, 0.46875, 0.28125, 0.46875, 0.28125, 0.5, 0.25, 0.5, 0.25, 0.5, 0.28125, 0.5, 0.28125, 0.53125, 0.25, 0.53125, 0.25, 0.53125, 0.28125, 0.53125, 0.28125, 0.5625, 0.25, 0.5625, 0.25, 0.5625, 0.28125, 0.5625, 0.28125, 0.59375, 0.25, 0.59375, 0.25, 0.59375, 0.28125, 0.59375, 0.28125, 0.625, 0.25, 0.625, 0.25, 0.625, 0.28125, 0.625, 0.28125, 0.65625, 0.25, 0.65625, 0.25, 0.65625, 0.28125, 0.65625, 0.28125, 0.6875, 0.25, 0.6875, 0.25, 0.6875, 0.28125, 0.6875, 0.28125, 0.71875, 0.25, 0.71875, 0.25, 0.71875, 0.28125, 0.71875, 0.28125, 0.75, 0.25, 0.75, 0.25, 0.75, 0.28125, 0.75, 0.28125, 0.78125, 0.25, 0.78125, 0.25, 0.78125, 0.28125, 0.78125, 0.28125, 0.8125, 0.25, 0.8125, 0.25, 0.8125, 0.28125, 0.8125, 0.28125, 0.84375, 0.25, 0.84375, 0.25, 0.84375, 0.28125, 0.84375, 0.28125, 0.875, 0.25, 0.875, 0.25, 0.875, 0.28125, 0.875, 0.28125, 0.90625, 0.25, 0.90625, 0.25, 0.90625, 0.28125, 0.90625, 0.28125, 0.9375, 0.25, 0.9375, 0.25, 0.9375, 0.28125, 0.9375, 0.28125, 0.96875, 0.25, 0.96875, 0.28125, 0.96875, 0.63412, 1, 0.25, 0.96875, 0.3125, 0.96875, 0.63412, 1, 0.28125, 0.96875, 0.28125, 0.9375, 0.3125, 0.9375, 0.3125, 0.96875, 0.28125, 0.96875, 0.28125, 0.90625, 0.3125, 0.90625, 0.3125, 0.9375, 0.28125, 0.9375, 0.28125, 0.875, 0.3125, 0.875, 0.3125, 0.90625, 0.28125, 0.90625, 0.28125, 0.84375, 0.3125, 0.84375, 0.3125, 0.875, 0.28125, 0.875, 0.28125, 0.8125, 0.3125, 0.8125, 0.3125, 0.84375, 0.28125, 0.84375, 0.28125, 0.78125, 0.3125, 0.78125, 0.3125, 0.8125, 0.28125, 0.8125, 0.28125, 0.75, 0.3125, 0.75, 0.3125, 0.78125, 0.28125, 0.78125, 0.28125, 0.71875, 0.3125, 0.71875, 0.3125, 0.75, 0.28125, 0.75, 0.28125, 0.6875, 0.3125, 0.6875, 0.3125, 0.71875, 0.28125, 0.71875, 0.28125, 0.65625, 0.3125, 0.65625, 0.3125, 0.6875, 0.28125, 0.6875, 0.28125, 0.625, 0.3125, 0.625, 0.3125, 0.65625, 0.28125, 0.65625, 0.28125, 0.59375, 0.3125, 0.59375, 0.3125, 0.625, 0.28125, 0.625, 0.28125, 0.5625, 0.3125, 0.5625, 0.3125, 0.59375, 0.28125, 0.59375, 0.28125, 0.53125, 0.3125, 0.53125, 0.3125, 0.5625, 0.28125, 0.5625, 0.28125, 0.5, 0.3125, 0.5, 0.3125, 0.53125, 0.28125, 0.53125, 0.28125, 0.46875, 0.3125, 0.46875, 0.3125, 0.5, 0.28125, 0.5, 0.28125, 0.4375, 0.3125, 0.4375, 0.3125, 0.46875, 0.28125, 0.46875, 0.28125, 0.40625, 0.3125, 0.40625, 0.3125, 0.4375, 0.28125, 0.4375, 0.28125, 0.375, 0.3125, 0.375, 0.3125, 0.40625, 0.28125, 0.40625, 0.28125, 0.34375, 0.3125, 0.34375, 0.3125, 0.375, 0.28125, 0.375, 0.28125, 0.3125, 0.3125, 0.3125, 0.3125, 0.34375, 0.28125, 0.34375, 0.28125, 0.28125, 0.3125, 0.28125, 0.3125, 0.3125, 0.28125, 0.3125, 0.28125, 0.25, 0.3125, 0.25, 0.3125, 0.28125, 0.28125, 0.28125, 0.28125, 0.21875, 0.3125, 0.21875, 0.3125, 0.25, 0.28125, 0.25, 0.28125, 0.1875, 0.3125, 0.1875, 0.3125, 0.21875, 0.28125, 0.21875, 0.28125, 0.15625, 0.3125, 0.15625, 0.3125, 0.1875, 0.28125, 0.1875, 0.28125, 0.125, 0.3125, 0.125, 0.3125, 0.15625, 0.28125, 0.15625, 0.28125, 0.09375, 0.3125, 0.09375, 0.3125, 0.125, 0.28125, 0.125, 0.28125, 0.0625, 0.3125, 0.0625, 0.3125, 0.09375, 0.28125, 0.09375, 0.28125, 0.03125, 0.3125, 0.03125, 0.3125, 0.0625, 0.28125, 0.0625, 0.3212, -0, 0.3125, 0.03125, 0.28125, 0.03125, 0.3212, -0, 0.34375, 0.03125, 0.3125, 0.03125, 0.3125, 0.03125, 0.34375, 0.03125, 0.34375, 0.0625, 0.3125, 0.0625, 0.3125, 0.0625, 0.34375, 0.0625, 0.34375, 0.09375, 0.3125, 0.09375, 0.3125, 0.09375, 0.34375, 0.09375, 0.34375, 0.125, 0.3125, 0.125, 0.3125, 0.125, 0.34375, 0.125, 0.34375, 0.15625, 0.3125, 0.15625, 0.3125, 0.15625, 0.34375, 0.15625, 0.34375, 0.1875, 0.3125, 0.1875, 0.3125, 0.1875, 0.34375, 0.1875, 0.34375, 0.21875, 0.3125, 0.21875, 0.3125, 0.21875, 0.34375, 0.21875, 0.34375, 0.25, 0.3125, 0.25, 0.3125, 0.25, 0.34375, 0.25, 0.34375, 0.28125, 0.3125, 0.28125, 0.3125, 0.28125, 0.34375, 0.28125, 0.34375, 0.3125, 0.3125, 0.3125, 0.3125, 0.3125, 0.34375, 0.3125, 0.34375, 0.34375, 0.3125, 0.34375, 0.3125, 0.34375, 0.34375, 0.34375, 0.34375, 0.375, 0.3125, 0.375, 0.3125, 0.375, 0.34375, 0.375, 0.34375, 0.40625, 0.3125, 0.40625, 0.3125, 0.40625, 0.34375, 0.40625, 0.34375, 0.4375, 0.3125, 0.4375, 0.3125, 0.4375, 0.34375, 0.4375, 0.34375, 0.46875, 0.3125, 0.46875, 0.3125, 0.46875, 0.34375, 0.46875, 0.34375, 0.5, 0.3125, 0.5, 0.3125, 0.5, 0.34375, 0.5, 0.34375, 0.53125, 0.3125, 0.53125, 0.3125, 0.53125, 0.34375, 0.53125, 0.34375, 0.5625, 0.3125, 0.5625, 0.3125, 0.5625, 0.34375, 0.5625, 0.34375, 0.59375, 0.3125, 0.59375, 0.3125, 0.59375, 0.34375, 0.59375, 0.34375, 0.625, 0.3125, 0.625, 0.3125, 0.625, 0.34375, 0.625, 0.34375, 0.65625, 0.3125, 0.65625, 0.3125, 0.65625, 0.34375, 0.65625, 0.34375, 0.6875, 0.3125, 0.6875, 0.3125, 0.6875, 0.34375, 0.6875, 0.34375, 0.71875, 0.3125, 0.71875, 0.3125, 0.71875, 0.34375, 0.71875, 0.34375, 0.75, 0.3125, 0.75, 0.3125, 0.75, 0.34375, 0.75, 0.34375, 0.78125, 0.3125, 0.78125, 0.3125, 0.78125, 0.34375, 0.78125, 0.34375, 0.8125, 0.3125, 0.8125, 0.3125, 0.8125, 0.34375, 0.8125, 0.34375, 0.84375, 0.3125, 0.84375, 0.3125, 0.84375, 0.34375, 0.84375, 0.34375, 0.875, 0.3125, 0.875, 0.3125, 0.875, 0.34375, 0.875, 0.34375, 0.90625, 0.3125, 0.90625, 0.3125, 0.90625, 0.34375, 0.90625, 0.34375, 0.9375, 0.3125, 0.9375, 0.3125, 0.9375, 0.34375, 0.9375, 0.34375, 0.96875, 0.3125, 0.96875, 0.34375, 0.96875, 0.63412, 1, 0.3125, 0.96875, 0.375, 0.96875, 0.63412, 1, 0.34375, 0.96875, 0.34375, 0.9375, 0.375, 0.9375, 0.375, 0.96875, 0.34375, 0.96875, 0.34375, 0.90625, 0.375, 0.90625, 0.375, 0.9375, 0.34375, 0.9375, 0.34375, 0.875, 0.375, 0.875, 0.375, 0.90625, 0.34375, 0.90625, 0.34375, 0.84375, 0.375, 0.84375, 0.375, 0.875, 0.34375, 0.875, 0.34375, 0.8125, 0.375, 0.8125, 0.375, 0.84375, 0.34375, 0.84375, 0.34375, 0.78125, 0.375, 0.78125, 0.375, 0.8125, 0.34375, 0.8125, 0.34375, 0.75, 0.375, 0.75, 0.375, 0.78125, 0.34375, 0.78125, 0.34375, 0.71875, 0.375, 0.71875, 0.375, 0.75, 0.34375, 0.75, 0.34375, 0.6875, 0.375, 0.6875, 0.375, 0.71875, 0.34375, 0.71875, 0.34375, 0.65625, 0.375, 0.65625, 0.375, 0.6875, 0.34375, 0.6875, 0.34375, 0.625, 0.375, 0.625, 0.375, 0.65625, 0.34375, 0.65625, 0.34375, 0.59375, 0.375, 0.59375, 0.375, 0.625, 0.34375, 0.625, 0.34375, 0.5625, 0.375, 0.5625, 0.375, 0.59375, 0.34375, 0.59375, 0.34375, 0.53125, 0.375, 0.53125, 0.375, 0.5625, 0.34375, 0.5625, 0.34375, 0.5, 0.375, 0.5, 0.375, 0.53125, 0.34375, 0.53125, 0.34375, 0.46875, 0.375, 0.46875, 0.375, 0.5, 0.34375, 0.5, 0.34375, 0.4375, 0.375, 0.4375, 0.375, 0.46875, 0.34375, 0.46875, 0.34375, 0.40625, 0.375, 0.40625, 0.375, 0.4375, 0.34375, 0.4375, 0.34375, 0.375, 0.375, 0.375, 0.375, 0.40625, 0.34375, 0.40625, 0.34375, 0.34375, 0.375, 0.34375, 0.375, 0.375, 0.34375, 0.375, 0.34375, 0.3125, 0.375, 0.3125, 0.375, 0.34375, 0.34375, 0.34375, 0.34375, 0.28125, 0.375, 0.28125, 0.375, 0.3125, 0.34375, 0.3125, 0.34375, 0.25, 0.375, 0.25, 0.375, 0.28125, 0.34375, 0.28125, 0.34375, 0.21875, 0.375, 0.21875, 0.375, 0.25, 0.34375, 0.25, 0.34375, 0.1875, 0.375, 0.1875, 0.375, 0.21875, 0.34375, 0.21875, 0.34375, 0.15625, 0.375, 0.15625, 0.375, 0.1875, 0.34375, 0.1875, 0.34375, 0.125, 0.375, 0.125, 0.375, 0.15625, 0.34375, 0.15625, 0.34375, 0.09375, 0.375, 0.09375, 0.375, 0.125, 0.34375, 0.125, 0.34375, 0.0625, 0.375, 0.0625, 0.375, 0.09375, 0.34375, 0.09375, 0.34375, 0.03125, 0.375, 0.03125, 0.375, 0.0625, 0.34375, 0.0625, 0.3212, -0, 0.375, 0.03125, 0.34375, 0.03125, 0.3212, -0, 0.40625, 0.03125, 0.375, 0.03125, 0.375, 0.03125, 0.40625, 0.03125, 0.40625, 0.0625, 0.375, 0.0625, 0.375, 0.0625, 0.40625, 0.0625, 0.40625, 0.09375, 0.375, 0.09375, 0.375, 0.09375, 0.40625, 0.09375, 0.40625, 0.125, 0.375, 0.125, 0.375, 0.125, 0.40625, 0.125, 0.40625, 0.15625, 0.375, 0.15625, 0.375, 0.15625, 0.40625, 0.15625, 0.40625, 0.1875, 0.375, 0.1875, 0.375, 0.1875, 0.40625, 0.1875, 0.40625, 0.21875, 0.375, 0.21875, 0.375, 0.21875, 0.40625, 0.21875, 0.40625, 0.25, 0.375, 0.25, 0.375, 0.25, 0.40625, 0.25, 0.40625, 0.28125, 0.375, 0.28125, 0.375, 0.28125, 0.40625, 0.28125, 0.40625, 0.3125, 0.375, 0.3125, 0.375, 0.3125, 0.40625, 0.3125, 0.40625, 0.34375, 0.375, 0.34375, 0.375, 0.34375, 0.40625, 0.34375, 0.40625, 0.375, 0.375, 0.375, 0.375, 0.375, 0.40625, 0.375, 0.40625, 0.40625, 0.375, 0.40625, 0.375, 0.40625, 0.40625, 0.40625, 0.40625, 0.4375, 0.375, 0.4375, 0.375, 0.4375, 0.40625, 0.4375, 0.40625, 0.46875, 0.375, 0.46875, 0.375, 0.46875, 0.40625, 0.46875, 0.40625, 0.5, 0.375, 0.5, 0.375, 0.5, 0.40625, 0.5, 0.40625, 0.53125, 0.375, 0.53125, 0.375, 0.53125, 0.40625, 0.53125, 0.40625, 0.5625, 0.375, 0.5625, 0.375, 0.5625, 0.40625, 0.5625, 0.40625, 0.59375, 0.375, 0.59375, 0.375, 0.59375, 0.40625, 0.59375, 0.40625, 0.625, 0.375, 0.625, 0.375, 0.625, 0.40625, 0.625, 0.40625, 0.65625, 0.375, 0.65625, 0.375, 0.65625, 0.40625, 0.65625, 0.40625, 0.6875, 0.375, 0.6875, 0.375, 0.6875, 0.40625, 0.6875, 0.40625, 0.71875, 0.375, 0.71875, 0.375, 0.71875, 0.40625, 0.71875, 0.40625, 0.75, 0.375, 0.75, 0.375, 0.75, 0.40625, 0.75, 0.40625, 0.78125, 0.375, 0.78125, 0.375, 0.78125, 0.40625, 0.78125, 0.40625, 0.8125, 0.375, 0.8125, 0.375, 0.8125, 0.40625, 0.8125, 0.40625, 0.84375, 0.375, 0.84375, 0.375, 0.84375, 0.40625, 0.84375, 0.40625, 0.875, 0.375, 0.875, 0.375, 0.875, 0.40625, 0.875, 0.40625, 0.90625, 0.375, 0.90625, 0.375, 0.90625, 0.40625, 0.90625, 0.40625, 0.9375, 0.375, 0.9375, 0.375, 0.9375, 0.40625, 0.9375, 0.40625, 0.96875, 0.375, 0.96875, 0.40625, 0.96875, 0.63412, 1, 0.375, 0.96875, 0.4375, 0.96875, 0.63412, 1, 0.40625, 0.96875, 0.40625, 0.9375, 0.4375, 0.9375, 0.4375, 0.96875, 0.40625, 0.96875, 0.40625, 0.90625, 0.4375, 0.90625, 0.4375, 0.9375, 0.40625, 0.9375, 0.40625, 0.875, 0.4375, 0.875, 0.4375, 0.90625, 0.40625, 0.90625, 0.40625, 0.84375, 0.4375, 0.84375, 0.4375, 0.875, 0.40625, 0.875, 0.40625, 0.8125, 0.4375, 0.8125, 0.4375, 0.84375, 0.40625, 0.84375, 0.40625, 0.78125, 0.4375, 0.78125, 0.4375, 0.8125, 0.40625, 0.8125, 0.40625, 0.75, 0.4375, 0.75, 0.4375, 0.78125, 0.40625, 0.78125, 0.40625, 0.71875, 0.4375, 0.71875, 0.4375, 0.75, 0.40625, 0.75, 0.40625, 0.6875, 0.4375, 0.6875, 0.4375, 0.71875, 0.40625, 0.71875, 0.40625, 0.65625, 0.4375, 0.65625, 0.4375, 0.6875, 0.40625, 0.6875, 0.40625, 0.625, 0.4375, 0.625, 0.4375, 0.65625, 0.40625, 0.65625, 0.40625, 0.59375, 0.4375, 0.59375, 0.4375, 0.625, 0.40625, 0.625, 0.40625, 0.5625, 0.4375, 0.5625, 0.4375, 0.59375, 0.40625, 0.59375, 0.40625, 0.53125, 0.4375, 0.53125, 0.4375, 0.5625, 0.40625, 0.5625, 0.40625, 0.5, 0.4375, 0.5, 0.4375, 0.53125, 0.40625, 0.53125, 0.40625, 0.46875, 0.4375, 0.46875, 0.4375, 0.5, 0.40625, 0.5, 0.40625, 0.4375, 0.4375, 0.4375, 0.4375, 0.46875, 0.40625, 0.46875, 0.40625, 0.40625, 0.4375, 0.40625, 0.4375, 0.4375, 0.40625, 0.4375, 0.40625, 0.375, 0.4375, 0.375, 0.4375, 0.40625, 0.40625, 0.40625, 0.40625, 0.34375, 0.4375, 0.34375, 0.4375, 0.375, 0.40625, 0.375, 0.40625, 0.3125, 0.4375, 0.3125, 0.4375, 0.34375, 0.40625, 0.34375, 0.40625, 0.28125, 0.4375, 0.28125, 0.4375, 0.3125, 0.40625, 0.3125, 0.40625, 0.25, 0.4375, 0.25, 0.4375, 0.28125, 0.40625, 0.28125, 0.40625, 0.21875, 0.4375, 0.21875, 0.4375, 0.25, 0.40625, 0.25, 0.40625, 0.1875, 0.4375, 0.1875, 0.4375, 0.21875, 0.40625, 0.21875, 0.40625, 0.15625, 0.4375, 0.15625, 0.4375, 0.1875, 0.40625, 0.1875, 0.40625, 0.125, 0.4375, 0.125, 0.4375, 0.15625, 0.40625, 0.15625, 0.40625, 0.09375, 0.4375, 0.09375, 0.4375, 0.125, 0.40625, 0.125, 0.40625, 0.0625, 0.4375, 0.0625, 0.4375, 0.09375, 0.40625, 0.09375, 0.40625, 0.03125, 0.4375, 0.03125, 0.4375, 0.0625, 0.40625, 0.0625, 0.3212, -0, 0.4375, 0.03125, 0.40625, 0.03125, 0.3212, -0, 0.46875, 0.03125, 0.4375, 0.03125, 0.4375, 0.03125, 0.46875, 0.03125, 0.46875, 0.0625, 0.4375, 0.0625, 0.4375, 0.0625, 0.46875, 0.0625, 0.46875, 0.09375, 0.4375, 0.09375, 0.4375, 0.09375, 0.46875, 0.09375, 0.46875, 0.125, 0.4375, 0.125, 0.4375, 0.125, 0.46875, 0.125, 0.46875, 0.15625, 0.4375, 0.15625, 0.4375, 0.15625, 0.46875, 0.15625, 0.46875, 0.1875, 0.4375, 0.1875, 0.4375, 0.1875, 0.46875, 0.1875, 0.46875, 0.21875, 0.4375, 0.21875, 0.4375, 0.21875, 0.46875, 0.21875, 0.46875, 0.25, 0.4375, 0.25, 0.4375, 0.25, 0.46875, 0.25, 0.46875, 0.28125, 0.4375, 0.28125, 0.4375, 0.28125, 0.46875, 0.28125, 0.46875, 0.3125, 0.4375, 0.3125, 0.4375, 0.3125, 0.46875, 0.3125, 0.46875, 0.34375, 0.4375, 0.34375, 0.4375, 0.34375, 0.46875, 0.34375, 0.46875, 0.375, 0.4375, 0.375, 0.4375, 0.375, 0.46875, 0.375, 0.46875, 0.40625, 0.4375, 0.40625, 0.4375, 0.40625, 0.46875, 0.40625, 0.46875, 0.4375, 0.4375, 0.4375, 0.4375, 0.4375, 0.46875, 0.4375, 0.46875, 0.46875, 0.4375, 0.46875, 0.4375, 0.46875, 0.46875, 0.46875, 0.46875, 0.5, 0.4375, 0.5, 0.4375, 0.5, 0.46875, 0.5, 0.46875, 0.53125, 0.4375, 0.53125, 0.4375, 0.53125, 0.46875, 0.53125, 0.46875, 0.5625, 0.4375, 0.5625, 0.4375, 0.5625, 0.46875, 0.5625, 0.46875, 0.59375, 0.4375, 0.59375, 0.4375, 0.59375, 0.46875, 0.59375, 0.46875, 0.625, 0.4375, 0.625, 0.4375, 0.625, 0.46875, 0.625, 0.46875, 0.65625, 0.4375, 0.65625, 0.4375, 0.65625, 0.46875, 0.65625, 0.46875, 0.6875, 0.4375, 0.6875, 0.4375, 0.6875, 0.46875, 0.6875, 0.46875, 0.71875, 0.4375, 0.71875, 0.4375, 0.71875, 0.46875, 0.71875, 0.46875, 0.75, 0.4375, 0.75, 0.4375, 0.75, 0.46875, 0.75, 0.46875, 0.78125, 0.4375, 0.78125, 0.4375, 0.78125, 0.46875, 0.78125, 0.46875, 0.8125, 0.4375, 0.8125, 0.4375, 0.8125, 0.46875, 0.8125, 0.46875, 0.84375, 0.4375, 0.84375, 0.4375, 0.84375, 0.46875, 0.84375, 0.46875, 0.875, 0.4375, 0.875, 0.4375, 0.875, 0.46875, 0.875, 0.46875, 0.90625, 0.4375, 0.90625, 0.4375, 0.90625, 0.46875, 0.90625, 0.46875, 0.9375, 0.4375, 0.9375, 0.4375, 0.9375, 0.46875, 0.9375, 0.46875, 0.96875, 0.4375, 0.96875, 0.46875, 0.96875, 0.63412, 1, 0.4375, 0.96875, 0.5, 0.96875, 0.63412, 1, 0.46875, 0.96875, 0.46875, 0.9375, 0.5, 0.9375, 0.5, 0.96875, 0.46875, 0.96875, 0.46875, 0.90625, 0.5, 0.90625, 0.5, 0.9375, 0.46875, 0.9375, 0.46875, 0.875, 0.5, 0.875, 0.5, 0.90625, 0.46875, 0.90625, 0.46875, 0.84375, 0.5, 0.84375, 0.5, 0.875, 0.46875, 0.875, 0.46875, 0.8125, 0.5, 0.8125, 0.5, 0.84375, 0.46875, 0.84375, 0.46875, 0.78125, 0.5, 0.78125, 0.5, 0.8125, 0.46875, 0.8125, 0.46875, 0.75, 0.5, 0.75, 0.5, 0.78125, 0.46875, 0.78125, 0.46875, 0.71875, 0.5, 0.71875, 0.5, 0.75, 0.46875, 0.75, 0.46875, 0.6875, 0.5, 0.6875, 0.5, 0.71875, 0.46875, 0.71875, 0.46875, 0.65625, 0.5, 0.65625, 0.5, 0.6875, 0.46875, 0.6875, 0.46875, 0.625, 0.5, 0.625, 0.5, 0.65625, 0.46875, 0.65625, 0.46875, 0.59375, 0.5, 0.59375, 0.5, 0.625, 0.46875, 0.625, 0.46875, 0.5625, 0.5, 0.5625, 0.5, 0.59375, 0.46875, 0.59375, 0.46875, 0.53125, 0.5, 0.53125, 0.5, 0.5625, 0.46875, 0.5625, 0.46875, 0.5, 0.5, 0.5, 0.5, 0.53125, 0.46875, 0.53125, 0.46875, 0.46875, 0.5, 0.46875, 0.5, 0.5, 0.46875, 0.5, 0.46875, 0.4375, 0.5, 0.4375, 0.5, 0.46875, 0.46875, 0.46875, 0.46875, 0.40625, 0.5, 0.40625, 0.5, 0.4375, 0.46875, 0.4375, 0.46875, 0.375, 0.5, 0.375, 0.5, 0.40625, 0.46875, 0.40625, 0.46875, 0.34375, 0.5, 0.34375, 0.5, 0.375, 0.46875, 0.375, 0.46875, 0.3125, 0.5, 0.3125, 0.5, 0.34375, 0.46875, 0.34375, 0.46875, 0.28125, 0.5, 0.28125, 0.5, 0.3125, 0.46875, 0.3125, 0.46875, 0.25, 0.5, 0.25, 0.5, 0.28125, 0.46875, 0.28125, 0.46875, 0.21875, 0.5, 0.21875, 0.5, 0.25, 0.46875, 0.25, 0.46875, 0.1875, 0.5, 0.1875, 0.5, 0.21875, 0.46875, 0.21875, 0.46875, 0.15625, 0.5, 0.15625, 0.5, 0.1875, 0.46875, 0.1875, 0.46875, 0.125, 0.5, 0.125, 0.5, 0.15625, 0.46875, 0.15625, 0.46875, 0.09375, 0.5, 0.09375, 0.5, 0.125, 0.46875, 0.125, 0.46875, 0.0625, 0.5, 0.0625, 0.5, 0.09375, 0.46875, 0.09375, 0.46875, 0.03125, 0.5, 0.03125, 0.5, 0.0625, 0.46875, 0.0625, 0.3212, -0, 0.5, 0.03125, 0.46875, 0.03125, 0.3212, -0, 0.53125, 0.03125, 0.5, 0.03125, 0.5, 0.03125, 0.53125, 0.03125, 0.53125, 0.0625, 0.5, 0.0625, 0.5, 0.0625, 0.53125, 0.0625, 0.53125, 0.09375, 0.5, 0.09375, 0.5, 0.09375, 0.53125, 0.09375, 0.53125, 0.125, 0.5, 0.125, 0.5, 0.125, 0.53125, 0.125, 0.53125, 0.15625, 0.5, 0.15625, 0.5, 0.15625, 0.53125, 0.15625, 0.53125, 0.1875, 0.5, 0.1875, 0.5, 0.1875, 0.53125, 0.1875, 0.53125, 0.21875, 0.5, 0.21875, 0.5, 0.21875, 0.53125, 0.21875, 0.53125, 0.25, 0.5, 0.25, 0.5, 0.25, 0.53125, 0.25, 0.53125, 0.28125, 0.5, 0.28125, 0.5, 0.28125, 0.53125, 0.28125, 0.53125, 0.3125, 0.5, 0.3125, 0.5, 0.3125, 0.53125, 0.3125, 0.53125, 0.34375, 0.5, 0.34375, 0.5, 0.34375, 0.53125, 0.34375, 0.53125, 0.375, 0.5, 0.375, 0.5, 0.375, 0.53125, 0.375, 0.53125, 0.40625, 0.5, 0.40625, 0.5, 0.40625, 0.53125, 0.40625, 0.53125, 0.4375, 0.5, 0.4375, 0.5, 0.4375, 0.53125, 0.4375, 0.53125, 0.46875, 0.5, 0.46875, 0.5, 0.46875, 0.53125, 0.46875, 0.53125, 0.5, 0.5, 0.5, 0.5, 0.5, 0.53125, 0.5, 0.53125, 0.53125, 0.5, 0.53125, 0.5, 0.53125, 0.53125, 0.53125, 0.53125, 0.5625, 0.5, 0.5625, 0.5, 0.5625, 0.53125, 0.5625, 0.53125, 0.59375, 0.5, 0.59375, 0.5, 0.59375, 0.53125, 0.59375, 0.53125, 0.625, 0.5, 0.625, 0.5, 0.625, 0.53125, 0.625, 0.53125, 0.65625, 0.5, 0.65625, 0.5, 0.65625, 0.53125, 0.65625, 0.53125, 0.6875, 0.5, 0.6875, 0.5, 0.6875, 0.53125, 0.6875, 0.53125, 0.71875, 0.5, 0.71875, 0.5, 0.71875, 0.53125, 0.71875, 0.53125, 0.75, 0.5, 0.75, 0.5, 0.75, 0.53125, 0.75, 0.53125, 0.78125, 0.5, 0.78125, 0.5, 0.78125, 0.53125, 0.78125, 0.53125, 0.8125, 0.5, 0.8125, 0.5, 0.8125, 0.53125, 0.8125, 0.53125, 0.84375, 0.5, 0.84375, 0.5, 0.84375, 0.53125, 0.84375, 0.53125, 0.875, 0.5, 0.875, 0.5, 0.875, 0.53125, 0.875, 0.53125, 0.90625, 0.5, 0.90625, 0.5, 0.90625, 0.53125, 0.90625, 0.53125, 0.9375, 0.5, 0.9375, 0.5, 0.9375, 0.53125, 0.9375, 0.53125, 0.96875, 0.5, 0.96875, 0.53125, 0.96875, 0.63412, 1, 0.5, 0.96875, 0.5625, 0.96875, 0.63412, 1, 0.53125, 0.96875, 0.53125, 0.9375, 0.5625, 0.9375, 0.5625, 0.96875, 0.53125, 0.96875, 0.53125, 0.90625, 0.5625, 0.90625, 0.5625, 0.9375, 0.53125, 0.9375, 0.53125, 0.875, 0.5625, 0.875, 0.5625, 0.90625, 0.53125, 0.90625, 0.53125, 0.84375, 0.5625, 0.84375, 0.5625, 0.875, 0.53125, 0.875, 0.53125, 0.8125, 0.5625, 0.8125, 0.5625, 0.84375, 0.53125, 0.84375, 0.53125, 0.78125, 0.5625, 0.78125, 0.5625, 0.8125, 0.53125, 0.8125, 0.53125, 0.75, 0.5625, 0.75, 0.5625, 0.78125, 0.53125, 0.78125, 0.53125, 0.71875, 0.5625, 0.71875, 0.5625, 0.75, 0.53125, 0.75, 0.53125, 0.6875, 0.5625, 0.6875, 0.5625, 0.71875, 0.53125, 0.71875, 0.53125, 0.65625, 0.5625, 0.65625, 0.5625, 0.6875, 0.53125, 0.6875, 0.53125, 0.625, 0.5625, 0.625, 0.5625, 0.65625, 0.53125, 0.65625, 0.53125, 0.59375, 0.5625, 0.59375, 0.5625, 0.625, 0.53125, 0.625, 0.53125, 0.5625, 0.5625, 0.5625, 0.5625, 0.59375, 0.53125, 0.59375, 0.53125, 0.53125, 0.5625, 0.53125, 0.5625, 0.5625, 0.53125, 0.5625, 0.53125, 0.5, 0.5625, 0.5, 0.5625, 0.53125, 0.53125, 0.53125, 0.53125, 0.46875, 0.5625, 0.46875, 0.5625, 0.5, 0.53125, 0.5, 0.53125, 0.4375, 0.5625, 0.4375, 0.5625, 0.46875, 0.53125, 0.46875, 0.53125, 0.40625, 0.5625, 0.40625, 0.5625, 0.4375, 0.53125, 0.4375, 0.53125, 0.375, 0.5625, 0.375, 0.5625, 0.40625, 0.53125, 0.40625, 0.53125, 0.34375, 0.5625, 0.34375, 0.5625, 0.375, 0.53125, 0.375, 0.53125, 0.3125, 0.5625, 0.3125, 0.5625, 0.34375, 0.53125, 0.34375, 0.53125, 0.28125, 0.5625, 0.28125, 0.5625, 0.3125, 0.53125, 0.3125, 0.53125, 0.25, 0.5625, 0.25, 0.5625, 0.28125, 0.53125, 0.28125, 0.53125, 0.21875, 0.5625, 0.21875, 0.5625, 0.25, 0.53125, 0.25, 0.53125, 0.1875, 0.5625, 0.1875, 0.5625, 0.21875, 0.53125, 0.21875, 0.53125, 0.15625, 0.5625, 0.15625, 0.5625, 0.1875, 0.53125, 0.1875, 0.53125, 0.125, 0.5625, 0.125, 0.5625, 0.15625, 0.53125, 0.15625, 0.53125, 0.09375, 0.5625, 0.09375, 0.5625, 0.125, 0.53125, 0.125, 0.53125, 0.0625, 0.5625, 0.0625, 0.5625, 0.09375, 0.53125, 0.09375, 0.53125, 0.03125, 0.5625, 0.03125, 0.5625, 0.0625, 0.53125, 0.0625, 0.3212, -0, 0.5625, 0.03125, 0.53125, 0.03125, 0.3212, -0, 0.59375, 0.03125, 0.5625, 0.03125, 0.5625, 0.03125, 0.59375, 0.03125, 0.59375, 0.0625, 0.5625, 0.0625, 0.5625, 0.0625, 0.59375, 0.0625, 0.59375, 0.09375, 0.5625, 0.09375, 0.5625, 0.09375, 0.59375, 0.09375, 0.59375, 0.125, 0.5625, 0.125, 0.5625, 0.125, 0.59375, 0.125, 0.59375, 0.15625, 0.5625, 0.15625, 0.5625, 0.15625, 0.59375, 0.15625, 0.59375, 0.1875, 0.5625, 0.1875, 0.5625, 0.1875, 0.59375, 0.1875, 0.59375, 0.21875, 0.5625, 0.21875, 0.5625, 0.21875, 0.59375, 0.21875, 0.59375, 0.25, 0.5625, 0.25, 0.5625, 0.25, 0.59375, 0.25, 0.59375, 0.28125, 0.5625, 0.28125, 0.5625, 0.28125, 0.59375, 0.28125, 0.59375, 0.3125, 0.5625, 0.3125, 0.5625, 0.3125, 0.59375, 0.3125, 0.59375, 0.34375, 0.5625, 0.34375, 0.5625, 0.34375, 0.59375, 0.34375, 0.59375, 0.375, 0.5625, 0.375, 0.5625, 0.375, 0.59375, 0.375, 0.59375, 0.40625, 0.5625, 0.40625, 0.5625, 0.40625, 0.59375, 0.40625, 0.59375, 0.4375, 0.5625, 0.4375, 0.5625, 0.4375, 0.59375, 0.4375, 0.59375, 0.46875, 0.5625, 0.46875, 0.5625, 0.46875, 0.59375, 0.46875, 0.59375, 0.5, 0.5625, 0.5, 0.5625, 0.5, 0.59375, 0.5, 0.59375, 0.53125, 0.5625, 0.53125, 0.5625, 0.53125, 0.59375, 0.53125, 0.59375, 0.5625, 0.5625, 0.5625, 0.5625, 0.5625, 0.59375, 0.5625, 0.59375, 0.59375, 0.5625, 0.59375, 0.5625, 0.59375, 0.59375, 0.59375, 0.59375, 0.625, 0.5625, 0.625, 0.5625, 0.625, 0.59375, 0.625, 0.59375, 0.65625, 0.5625, 0.65625, 0.5625, 0.65625, 0.59375, 0.65625, 0.59375, 0.6875, 0.5625, 0.6875, 0.5625, 0.6875, 0.59375, 0.6875, 0.59375, 0.71875, 0.5625, 0.71875, 0.5625, 0.71875, 0.59375, 0.71875, 0.59375, 0.75, 0.5625, 0.75, 0.5625, 0.75, 0.59375, 0.75, 0.59375, 0.78125, 0.5625, 0.78125, 0.5625, 0.78125, 0.59375, 0.78125, 0.59375, 0.8125, 0.5625, 0.8125, 0.5625, 0.8125, 0.59375, 0.8125, 0.59375, 0.84375, 0.5625, 0.84375, 0.5625, 0.84375, 0.59375, 0.84375, 0.59375, 0.875, 0.5625, 0.875, 0.5625, 0.875, 0.59375, 0.875, 0.59375, 0.90625, 0.5625, 0.90625, 0.5625, 0.90625, 0.59375, 0.90625, 0.59375, 0.9375, 0.5625, 0.9375, 0.5625, 0.9375, 0.59375, 0.9375, 0.59375, 0.96875, 0.5625, 0.96875, 0.59375, 0.96875, 0.63412, 1, 0.5625, 0.96875, 0.625, 0.96875, 0.63412, 1, 0.59375, 0.96875, 0.59375, 0.9375, 0.625, 0.9375, 0.625, 0.96875, 0.59375, 0.96875, 0.59375, 0.90625, 0.625, 0.90625, 0.625, 0.9375, 0.59375, 0.9375, 0.59375, 0.875, 0.625, 0.875, 0.625, 0.90625, 0.59375, 0.90625, 0.59375, 0.84375, 0.625, 0.84375, 0.625, 0.875, 0.59375, 0.875, 0.59375, 0.8125, 0.625, 0.8125, 0.625, 0.84375, 0.59375, 0.84375, 0.59375, 0.78125, 0.625, 0.78125, 0.625, 0.8125, 0.59375, 0.8125, 0.59375, 0.75, 0.625, 0.75, 0.625, 0.78125, 0.59375, 0.78125, 0.59375, 0.71875, 0.625, 0.71875, 0.625, 0.75, 0.59375, 0.75, 0.59375, 0.6875, 0.625, 0.6875, 0.625, 0.71875, 0.59375, 0.71875, 0.59375, 0.65625, 0.625, 0.65625, 0.625, 0.6875, 0.59375, 0.6875, 0.59375, 0.625, 0.625, 0.625, 0.625, 0.65625, 0.59375, 0.65625, 0.59375, 0.59375, 0.625, 0.59375, 0.625, 0.625, 0.59375, 0.625, 0.59375, 0.5625, 0.625, 0.5625, 0.625, 0.59375, 0.59375, 0.59375, 0.59375, 0.53125, 0.625, 0.53125, 0.625, 0.5625, 0.59375, 0.5625, 0.59375, 0.5, 0.625, 0.5, 0.625, 0.53125, 0.59375, 0.53125, 0.59375, 0.46875, 0.625, 0.46875, 0.625, 0.5, 0.59375, 0.5, 0.59375, 0.4375, 0.625, 0.4375, 0.625, 0.46875, 0.59375, 0.46875, 0.59375, 0.40625, 0.625, 0.40625, 0.625, 0.4375, 0.59375, 0.4375, 0.59375, 0.375, 0.625, 0.375, 0.625, 0.40625, 0.59375, 0.40625, 0.59375, 0.34375, 0.625, 0.34375, 0.625, 0.375, 0.59375, 0.375, 0.59375, 0.3125, 0.625, 0.3125, 0.625, 0.34375, 0.59375, 0.34375, 0.59375, 0.28125, 0.625, 0.28125, 0.625, 0.3125, 0.59375, 0.3125, 0.59375, 0.25, 0.625, 0.25, 0.625, 0.28125, 0.59375, 0.28125, 0.59375, 0.21875, 0.625, 0.21875, 0.625, 0.25, 0.59375, 0.25, 0.59375, 0.1875, 0.625, 0.1875, 0.625, 0.21875, 0.59375, 0.21875, 0.59375, 0.15625, 0.625, 0.15625, 0.625, 0.1875, 0.59375, 0.1875, 0.59375, 0.125, 0.625, 0.125, 0.625, 0.15625, 0.59375, 0.15625, 0.59375, 0.09375, 0.625, 0.09375, 0.625, 0.125, 0.59375, 0.125, 0.59375, 0.0625, 0.625, 0.0625, 0.625, 0.09375, 0.59375, 0.09375, 0.59375, 0.03125, 0.625, 0.03125, 0.625, 0.0625, 0.59375, 0.0625, 0.3212, -0, 0.625, 0.03125, 0.59375, 0.03125, 0.3212, -0, 0.65625, 0.03125, 0.625, 0.03125, 0.625, 0.03125, 0.65625, 0.03125, 0.65625, 0.0625, 0.625, 0.0625, 0.625, 0.0625, 0.65625, 0.0625, 0.65625, 0.09375, 0.625, 0.09375, 0.625, 0.09375, 0.65625, 0.09375, 0.65625, 0.125, 0.625, 0.125, 0.625, 0.125, 0.65625, 0.125, 0.65625, 0.15625, 0.625, 0.15625, 0.625, 0.15625, 0.65625, 0.15625, 0.65625, 0.1875, 0.625, 0.1875, 0.625, 0.1875, 0.65625, 0.1875, 0.65625, 0.21875, 0.625, 0.21875, 0.625, 0.21875, 0.65625, 0.21875, 0.65625, 0.25, 0.625, 0.25, 0.625, 0.25, 0.65625, 0.25, 0.65625, 0.28125, 0.625, 0.28125, 0.625, 0.28125, 0.65625, 0.28125, 0.65625, 0.3125, 0.625, 0.3125, 0.625, 0.3125, 0.65625, 0.3125, 0.65625, 0.34375, 0.625, 0.34375, 0.625, 0.34375, 0.65625, 0.34375, 0.65625, 0.375, 0.625, 0.375, 0.625, 0.375, 0.65625, 0.375, 0.65625, 0.40625, 0.625, 0.40625, 0.625, 0.40625, 0.65625, 0.40625, 0.65625, 0.4375, 0.625, 0.4375, 0.625, 0.4375, 0.65625, 0.4375, 0.65625, 0.46875, 0.625, 0.46875, 0.625, 0.46875, 0.65625, 0.46875, 0.65625, 0.5, 0.625, 0.5, 0.625, 0.5, 0.65625, 0.5, 0.65625, 0.53125, 0.625, 0.53125, 0.625, 0.53125, 0.65625, 0.53125, 0.65625, 0.5625, 0.625, 0.5625, 0.625, 0.5625, 0.65625, 0.5625, 0.65625, 0.59375, 0.625, 0.59375, 0.625, 0.59375, 0.65625, 0.59375, 0.65625, 0.625, 0.625, 0.625, 0.625, 0.625, 0.65625, 0.625, 0.65625, 0.65625, 0.625, 0.65625, 0.625, 0.65625, 0.65625, 0.65625, 0.65625, 0.6875, 0.625, 0.6875, 0.625, 0.6875, 0.65625, 0.6875, 0.65625, 0.71875, 0.625, 0.71875, 0.625, 0.71875, 0.65625, 0.71875, 0.65625, 0.75, 0.625, 0.75, 0.625, 0.75, 0.65625, 0.75, 0.65625, 0.78125, 0.625, 0.78125, 0.625, 0.78125, 0.65625, 0.78125, 0.65625, 0.8125, 0.625, 0.8125, 0.625, 0.8125, 0.65625, 0.8125, 0.65625, 0.84375, 0.625, 0.84375, 0.625, 0.84375, 0.65625, 0.84375, 0.65625, 0.875, 0.625, 0.875, 0.625, 0.875, 0.65625, 0.875, 0.65625, 0.90625, 0.625, 0.90625, 0.625, 0.90625, 0.65625, 0.90625, 0.65625, 0.9375, 0.625, 0.9375, 0.625, 0.9375, 0.65625, 0.9375, 0.65625, 0.96875, 0.625, 0.96875, 0.65625, 0.96875, 0.63412, 1, 0.625, 0.96875, 0.6875, 0.96875, 0.63412, 1, 0.65625, 0.96875, 0.65625, 0.9375, 0.6875, 0.9375, 0.6875, 0.96875, 0.65625, 0.96875, 0.65625, 0.90625, 0.6875, 0.90625, 0.6875, 0.9375, 0.65625, 0.9375, 0.65625, 0.875, 0.6875, 0.875, 0.6875, 0.90625, 0.65625, 0.90625, 0.65625, 0.84375, 0.6875, 0.84375, 0.6875, 0.875, 0.65625, 0.875, 0.65625, 0.8125, 0.6875, 0.8125, 0.6875, 0.84375, 0.65625, 0.84375, 0.65625, 0.78125, 0.6875, 0.78125, 0.6875, 0.8125, 0.65625, 0.8125, 0.65625, 0.75, 0.6875, 0.75, 0.6875, 0.78125, 0.65625, 0.78125, 0.65625, 0.71875, 0.6875, 0.71875, 0.6875, 0.75, 0.65625, 0.75, 0.65625, 0.6875, 0.6875, 0.6875, 0.6875, 0.71875, 0.65625, 0.71875, 0.65625, 0.65625, 0.6875, 0.65625, 0.6875, 0.6875, 0.65625, 0.6875, 0.65625, 0.625, 0.6875, 0.625, 0.6875, 0.65625, 0.65625, 0.65625, 0.65625, 0.59375, 0.6875, 0.59375, 0.6875, 0.625, 0.65625, 0.625, 0.65625, 0.5625, 0.6875, 0.5625, 0.6875, 0.59375, 0.65625, 0.59375, 0.65625, 0.53125, 0.6875, 0.53125, 0.6875, 0.5625, 0.65625, 0.5625, 0.65625, 0.5, 0.6875, 0.5, 0.6875, 0.53125, 0.65625, 0.53125, 0.65625, 0.46875, 0.6875, 0.46875, 0.6875, 0.5, 0.65625, 0.5, 0.65625, 0.4375, 0.6875, 0.4375, 0.6875, 0.46875, 0.65625, 0.46875, 0.65625, 0.40625, 0.6875, 0.40625, 0.6875, 0.4375, 0.65625, 0.4375, 0.65625, 0.375, 0.6875, 0.375, 0.6875, 0.40625, 0.65625, 0.40625, 0.65625, 0.34375, 0.6875, 0.34375, 0.6875, 0.375, 0.65625, 0.375, 0.65625, 0.3125, 0.6875, 0.3125, 0.6875, 0.34375, 0.65625, 0.34375, 0.65625, 0.28125, 0.6875, 0.28125, 0.6875, 0.3125, 0.65625, 0.3125, 0.65625, 0.25, 0.6875, 0.25, 0.6875, 0.28125, 0.65625, 0.28125, 0.65625, 0.21875, 0.6875, 0.21875, 0.6875, 0.25, 0.65625, 0.25, 0.65625, 0.1875, 0.6875, 0.1875, 0.6875, 0.21875, 0.65625, 0.21875, 0.65625, 0.15625, 0.6875, 0.15625, 0.6875, 0.1875, 0.65625, 0.1875, 0.65625, 0.125, 0.6875, 0.125, 0.6875, 0.15625, 0.65625, 0.15625, 0.65625, 0.09375, 0.6875, 0.09375, 0.6875, 0.125, 0.65625, 0.125, 0.65625, 0.0625, 0.6875, 0.0625, 0.6875, 0.09375, 0.65625, 0.09375, 0.65625, 0.03125, 0.6875, 0.03125, 0.6875, 0.0625, 0.65625, 0.0625, 0.3212, -0, 0.6875, 0.03125, 0.65625, 0.03125, 0.3212, -0, 0.71875, 0.03125, 0.6875, 0.03125, 0.6875, 0.03125, 0.71875, 0.03125, 0.71875, 0.0625, 0.6875, 0.0625, 0.6875, 0.0625, 0.71875, 0.0625, 0.71875, 0.09375, 0.6875, 0.09375, 0.6875, 0.09375, 0.71875, 0.09375, 0.71875, 0.125, 0.6875, 0.125, 0.6875, 0.125, 0.71875, 0.125, 0.71875, 0.15625, 0.6875, 0.15625, 0.6875, 0.15625, 0.71875, 0.15625, 0.71875, 0.1875, 0.6875, 0.1875, 0.6875, 0.1875, 0.71875, 0.1875, 0.71875, 0.21875, 0.6875, 0.21875, 0.6875, 0.21875, 0.71875, 0.21875, 0.71875, 0.25, 0.6875, 0.25, 0.6875, 0.25, 0.71875, 0.25, 0.71875, 0.28125, 0.6875, 0.28125, 0.6875, 0.28125, 0.71875, 0.28125, 0.71875, 0.3125, 0.6875, 0.3125, 0.6875, 0.3125, 0.71875, 0.3125, 0.71875, 0.34375, 0.6875, 0.34375, 0.6875, 0.34375, 0.71875, 0.34375, 0.71875, 0.375, 0.6875, 0.375, 0.6875, 0.375, 0.71875, 0.375, 0.71875, 0.40625, 0.6875, 0.40625, 0.6875, 0.40625, 0.71875, 0.40625, 0.71875, 0.4375, 0.6875, 0.4375, 0.6875, 0.4375, 0.71875, 0.4375, 0.71875, 0.46875, 0.6875, 0.46875, 0.6875, 0.46875, 0.71875, 0.46875, 0.71875, 0.5, 0.6875, 0.5, 0.6875, 0.5, 0.71875, 0.5, 0.71875, 0.53125, 0.6875, 0.53125, 0.6875, 0.53125, 0.71875, 0.53125, 0.71875, 0.5625, 0.6875, 0.5625, 0.6875, 0.5625, 0.71875, 0.5625, 0.71875, 0.59375, 0.6875, 0.59375, 0.6875, 0.59375, 0.71875, 0.59375, 0.71875, 0.625, 0.6875, 0.625, 0.6875, 0.625, 0.71875, 0.625, 0.71875, 0.65625, 0.6875, 0.65625, 0.6875, 0.65625, 0.71875, 0.65625, 0.71875, 0.6875, 0.6875, 0.6875, 0.6875, 0.6875, 0.71875, 0.6875, 0.71875, 0.71875, 0.6875, 0.71875, 0.6875, 0.71875, 0.71875, 0.71875, 0.71875, 0.75, 0.6875, 0.75, 0.6875, 0.75, 0.71875, 0.75, 0.71875, 0.78125, 0.6875, 0.78125, 0.6875, 0.78125, 0.71875, 0.78125, 0.71875, 0.8125, 0.6875, 0.8125, 0.6875, 0.8125, 0.71875, 0.8125, 0.71875, 0.84375, 0.6875, 0.84375, 0.6875, 0.84375, 0.71875, 0.84375, 0.71875, 0.875, 0.6875, 0.875, 0.6875, 0.875, 0.71875, 0.875, 0.71875, 0.90625, 0.6875, 0.90625, 0.6875, 0.90625, 0.71875, 0.90625, 0.71875, 0.9375, 0.6875, 0.9375, 0.6875, 0.9375, 0.71875, 0.9375, 0.71875, 0.96875, 0.6875, 0.96875, 0.71875, 0.96875, 0.63412, 1, 0.6875, 0.96875, 0.75, 0.96875, 0.63412, 1, 0.71875, 0.96875, 0.71875, 0.9375, 0.75, 0.9375, 0.75, 0.96875, 0.71875, 0.96875, 0.71875, 0.90625, 0.75, 0.90625, 0.75, 0.9375, 0.71875, 0.9375, 0.71875, 0.875, 0.75, 0.875, 0.75, 0.90625, 0.71875, 0.90625, 0.71875, 0.84375, 0.75, 0.84375, 0.75, 0.875, 0.71875, 0.875, 0.71875, 0.8125, 0.75, 0.8125, 0.75, 0.84375, 0.71875, 0.84375, 0.71875, 0.78125, 0.75, 0.78125, 0.75, 0.8125, 0.71875, 0.8125, 0.71875, 0.75, 0.75, 0.75, 0.75, 0.78125, 0.71875, 0.78125, 0.71875, 0.71875, 0.75, 0.71875, 0.75, 0.75, 0.71875, 0.75, 0.71875, 0.6875, 0.75, 0.6875, 0.75, 0.71875, 0.71875, 0.71875, 0.71875, 0.65625, 0.75, 0.65625, 0.75, 0.6875, 0.71875, 0.6875, 0.71875, 0.625, 0.75, 0.625, 0.75, 0.65625, 0.71875, 0.65625, 0.71875, 0.59375, 0.75, 0.59375, 0.75, 0.625, 0.71875, 0.625, 0.71875, 0.5625, 0.75, 0.5625, 0.75, 0.59375, 0.71875, 0.59375, 0.71875, 0.53125, 0.75, 0.53125, 0.75, 0.5625, 0.71875, 0.5625, 0.71875, 0.5, 0.75, 0.5, 0.75, 0.53125, 0.71875, 0.53125, 0.71875, 0.46875, 0.75, 0.46875, 0.75, 0.5, 0.71875, 0.5, 0.71875, 0.4375, 0.75, 0.4375, 0.75, 0.46875, 0.71875, 0.46875, 0.71875, 0.40625, 0.75, 0.40625, 0.75, 0.4375, 0.71875, 0.4375, 0.71875, 0.375, 0.75, 0.375, 0.75, 0.40625, 0.71875, 0.40625, 0.71875, 0.34375, 0.75, 0.34375, 0.75, 0.375, 0.71875, 0.375, 0.71875, 0.3125, 0.75, 0.3125, 0.75, 0.34375, 0.71875, 0.34375, 0.71875, 0.28125, 0.75, 0.28125, 0.75, 0.3125, 0.71875, 0.3125, 0.71875, 0.25, 0.75, 0.25, 0.75, 0.28125, 0.71875, 0.28125, 0.71875, 0.21875, 0.75, 0.21875, 0.75, 0.25, 0.71875, 0.25, 0.71875, 0.1875, 0.75, 0.1875, 0.75, 0.21875, 0.71875, 0.21875, 0.71875, 0.15625, 0.75, 0.15625, 0.75, 0.1875, 0.71875, 0.1875, 0.71875, 0.125, 0.75, 0.125, 0.75, 0.15625, 0.71875, 0.15625, 0.71875, 0.09375, 0.75, 0.09375, 0.75, 0.125, 0.71875, 0.125, 0.71875, 0.0625, 0.75, 0.0625, 0.75, 0.09375, 0.71875, 0.09375, 0.71875, 0.03125, 0.75, 0.03125, 0.75, 0.0625, 0.71875, 0.0625, 0.3212, -0, 0.75, 0.03125, 0.71875, 0.03125 ],
	                                'itemSize': 2,
	                                'type': 'ARRAY_BUFFER'
	                            },
	                            'Vertex': {
	                                'elements': [ -0, -0, -1, 0.09613, 0.01912, -0.99518, 0.09802, 0, -0.99518, 0.09802, 0, -0.99518, 0.09613, 0.01912, -0.99518, 0.19134, 0.03806, -0.98079, 0.19509, 0, -0.98079, 0.19509, 0, -0.98079, 0.19134, 0.03806, -0.98079, 0.28471, 0.05663, -0.95694, 0.29028, 0, -0.95694, 0.29028, 0, -0.95694, 0.28471, 0.05663, -0.95694, 0.37533, 0.07466, -0.92388, 0.38268, 0, -0.92388, 0.38268, 0, -0.92388, 0.37533, 0.07466, -0.92388, 0.46234, 0.09196, -0.88192, 0.4714, 0, -0.88192, 0.4714, 0, -0.88192, 0.46234, 0.09196, -0.88192, 0.54489, 0.10839, -0.83147, 0.55557, 0, -0.83147, 0.55557, 0, -0.83147, 0.54489, 0.10839, -0.83147, 0.6222, 0.12376, -0.77301, 0.63439, 0, -0.77301, 0.63439, 0, -0.77301, 0.6222, 0.12376, -0.77301, 0.69352, 0.13795, -0.70711, 0.70711, 0, -0.70711, 0.70711, 0, -0.70711, 0.69352, 0.13795, -0.70711, 0.75816, 0.15081, -0.63439, 0.77301, 0, -0.63439, 0.77301, 0, -0.63439, 0.75816, 0.15081, -0.63439, 0.81549, 0.16221, -0.55557, 0.83147, 0, -0.55557, 0.83147, 0, -0.55557, 0.81549, 0.16221, -0.55557, 0.86498, 0.17205, -0.4714, 0.88192, 0, -0.4714, 0.88192, 0, -0.4714, 0.86498, 0.17205, -0.4714, 0.90613, 0.18024, -0.38268, 0.92388, 0, -0.38268, 0.92388, 0, -0.38268, 0.90613, 0.18024, -0.38268, 0.93855, 0.18669, -0.29028, 0.95694, 0, -0.29028, 0.95694, 0, -0.29028, 0.93855, 0.18669, -0.29028, 0.96194, 0.19134, -0.19509, 0.98078, 0, -0.19509, 0.98078, 0, -0.19509, 0.96194, 0.19134, -0.19509, 0.97606, 0.19415, -0.09802, 0.99518, 0, -0.09802, 0.99518, 0, -0.09802, 0.97606, 0.19415, -0.09802, 0.98079, 0.19509, -0, 1, 0, -0, 1, 0, -0, 0.98079, 0.19509, -0, 0.97606, 0.19415, 0.09802, 0.99518, 0, 0.09802, 0.99518, 0, 0.09802, 0.97606, 0.19415, 0.09802, 0.96194, 0.19134, 0.19509, 0.98078, 0, 0.19509, 0.98078, 0, 0.19509, 0.96194, 0.19134, 0.19509, 0.93855, 0.18669, 0.29028, 0.95694, 0, 0.29028, 0.95694, 0, 0.29028, 0.93855, 0.18669, 0.29028, 0.90613, 0.18024, 0.38268, 0.92388, 0, 0.38268, 0.92388, 0, 0.38268, 0.90613, 0.18024, 0.38268, 0.86498, 0.17205, 0.4714, 0.88192, 0, 0.4714, 0.88192, 0, 0.4714, 0.86498, 0.17205, 0.4714, 0.81549, 0.16221, 0.55557, 0.83147, 0, 0.55557, 0.83147, 0, 0.55557, 0.81549, 0.16221, 0.55557, 0.75816, 0.15081, 0.63439, 0.77301, 0, 0.63439, 0.77301, 0, 0.63439, 0.75816, 0.15081, 0.63439, 0.69352, 0.13795, 0.70711, 0.70711, 0, 0.70711, 0.70711, 0, 0.70711, 0.69352, 0.13795, 0.70711, 0.6222, 0.12376, 0.77301, 0.63439, 0, 0.77301, 0.63439, 0, 0.77301, 0.6222, 0.12376, 0.77301, 0.5449, 0.10839, 0.83147, 0.55557, 0, 0.83147, 0.55557, 0, 0.83147, 0.5449, 0.10839, 0.83147, 0.46234, 0.09196, 0.88192, 0.4714, 0, 0.88192, 0.4714, 0, 0.88192, 0.46234, 0.09196, 0.88192, 0.37533, 0.07466, 0.92388, 0.38268, 0, 0.92388, 0.38268, 0, 0.92388, 0.37533, 0.07466, 0.92388, 0.28471, 0.05663, 0.95694, 0.29028, 0, 0.95694, 0.29028, 0, 0.95694, 0.28471, 0.05663, 0.95694, 0.19134, 0.03806, 0.98079, 0.19509, 0, 0.98079, 0.19509, 0, 0.98079, 0.19134, 0.03806, 0.98079, 0.09613, 0.01912, 0.99518, 0.09802, 0, 0.99518, 0.09613, 0.01912, 0.99518, 0, 0, 1, 0.09802, 0, 0.99518, 0.09056, 0.03751, 0.99518, 0, 0, 1, 0.09613, 0.01912, 0.99518, 0.19134, 0.03806, 0.98079, 0.18024, 0.07466, 0.98079, 0.09056, 0.03751, 0.99518, 0.09613, 0.01912, 0.99518, 0.28471, 0.05663, 0.95694, 0.26819, 0.11109, 0.95694, 0.18024, 0.07466, 0.98079, 0.19134, 0.03806, 0.98079, 0.37533, 0.07466, 0.92388, 0.35355, 0.14645, 0.92388, 0.26819, 0.11109, 0.95694, 0.28471, 0.05663, 0.95694, 0.46234, 0.09196, 0.88192, 0.43551, 0.1804, 0.88192, 0.35355, 0.14645, 0.92388, 0.37533, 0.07466, 0.92388, 0.5449, 0.10839, 0.83147, 0.51328, 0.21261, 0.83147, 0.43551, 0.1804, 0.88192, 0.46234, 0.09196, 0.88192, 0.6222, 0.12376, 0.77301, 0.5861, 0.24277, 0.77301, 0.51328, 0.21261, 0.83147, 0.5449, 0.10839, 0.83147, 0.69352, 0.13795, 0.70711, 0.65328, 0.2706, 0.70711, 0.5861, 0.24277, 0.77301, 0.6222, 0.12376, 0.77301, 0.75816, 0.15081, 0.63439, 0.71417, 0.29582, 0.63439, 0.65328, 0.2706, 0.70711, 0.69352, 0.13795, 0.70711, 0.81549, 0.16221, 0.55557, 0.76818, 0.31819, 0.55557, 0.71417, 0.29582, 0.63439, 0.75816, 0.15081, 0.63439, 0.86498, 0.17205, 0.4714, 0.81479, 0.3375, 0.4714, 0.76818, 0.31819, 0.55557, 0.81549, 0.16221, 0.55557, 0.90613, 0.18024, 0.38268, 0.85355, 0.35355, 0.38268, 0.81479, 0.3375, 0.4714, 0.86498, 0.17205, 0.4714, 0.93855, 0.18669, 0.29028, 0.8841, 0.36621, 0.29028, 0.85355, 0.35355, 0.38268, 0.90613, 0.18024, 0.38268, 0.96194, 0.19134, 0.19509, 0.90613, 0.37533, 0.19509, 0.8841, 0.36621, 0.29028, 0.93855, 0.18669, 0.29028, 0.97606, 0.19415, 0.09802, 0.91943, 0.38084, 0.09802, 0.90613, 0.37533, 0.19509, 0.96194, 0.19134, 0.19509, 0.98079, 0.19509, -0, 0.92388, 0.38268, -0, 0.91943, 0.38084, 0.09802, 0.97606, 0.19415, 0.09802, 0.97606, 0.19415, -0.09802, 0.91943, 0.38084, -0.09802, 0.92388, 0.38268, -0, 0.98079, 0.19509, -0, 0.96194, 0.19134, -0.19509, 0.90613, 0.37533, -0.19509, 0.91943, 0.38084, -0.09802, 0.97606, 0.19415, -0.09802, 0.93855, 0.18669, -0.29028, 0.8841, 0.36621, -0.29028, 0.90613, 0.37533, -0.19509, 0.96194, 0.19134, -0.19509, 0.90613, 0.18024, -0.38268, 0.85355, 0.35355, -0.38268, 0.8841, 0.36621, -0.29028, 0.93855, 0.18669, -0.29028, 0.86498, 0.17205, -0.4714, 0.81479, 0.3375, -0.4714, 0.85355, 0.35355, -0.38268, 0.90613, 0.18024, -0.38268, 0.81549, 0.16221, -0.55557, 0.76818, 0.31819, -0.55557, 0.81479, 0.3375, -0.4714, 0.86498, 0.17205, -0.4714, 0.75816, 0.15081, -0.63439, 0.71417, 0.29582, -0.63439, 0.76818, 0.31819, -0.55557, 0.81549, 0.16221, -0.55557, 0.69352, 0.13795, -0.70711, 0.65328, 0.2706, -0.70711, 0.71417, 0.29582, -0.63439, 0.75816, 0.15081, -0.63439, 0.6222, 0.12376, -0.77301, 0.5861, 0.24277, -0.77301, 0.65328, 0.2706, -0.70711, 0.69352, 0.13795, -0.70711, 0.54489, 0.10839, -0.83147, 0.51328, 0.21261, -0.83147, 0.5861, 0.24277, -0.77301, 0.6222, 0.12376, -0.77301, 0.46234, 0.09196, -0.88192, 0.43551, 0.1804, -0.88192, 0.51328, 0.21261, -0.83147, 0.54489, 0.10839, -0.83147, 0.37533, 0.07466, -0.92388, 0.35355, 0.14645, -0.92388, 0.43551, 0.1804, -0.88192, 0.46234, 0.09196, -0.88192, 0.28471, 0.05663, -0.95694, 0.26819, 0.11109, -0.95694, 0.35355, 0.14645, -0.92388, 0.37533, 0.07466, -0.92388, 0.19134, 0.03806, -0.98079, 0.18024, 0.07466, -0.98079, 0.26819, 0.11109, -0.95694, 0.28471, 0.05663, -0.95694, 0.09613, 0.01912, -0.99518, 0.09056, 0.03751, -0.99518, 0.18024, 0.07466, -0.98079, 0.19134, 0.03806, -0.98079, -0, -0, -1, 0.09056, 0.03751, -0.99518, 0.09613, 0.01912, -0.99518, -0, -0, -1, 0.0815, 0.05446, -0.99518, 0.09056, 0.03751, -0.99518, 0.09056, 0.03751, -0.99518, 0.0815, 0.05446, -0.99518, 0.16221, 0.10839, -0.98079, 0.18024, 0.07466, -0.98079, 0.18024, 0.07466, -0.98079, 0.16221, 0.10839, -0.98079, 0.24136, 0.16127, -0.95694, 0.26819, 0.11109, -0.95694, 0.26819, 0.11109, -0.95694, 0.24136, 0.16127, -0.95694, 0.31819, 0.21261, -0.92388, 0.35355, 0.14645, -0.92388, 0.35355, 0.14645, -0.92388, 0.31819, 0.21261, -0.92388, 0.39195, 0.26189, -0.88192, 0.43551, 0.1804, -0.88192, 0.43551, 0.1804, -0.88192, 0.39195, 0.26189, -0.88192, 0.46194, 0.30866, -0.83147, 0.51328, 0.21261, -0.83147, 0.51328, 0.21261, -0.83147, 0.46194, 0.30866, -0.83147, 0.52748, 0.35245, -0.77301, 0.5861, 0.24277, -0.77301, 0.5861, 0.24277, -0.77301, 0.52748, 0.35245, -0.77301, 0.58794, 0.39285, -0.70711, 0.65328, 0.2706, -0.70711, 0.65328, 0.2706, -0.70711, 0.58794, 0.39285, -0.70711, 0.64273, 0.42946, -0.63439, 0.71417, 0.29582, -0.63439, 0.71417, 0.29582, -0.63439, 0.64273, 0.42946, -0.63439, 0.69134, 0.46194, -0.55557, 0.76818, 0.31819, -0.55557, 0.76818, 0.31819, -0.55557, 0.69134, 0.46194, -0.55557, 0.73329, 0.48997, -0.4714, 0.81479, 0.3375, -0.4714, 0.81479, 0.3375, -0.4714, 0.73329, 0.48997, -0.4714, 0.76818, 0.51328, -0.38268, 0.85355, 0.35355, -0.38268, 0.85355, 0.35355, -0.38268, 0.76818, 0.51328, -0.38268, 0.79567, 0.53165, -0.29028, 0.8841, 0.36621, -0.29028, 0.8841, 0.36621, -0.29028, 0.79567, 0.53165, -0.29028, 0.81549, 0.5449, -0.19509, 0.90613, 0.37533, -0.19509, 0.90613, 0.37533, -0.19509, 0.81549, 0.5449, -0.19509, 0.82747, 0.55289, -0.09802, 0.91943, 0.38084, -0.09802, 0.91943, 0.38084, -0.09802, 0.82747, 0.55289, -0.09802, 0.83147, 0.55557, -0, 0.92388, 0.38268, -0, 0.92388, 0.38268, -0, 0.83147, 0.55557, -0, 0.82747, 0.55289, 0.09802, 0.91943, 0.38084, 0.09802, 0.91943, 0.38084, 0.09802, 0.82747, 0.55289, 0.09802, 0.81549, 0.5449, 0.19509, 0.90613, 0.37533, 0.19509, 0.90613, 0.37533, 0.19509, 0.81549, 0.5449, 0.19509, 0.79567, 0.53165, 0.29028, 0.8841, 0.36621, 0.29028, 0.8841, 0.36621, 0.29028, 0.79567, 0.53165, 0.29028, 0.76818, 0.51328, 0.38268, 0.85355, 0.35355, 0.38268, 0.85355, 0.35355, 0.38268, 0.76818, 0.51328, 0.38268, 0.73329, 0.48997, 0.4714, 0.81479, 0.3375, 0.4714, 0.81479, 0.3375, 0.4714, 0.73329, 0.48997, 0.4714, 0.69134, 0.46194, 0.55557, 0.76818, 0.31819, 0.55557, 0.76818, 0.31819, 0.55557, 0.69134, 0.46194, 0.55557, 0.64273, 0.42946, 0.63439, 0.71417, 0.29582, 0.63439, 0.71417, 0.29582, 0.63439, 0.64273, 0.42946, 0.63439, 0.58794, 0.39285, 0.70711, 0.65328, 0.2706, 0.70711, 0.65328, 0.2706, 0.70711, 0.58794, 0.39285, 0.70711, 0.52748, 0.35245, 0.77301, 0.5861, 0.24277, 0.77301, 0.5861, 0.24277, 0.77301, 0.52748, 0.35245, 0.77301, 0.46194, 0.30866, 0.83147, 0.51328, 0.21261, 0.83147, 0.51328, 0.21261, 0.83147, 0.46194, 0.30866, 0.83147, 0.39195, 0.26189, 0.88192, 0.43551, 0.1804, 0.88192, 0.43551, 0.1804, 0.88192, 0.39195, 0.26189, 0.88192, 0.31819, 0.21261, 0.92388, 0.35355, 0.14645, 0.92388, 0.35355, 0.14645, 0.92388, 0.31819, 0.21261, 0.92388, 0.24136, 0.16127, 0.95694, 0.26819, 0.11109, 0.95694, 0.26819, 0.11109, 0.95694, 0.24136, 0.16127, 0.95694, 0.16221, 0.10839, 0.98079, 0.18024, 0.07466, 0.98079, 0.18024, 0.07466, 0.98079, 0.16221, 0.10839, 0.98079, 0.0815, 0.05446, 0.99518, 0.09056, 0.03751, 0.99518, 0.0815, 0.05446, 0.99518, 0, 0, 1, 0.09056, 0.03751, 0.99518, 0.06931, 0.06931, 0.99518, 0, 0, 1, 0.0815, 0.05446, 0.99518, 0.16221, 0.10839, 0.98079, 0.13795, 0.13795, 0.98079, 0.06931, 0.06931, 0.99518, 0.0815, 0.05446, 0.99518, 0.24136, 0.16127, 0.95694, 0.20526, 0.20526, 0.95694, 0.13795, 0.13795, 0.98079, 0.16221, 0.10839, 0.98079, 0.31819, 0.21261, 0.92388, 0.2706, 0.2706, 0.92388, 0.20526, 0.20526, 0.95694, 0.24136, 0.16127, 0.95694, 0.39195, 0.26189, 0.88192, 0.33333, 0.33333, 0.88192, 0.2706, 0.2706, 0.92388, 0.31819, 0.21261, 0.92388, 0.46194, 0.30866, 0.83147, 0.39285, 0.39285, 0.83147, 0.33333, 0.33333, 0.88192, 0.39195, 0.26189, 0.88192, 0.52748, 0.35245, 0.77301, 0.44858, 0.44858, 0.77301, 0.39285, 0.39285, 0.83147, 0.46194, 0.30866, 0.83147, 0.58794, 0.39285, 0.70711, 0.5, 0.5, 0.70711, 0.44858, 0.44858, 0.77301, 0.52748, 0.35245, 0.77301, 0.64273, 0.42946, 0.63439, 0.5466, 0.5466, 0.63439, 0.5, 0.5, 0.70711, 0.58794, 0.39285, 0.70711, 0.69134, 0.46194, 0.55557, 0.58794, 0.58794, 0.55557, 0.5466, 0.5466, 0.63439, 0.64273, 0.42946, 0.63439, 0.73329, 0.48997, 0.4714, 0.62361, 0.62361, 0.4714, 0.58794, 0.58794, 0.55557, 0.69134, 0.46194, 0.55557, 0.76818, 0.51328, 0.38268, 0.65328, 0.65328, 0.38268, 0.62361, 0.62361, 0.4714, 0.73329, 0.48997, 0.4714, 0.79567, 0.53165, 0.29028, 0.67666, 0.67666, 0.29028, 0.65328, 0.65328, 0.38268, 0.76818, 0.51328, 0.38268, 0.81549, 0.5449, 0.19509, 0.69352, 0.69352, 0.19509, 0.67666, 0.67666, 0.29028, 0.79567, 0.53165, 0.29028, 0.82747, 0.55289, 0.09802, 0.7037, 0.7037, 0.09802, 0.69352, 0.69352, 0.19509, 0.81549, 0.5449, 0.19509, 0.83147, 0.55557, -0, 0.70711, 0.70711, -0, 0.7037, 0.7037, 0.09802, 0.82747, 0.55289, 0.09802, 0.82747, 0.55289, -0.09802, 0.7037, 0.7037, -0.09802, 0.70711, 0.70711, -0, 0.83147, 0.55557, -0, 0.81549, 0.5449, -0.19509, 0.69352, 0.69352, -0.19509, 0.7037, 0.7037, -0.09802, 0.82747, 0.55289, -0.09802, 0.79567, 0.53165, -0.29028, 0.67666, 0.67666, -0.29028, 0.69352, 0.69352, -0.19509, 0.81549, 0.5449, -0.19509, 0.76818, 0.51328, -0.38268, 0.65328, 0.65328, -0.38268, 0.67666, 0.67666, -0.29028, 0.79567, 0.53165, -0.29028, 0.73329, 0.48997, -0.4714, 0.62361, 0.62361, -0.4714, 0.65328, 0.65328, -0.38268, 0.76818, 0.51328, -0.38268, 0.69134, 0.46194, -0.55557, 0.58794, 0.58794, -0.55557, 0.62361, 0.62361, -0.4714, 0.73329, 0.48997, -0.4714, 0.64273, 0.42946, -0.63439, 0.5466, 0.5466, -0.63439, 0.58794, 0.58794, -0.55557, 0.69134, 0.46194, -0.55557, 0.58794, 0.39285, -0.70711, 0.5, 0.5, -0.70711, 0.5466, 0.5466, -0.63439, 0.64273, 0.42946, -0.63439, 0.52748, 0.35245, -0.77301, 0.44858, 0.44858, -0.77301, 0.5, 0.5, -0.70711, 0.58794, 0.39285, -0.70711, 0.46194, 0.30866, -0.83147, 0.39285, 0.39285, -0.83147, 0.44858, 0.44858, -0.77301, 0.52748, 0.35245, -0.77301, 0.39195, 0.26189, -0.88192, 0.33333, 0.33333, -0.88192, 0.39285, 0.39285, -0.83147, 0.46194, 0.30866, -0.83147, 0.31819, 0.21261, -0.92388, 0.2706, 0.2706, -0.92388, 0.33333, 0.33333, -0.88192, 0.39195, 0.26189, -0.88192, 0.24136, 0.16127, -0.95694, 0.20526, 0.20526, -0.95694, 0.2706, 0.2706, -0.92388, 0.31819, 0.21261, -0.92388, 0.16221, 0.10839, -0.98079, 0.13795, 0.13795, -0.98079, 0.20526, 0.20526, -0.95694, 0.24136, 0.16127, -0.95694, 0.0815, 0.05446, -0.99518, 0.06931, 0.06931, -0.99518, 0.13795, 0.13795, -0.98079, 0.16221, 0.10839, -0.98079, -0, -0, -1, 0.06931, 0.06931, -0.99518, 0.0815, 0.05446, -0.99518, -0, -0, -1, 0.05445, 0.0815, -0.99518, 0.06931, 0.06931, -0.99518, 0.06931, 0.06931, -0.99518, 0.05445, 0.0815, -0.99518, 0.10839, 0.16221, -0.98079, 0.13795, 0.13795, -0.98079, 0.13795, 0.13795, -0.98079, 0.10839, 0.16221, -0.98079, 0.16127, 0.24136, -0.95694, 0.20526, 0.20526, -0.95694, 0.20526, 0.20526, -0.95694, 0.16127, 0.24136, -0.95694, 0.21261, 0.31819, -0.92388, 0.2706, 0.2706, -0.92388, 0.2706, 0.2706, -0.92388, 0.21261, 0.31819, -0.92388, 0.26189, 0.39195, -0.88192, 0.33333, 0.33333, -0.88192, 0.33333, 0.33333, -0.88192, 0.26189, 0.39195, -0.88192, 0.30866, 0.46194, -0.83147, 0.39285, 0.39285, -0.83147, 0.39285, 0.39285, -0.83147, 0.30866, 0.46194, -0.83147, 0.35245, 0.52748, -0.77301, 0.44858, 0.44858, -0.77301, 0.44858, 0.44858, -0.77301, 0.35245, 0.52748, -0.77301, 0.39285, 0.58794, -0.70711, 0.5, 0.5, -0.70711, 0.5, 0.5, -0.70711, 0.39285, 0.58794, -0.70711, 0.42946, 0.64273, -0.63439, 0.5466, 0.5466, -0.63439, 0.5466, 0.5466, -0.63439, 0.42946, 0.64273, -0.63439, 0.46194, 0.69134, -0.55557, 0.58794, 0.58794, -0.55557, 0.58794, 0.58794, -0.55557, 0.46194, 0.69134, -0.55557, 0.48997, 0.73329, -0.4714, 0.62361, 0.62361, -0.4714, 0.62361, 0.62361, -0.4714, 0.48997, 0.73329, -0.4714, 0.51328, 0.76818, -0.38268, 0.65328, 0.65328, -0.38268, 0.65328, 0.65328, -0.38268, 0.51328, 0.76818, -0.38268, 0.53165, 0.79567, -0.29028, 0.67666, 0.67666, -0.29028, 0.67666, 0.67666, -0.29028, 0.53165, 0.79567, -0.29028, 0.54489, 0.81549, -0.19509, 0.69352, 0.69352, -0.19509, 0.69352, 0.69352, -0.19509, 0.54489, 0.81549, -0.19509, 0.55289, 0.82747, -0.09802, 0.7037, 0.7037, -0.09802, 0.7037, 0.7037, -0.09802, 0.55289, 0.82747, -0.09802, 0.55557, 0.83147, -0, 0.70711, 0.70711, -0, 0.70711, 0.70711, -0, 0.55557, 0.83147, -0, 0.55289, 0.82747, 0.09802, 0.7037, 0.7037, 0.09802, 0.7037, 0.7037, 0.09802, 0.55289, 0.82747, 0.09802, 0.54489, 0.81549, 0.19509, 0.69352, 0.69352, 0.19509, 0.69352, 0.69352, 0.19509, 0.54489, 0.81549, 0.19509, 0.53165, 0.79567, 0.29028, 0.67666, 0.67666, 0.29028, 0.67666, 0.67666, 0.29028, 0.53165, 0.79567, 0.29028, 0.51328, 0.76818, 0.38268, 0.65328, 0.65328, 0.38268, 0.65328, 0.65328, 0.38268, 0.51328, 0.76818, 0.38268, 0.48997, 0.73329, 0.4714, 0.62361, 0.62361, 0.4714, 0.62361, 0.62361, 0.4714, 0.48997, 0.73329, 0.4714, 0.46194, 0.69134, 0.55557, 0.58794, 0.58794, 0.55557, 0.58794, 0.58794, 0.55557, 0.46194, 0.69134, 0.55557, 0.42946, 0.64273, 0.63439, 0.5466, 0.5466, 0.63439, 0.5466, 0.5466, 0.63439, 0.42946, 0.64273, 0.63439, 0.39285, 0.58794, 0.70711, 0.5, 0.5, 0.70711, 0.5, 0.5, 0.70711, 0.39285, 0.58794, 0.70711, 0.35245, 0.52748, 0.77301, 0.44858, 0.44858, 0.77301, 0.44858, 0.44858, 0.77301, 0.35245, 0.52748, 0.77301, 0.30866, 0.46194, 0.83147, 0.39285, 0.39285, 0.83147, 0.39285, 0.39285, 0.83147, 0.30866, 0.46194, 0.83147, 0.26189, 0.39195, 0.88192, 0.33333, 0.33333, 0.88192, 0.33333, 0.33333, 0.88192, 0.26189, 0.39195, 0.88192, 0.21261, 0.31819, 0.92388, 0.2706, 0.2706, 0.92388, 0.2706, 0.2706, 0.92388, 0.21261, 0.31819, 0.92388, 0.16127, 0.24136, 0.95694, 0.20526, 0.20526, 0.95694, 0.20526, 0.20526, 0.95694, 0.16127, 0.24136, 0.95694, 0.10839, 0.16221, 0.98079, 0.13795, 0.13795, 0.98079, 0.13795, 0.13795, 0.98079, 0.10839, 0.16221, 0.98079, 0.05446, 0.0815, 0.99518, 0.06931, 0.06931, 0.99518, 0.05446, 0.0815, 0.99518, 0, 0, 1, 0.06931, 0.06931, 0.99518, 0.03751, 0.09056, 0.99518, 0, 0, 1, 0.05446, 0.0815, 0.99518, 0.10839, 0.16221, 0.98079, 0.07466, 0.18024, 0.98079, 0.03751, 0.09056, 0.99518, 0.05446, 0.0815, 0.99518, 0.16127, 0.24136, 0.95694, 0.11109, 0.26819, 0.95694, 0.07466, 0.18024, 0.98079, 0.10839, 0.16221, 0.98079, 0.21261, 0.31819, 0.92388, 0.14645, 0.35355, 0.92388, 0.11109, 0.26819, 0.95694, 0.16127, 0.24136, 0.95694, 0.26189, 0.39195, 0.88192, 0.1804, 0.43551, 0.88192, 0.14645, 0.35355, 0.92388, 0.21261, 0.31819, 0.92388, 0.30866, 0.46194, 0.83147, 0.21261, 0.51328, 0.83147, 0.1804, 0.43551, 0.88192, 0.26189, 0.39195, 0.88192, 0.35245, 0.52748, 0.77301, 0.24277, 0.5861, 0.77301, 0.21261, 0.51328, 0.83147, 0.30866, 0.46194, 0.83147, 0.39285, 0.58794, 0.70711, 0.2706, 0.65328, 0.70711, 0.24277, 0.5861, 0.77301, 0.35245, 0.52748, 0.77301, 0.42946, 0.64273, 0.63439, 0.29582, 0.71417, 0.63439, 0.2706, 0.65328, 0.70711, 0.39285, 0.58794, 0.70711, 0.46194, 0.69134, 0.55557, 0.31819, 0.76818, 0.55557, 0.29582, 0.71417, 0.63439, 0.42946, 0.64273, 0.63439, 0.48997, 0.73329, 0.4714, 0.3375, 0.81479, 0.4714, 0.31819, 0.76818, 0.55557, 0.46194, 0.69134, 0.55557, 0.51328, 0.76818, 0.38268, 0.35355, 0.85355, 0.38268, 0.3375, 0.81479, 0.4714, 0.48997, 0.73329, 0.4714, 0.53165, 0.79567, 0.29028, 0.36621, 0.8841, 0.29028, 0.35355, 0.85355, 0.38268, 0.51328, 0.76818, 0.38268, 0.54489, 0.81549, 0.19509, 0.37533, 0.90613, 0.19509, 0.36621, 0.8841, 0.29028, 0.53165, 0.79567, 0.29028, 0.55289, 0.82747, 0.09802, 0.38084, 0.91943, 0.09802, 0.37533, 0.90613, 0.19509, 0.54489, 0.81549, 0.19509, 0.55557, 0.83147, -0, 0.38268, 0.92388, -0, 0.38084, 0.91943, 0.09802, 0.55289, 0.82747, 0.09802, 0.55289, 0.82747, -0.09802, 0.38084, 0.91943, -0.09802, 0.38268, 0.92388, -0, 0.55557, 0.83147, -0, 0.54489, 0.81549, -0.19509, 0.37533, 0.90613, -0.19509, 0.38084, 0.91943, -0.09802, 0.55289, 0.82747, -0.09802, 0.53165, 0.79567, -0.29028, 0.36621, 0.8841, -0.29028, 0.37533, 0.90613, -0.19509, 0.54489, 0.81549, -0.19509, 0.51328, 0.76818, -0.38268, 0.35355, 0.85355, -0.38268, 0.36621, 0.8841, -0.29028, 0.53165, 0.79567, -0.29028, 0.48997, 0.73329, -0.4714, 0.3375, 0.81479, -0.4714, 0.35355, 0.85355, -0.38268, 0.51328, 0.76818, -0.38268, 0.46194, 0.69134, -0.55557, 0.31819, 0.76818, -0.55557, 0.3375, 0.81479, -0.4714, 0.48997, 0.73329, -0.4714, 0.42946, 0.64273, -0.63439, 0.29582, 0.71417, -0.63439, 0.31819, 0.76818, -0.55557, 0.46194, 0.69134, -0.55557, 0.39285, 0.58794, -0.70711, 0.2706, 0.65328, -0.70711, 0.29582, 0.71417, -0.63439, 0.42946, 0.64273, -0.63439, 0.35245, 0.52748, -0.77301, 0.24277, 0.5861, -0.77301, 0.2706, 0.65328, -0.70711, 0.39285, 0.58794, -0.70711, 0.30866, 0.46194, -0.83147, 0.21261, 0.51328, -0.83147, 0.24277, 0.5861, -0.77301, 0.35245, 0.52748, -0.77301, 0.26189, 0.39195, -0.88192, 0.1804, 0.43551, -0.88192, 0.21261, 0.51328, -0.83147, 0.30866, 0.46194, -0.83147, 0.21261, 0.31819, -0.92388, 0.14645, 0.35355, -0.92388, 0.1804, 0.43551, -0.88192, 0.26189, 0.39195, -0.88192, 0.16127, 0.24136, -0.95694, 0.11109, 0.26819, -0.95694, 0.14645, 0.35355, -0.92388, 0.21261, 0.31819, -0.92388, 0.10839, 0.16221, -0.98079, 0.07466, 0.18024, -0.98079, 0.11109, 0.26819, -0.95694, 0.16127, 0.24136, -0.95694, 0.05445, 0.0815, -0.99518, 0.03751, 0.09056, -0.99518, 0.07466, 0.18024, -0.98079, 0.10839, 0.16221, -0.98079, -0, -0, -1, 0.03751, 0.09056, -0.99518, 0.05445, 0.0815, -0.99518, -0, -0, -1, 0.01912, 0.09613, -0.99518, 0.03751, 0.09056, -0.99518, 0.03751, 0.09056, -0.99518, 0.01912, 0.09613, -0.99518, 0.03806, 0.19134, -0.98079, 0.07466, 0.18024, -0.98079, 0.07466, 0.18024, -0.98079, 0.03806, 0.19134, -0.98079, 0.05663, 0.28471, -0.95694, 0.11109, 0.26819, -0.95694, 0.11109, 0.26819, -0.95694, 0.05663, 0.28471, -0.95694, 0.07466, 0.37533, -0.92388, 0.14645, 0.35355, -0.92388, 0.14645, 0.35355, -0.92388, 0.07466, 0.37533, -0.92388, 0.09196, 0.46234, -0.88192, 0.1804, 0.43551, -0.88192, 0.1804, 0.43551, -0.88192, 0.09196, 0.46234, -0.88192, 0.10839, 0.54489, -0.83147, 0.21261, 0.51328, -0.83147, 0.21261, 0.51328, -0.83147, 0.10839, 0.54489, -0.83147, 0.12376, 0.6222, -0.77301, 0.24277, 0.5861, -0.77301, 0.24277, 0.5861, -0.77301, 0.12376, 0.6222, -0.77301, 0.13795, 0.69352, -0.70711, 0.2706, 0.65328, -0.70711, 0.2706, 0.65328, -0.70711, 0.13795, 0.69352, -0.70711, 0.15081, 0.75816, -0.63439, 0.29582, 0.71417, -0.63439, 0.29582, 0.71417, -0.63439, 0.15081, 0.75816, -0.63439, 0.16221, 0.81549, -0.55557, 0.31819, 0.76818, -0.55557, 0.31819, 0.76818, -0.55557, 0.16221, 0.81549, -0.55557, 0.17205, 0.86498, -0.4714, 0.3375, 0.81479, -0.4714, 0.3375, 0.81479, -0.4714, 0.17205, 0.86498, -0.4714, 0.18024, 0.90613, -0.38268, 0.35355, 0.85355, -0.38268, 0.35355, 0.85355, -0.38268, 0.18024, 0.90613, -0.38268, 0.18669, 0.93855, -0.29028, 0.36621, 0.8841, -0.29028, 0.36621, 0.8841, -0.29028, 0.18669, 0.93855, -0.29028, 0.19134, 0.96194, -0.19509, 0.37533, 0.90613, -0.19509, 0.37533, 0.90613, -0.19509, 0.19134, 0.96194, -0.19509, 0.19415, 0.97606, -0.09802, 0.38084, 0.91943, -0.09802, 0.38084, 0.91943, -0.09802, 0.19415, 0.97606, -0.09802, 0.19509, 0.98079, -0, 0.38268, 0.92388, -0, 0.38268, 0.92388, -0, 0.19509, 0.98079, -0, 0.19415, 0.97606, 0.09802, 0.38084, 0.91943, 0.09802, 0.38084, 0.91943, 0.09802, 0.19415, 0.97606, 0.09802, 0.19134, 0.96194, 0.19509, 0.37533, 0.90613, 0.19509, 0.37533, 0.90613, 0.19509, 0.19134, 0.96194, 0.19509, 0.18669, 0.93855, 0.29028, 0.36621, 0.8841, 0.29028, 0.36621, 0.8841, 0.29028, 0.18669, 0.93855, 0.29028, 0.18024, 0.90613, 0.38268, 0.35355, 0.85355, 0.38268, 0.35355, 0.85355, 0.38268, 0.18024, 0.90613, 0.38268, 0.17205, 0.86498, 0.4714, 0.3375, 0.81479, 0.4714, 0.3375, 0.81479, 0.4714, 0.17205, 0.86498, 0.4714, 0.16221, 0.81549, 0.55557, 0.31819, 0.76818, 0.55557, 0.31819, 0.76818, 0.55557, 0.16221, 0.81549, 0.55557, 0.15081, 0.75816, 0.63439, 0.29582, 0.71417, 0.63439, 0.29582, 0.71417, 0.63439, 0.15081, 0.75816, 0.63439, 0.13795, 0.69352, 0.70711, 0.2706, 0.65328, 0.70711, 0.2706, 0.65328, 0.70711, 0.13795, 0.69352, 0.70711, 0.12376, 0.6222, 0.77301, 0.24277, 0.5861, 0.77301, 0.24277, 0.5861, 0.77301, 0.12376, 0.6222, 0.77301, 0.10839, 0.5449, 0.83147, 0.21261, 0.51328, 0.83147, 0.21261, 0.51328, 0.83147, 0.10839, 0.5449, 0.83147, 0.09196, 0.46234, 0.88192, 0.1804, 0.43551, 0.88192, 0.1804, 0.43551, 0.88192, 0.09196, 0.46234, 0.88192, 0.07466, 0.37533, 0.92388, 0.14645, 0.35355, 0.92388, 0.14645, 0.35355, 0.92388, 0.07466, 0.37533, 0.92388, 0.05663, 0.28471, 0.95694, 0.11109, 0.26819, 0.95694, 0.11109, 0.26819, 0.95694, 0.05663, 0.28471, 0.95694, 0.03806, 0.19134, 0.98079, 0.07466, 0.18024, 0.98079, 0.07466, 0.18024, 0.98079, 0.03806, 0.19134, 0.98079, 0.01912, 0.09613, 0.99518, 0.03751, 0.09056, 0.99518, 0.01912, 0.09613, 0.99518, 0, 0, 1, 0.03751, 0.09056, 0.99518, -0, 0.09802, 0.99518, 0, 0, 1, 0.01912, 0.09613, 0.99518, 0.03806, 0.19134, 0.98079, -0, 0.19509, 0.98079, -0, 0.09802, 0.99518, 0.01912, 0.09613, 0.99518, 0.05663, 0.28471, 0.95694, -0, 0.29028, 0.95694, -0, 0.19509, 0.98079, 0.03806, 0.19134, 0.98079, 0.07466, 0.37533, 0.92388, -0, 0.38268, 0.92388, -0, 0.29028, 0.95694, 0.05663, 0.28471, 0.95694, 0.09196, 0.46234, 0.88192, -0, 0.4714, 0.88192, -0, 0.38268, 0.92388, 0.07466, 0.37533, 0.92388, 0.10839, 0.5449, 0.83147, -0, 0.55557, 0.83147, -0, 0.4714, 0.88192, 0.09196, 0.46234, 0.88192, 0.12376, 0.6222, 0.77301, -0, 0.63439, 0.77301, -0, 0.55557, 0.83147, 0.10839, 0.5449, 0.83147, 0.13795, 0.69352, 0.70711, -0, 0.70711, 0.70711, -0, 0.63439, 0.77301, 0.12376, 0.6222, 0.77301, 0.15081, 0.75816, 0.63439, -0, 0.77301, 0.63439, -0, 0.70711, 0.70711, 0.13795, 0.69352, 0.70711, 0.16221, 0.81549, 0.55557, 0, 0.83147, 0.55557, -0, 0.77301, 0.63439, 0.15081, 0.75816, 0.63439, 0.17205, 0.86498, 0.4714, -0, 0.88192, 0.4714, 0, 0.83147, 0.55557, 0.16221, 0.81549, 0.55557, 0.18024, 0.90613, 0.38268, -0, 0.92388, 0.38268, -0, 0.88192, 0.4714, 0.17205, 0.86498, 0.4714, 0.18669, 0.93855, 0.29028, -0, 0.95694, 0.29028, -0, 0.92388, 0.38268, 0.18024, 0.90613, 0.38268, 0.19134, 0.96194, 0.19509, -0, 0.98079, 0.19509, -0, 0.95694, 0.29028, 0.18669, 0.93855, 0.29028, 0.19415, 0.97606, 0.09802, -0, 0.99518, 0.09802, -0, 0.98079, 0.19509, 0.19134, 0.96194, 0.19509, 0.19509, 0.98079, -0, -0, 1, -0, -0, 0.99518, 0.09802, 0.19415, 0.97606, 0.09802, 0.19415, 0.97606, -0.09802, -0, 0.99518, -0.09802, -0, 1, -0, 0.19509, 0.98079, -0, 0.19134, 0.96194, -0.19509, -0, 0.98078, -0.19509, -0, 0.99518, -0.09802, 0.19415, 0.97606, -0.09802, 0.18669, 0.93855, -0.29028, -0, 0.95694, -0.29028, -0, 0.98078, -0.19509, 0.19134, 0.96194, -0.19509, 0.18024, 0.90613, -0.38268, -0, 0.92388, -0.38268, -0, 0.95694, -0.29028, 0.18669, 0.93855, -0.29028, 0.17205, 0.86498, -0.4714, -0, 0.88192, -0.4714, -0, 0.92388, -0.38268, 0.18024, 0.90613, -0.38268, 0.16221, 0.81549, -0.55557, -0, 0.83147, -0.55557, -0, 0.88192, -0.4714, 0.17205, 0.86498, -0.4714, 0.15081, 0.75816, -0.63439, -0, 0.77301, -0.63439, -0, 0.83147, -0.55557, 0.16221, 0.81549, -0.55557, 0.13795, 0.69352, -0.70711, -0, 0.70711, -0.70711, -0, 0.77301, -0.63439, 0.15081, 0.75816, -0.63439, 0.12376, 0.6222, -0.77301, -0, 0.63439, -0.77301, -0, 0.70711, -0.70711, 0.13795, 0.69352, -0.70711, 0.10839, 0.54489, -0.83147, -0, 0.55557, -0.83147, -0, 0.63439, -0.77301, 0.12376, 0.6222, -0.77301, 0.09196, 0.46234, -0.88192, -0, 0.4714, -0.88192, -0, 0.55557, -0.83147, 0.10839, 0.54489, -0.83147, 0.07466, 0.37533, -0.92388, -0, 0.38268, -0.92388, -0, 0.4714, -0.88192, 0.09196, 0.46234, -0.88192, 0.05663, 0.28471, -0.95694, -0, 0.29028, -0.95694, -0, 0.38268, -0.92388, 0.07466, 0.37533, -0.92388, 0.03806, 0.19134, -0.98079, -0, 0.19509, -0.98079, -0, 0.29028, -0.95694, 0.05663, 0.28471, -0.95694, 0.01912, 0.09613, -0.99518, -0, 0.09802, -0.99518, -0, 0.19509, -0.98079, 0.03806, 0.19134, -0.98079, -0, -0, -1, -0, 0.09802, -0.99518, 0.01912, 0.09613, -0.99518, -0, -0, -1, -0.01912, 0.09613, -0.99518, -0, 0.09802, -0.99518, -0, 0.09802, -0.99518, -0.01912, 0.09613, -0.99518, -0.03806, 0.19134, -0.98079, -0, 0.19509, -0.98079, -0, 0.19509, -0.98079, -0.03806, 0.19134, -0.98079, -0.05663, 0.28471, -0.95694, -0, 0.29028, -0.95694, -0, 0.29028, -0.95694, -0.05663, 0.28471, -0.95694, -0.07466, 0.37533, -0.92388, -0, 0.38268, -0.92388, -0, 0.38268, -0.92388, -0.07466, 0.37533, -0.92388, -0.09196, 0.46234, -0.88192, -0, 0.4714, -0.88192, -0, 0.4714, -0.88192, -0.09196, 0.46234, -0.88192, -0.10839, 0.54489, -0.83147, -0, 0.55557, -0.83147, -0, 0.55557, -0.83147, -0.10839, 0.54489, -0.83147, -0.12376, 0.6222, -0.77301, -0, 0.63439, -0.77301, -0, 0.63439, -0.77301, -0.12376, 0.6222, -0.77301, -0.13795, 0.69352, -0.70711, -0, 0.70711, -0.70711, -0, 0.70711, -0.70711, -0.13795, 0.69352, -0.70711, -0.15081, 0.75816, -0.63439, -0, 0.77301, -0.63439, -0, 0.77301, -0.63439, -0.15081, 0.75816, -0.63439, -0.16221, 0.81549, -0.55557, -0, 0.83147, -0.55557, -0, 0.83147, -0.55557, -0.16221, 0.81549, -0.55557, -0.17205, 0.86498, -0.4714, -0, 0.88192, -0.4714, -0, 0.88192, -0.4714, -0.17205, 0.86498, -0.4714, -0.18024, 0.90613, -0.38268, -0, 0.92388, -0.38268, -0, 0.92388, -0.38268, -0.18024, 0.90613, -0.38268, -0.18669, 0.93855, -0.29028, -0, 0.95694, -0.29028, -0, 0.95694, -0.29028, -0.18669, 0.93855, -0.29028, -0.19134, 0.96194, -0.19509, -0, 0.98078, -0.19509, -0, 0.98078, -0.19509, -0.19134, 0.96194, -0.19509, -0.19415, 0.97606, -0.09802, -0, 0.99518, -0.09802, -0, 0.99518, -0.09802, -0.19415, 0.97606, -0.09802, -0.19509, 0.98078, -0, -0, 1, -0, -0, 1, -0, -0.19509, 0.98078, -0, -0.19415, 0.97606, 0.09802, -0, 0.99518, 0.09802, -0, 0.99518, 0.09802, -0.19415, 0.97606, 0.09802, -0.19134, 0.96194, 0.19509, -0, 0.98079, 0.19509, -0, 0.98079, 0.19509, -0.19134, 0.96194, 0.19509, -0.18669, 0.93855, 0.29028, -0, 0.95694, 0.29028, -0, 0.95694, 0.29028, -0.18669, 0.93855, 0.29028, -0.18024, 0.90613, 0.38268, -0, 0.92388, 0.38268, -0, 0.92388, 0.38268, -0.18024, 0.90613, 0.38268, -0.17205, 0.86498, 0.4714, -0, 0.88192, 0.4714, -0, 0.88192, 0.4714, -0.17205, 0.86498, 0.4714, -0.16221, 0.81549, 0.55557, 0, 0.83147, 0.55557, 0, 0.83147, 0.55557, -0.16221, 0.81549, 0.55557, -0.15081, 0.75816, 0.63439, -0, 0.77301, 0.63439, -0, 0.77301, 0.63439, -0.15081, 0.75816, 0.63439, -0.13795, 0.69352, 0.70711, -0, 0.70711, 0.70711, -0, 0.70711, 0.70711, -0.13795, 0.69352, 0.70711, -0.12376, 0.6222, 0.77301, -0, 0.63439, 0.77301, -0, 0.63439, 0.77301, -0.12376, 0.6222, 0.77301, -0.10839, 0.54489, 0.83147, -0, 0.55557, 0.83147, -0, 0.55557, 0.83147, -0.10839, 0.54489, 0.83147, -0.09196, 0.46234, 0.88192, -0, 0.4714, 0.88192, -0, 0.4714, 0.88192, -0.09196, 0.46234, 0.88192, -0.07466, 0.37533, 0.92388, -0, 0.38268, 0.92388, -0, 0.38268, 0.92388, -0.07466, 0.37533, 0.92388, -0.05663, 0.28471, 0.95694, -0, 0.29028, 0.95694, -0, 0.29028, 0.95694, -0.05663, 0.28471, 0.95694, -0.03806, 0.19134, 0.98079, -0, 0.19509, 0.98079, -0, 0.19509, 0.98079, -0.03806, 0.19134, 0.98079, -0.01912, 0.09613, 0.99518, -0, 0.09802, 0.99518, -0.01912, 0.09613, 0.99518, 0, 0, 1, -0, 0.09802, 0.99518, -0.03751, 0.09056, 0.99518, 0, 0, 1, -0.01912, 0.09613, 0.99518, -0.03806, 0.19134, 0.98079, -0.07466, 0.18024, 0.98079, -0.03751, 0.09056, 0.99518, -0.01912, 0.09613, 0.99518, -0.05663, 0.28471, 0.95694, -0.11109, 0.26819, 0.95694, -0.07466, 0.18024, 0.98079, -0.03806, 0.19134, 0.98079, -0.07466, 0.37533, 0.92388, -0.14645, 0.35355, 0.92388, -0.11109, 0.26819, 0.95694, -0.05663, 0.28471, 0.95694, -0.09196, 0.46234, 0.88192, -0.1804, 0.43551, 0.88192, -0.14645, 0.35355, 0.92388, -0.07466, 0.37533, 0.92388, -0.10839, 0.54489, 0.83147, -0.21261, 0.51328, 0.83147, -0.1804, 0.43551, 0.88192, -0.09196, 0.46234, 0.88192, -0.12376, 0.6222, 0.77301, -0.24277, 0.5861, 0.77301, -0.21261, 0.51328, 0.83147, -0.10839, 0.54489, 0.83147, -0.13795, 0.69352, 0.70711, -0.2706, 0.65328, 0.70711, -0.24277, 0.5861, 0.77301, -0.12376, 0.6222, 0.77301, -0.15081, 0.75816, 0.63439, -0.29582, 0.71417, 0.63439, -0.2706, 0.65328, 0.70711, -0.13795, 0.69352, 0.70711, -0.16221, 0.81549, 0.55557, -0.31819, 0.76818, 0.55557, -0.29582, 0.71417, 0.63439, -0.15081, 0.75816, 0.63439, -0.17205, 0.86498, 0.4714, -0.3375, 0.81479, 0.4714, -0.31819, 0.76818, 0.55557, -0.16221, 0.81549, 0.55557, -0.18024, 0.90613, 0.38268, -0.35355, 0.85355, 0.38268, -0.3375, 0.81479, 0.4714, -0.17205, 0.86498, 0.4714, -0.18669, 0.93855, 0.29028, -0.36621, 0.8841, 0.29028, -0.35355, 0.85355, 0.38268, -0.18024, 0.90613, 0.38268, -0.19134, 0.96194, 0.19509, -0.37533, 0.90613, 0.19509, -0.36621, 0.8841, 0.29028, -0.18669, 0.93855, 0.29028, -0.19415, 0.97606, 0.09802, -0.38084, 0.91943, 0.09802, -0.37533, 0.90613, 0.19509, -0.19134, 0.96194, 0.19509, -0.19509, 0.98078, -0, -0.38268, 0.92388, -0, -0.38084, 0.91943, 0.09802, -0.19415, 0.97606, 0.09802, -0.19415, 0.97606, -0.09802, -0.38084, 0.91943, -0.09802, -0.38268, 0.92388, -0, -0.19509, 0.98078, -0, -0.19134, 0.96194, -0.19509, -0.37533, 0.90613, -0.19509, -0.38084, 0.91943, -0.09802, -0.19415, 0.97606, -0.09802, -0.18669, 0.93855, -0.29028, -0.36621, 0.8841, -0.29028, -0.37533, 0.90613, -0.19509, -0.19134, 0.96194, -0.19509, -0.18024, 0.90613, -0.38268, -0.35355, 0.85355, -0.38268, -0.36621, 0.8841, -0.29028, -0.18669, 0.93855, -0.29028, -0.17205, 0.86498, -0.4714, -0.3375, 0.81479, -0.4714, -0.35355, 0.85355, -0.38268, -0.18024, 0.90613, -0.38268, -0.16221, 0.81549, -0.55557, -0.31819, 0.76818, -0.55557, -0.3375, 0.81479, -0.4714, -0.17205, 0.86498, -0.4714, -0.15081, 0.75816, -0.63439, -0.29582, 0.71417, -0.63439, -0.31819, 0.76818, -0.55557, -0.16221, 0.81549, -0.55557, -0.13795, 0.69352, -0.70711, -0.2706, 0.65328, -0.70711, -0.29582, 0.71417, -0.63439, -0.15081, 0.75816, -0.63439, -0.12376, 0.6222, -0.77301, -0.24277, 0.5861, -0.77301, -0.2706, 0.65328, -0.70711, -0.13795, 0.69352, -0.70711, -0.10839, 0.54489, -0.83147, -0.21261, 0.51328, -0.83147, -0.24277, 0.5861, -0.77301, -0.12376, 0.6222, -0.77301, -0.09196, 0.46234, -0.88192, -0.1804, 0.43551, -0.88192, -0.21261, 0.51328, -0.83147, -0.10839, 0.54489, -0.83147, -0.07466, 0.37533, -0.92388, -0.14645, 0.35355, -0.92388, -0.1804, 0.43551, -0.88192, -0.09196, 0.46234, -0.88192, -0.05663, 0.28471, -0.95694, -0.11109, 0.26819, -0.95694, -0.14645, 0.35355, -0.92388, -0.07466, 0.37533, -0.92388, -0.03806, 0.19134, -0.98079, -0.07466, 0.18024, -0.98079, -0.11109, 0.26819, -0.95694, -0.05663, 0.28471, -0.95694, -0.01912, 0.09613, -0.99518, -0.03751, 0.09056, -0.99518, -0.07466, 0.18024, -0.98079, -0.03806, 0.19134, -0.98079, -0, -0, -1, -0.03751, 0.09056, -0.99518, -0.01912, 0.09613, -0.99518, -0, -0, -1, -0.05445, 0.0815, -0.99518, -0.03751, 0.09056, -0.99518, -0.03751, 0.09056, -0.99518, -0.05445, 0.0815, -0.99518, -0.10839, 0.16221, -0.98079, -0.07466, 0.18024, -0.98079, -0.07466, 0.18024, -0.98079, -0.10839, 0.16221, -0.98079, -0.16127, 0.24136, -0.95694, -0.11109, 0.26819, -0.95694, -0.11109, 0.26819, -0.95694, -0.16127, 0.24136, -0.95694, -0.21261, 0.31819, -0.92388, -0.14645, 0.35355, -0.92388, -0.14645, 0.35355, -0.92388, -0.21261, 0.31819, -0.92388, -0.26189, 0.39195, -0.88192, -0.1804, 0.43551, -0.88192, -0.1804, 0.43551, -0.88192, -0.26189, 0.39195, -0.88192, -0.30866, 0.46194, -0.83147, -0.21261, 0.51328, -0.83147, -0.21261, 0.51328, -0.83147, -0.30866, 0.46194, -0.83147, -0.35245, 0.52748, -0.77301, -0.24277, 0.5861, -0.77301, -0.24277, 0.5861, -0.77301, -0.35245, 0.52748, -0.77301, -0.39285, 0.58794, -0.70711, -0.2706, 0.65328, -0.70711, -0.2706, 0.65328, -0.70711, -0.39285, 0.58794, -0.70711, -0.42946, 0.64273, -0.63439, -0.29582, 0.71417, -0.63439, -0.29582, 0.71417, -0.63439, -0.42946, 0.64273, -0.63439, -0.46194, 0.69134, -0.55557, -0.31819, 0.76818, -0.55557, -0.31819, 0.76818, -0.55557, -0.46194, 0.69134, -0.55557, -0.48997, 0.73329, -0.4714, -0.3375, 0.81479, -0.4714, -0.3375, 0.81479, -0.4714, -0.48997, 0.73329, -0.4714, -0.51328, 0.76818, -0.38268, -0.35355, 0.85355, -0.38268, -0.35355, 0.85355, -0.38268, -0.51328, 0.76818, -0.38268, -0.53165, 0.79567, -0.29028, -0.36621, 0.8841, -0.29028, -0.36621, 0.8841, -0.29028, -0.53165, 0.79567, -0.29028, -0.54489, 0.81549, -0.19509, -0.37533, 0.90613, -0.19509, -0.37533, 0.90613, -0.19509, -0.54489, 0.81549, -0.19509, -0.55289, 0.82747, -0.09802, -0.38084, 0.91943, -0.09802, -0.38084, 0.91943, -0.09802, -0.55289, 0.82747, -0.09802, -0.55557, 0.83147, -0, -0.38268, 0.92388, -0, -0.38268, 0.92388, -0, -0.55557, 0.83147, -0, -0.55289, 0.82747, 0.09802, -0.38084, 0.91943, 0.09802, -0.38084, 0.91943, 0.09802, -0.55289, 0.82747, 0.09802, -0.54489, 0.81549, 0.19509, -0.37533, 0.90613, 0.19509, -0.37533, 0.90613, 0.19509, -0.54489, 0.81549, 0.19509, -0.53165, 0.79567, 0.29028, -0.36621, 0.8841, 0.29028, -0.36621, 0.8841, 0.29028, -0.53165, 0.79567, 0.29028, -0.51328, 0.76818, 0.38268, -0.35355, 0.85355, 0.38268, -0.35355, 0.85355, 0.38268, -0.51328, 0.76818, 0.38268, -0.48997, 0.73329, 0.4714, -0.3375, 0.81479, 0.4714, -0.3375, 0.81479, 0.4714, -0.48997, 0.73329, 0.4714, -0.46194, 0.69134, 0.55557, -0.31819, 0.76818, 0.55557, -0.31819, 0.76818, 0.55557, -0.46194, 0.69134, 0.55557, -0.42946, 0.64273, 0.63439, -0.29582, 0.71417, 0.63439, -0.29582, 0.71417, 0.63439, -0.42946, 0.64273, 0.63439, -0.39285, 0.58794, 0.70711, -0.2706, 0.65328, 0.70711, -0.2706, 0.65328, 0.70711, -0.39285, 0.58794, 0.70711, -0.35245, 0.52748, 0.77301, -0.24277, 0.5861, 0.77301, -0.24277, 0.5861, 0.77301, -0.35245, 0.52748, 0.77301, -0.30866, 0.46194, 0.83147, -0.21261, 0.51328, 0.83147, -0.21261, 0.51328, 0.83147, -0.30866, 0.46194, 0.83147, -0.26189, 0.39195, 0.88192, -0.1804, 0.43551, 0.88192, -0.1804, 0.43551, 0.88192, -0.26189, 0.39195, 0.88192, -0.21261, 0.31819, 0.92388, -0.14645, 0.35355, 0.92388, -0.14645, 0.35355, 0.92388, -0.21261, 0.31819, 0.92388, -0.16127, 0.24136, 0.95694, -0.11109, 0.26819, 0.95694, -0.11109, 0.26819, 0.95694, -0.16127, 0.24136, 0.95694, -0.10839, 0.16221, 0.98079, -0.07466, 0.18024, 0.98079, -0.07466, 0.18024, 0.98079, -0.10839, 0.16221, 0.98079, -0.05446, 0.0815, 0.99518, -0.03751, 0.09056, 0.99518, -0.05446, 0.0815, 0.99518, 0, 0, 1, -0.03751, 0.09056, 0.99518, -0.06931, 0.06931, 0.99518, 0, 0, 1, -0.05446, 0.0815, 0.99518, -0.10839, 0.16221, 0.98079, -0.13795, 0.13795, 0.98079, -0.06931, 0.06931, 0.99518, -0.05446, 0.0815, 0.99518, -0.16127, 0.24136, 0.95694, -0.20526, 0.20526, 0.95694, -0.13795, 0.13795, 0.98079, -0.10839, 0.16221, 0.98079, -0.21261, 0.31819, 0.92388, -0.2706, 0.2706, 0.92388, -0.20526, 0.20526, 0.95694, -0.16127, 0.24136, 0.95694, -0.26189, 0.39195, 0.88192, -0.33333, 0.33333, 0.88192, -0.2706, 0.2706, 0.92388, -0.21261, 0.31819, 0.92388, -0.30866, 0.46194, 0.83147, -0.39285, 0.39285, 0.83147, -0.33333, 0.33333, 0.88192, -0.26189, 0.39195, 0.88192, -0.35245, 0.52748, 0.77301, -0.44858, 0.44858, 0.77301, -0.39285, 0.39285, 0.83147, -0.30866, 0.46194, 0.83147, -0.39285, 0.58794, 0.70711, -0.5, 0.5, 0.70711, -0.44858, 0.44858, 0.77301, -0.35245, 0.52748, 0.77301, -0.42946, 0.64273, 0.63439, -0.5466, 0.5466, 0.63439, -0.5, 0.5, 0.70711, -0.39285, 0.58794, 0.70711, -0.46194, 0.69134, 0.55557, -0.58794, 0.58794, 0.55557, -0.5466, 0.5466, 0.63439, -0.42946, 0.64273, 0.63439, -0.48997, 0.73329, 0.4714, -0.62361, 0.62361, 0.4714, -0.58794, 0.58794, 0.55557, -0.46194, 0.69134, 0.55557, -0.51328, 0.76818, 0.38268, -0.65328, 0.65328, 0.38268, -0.62361, 0.62361, 0.4714, -0.48997, 0.73329, 0.4714, -0.53165, 0.79567, 0.29028, -0.67666, 0.67666, 0.29028, -0.65328, 0.65328, 0.38268, -0.51328, 0.76818, 0.38268, -0.54489, 0.81549, 0.19509, -0.69352, 0.69352, 0.19509, -0.67666, 0.67666, 0.29028, -0.53165, 0.79567, 0.29028, -0.55289, 0.82747, 0.09802, -0.7037, 0.7037, 0.09802, -0.69352, 0.69352, 0.19509, -0.54489, 0.81549, 0.19509, -0.55557, 0.83147, -0, -0.70711, 0.70711, -0, -0.7037, 0.7037, 0.09802, -0.55289, 0.82747, 0.09802, -0.55289, 0.82747, -0.09802, -0.7037, 0.7037, -0.09802, -0.70711, 0.70711, -0, -0.55557, 0.83147, -0, -0.54489, 0.81549, -0.19509, -0.69352, 0.69352, -0.19509, -0.7037, 0.7037, -0.09802, -0.55289, 0.82747, -0.09802, -0.53165, 0.79567, -0.29028, -0.67666, 0.67666, -0.29028, -0.69352, 0.69352, -0.19509, -0.54489, 0.81549, -0.19509, -0.51328, 0.76818, -0.38268, -0.65328, 0.65328, -0.38268, -0.67666, 0.67666, -0.29028, -0.53165, 0.79567, -0.29028, -0.48997, 0.73329, -0.4714, -0.62361, 0.62361, -0.4714, -0.65328, 0.65328, -0.38268, -0.51328, 0.76818, -0.38268, -0.46194, 0.69134, -0.55557, -0.58794, 0.58794, -0.55557, -0.62361, 0.62361, -0.4714, -0.48997, 0.73329, -0.4714, -0.42946, 0.64273, -0.63439, -0.5466, 0.5466, -0.63439, -0.58794, 0.58794, -0.55557, -0.46194, 0.69134, -0.55557, -0.39285, 0.58794, -0.70711, -0.5, 0.5, -0.70711, -0.5466, 0.5466, -0.63439, -0.42946, 0.64273, -0.63439, -0.35245, 0.52748, -0.77301, -0.44858, 0.44858, -0.77301, -0.5, 0.5, -0.70711, -0.39285, 0.58794, -0.70711, -0.30866, 0.46194, -0.83147, -0.39285, 0.39285, -0.83147, -0.44858, 0.44858, -0.77301, -0.35245, 0.52748, -0.77301, -0.26189, 0.39195, -0.88192, -0.33333, 0.33333, -0.88192, -0.39285, 0.39285, -0.83147, -0.30866, 0.46194, -0.83147, -0.21261, 0.31819, -0.92388, -0.2706, 0.2706, -0.92388, -0.33333, 0.33333, -0.88192, -0.26189, 0.39195, -0.88192, -0.16127, 0.24136, -0.95694, -0.20526, 0.20526, -0.95694, -0.2706, 0.2706, -0.92388, -0.21261, 0.31819, -0.92388, -0.10839, 0.16221, -0.98079, -0.13795, 0.13795, -0.98079, -0.20526, 0.20526, -0.95694, -0.16127, 0.24136, -0.95694, -0.05445, 0.0815, -0.99518, -0.06931, 0.06931, -0.99518, -0.13795, 0.13795, -0.98079, -0.10839, 0.16221, -0.98079, -0, -0, -1, -0.06931, 0.06931, -0.99518, -0.05445, 0.0815, -0.99518, -0, -0, -1, -0.0815, 0.05445, -0.99518, -0.06931, 0.06931, -0.99518, -0.06931, 0.06931, -0.99518, -0.0815, 0.05445, -0.99518, -0.16221, 0.10839, -0.98079, -0.13795, 0.13795, -0.98079, -0.13795, 0.13795, -0.98079, -0.16221, 0.10839, -0.98079, -0.24136, 0.16127, -0.95694, -0.20526, 0.20526, -0.95694, -0.20526, 0.20526, -0.95694, -0.24136, 0.16127, -0.95694, -0.31819, 0.21261, -0.92388, -0.2706, 0.2706, -0.92388, -0.2706, 0.2706, -0.92388, -0.31819, 0.21261, -0.92388, -0.39195, 0.26189, -0.88192, -0.33333, 0.33333, -0.88192, -0.33333, 0.33333, -0.88192, -0.39195, 0.26189, -0.88192, -0.46194, 0.30866, -0.83147, -0.39285, 0.39285, -0.83147, -0.39285, 0.39285, -0.83147, -0.46194, 0.30866, -0.83147, -0.52748, 0.35245, -0.77301, -0.44858, 0.44858, -0.77301, -0.44858, 0.44858, -0.77301, -0.52748, 0.35245, -0.77301, -0.58794, 0.39285, -0.70711, -0.5, 0.5, -0.70711, -0.5, 0.5, -0.70711, -0.58794, 0.39285, -0.70711, -0.64273, 0.42946, -0.63439, -0.5466, 0.5466, -0.63439, -0.5466, 0.5466, -0.63439, -0.64273, 0.42946, -0.63439, -0.69134, 0.46194, -0.55557, -0.58794, 0.58794, -0.55557, -0.58794, 0.58794, -0.55557, -0.69134, 0.46194, -0.55557, -0.73329, 0.48997, -0.4714, -0.62361, 0.62361, -0.4714, -0.62361, 0.62361, -0.4714, -0.73329, 0.48997, -0.4714, -0.76818, 0.51328, -0.38268, -0.65328, 0.65328, -0.38268, -0.65328, 0.65328, -0.38268, -0.76818, 0.51328, -0.38268, -0.79567, 0.53165, -0.29028, -0.67666, 0.67666, -0.29028, -0.67666, 0.67666, -0.29028, -0.79567, 0.53165, -0.29028, -0.81549, 0.54489, -0.19509, -0.69352, 0.69352, -0.19509, -0.69352, 0.69352, -0.19509, -0.81549, 0.54489, -0.19509, -0.82747, 0.55289, -0.09802, -0.7037, 0.7037, -0.09802, -0.7037, 0.7037, -0.09802, -0.82747, 0.55289, -0.09802, -0.83147, 0.55557, -0, -0.70711, 0.70711, -0, -0.70711, 0.70711, -0, -0.83147, 0.55557, -0, -0.82747, 0.55289, 0.09802, -0.7037, 0.7037, 0.09802, -0.7037, 0.7037, 0.09802, -0.82747, 0.55289, 0.09802, -0.81549, 0.54489, 0.19509, -0.69352, 0.69352, 0.19509, -0.69352, 0.69352, 0.19509, -0.81549, 0.54489, 0.19509, -0.79567, 0.53165, 0.29028, -0.67666, 0.67666, 0.29028, -0.67666, 0.67666, 0.29028, -0.79567, 0.53165, 0.29028, -0.76818, 0.51328, 0.38268, -0.65328, 0.65328, 0.38268, -0.65328, 0.65328, 0.38268, -0.76818, 0.51328, 0.38268, -0.73329, 0.48997, 0.4714, -0.62361, 0.62361, 0.4714, -0.62361, 0.62361, 0.4714, -0.73329, 0.48997, 0.4714, -0.69134, 0.46194, 0.55557, -0.58794, 0.58794, 0.55557, -0.58794, 0.58794, 0.55557, -0.69134, 0.46194, 0.55557, -0.64273, 0.42946, 0.63439, -0.5466, 0.5466, 0.63439, -0.5466, 0.5466, 0.63439, -0.64273, 0.42946, 0.63439, -0.58794, 0.39285, 0.70711, -0.5, 0.5, 0.70711, -0.5, 0.5, 0.70711, -0.58794, 0.39285, 0.70711, -0.52748, 0.35245, 0.77301, -0.44858, 0.44858, 0.77301, -0.44858, 0.44858, 0.77301, -0.52748, 0.35245, 0.77301, -0.46194, 0.30866, 0.83147, -0.39285, 0.39285, 0.83147, -0.39285, 0.39285, 0.83147, -0.46194, 0.30866, 0.83147, -0.39195, 0.26189, 0.88192, -0.33333, 0.33333, 0.88192, -0.33333, 0.33333, 0.88192, -0.39195, 0.26189, 0.88192, -0.31819, 0.21261, 0.92388, -0.2706, 0.2706, 0.92388, -0.2706, 0.2706, 0.92388, -0.31819, 0.21261, 0.92388, -0.24136, 0.16127, 0.95694, -0.20526, 0.20526, 0.95694, -0.20526, 0.20526, 0.95694, -0.24136, 0.16127, 0.95694, -0.16221, 0.10839, 0.98079, -0.13795, 0.13795, 0.98079, -0.13795, 0.13795, 0.98079, -0.16221, 0.10839, 0.98079, -0.0815, 0.05446, 0.99518, -0.06931, 0.06931, 0.99518, -0.0815, 0.05446, 0.99518, 0, 0, 1, -0.06931, 0.06931, 0.99518, -0.09056, 0.03751, 0.99518, 0, 0, 1, -0.0815, 0.05446, 0.99518, -0.16221, 0.10839, 0.98079, -0.18024, 0.07466, 0.98079, -0.09056, 0.03751, 0.99518, -0.0815, 0.05446, 0.99518, -0.24136, 0.16127, 0.95694, -0.26819, 0.11109, 0.95694, -0.18024, 0.07466, 0.98079, -0.16221, 0.10839, 0.98079, -0.31819, 0.21261, 0.92388, -0.35355, 0.14645, 0.92388, -0.26819, 0.11109, 0.95694, -0.24136, 0.16127, 0.95694, -0.39195, 0.26189, 0.88192, -0.43551, 0.1804, 0.88192, -0.35355, 0.14645, 0.92388, -0.31819, 0.21261, 0.92388, -0.46194, 0.30866, 0.83147, -0.51328, 0.21261, 0.83147, -0.43551, 0.1804, 0.88192, -0.39195, 0.26189, 0.88192, -0.52748, 0.35245, 0.77301, -0.5861, 0.24277, 0.77301, -0.51328, 0.21261, 0.83147, -0.46194, 0.30866, 0.83147, -0.58794, 0.39285, 0.70711, -0.65328, 0.2706, 0.70711, -0.5861, 0.24277, 0.77301, -0.52748, 0.35245, 0.77301, -0.64273, 0.42946, 0.63439, -0.71417, 0.29582, 0.63439, -0.65328, 0.2706, 0.70711, -0.58794, 0.39285, 0.70711, -0.69134, 0.46194, 0.55557, -0.76818, 0.31819, 0.55557, -0.71417, 0.29582, 0.63439, -0.64273, 0.42946, 0.63439, -0.73329, 0.48997, 0.4714, -0.81479, 0.3375, 0.4714, -0.76818, 0.31819, 0.55557, -0.69134, 0.46194, 0.55557, -0.76818, 0.51328, 0.38268, -0.85355, 0.35355, 0.38268, -0.81479, 0.3375, 0.4714, -0.73329, 0.48997, 0.4714, -0.79567, 0.53165, 0.29028, -0.8841, 0.3662, 0.29028, -0.85355, 0.35355, 0.38268, -0.76818, 0.51328, 0.38268, -0.81549, 0.54489, 0.19509, -0.90613, 0.37533, 0.19509, -0.8841, 0.3662, 0.29028, -0.79567, 0.53165, 0.29028, -0.82747, 0.55289, 0.09802, -0.91943, 0.38084, 0.09802, -0.90613, 0.37533, 0.19509, -0.81549, 0.54489, 0.19509, -0.83147, 0.55557, -0, -0.92388, 0.38268, -0, -0.91943, 0.38084, 0.09802, -0.82747, 0.55289, 0.09802, -0.82747, 0.55289, -0.09802, -0.91943, 0.38084, -0.09802, -0.92388, 0.38268, -0, -0.83147, 0.55557, -0, -0.81549, 0.54489, -0.19509, -0.90613, 0.37533, -0.19509, -0.91943, 0.38084, -0.09802, -0.82747, 0.55289, -0.09802, -0.79567, 0.53165, -0.29028, -0.8841, 0.3662, -0.29028, -0.90613, 0.37533, -0.19509, -0.81549, 0.54489, -0.19509, -0.76818, 0.51328, -0.38268, -0.85355, 0.35355, -0.38268, -0.8841, 0.3662, -0.29028, -0.79567, 0.53165, -0.29028, -0.73329, 0.48997, -0.4714, -0.81479, 0.3375, -0.4714, -0.85355, 0.35355, -0.38268, -0.76818, 0.51328, -0.38268, -0.69134, 0.46194, -0.55557, -0.76818, 0.31819, -0.55557, -0.81479, 0.3375, -0.4714, -0.73329, 0.48997, -0.4714, -0.64273, 0.42946, -0.63439, -0.71417, 0.29582, -0.63439, -0.76818, 0.31819, -0.55557, -0.69134, 0.46194, -0.55557, -0.58794, 0.39285, -0.70711, -0.65328, 0.2706, -0.70711, -0.71417, 0.29582, -0.63439, -0.64273, 0.42946, -0.63439, -0.52748, 0.35245, -0.77301, -0.5861, 0.24277, -0.77301, -0.65328, 0.2706, -0.70711, -0.58794, 0.39285, -0.70711, -0.46194, 0.30866, -0.83147, -0.51328, 0.21261, -0.83147, -0.5861, 0.24277, -0.77301, -0.52748, 0.35245, -0.77301, -0.39195, 0.26189, -0.88192, -0.43551, 0.1804, -0.88192, -0.51328, 0.21261, -0.83147, -0.46194, 0.30866, -0.83147, -0.31819, 0.21261, -0.92388, -0.35355, 0.14645, -0.92388, -0.43551, 0.1804, -0.88192, -0.39195, 0.26189, -0.88192, -0.24136, 0.16127, -0.95694, -0.26819, 0.11109, -0.95694, -0.35355, 0.14645, -0.92388, -0.31819, 0.21261, -0.92388, -0.16221, 0.10839, -0.98079, -0.18024, 0.07466, -0.98079, -0.26819, 0.11109, -0.95694, -0.24136, 0.16127, -0.95694, -0.0815, 0.05445, -0.99518, -0.09056, 0.03751, -0.99518, -0.18024, 0.07466, -0.98079, -0.16221, 0.10839, -0.98079, -0, -0, -1, -0.09056, 0.03751, -0.99518, -0.0815, 0.05445, -0.99518, -0, -0, -1, -0.09613, 0.01912, -0.99518, -0.09056, 0.03751, -0.99518, -0.09056, 0.03751, -0.99518, -0.09613, 0.01912, -0.99518, -0.19134, 0.03806, -0.98079, -0.18024, 0.07466, -0.98079, -0.18024, 0.07466, -0.98079, -0.19134, 0.03806, -0.98079, -0.28471, 0.05663, -0.95694, -0.26819, 0.11109, -0.95694, -0.26819, 0.11109, -0.95694, -0.28471, 0.05663, -0.95694, -0.37533, 0.07466, -0.92388, -0.35355, 0.14645, -0.92388, -0.35355, 0.14645, -0.92388, -0.37533, 0.07466, -0.92388, -0.46234, 0.09196, -0.88192, -0.43551, 0.1804, -0.88192, -0.43551, 0.1804, -0.88192, -0.46234, 0.09196, -0.88192, -0.54489, 0.10839, -0.83147, -0.51328, 0.21261, -0.83147, -0.51328, 0.21261, -0.83147, -0.54489, 0.10839, -0.83147, -0.6222, 0.12376, -0.77301, -0.5861, 0.24277, -0.77301, -0.5861, 0.24277, -0.77301, -0.6222, 0.12376, -0.77301, -0.69352, 0.13795, -0.70711, -0.65328, 0.2706, -0.70711, -0.65328, 0.2706, -0.70711, -0.69352, 0.13795, -0.70711, -0.75816, 0.15081, -0.63439, -0.71417, 0.29582, -0.63439, -0.71417, 0.29582, -0.63439, -0.75816, 0.15081, -0.63439, -0.81549, 0.16221, -0.55557, -0.76818, 0.31819, -0.55557, -0.76818, 0.31819, -0.55557, -0.81549, 0.16221, -0.55557, -0.86497, 0.17205, -0.4714, -0.81479, 0.3375, -0.4714, -0.81479, 0.3375, -0.4714, -0.86497, 0.17205, -0.4714, -0.90613, 0.18024, -0.38268, -0.85355, 0.35355, -0.38268, -0.85355, 0.35355, -0.38268, -0.90613, 0.18024, -0.38268, -0.93855, 0.18669, -0.29028, -0.8841, 0.3662, -0.29028, -0.8841, 0.3662, -0.29028, -0.93855, 0.18669, -0.29028, -0.96194, 0.19134, -0.19509, -0.90613, 0.37533, -0.19509, -0.90613, 0.37533, -0.19509, -0.96194, 0.19134, -0.19509, -0.97606, 0.19415, -0.09802, -0.91943, 0.38084, -0.09802, -0.91943, 0.38084, -0.09802, -0.97606, 0.19415, -0.09802, -0.98078, 0.19509, -0, -0.92388, 0.38268, -0, -0.92388, 0.38268, -0, -0.98078, 0.19509, -0, -0.97606, 0.19415, 0.09802, -0.91943, 0.38084, 0.09802, -0.91943, 0.38084, 0.09802, -0.97606, 0.19415, 0.09802, -0.96194, 0.19134, 0.19509, -0.90613, 0.37533, 0.19509, -0.90613, 0.37533, 0.19509, -0.96194, 0.19134, 0.19509, -0.93855, 0.18669, 0.29028, -0.8841, 0.3662, 0.29028, -0.8841, 0.3662, 0.29028, -0.93855, 0.18669, 0.29028, -0.90613, 0.18024, 0.38268, -0.85355, 0.35355, 0.38268, -0.85355, 0.35355, 0.38268, -0.90613, 0.18024, 0.38268, -0.86498, 0.17205, 0.4714, -0.81479, 0.3375, 0.4714, -0.81479, 0.3375, 0.4714, -0.86498, 0.17205, 0.4714, -0.81549, 0.16221, 0.55557, -0.76818, 0.31819, 0.55557, -0.76818, 0.31819, 0.55557, -0.81549, 0.16221, 0.55557, -0.75816, 0.15081, 0.63439, -0.71417, 0.29582, 0.63439, -0.71417, 0.29582, 0.63439, -0.75816, 0.15081, 0.63439, -0.69352, 0.13795, 0.70711, -0.65328, 0.2706, 0.70711, -0.65328, 0.2706, 0.70711, -0.69352, 0.13795, 0.70711, -0.6222, 0.12376, 0.77301, -0.5861, 0.24277, 0.77301, -0.5861, 0.24277, 0.77301, -0.6222, 0.12376, 0.77301, -0.54489, 0.10839, 0.83147, -0.51328, 0.21261, 0.83147, -0.51328, 0.21261, 0.83147, -0.54489, 0.10839, 0.83147, -0.46234, 0.09196, 0.88192, -0.43551, 0.1804, 0.88192, -0.43551, 0.1804, 0.88192, -0.46234, 0.09196, 0.88192, -0.37533, 0.07466, 0.92388, -0.35355, 0.14645, 0.92388, -0.35355, 0.14645, 0.92388, -0.37533, 0.07466, 0.92388, -0.28471, 0.05663, 0.95694, -0.26819, 0.11109, 0.95694, -0.26819, 0.11109, 0.95694, -0.28471, 0.05663, 0.95694, -0.19134, 0.03806, 0.98079, -0.18024, 0.07466, 0.98079, -0.18024, 0.07466, 0.98079, -0.19134, 0.03806, 0.98079, -0.09613, 0.01912, 0.99518, -0.09056, 0.03751, 0.99518, -0.09613, 0.01912, 0.99518, 0, 0, 1, -0.09056, 0.03751, 0.99518, -0.09802, -0, 0.99518, 0, 0, 1, -0.09613, 0.01912, 0.99518, -0.19134, 0.03806, 0.98079, -0.19509, -0, 0.98079, -0.09802, -0, 0.99518, -0.09613, 0.01912, 0.99518, -0.28471, 0.05663, 0.95694, -0.29028, -0, 0.95694, -0.19509, -0, 0.98079, -0.19134, 0.03806, 0.98079, -0.37533, 0.07466, 0.92388, -0.38268, -0, 0.92388, -0.29028, -0, 0.95694, -0.28471, 0.05663, 0.95694, -0.46234, 0.09196, 0.88192, -0.4714, -0, 0.88192, -0.38268, -0, 0.92388, -0.37533, 0.07466, 0.92388, -0.54489, 0.10839, 0.83147, -0.55557, -0, 0.83147, -0.4714, -0, 0.88192, -0.46234, 0.09196, 0.88192, -0.6222, 0.12376, 0.77301, -0.63439, -0, 0.77301, -0.55557, -0, 0.83147, -0.54489, 0.10839, 0.83147, -0.69352, 0.13795, 0.70711, -0.70711, -0, 0.70711, -0.63439, -0, 0.77301, -0.6222, 0.12376, 0.77301, -0.75816, 0.15081, 0.63439, -0.77301, -0, 0.63439, -0.70711, -0, 0.70711, -0.69352, 0.13795, 0.70711, -0.81549, 0.16221, 0.55557, -0.83147, -0, 0.55557, -0.77301, -0, 0.63439, -0.75816, 0.15081, 0.63439, -0.86498, 0.17205, 0.4714, -0.88192, -0, 0.4714, -0.83147, -0, 0.55557, -0.81549, 0.16221, 0.55557, -0.90613, 0.18024, 0.38268, -0.92388, -0, 0.38268, -0.88192, -0, 0.4714, -0.86498, 0.17205, 0.4714, -0.93855, 0.18669, 0.29028, -0.95694, -0, 0.29028, -0.92388, -0, 0.38268, -0.90613, 0.18024, 0.38268, -0.96194, 0.19134, 0.19509, -0.98078, -0, 0.19509, -0.95694, -0, 0.29028, -0.93855, 0.18669, 0.29028, -0.97606, 0.19415, 0.09802, -0.99518, -0, 0.09802, -0.98078, -0, 0.19509, -0.96194, 0.19134, 0.19509, -0.98078, 0.19509, -0, -1, -0, -0, -0.99518, -0, 0.09802, -0.97606, 0.19415, 0.09802, -0.97606, 0.19415, -0.09802, -0.99518, -0, -0.09802, -1, -0, -0, -0.98078, 0.19509, -0, -0.96194, 0.19134, -0.19509, -0.98078, -0, -0.19509, -0.99518, -0, -0.09802, -0.97606, 0.19415, -0.09802, -0.93855, 0.18669, -0.29028, -0.95694, -0, -0.29028, -0.98078, -0, -0.19509, -0.96194, 0.19134, -0.19509, -0.90613, 0.18024, -0.38268, -0.92388, -0, -0.38268, -0.95694, -0, -0.29028, -0.93855, 0.18669, -0.29028, -0.86497, 0.17205, -0.4714, -0.88192, -0, -0.4714, -0.92388, -0, -0.38268, -0.90613, 0.18024, -0.38268, -0.81549, 0.16221, -0.55557, -0.83147, -0, -0.55557, -0.88192, -0, -0.4714, -0.86497, 0.17205, -0.4714, -0.75816, 0.15081, -0.63439, -0.77301, -0, -0.63439, -0.83147, -0, -0.55557, -0.81549, 0.16221, -0.55557, -0.69352, 0.13795, -0.70711, -0.70711, -0, -0.70711, -0.77301, -0, -0.63439, -0.75816, 0.15081, -0.63439, -0.6222, 0.12376, -0.77301, -0.63439, -0, -0.77301, -0.70711, -0, -0.70711, -0.69352, 0.13795, -0.70711, -0.54489, 0.10839, -0.83147, -0.55557, -0, -0.83147, -0.63439, -0, -0.77301, -0.6222, 0.12376, -0.77301, -0.46234, 0.09196, -0.88192, -0.4714, -0, -0.88192, -0.55557, -0, -0.83147, -0.54489, 0.10839, -0.83147, -0.37533, 0.07466, -0.92388, -0.38268, -0, -0.92388, -0.4714, -0, -0.88192, -0.46234, 0.09196, -0.88192, -0.28471, 0.05663, -0.95694, -0.29028, -0, -0.95694, -0.38268, -0, -0.92388, -0.37533, 0.07466, -0.92388, -0.19134, 0.03806, -0.98079, -0.19509, -0, -0.98079, -0.29028, -0, -0.95694, -0.28471, 0.05663, -0.95694, -0.09613, 0.01912, -0.99518, -0.09802, -0, -0.99518, -0.19509, -0, -0.98079, -0.19134, 0.03806, -0.98079, -0, -0, -1, -0.09802, -0, -0.99518, -0.09613, 0.01912, -0.99518, -0, -0, -1, -0.09613, -0.01912, -0.99518, -0.09802, -0, -0.99518, -0.09802, -0, -0.99518, -0.09613, -0.01912, -0.99518, -0.19134, -0.03806, -0.98079, -0.19509, -0, -0.98079, -0.19509, -0, -0.98079, -0.19134, -0.03806, -0.98079, -0.28471, -0.05663, -0.95694, -0.29028, -0, -0.95694, -0.29028, -0, -0.95694, -0.28471, -0.05663, -0.95694, -0.37533, -0.07466, -0.92388, -0.38268, -0, -0.92388, -0.38268, -0, -0.92388, -0.37533, -0.07466, -0.92388, -0.46234, -0.09196, -0.88192, -0.4714, -0, -0.88192, -0.4714, -0, -0.88192, -0.46234, -0.09196, -0.88192, -0.54489, -0.10839, -0.83147, -0.55557, -0, -0.83147, -0.55557, -0, -0.83147, -0.54489, -0.10839, -0.83147, -0.6222, -0.12376, -0.77301, -0.63439, -0, -0.77301, -0.63439, -0, -0.77301, -0.6222, -0.12376, -0.77301, -0.69352, -0.13795, -0.70711, -0.70711, -0, -0.70711, -0.70711, -0, -0.70711, -0.69352, -0.13795, -0.70711, -0.75816, -0.15081, -0.63439, -0.77301, -0, -0.63439, -0.77301, -0, -0.63439, -0.75816, -0.15081, -0.63439, -0.81549, -0.16221, -0.55557, -0.83147, -0, -0.55557, -0.83147, -0, -0.55557, -0.81549, -0.16221, -0.55557, -0.86497, -0.17205, -0.4714, -0.88192, -0, -0.4714, -0.88192, -0, -0.4714, -0.86497, -0.17205, -0.4714, -0.90613, -0.18024, -0.38268, -0.92388, -0, -0.38268, -0.92388, -0, -0.38268, -0.90613, -0.18024, -0.38268, -0.93855, -0.18669, -0.29028, -0.95694, -0, -0.29028, -0.95694, -0, -0.29028, -0.93855, -0.18669, -0.29028, -0.96194, -0.19134, -0.19509, -0.98078, -0, -0.19509, -0.98078, -0, -0.19509, -0.96194, -0.19134, -0.19509, -0.97606, -0.19415, -0.09802, -0.99518, -0, -0.09802, -0.99518, -0, -0.09802, -0.97606, -0.19415, -0.09802, -0.98078, -0.19509, -0, -1, -0, -0, -1, -0, -0, -0.98078, -0.19509, -0, -0.97606, -0.19415, 0.09802, -0.99518, -0, 0.09802, -0.99518, -0, 0.09802, -0.97606, -0.19415, 0.09802, -0.96194, -0.19134, 0.19509, -0.98078, -0, 0.19509, -0.98078, -0, 0.19509, -0.96194, -0.19134, 0.19509, -0.93855, -0.18669, 0.29028, -0.95694, -0, 0.29028, -0.95694, -0, 0.29028, -0.93855, -0.18669, 0.29028, -0.90613, -0.18024, 0.38268, -0.92388, -0, 0.38268, -0.92388, -0, 0.38268, -0.90613, -0.18024, 0.38268, -0.86497, -0.17205, 0.4714, -0.88192, -0, 0.4714, -0.88192, -0, 0.4714, -0.86497, -0.17205, 0.4714, -0.81549, -0.16221, 0.55557, -0.83147, -0, 0.55557, -0.83147, -0, 0.55557, -0.81549, -0.16221, 0.55557, -0.75816, -0.15081, 0.63439, -0.77301, -0, 0.63439, -0.77301, -0, 0.63439, -0.75816, -0.15081, 0.63439, -0.69352, -0.13795, 0.70711, -0.70711, -0, 0.70711, -0.70711, -0, 0.70711, -0.69352, -0.13795, 0.70711, -0.6222, -0.12376, 0.77301, -0.63439, -0, 0.77301, -0.63439, -0, 0.77301, -0.6222, -0.12376, 0.77301, -0.54489, -0.10839, 0.83147, -0.55557, -0, 0.83147, -0.55557, -0, 0.83147, -0.54489, -0.10839, 0.83147, -0.46234, -0.09196, 0.88192, -0.4714, -0, 0.88192, -0.4714, -0, 0.88192, -0.46234, -0.09196, 0.88192, -0.37533, -0.07466, 0.92388, -0.38268, -0, 0.92388, -0.38268, -0, 0.92388, -0.37533, -0.07466, 0.92388, -0.28471, -0.05663, 0.95694, -0.29028, -0, 0.95694, -0.29028, -0, 0.95694, -0.28471, -0.05663, 0.95694, -0.19134, -0.03806, 0.98079, -0.19509, -0, 0.98079, -0.19509, -0, 0.98079, -0.19134, -0.03806, 0.98079, -0.09613, -0.01912, 0.99518, -0.09802, -0, 0.99518, -0.09613, -0.01912, 0.99518, 0, 0, 1, -0.09802, -0, 0.99518, -0.09056, -0.03751, 0.99518, 0, 0, 1, -0.09613, -0.01912, 0.99518, -0.19134, -0.03806, 0.98079, -0.18024, -0.07466, 0.98079, -0.09056, -0.03751, 0.99518, -0.09613, -0.01912, 0.99518, -0.28471, -0.05663, 0.95694, -0.26819, -0.11109, 0.95694, -0.18024, -0.07466, 0.98079, -0.19134, -0.03806, 0.98079, -0.37533, -0.07466, 0.92388, -0.35355, -0.14645, 0.92388, -0.26819, -0.11109, 0.95694, -0.28471, -0.05663, 0.95694, -0.46234, -0.09196, 0.88192, -0.43551, -0.1804, 0.88192, -0.35355, -0.14645, 0.92388, -0.37533, -0.07466, 0.92388, -0.54489, -0.10839, 0.83147, -0.51328, -0.21261, 0.83147, -0.43551, -0.1804, 0.88192, -0.46234, -0.09196, 0.88192, -0.6222, -0.12376, 0.77301, -0.5861, -0.24277, 0.77301, -0.51328, -0.21261, 0.83147, -0.54489, -0.10839, 0.83147, -0.69352, -0.13795, 0.70711, -0.65328, -0.2706, 0.70711, -0.5861, -0.24277, 0.77301, -0.6222, -0.12376, 0.77301, -0.75816, -0.15081, 0.63439, -0.71417, -0.29582, 0.63439, -0.65328, -0.2706, 0.70711, -0.69352, -0.13795, 0.70711, -0.81549, -0.16221, 0.55557, -0.76818, -0.31819, 0.55557, -0.71417, -0.29582, 0.63439, -0.75816, -0.15081, 0.63439, -0.86497, -0.17205, 0.4714, -0.81479, -0.3375, 0.4714, -0.76818, -0.31819, 0.55557, -0.81549, -0.16221, 0.55557, -0.90613, -0.18024, 0.38268, -0.85355, -0.35355, 0.38268, -0.81479, -0.3375, 0.4714, -0.86497, -0.17205, 0.4714, -0.93855, -0.18669, 0.29028, -0.8841, -0.36621, 0.29028, -0.85355, -0.35355, 0.38268, -0.90613, -0.18024, 0.38268, -0.96194, -0.19134, 0.19509, -0.90613, -0.37533, 0.19509, -0.8841, -0.36621, 0.29028, -0.93855, -0.18669, 0.29028, -0.97606, -0.19415, 0.09802, -0.91943, -0.38084, 0.09802, -0.90613, -0.37533, 0.19509, -0.96194, -0.19134, 0.19509, -0.98078, -0.19509, -0, -0.92388, -0.38268, -0, -0.91943, -0.38084, 0.09802, -0.97606, -0.19415, 0.09802, -0.97606, -0.19415, -0.09802, -0.91943, -0.38084, -0.09802, -0.92388, -0.38268, -0, -0.98078, -0.19509, -0, -0.96194, -0.19134, -0.19509, -0.90613, -0.37533, -0.19509, -0.91943, -0.38084, -0.09802, -0.97606, -0.19415, -0.09802, -0.93855, -0.18669, -0.29028, -0.8841, -0.36621, -0.29028, -0.90613, -0.37533, -0.19509, -0.96194, -0.19134, -0.19509, -0.90613, -0.18024, -0.38268, -0.85355, -0.35355, -0.38268, -0.8841, -0.36621, -0.29028, -0.93855, -0.18669, -0.29028, -0.86497, -0.17205, -0.4714, -0.81479, -0.3375, -0.4714, -0.85355, -0.35355, -0.38268, -0.90613, -0.18024, -0.38268, -0.81549, -0.16221, -0.55557, -0.76818, -0.31819, -0.55557, -0.81479, -0.3375, -0.4714, -0.86497, -0.17205, -0.4714, -0.75816, -0.15081, -0.63439, -0.71417, -0.29582, -0.63439, -0.76818, -0.31819, -0.55557, -0.81549, -0.16221, -0.55557, -0.69352, -0.13795, -0.70711, -0.65328, -0.2706, -0.70711, -0.71417, -0.29582, -0.63439, -0.75816, -0.15081, -0.63439, -0.6222, -0.12376, -0.77301, -0.5861, -0.24277, -0.77301, -0.65328, -0.2706, -0.70711, -0.69352, -0.13795, -0.70711, -0.54489, -0.10839, -0.83147, -0.51328, -0.21261, -0.83147, -0.5861, -0.24277, -0.77301, -0.6222, -0.12376, -0.77301, -0.46234, -0.09196, -0.88192, -0.43551, -0.1804, -0.88192, -0.51328, -0.21261, -0.83147, -0.54489, -0.10839, -0.83147, -0.37533, -0.07466, -0.92388, -0.35355, -0.14645, -0.92388, -0.43551, -0.1804, -0.88192, -0.46234, -0.09196, -0.88192, -0.28471, -0.05663, -0.95694, -0.26819, -0.11109, -0.95694, -0.35355, -0.14645, -0.92388, -0.37533, -0.07466, -0.92388, -0.19134, -0.03806, -0.98079, -0.18024, -0.07466, -0.98079, -0.26819, -0.11109, -0.95694, -0.28471, -0.05663, -0.95694, -0.09613, -0.01912, -0.99518, -0.09056, -0.03751, -0.99518, -0.18024, -0.07466, -0.98079, -0.19134, -0.03806, -0.98079, -0, -0, -1, -0.09056, -0.03751, -0.99518, -0.09613, -0.01912, -0.99518, -0, -0, -1, -0.0815, -0.05445, -0.99518, -0.09056, -0.03751, -0.99518, -0.09056, -0.03751, -0.99518, -0.0815, -0.05445, -0.99518, -0.16221, -0.10839, -0.98079, -0.18024, -0.07466, -0.98079, -0.18024, -0.07466, -0.98079, -0.16221, -0.10839, -0.98079, -0.24136, -0.16127, -0.95694, -0.26819, -0.11109, -0.95694, -0.26819, -0.11109, -0.95694, -0.24136, -0.16127, -0.95694, -0.31819, -0.21261, -0.92388, -0.35355, -0.14645, -0.92388, -0.35355, -0.14645, -0.92388, -0.31819, -0.21261, -0.92388, -0.39195, -0.26189, -0.88192, -0.43551, -0.1804, -0.88192, -0.43551, -0.1804, -0.88192, -0.39195, -0.26189, -0.88192, -0.46194, -0.30866, -0.83147, -0.51328, -0.21261, -0.83147, -0.51328, -0.21261, -0.83147, -0.46194, -0.30866, -0.83147, -0.52748, -0.35245, -0.77301, -0.5861, -0.24277, -0.77301, -0.5861, -0.24277, -0.77301, -0.52748, -0.35245, -0.77301, -0.58794, -0.39285, -0.70711, -0.65328, -0.2706, -0.70711, -0.65328, -0.2706, -0.70711, -0.58794, -0.39285, -0.70711, -0.64273, -0.42946, -0.63439, -0.71417, -0.29582, -0.63439, -0.71417, -0.29582, -0.63439, -0.64273, -0.42946, -0.63439, -0.69134, -0.46194, -0.55557, -0.76818, -0.31819, -0.55557, -0.76818, -0.31819, -0.55557, -0.69134, -0.46194, -0.55557, -0.73329, -0.48997, -0.4714, -0.81479, -0.3375, -0.4714, -0.81479, -0.3375, -0.4714, -0.73329, -0.48997, -0.4714, -0.76818, -0.51328, -0.38268, -0.85355, -0.35355, -0.38268, -0.85355, -0.35355, -0.38268, -0.76818, -0.51328, -0.38268, -0.79567, -0.53165, -0.29028, -0.8841, -0.36621, -0.29028, -0.8841, -0.36621, -0.29028, -0.79567, -0.53165, -0.29028, -0.81549, -0.54489, -0.19509, -0.90613, -0.37533, -0.19509, -0.90613, -0.37533, -0.19509, -0.81549, -0.54489, -0.19509, -0.82747, -0.55289, -0.09802, -0.91943, -0.38084, -0.09802, -0.91943, -0.38084, -0.09802, -0.82747, -0.55289, -0.09802, -0.83147, -0.55557, -0, -0.92388, -0.38268, -0, -0.92388, -0.38268, -0, -0.83147, -0.55557, -0, -0.82747, -0.55289, 0.09802, -0.91943, -0.38084, 0.09802, -0.91943, -0.38084, 0.09802, -0.82747, -0.55289, 0.09802, -0.81549, -0.54489, 0.19509, -0.90613, -0.37533, 0.19509, -0.90613, -0.37533, 0.19509, -0.81549, -0.54489, 0.19509, -0.79567, -0.53165, 0.29028, -0.8841, -0.36621, 0.29028, -0.8841, -0.36621, 0.29028, -0.79567, -0.53165, 0.29028, -0.76818, -0.51328, 0.38268, -0.85355, -0.35355, 0.38268, -0.85355, -0.35355, 0.38268, -0.76818, -0.51328, 0.38268, -0.73329, -0.48997, 0.4714, -0.81479, -0.3375, 0.4714, -0.81479, -0.3375, 0.4714, -0.73329, -0.48997, 0.4714, -0.69134, -0.46194, 0.55557, -0.76818, -0.31819, 0.55557, -0.76818, -0.31819, 0.55557, -0.69134, -0.46194, 0.55557, -0.64273, -0.42946, 0.63439, -0.71417, -0.29582, 0.63439, -0.71417, -0.29582, 0.63439, -0.64273, -0.42946, 0.63439, -0.58794, -0.39285, 0.70711, -0.65328, -0.2706, 0.70711, -0.65328, -0.2706, 0.70711, -0.58794, -0.39285, 0.70711, -0.52748, -0.35245, 0.77301, -0.5861, -0.24277, 0.77301, -0.5861, -0.24277, 0.77301, -0.52748, -0.35245, 0.77301, -0.46194, -0.30866, 0.83147, -0.51328, -0.21261, 0.83147, -0.51328, -0.21261, 0.83147, -0.46194, -0.30866, 0.83147, -0.39195, -0.26189, 0.88192, -0.43551, -0.1804, 0.88192, -0.43551, -0.1804, 0.88192, -0.39195, -0.26189, 0.88192, -0.31819, -0.21261, 0.92388, -0.35355, -0.14645, 0.92388, -0.35355, -0.14645, 0.92388, -0.31819, -0.21261, 0.92388, -0.24136, -0.16127, 0.95694, -0.26819, -0.11109, 0.95694, -0.26819, -0.11109, 0.95694, -0.24136, -0.16127, 0.95694, -0.16221, -0.10839, 0.98079, -0.18024, -0.07466, 0.98079, -0.18024, -0.07466, 0.98079, -0.16221, -0.10839, 0.98079, -0.0815, -0.05446, 0.99518, -0.09056, -0.03751, 0.99518, -0.0815, -0.05446, 0.99518, 0, 0, 1, -0.09056, -0.03751, 0.99518, -0.06931, -0.06931, 0.99518, 0, 0, 1, -0.0815, -0.05446, 0.99518, -0.16221, -0.10839, 0.98079, -0.13795, -0.13795, 0.98079, -0.06931, -0.06931, 0.99518, -0.0815, -0.05446, 0.99518, -0.24136, -0.16127, 0.95694, -0.20526, -0.20526, 0.95694, -0.13795, -0.13795, 0.98079, -0.16221, -0.10839, 0.98079, -0.31819, -0.21261, 0.92388, -0.2706, -0.2706, 0.92388, -0.20526, -0.20526, 0.95694, -0.24136, -0.16127, 0.95694, -0.39195, -0.26189, 0.88192, -0.33333, -0.33333, 0.88192, -0.2706, -0.2706, 0.92388, -0.31819, -0.21261, 0.92388, -0.46194, -0.30866, 0.83147, -0.39285, -0.39285, 0.83147, -0.33333, -0.33333, 0.88192, -0.39195, -0.26189, 0.88192, -0.52748, -0.35245, 0.77301, -0.44858, -0.44858, 0.77301, -0.39285, -0.39285, 0.83147, -0.46194, -0.30866, 0.83147, -0.58794, -0.39285, 0.70711, -0.5, -0.5, 0.70711, -0.44858, -0.44858, 0.77301, -0.52748, -0.35245, 0.77301, -0.64273, -0.42946, 0.63439, -0.5466, -0.5466, 0.63439, -0.5, -0.5, 0.70711, -0.58794, -0.39285, 0.70711, -0.69134, -0.46194, 0.55557, -0.58794, -0.58794, 0.55557, -0.5466, -0.5466, 0.63439, -0.64273, -0.42946, 0.63439, -0.73329, -0.48997, 0.4714, -0.62361, -0.62361, 0.4714, -0.58794, -0.58794, 0.55557, -0.69134, -0.46194, 0.55557, -0.76818, -0.51328, 0.38268, -0.65328, -0.65328, 0.38268, -0.62361, -0.62361, 0.4714, -0.73329, -0.48997, 0.4714, -0.79567, -0.53165, 0.29028, -0.67666, -0.67666, 0.29028, -0.65328, -0.65328, 0.38268, -0.76818, -0.51328, 0.38268, -0.81549, -0.54489, 0.19509, -0.69352, -0.69352, 0.19509, -0.67666, -0.67666, 0.29028, -0.79567, -0.53165, 0.29028, -0.82747, -0.55289, 0.09802, -0.7037, -0.7037, 0.09802, -0.69352, -0.69352, 0.19509, -0.81549, -0.54489, 0.19509, -0.83147, -0.55557, -0, -0.70711, -0.70711, -0, -0.7037, -0.7037, 0.09802, -0.82747, -0.55289, 0.09802, -0.82747, -0.55289, -0.09802, -0.7037, -0.7037, -0.09802, -0.70711, -0.70711, -0, -0.83147, -0.55557, -0, -0.81549, -0.54489, -0.19509, -0.69352, -0.69352, -0.19509, -0.7037, -0.7037, -0.09802, -0.82747, -0.55289, -0.09802, -0.79567, -0.53165, -0.29028, -0.67666, -0.67666, -0.29028, -0.69352, -0.69352, -0.19509, -0.81549, -0.54489, -0.19509, -0.76818, -0.51328, -0.38268, -0.65328, -0.65328, -0.38268, -0.67666, -0.67666, -0.29028, -0.79567, -0.53165, -0.29028, -0.73329, -0.48997, -0.4714, -0.62361, -0.62361, -0.4714, -0.65328, -0.65328, -0.38268, -0.76818, -0.51328, -0.38268, -0.69134, -0.46194, -0.55557, -0.58794, -0.58794, -0.55557, -0.62361, -0.62361, -0.4714, -0.73329, -0.48997, -0.4714, -0.64273, -0.42946, -0.63439, -0.5466, -0.5466, -0.63439, -0.58794, -0.58794, -0.55557, -0.69134, -0.46194, -0.55557, -0.58794, -0.39285, -0.70711, -0.5, -0.5, -0.70711, -0.5466, -0.5466, -0.63439, -0.64273, -0.42946, -0.63439, -0.52748, -0.35245, -0.77301, -0.44858, -0.44858, -0.77301, -0.5, -0.5, -0.70711, -0.58794, -0.39285, -0.70711, -0.46194, -0.30866, -0.83147, -0.39285, -0.39285, -0.83147, -0.44858, -0.44858, -0.77301, -0.52748, -0.35245, -0.77301, -0.39195, -0.26189, -0.88192, -0.33333, -0.33333, -0.88192, -0.39285, -0.39285, -0.83147, -0.46194, -0.30866, -0.83147, -0.31819, -0.21261, -0.92388, -0.2706, -0.2706, -0.92388, -0.33333, -0.33333, -0.88192, -0.39195, -0.26189, -0.88192, -0.24136, -0.16127, -0.95694, -0.20526, -0.20526, -0.95694, -0.2706, -0.2706, -0.92388, -0.31819, -0.21261, -0.92388, -0.16221, -0.10839, -0.98079, -0.13795, -0.13795, -0.98079, -0.20526, -0.20526, -0.95694, -0.24136, -0.16127, -0.95694, -0.0815, -0.05445, -0.99518, -0.06931, -0.06931, -0.99518, -0.13795, -0.13795, -0.98079, -0.16221, -0.10839, -0.98079, -0, -0, -1, -0.06931, -0.06931, -0.99518, -0.0815, -0.05445, -0.99518, -0, -0, -1, -0.05445, -0.0815, -0.99518, -0.06931, -0.06931, -0.99518, -0.06931, -0.06931, -0.99518, -0.05445, -0.0815, -0.99518, -0.10839, -0.16221, -0.98079, -0.13795, -0.13795, -0.98079, -0.13795, -0.13795, -0.98079, -0.10839, -0.16221, -0.98079, -0.16127, -0.24136, -0.95694, -0.20526, -0.20526, -0.95694, -0.20526, -0.20526, -0.95694, -0.16127, -0.24136, -0.95694, -0.21261, -0.31819, -0.92388, -0.2706, -0.2706, -0.92388, -0.2706, -0.2706, -0.92388, -0.21261, -0.31819, -0.92388, -0.26189, -0.39195, -0.88192, -0.33333, -0.33333, -0.88192, -0.33333, -0.33333, -0.88192, -0.26189, -0.39195, -0.88192, -0.30866, -0.46194, -0.83147, -0.39285, -0.39285, -0.83147, -0.39285, -0.39285, -0.83147, -0.30866, -0.46194, -0.83147, -0.35245, -0.52748, -0.77301, -0.44858, -0.44858, -0.77301, -0.44858, -0.44858, -0.77301, -0.35245, -0.52748, -0.77301, -0.39285, -0.58794, -0.70711, -0.5, -0.5, -0.70711, -0.5, -0.5, -0.70711, -0.39285, -0.58794, -0.70711, -0.42946, -0.64273, -0.63439, -0.5466, -0.5466, -0.63439, -0.5466, -0.5466, -0.63439, -0.42946, -0.64273, -0.63439, -0.46194, -0.69134, -0.55557, -0.58794, -0.58794, -0.55557, -0.58794, -0.58794, -0.55557, -0.46194, -0.69134, -0.55557, -0.48997, -0.73329, -0.4714, -0.62361, -0.62361, -0.4714, -0.62361, -0.62361, -0.4714, -0.48997, -0.73329, -0.4714, -0.51328, -0.76818, -0.38268, -0.65328, -0.65328, -0.38268, -0.65328, -0.65328, -0.38268, -0.51328, -0.76818, -0.38268, -0.53165, -0.79567, -0.29028, -0.67666, -0.67666, -0.29028, -0.67666, -0.67666, -0.29028, -0.53165, -0.79567, -0.29028, -0.54489, -0.81549, -0.19509, -0.69352, -0.69352, -0.19509, -0.69352, -0.69352, -0.19509, -0.54489, -0.81549, -0.19509, -0.55289, -0.82747, -0.09802, -0.7037, -0.7037, -0.09802, -0.7037, -0.7037, -0.09802, -0.55289, -0.82747, -0.09802, -0.55557, -0.83147, -0, -0.70711, -0.70711, -0, -0.70711, -0.70711, -0, -0.55557, -0.83147, -0, -0.55289, -0.82747, 0.09802, -0.7037, -0.7037, 0.09802, -0.7037, -0.7037, 0.09802, -0.55289, -0.82747, 0.09802, -0.54489, -0.81549, 0.19509, -0.69352, -0.69352, 0.19509, -0.69352, -0.69352, 0.19509, -0.54489, -0.81549, 0.19509, -0.53165, -0.79567, 0.29028, -0.67666, -0.67666, 0.29028, -0.67666, -0.67666, 0.29028, -0.53165, -0.79567, 0.29028, -0.51328, -0.76818, 0.38268, -0.65328, -0.65328, 0.38268, -0.65328, -0.65328, 0.38268, -0.51328, -0.76818, 0.38268, -0.48997, -0.73329, 0.4714, -0.62361, -0.62361, 0.4714, -0.62361, -0.62361, 0.4714, -0.48997, -0.73329, 0.4714, -0.46194, -0.69134, 0.55557, -0.58794, -0.58794, 0.55557, -0.58794, -0.58794, 0.55557, -0.46194, -0.69134, 0.55557, -0.42946, -0.64273, 0.63439, -0.5466, -0.5466, 0.63439, -0.5466, -0.5466, 0.63439, -0.42946, -0.64273, 0.63439, -0.39285, -0.58794, 0.70711, -0.5, -0.5, 0.70711, -0.5, -0.5, 0.70711, -0.39285, -0.58794, 0.70711, -0.35245, -0.52748, 0.77301, -0.44858, -0.44858, 0.77301, -0.44858, -0.44858, 0.77301, -0.35245, -0.52748, 0.77301, -0.30866, -0.46194, 0.83147, -0.39285, -0.39285, 0.83147, -0.39285, -0.39285, 0.83147, -0.30866, -0.46194, 0.83147, -0.26189, -0.39195, 0.88192, -0.33333, -0.33333, 0.88192, -0.33333, -0.33333, 0.88192, -0.26189, -0.39195, 0.88192, -0.21261, -0.31819, 0.92388, -0.2706, -0.2706, 0.92388, -0.2706, -0.2706, 0.92388, -0.21261, -0.31819, 0.92388, -0.16127, -0.24136, 0.95694, -0.20526, -0.20526, 0.95694, -0.20526, -0.20526, 0.95694, -0.16127, -0.24136, 0.95694, -0.10839, -0.16221, 0.98079, -0.13795, -0.13795, 0.98079, -0.13795, -0.13795, 0.98079, -0.10839, -0.16221, 0.98079, -0.05446, -0.0815, 0.99518, -0.06931, -0.06931, 0.99518, -0.05446, -0.0815, 0.99518, 0, 0, 1, -0.06931, -0.06931, 0.99518, -0.03751, -0.09056, 0.99518, 0, 0, 1, -0.05446, -0.0815, 0.99518, -0.10839, -0.16221, 0.98079, -0.07466, -0.18024, 0.98079, -0.03751, -0.09056, 0.99518, -0.05446, -0.0815, 0.99518, -0.16127, -0.24136, 0.95694, -0.11109, -0.26819, 0.95694, -0.07466, -0.18024, 0.98079, -0.10839, -0.16221, 0.98079, -0.21261, -0.31819, 0.92388, -0.14645, -0.35355, 0.92388, -0.11109, -0.26819, 0.95694, -0.16127, -0.24136, 0.95694, -0.26189, -0.39195, 0.88192, -0.1804, -0.43551, 0.88192, -0.14645, -0.35355, 0.92388, -0.21261, -0.31819, 0.92388, -0.30866, -0.46194, 0.83147, -0.21261, -0.51328, 0.83147, -0.1804, -0.43551, 0.88192, -0.26189, -0.39195, 0.88192, -0.35245, -0.52748, 0.77301, -0.24277, -0.5861, 0.77301, -0.21261, -0.51328, 0.83147, -0.30866, -0.46194, 0.83147, -0.39285, -0.58794, 0.70711, -0.2706, -0.65328, 0.70711, -0.24277, -0.5861, 0.77301, -0.35245, -0.52748, 0.77301, -0.42946, -0.64273, 0.63439, -0.29582, -0.71417, 0.63439, -0.2706, -0.65328, 0.70711, -0.39285, -0.58794, 0.70711, -0.46194, -0.69134, 0.55557, -0.31819, -0.76818, 0.55557, -0.29582, -0.71417, 0.63439, -0.42946, -0.64273, 0.63439, -0.48997, -0.73329, 0.4714, -0.3375, -0.81479, 0.4714, -0.31819, -0.76818, 0.55557, -0.46194, -0.69134, 0.55557, -0.51328, -0.76818, 0.38268, -0.35355, -0.85355, 0.38268, -0.3375, -0.81479, 0.4714, -0.48997, -0.73329, 0.4714, -0.53165, -0.79567, 0.29028, -0.3662, -0.8841, 0.29028, -0.35355, -0.85355, 0.38268, -0.51328, -0.76818, 0.38268, -0.54489, -0.81549, 0.19509, -0.37533, -0.90613, 0.19509, -0.3662, -0.8841, 0.29028, -0.53165, -0.79567, 0.29028, -0.55289, -0.82747, 0.09802, -0.38084, -0.91943, 0.09802, -0.37533, -0.90613, 0.19509, -0.54489, -0.81549, 0.19509, -0.55557, -0.83147, -0, -0.38268, -0.92388, -0, -0.38084, -0.91943, 0.09802, -0.55289, -0.82747, 0.09802, -0.55289, -0.82747, -0.09802, -0.38084, -0.91943, -0.09802, -0.38268, -0.92388, -0, -0.55557, -0.83147, -0, -0.54489, -0.81549, -0.19509, -0.37533, -0.90613, -0.19509, -0.38084, -0.91943, -0.09802, -0.55289, -0.82747, -0.09802, -0.53165, -0.79567, -0.29028, -0.3662, -0.8841, -0.29028, -0.37533, -0.90613, -0.19509, -0.54489, -0.81549, -0.19509, -0.51328, -0.76818, -0.38268, -0.35355, -0.85355, -0.38268, -0.3662, -0.8841, -0.29028, -0.53165, -0.79567, -0.29028, -0.48997, -0.73329, -0.4714, -0.3375, -0.81479, -0.4714, -0.35355, -0.85355, -0.38268, -0.51328, -0.76818, -0.38268, -0.46194, -0.69134, -0.55557, -0.31819, -0.76818, -0.55557, -0.3375, -0.81479, -0.4714, -0.48997, -0.73329, -0.4714, -0.42946, -0.64273, -0.63439, -0.29582, -0.71417, -0.63439, -0.31819, -0.76818, -0.55557, -0.46194, -0.69134, -0.55557, -0.39285, -0.58794, -0.70711, -0.2706, -0.65328, -0.70711, -0.29582, -0.71417, -0.63439, -0.42946, -0.64273, -0.63439, -0.35245, -0.52748, -0.77301, -0.24277, -0.5861, -0.77301, -0.2706, -0.65328, -0.70711, -0.39285, -0.58794, -0.70711, -0.30866, -0.46194, -0.83147, -0.21261, -0.51328, -0.83147, -0.24277, -0.5861, -0.77301, -0.35245, -0.52748, -0.77301, -0.26189, -0.39195, -0.88192, -0.1804, -0.43551, -0.88192, -0.21261, -0.51328, -0.83147, -0.30866, -0.46194, -0.83147, -0.21261, -0.31819, -0.92388, -0.14645, -0.35355, -0.92388, -0.1804, -0.43551, -0.88192, -0.26189, -0.39195, -0.88192, -0.16127, -0.24136, -0.95694, -0.11109, -0.26819, -0.95694, -0.14645, -0.35355, -0.92388, -0.21261, -0.31819, -0.92388, -0.10839, -0.16221, -0.98079, -0.07466, -0.18024, -0.98079, -0.11109, -0.26819, -0.95694, -0.16127, -0.24136, -0.95694, -0.05445, -0.0815, -0.99518, -0.03751, -0.09056, -0.99518, -0.07466, -0.18024, -0.98079, -0.10839, -0.16221, -0.98079, -0, -0, -1, -0.03751, -0.09056, -0.99518, -0.05445, -0.0815, -0.99518, -0, -0, -1, -0.01912, -0.09613, -0.99518, -0.03751, -0.09056, -0.99518, -0.03751, -0.09056, -0.99518, -0.01912, -0.09613, -0.99518, -0.03806, -0.19134, -0.98079, -0.07466, -0.18024, -0.98079, -0.07466, -0.18024, -0.98079, -0.03806, -0.19134, -0.98079, -0.05663, -0.28471, -0.95694, -0.11109, -0.26819, -0.95694, -0.11109, -0.26819, -0.95694, -0.05663, -0.28471, -0.95694, -0.07466, -0.37533, -0.92388, -0.14645, -0.35355, -0.92388, -0.14645, -0.35355, -0.92388, -0.07466, -0.37533, -0.92388, -0.09196, -0.46234, -0.88192, -0.1804, -0.43551, -0.88192, -0.1804, -0.43551, -0.88192, -0.09196, -0.46234, -0.88192, -0.10839, -0.54489, -0.83147, -0.21261, -0.51328, -0.83147, -0.21261, -0.51328, -0.83147, -0.10839, -0.54489, -0.83147, -0.12376, -0.6222, -0.77301, -0.24277, -0.5861, -0.77301, -0.24277, -0.5861, -0.77301, -0.12376, -0.6222, -0.77301, -0.13795, -0.69352, -0.70711, -0.2706, -0.65328, -0.70711, -0.2706, -0.65328, -0.70711, -0.13795, -0.69352, -0.70711, -0.15081, -0.75816, -0.63439, -0.29582, -0.71417, -0.63439, -0.29582, -0.71417, -0.63439, -0.15081, -0.75816, -0.63439, -0.16221, -0.81549, -0.55557, -0.31819, -0.76818, -0.55557, -0.31819, -0.76818, -0.55557, -0.16221, -0.81549, -0.55557, -0.17205, -0.86497, -0.4714, -0.3375, -0.81479, -0.4714, -0.3375, -0.81479, -0.4714, -0.17205, -0.86497, -0.4714, -0.18024, -0.90613, -0.38268, -0.35355, -0.85355, -0.38268, -0.35355, -0.85355, -0.38268, -0.18024, -0.90613, -0.38268, -0.18669, -0.93855, -0.29028, -0.3662, -0.8841, -0.29028, -0.3662, -0.8841, -0.29028, -0.18669, -0.93855, -0.29028, -0.19134, -0.96194, -0.19509, -0.37533, -0.90613, -0.19509, -0.37533, -0.90613, -0.19509, -0.19134, -0.96194, -0.19509, -0.19415, -0.97606, -0.09802, -0.38084, -0.91943, -0.09802, -0.38084, -0.91943, -0.09802, -0.19415, -0.97606, -0.09802, -0.19509, -0.98078, -0, -0.38268, -0.92388, -0, -0.38268, -0.92388, -0, -0.19509, -0.98078, -0, -0.19415, -0.97606, 0.09802, -0.38084, -0.91943, 0.09802, -0.38084, -0.91943, 0.09802, -0.19415, -0.97606, 0.09802, -0.19134, -0.96194, 0.19509, -0.37533, -0.90613, 0.19509, -0.37533, -0.90613, 0.19509, -0.19134, -0.96194, 0.19509, -0.18669, -0.93855, 0.29028, -0.3662, -0.8841, 0.29028, -0.3662, -0.8841, 0.29028, -0.18669, -0.93855, 0.29028, -0.18024, -0.90613, 0.38268, -0.35355, -0.85355, 0.38268, -0.35355, -0.85355, 0.38268, -0.18024, -0.90613, 0.38268, -0.17205, -0.86497, 0.4714, -0.3375, -0.81479, 0.4714, -0.3375, -0.81479, 0.4714, -0.17205, -0.86497, 0.4714, -0.16221, -0.81549, 0.55557, -0.31819, -0.76818, 0.55557, -0.31819, -0.76818, 0.55557, -0.16221, -0.81549, 0.55557, -0.15081, -0.75816, 0.63439, -0.29582, -0.71417, 0.63439, -0.29582, -0.71417, 0.63439, -0.15081, -0.75816, 0.63439, -0.13795, -0.69352, 0.70711, -0.2706, -0.65328, 0.70711, -0.2706, -0.65328, 0.70711, -0.13795, -0.69352, 0.70711, -0.12376, -0.6222, 0.77301, -0.24277, -0.5861, 0.77301, -0.24277, -0.5861, 0.77301, -0.12376, -0.6222, 0.77301, -0.10839, -0.54489, 0.83147, -0.21261, -0.51328, 0.83147, -0.21261, -0.51328, 0.83147, -0.10839, -0.54489, 0.83147, -0.09196, -0.46234, 0.88192, -0.1804, -0.43551, 0.88192, -0.1804, -0.43551, 0.88192, -0.09196, -0.46234, 0.88192, -0.07466, -0.37533, 0.92388, -0.14645, -0.35355, 0.92388, -0.14645, -0.35355, 0.92388, -0.07466, -0.37533, 0.92388, -0.05663, -0.28471, 0.95694, -0.11109, -0.26819, 0.95694, -0.11109, -0.26819, 0.95694, -0.05663, -0.28471, 0.95694, -0.03806, -0.19134, 0.98079, -0.07466, -0.18024, 0.98079, -0.07466, -0.18024, 0.98079, -0.03806, -0.19134, 0.98079, -0.01912, -0.09613, 0.99518, -0.03751, -0.09056, 0.99518, -0.01912, -0.09613, 0.99518, 0, 0, 1, -0.03751, -0.09056, 0.99518, 0, -0.09802, 0.99518, 0, 0, 1, -0.01912, -0.09613, 0.99518, -0.03806, -0.19134, 0.98079, 0, -0.19509, 0.98079, 0, -0.09802, 0.99518, -0.01912, -0.09613, 0.99518, -0.05663, -0.28471, 0.95694, 0, -0.29028, 0.95694, 0, -0.19509, 0.98079, -0.03806, -0.19134, 0.98079, -0.07466, -0.37533, 0.92388, 0, -0.38268, 0.92388, 0, -0.29028, 0.95694, -0.05663, -0.28471, 0.95694, -0.09196, -0.46234, 0.88192, 0, -0.4714, 0.88192, 0, -0.38268, 0.92388, -0.07466, -0.37533, 0.92388, -0.10839, -0.54489, 0.83147, 0, -0.55557, 0.83147, 0, -0.4714, 0.88192, -0.09196, -0.46234, 0.88192, -0.12376, -0.6222, 0.77301, 0, -0.63439, 0.77301, 0, -0.55557, 0.83147, -0.10839, -0.54489, 0.83147, -0.13795, -0.69352, 0.70711, 0, -0.70711, 0.70711, 0, -0.63439, 0.77301, -0.12376, -0.6222, 0.77301, -0.15081, -0.75816, 0.63439, 0, -0.77301, 0.63439, 0, -0.70711, 0.70711, -0.13795, -0.69352, 0.70711, -0.16221, -0.81549, 0.55557, 0, -0.83147, 0.55557, 0, -0.77301, 0.63439, -0.15081, -0.75816, 0.63439, -0.17205, -0.86497, 0.4714, 0, -0.88192, 0.4714, 0, -0.83147, 0.55557, -0.16221, -0.81549, 0.55557, -0.18024, -0.90613, 0.38268, 0, -0.92388, 0.38268, 0, -0.88192, 0.4714, -0.17205, -0.86497, 0.4714, -0.18669, -0.93855, 0.29028, 0, -0.95694, 0.29028, 0, -0.92388, 0.38268, -0.18024, -0.90613, 0.38268, -0.19134, -0.96194, 0.19509, 0, -0.98078, 0.19509, 0, -0.95694, 0.29028, -0.18669, -0.93855, 0.29028, -0.19415, -0.97606, 0.09802, 0, -0.99518, 0.09802, 0, -0.98078, 0.19509, -0.19134, -0.96194, 0.19509, -0.19509, -0.98078, -0, 0, -1, -0, 0, -0.99518, 0.09802, -0.19415, -0.97606, 0.09802, -0.19415, -0.97606, -0.09802, 0, -0.99518, -0.09802, 0, -1, -0, -0.19509, -0.98078, -0, -0.19134, -0.96194, -0.19509, 0, -0.98078, -0.19509, 0, -0.99518, -0.09802, -0.19415, -0.97606, -0.09802, -0.18669, -0.93855, -0.29028, 0, -0.95694, -0.29028, 0, -0.98078, -0.19509, -0.19134, -0.96194, -0.19509, -0.18024, -0.90613, -0.38268, 0, -0.92388, -0.38268, 0, -0.95694, -0.29028, -0.18669, -0.93855, -0.29028, -0.17205, -0.86497, -0.4714, 0, -0.88192, -0.4714, 0, -0.92388, -0.38268, -0.18024, -0.90613, -0.38268, -0.16221, -0.81549, -0.55557, 0, -0.83147, -0.55557, 0, -0.88192, -0.4714, -0.17205, -0.86497, -0.4714, -0.15081, -0.75816, -0.63439, 0, -0.77301, -0.63439, 0, -0.83147, -0.55557, -0.16221, -0.81549, -0.55557, -0.13795, -0.69352, -0.70711, 0, -0.70711, -0.70711, 0, -0.77301, -0.63439, -0.15081, -0.75816, -0.63439, -0.12376, -0.6222, -0.77301, 0, -0.63439, -0.77301, 0, -0.70711, -0.70711, -0.13795, -0.69352, -0.70711, -0.10839, -0.54489, -0.83147, 0, -0.55557, -0.83147, 0, -0.63439, -0.77301, -0.12376, -0.6222, -0.77301, -0.09196, -0.46234, -0.88192, 0, -0.4714, -0.88192, 0, -0.55557, -0.83147, -0.10839, -0.54489, -0.83147, -0.07466, -0.37533, -0.92388, 0, -0.38268, -0.92388, 0, -0.4714, -0.88192, -0.09196, -0.46234, -0.88192, -0.05663, -0.28471, -0.95694, 0, -0.29028, -0.95694, 0, -0.38268, -0.92388, -0.07466, -0.37533, -0.92388, -0.03806, -0.19134, -0.98079, 0, -0.19509, -0.98079, 0, -0.29028, -0.95694, -0.05663, -0.28471, -0.95694, -0.01912, -0.09613, -0.99518, 0, -0.09802, -0.99518, 0, -0.19509, -0.98079, -0.03806, -0.19134, -0.98079, -0, -0, -1, 0, -0.09802, -0.99518, -0.01912, -0.09613, -0.99518, -0, -0, -1, 0.01912, -0.09613, -0.99518, 0, -0.09802, -0.99518, 0, -0.09802, -0.99518, 0.01912, -0.09613, -0.99518, 0.03806, -0.19134, -0.98079, 0, -0.19509, -0.98079, 0, -0.19509, -0.98079, 0.03806, -0.19134, -0.98079, 0.05663, -0.28471, -0.95694, 0, -0.29028, -0.95694, 0, -0.29028, -0.95694, 0.05663, -0.28471, -0.95694, 0.07466, -0.37533, -0.92388, 0, -0.38268, -0.92388, 0, -0.38268, -0.92388, 0.07466, -0.37533, -0.92388, 0.09196, -0.46234, -0.88192, 0, -0.4714, -0.88192, 0, -0.4714, -0.88192, 0.09196, -0.46234, -0.88192, 0.10839, -0.54489, -0.83147, 0, -0.55557, -0.83147, 0, -0.55557, -0.83147, 0.10839, -0.54489, -0.83147, 0.12376, -0.6222, -0.77301, 0, -0.63439, -0.77301, 0, -0.63439, -0.77301, 0.12376, -0.6222, -0.77301, 0.13795, -0.69352, -0.70711, 0, -0.70711, -0.70711, 0, -0.70711, -0.70711, 0.13795, -0.69352, -0.70711, 0.15081, -0.75816, -0.63439, 0, -0.77301, -0.63439, 0, -0.77301, -0.63439, 0.15081, -0.75816, -0.63439, 0.16221, -0.81549, -0.55557, 0, -0.83147, -0.55557, 0, -0.83147, -0.55557, 0.16221, -0.81549, -0.55557, 0.17205, -0.86497, -0.4714, 0, -0.88192, -0.4714, 0, -0.88192, -0.4714, 0.17205, -0.86497, -0.4714, 0.18024, -0.90613, -0.38268, 0, -0.92388, -0.38268, 0, -0.92388, -0.38268, 0.18024, -0.90613, -0.38268, 0.18669, -0.93855, -0.29028, 0, -0.95694, -0.29028, 0, -0.95694, -0.29028, 0.18669, -0.93855, -0.29028, 0.19134, -0.96194, -0.19509, 0, -0.98078, -0.19509, 0, -0.98078, -0.19509, 0.19134, -0.96194, -0.19509, 0.19415, -0.97606, -0.09802, 0, -0.99518, -0.09802, 0, -0.99518, -0.09802, 0.19415, -0.97606, -0.09802, 0.19509, -0.98078, -0, 0, -1, -0, 0, -1, -0, 0.19509, -0.98078, -0, 0.19415, -0.97606, 0.09802, 0, -0.99518, 0.09802, 0, -0.99518, 0.09802, 0.19415, -0.97606, 0.09802, 0.19134, -0.96194, 0.19509, 0, -0.98078, 0.19509, 0, -0.98078, 0.19509, 0.19134, -0.96194, 0.19509, 0.18669, -0.93855, 0.29028, 0, -0.95694, 0.29028, 0, -0.95694, 0.29028, 0.18669, -0.93855, 0.29028, 0.18024, -0.90613, 0.38268, 0, -0.92388, 0.38268, 0, -0.92388, 0.38268, 0.18024, -0.90613, 0.38268, 0.17205, -0.86497, 0.4714, 0, -0.88192, 0.4714, 0, -0.88192, 0.4714, 0.17205, -0.86497, 0.4714, 0.16221, -0.81549, 0.55557, 0, -0.83147, 0.55557, 0, -0.83147, 0.55557, 0.16221, -0.81549, 0.55557, 0.15081, -0.75816, 0.63439, 0, -0.77301, 0.63439, 0, -0.77301, 0.63439, 0.15081, -0.75816, 0.63439, 0.13795, -0.69352, 0.70711, 0, -0.70711, 0.70711, 0, -0.70711, 0.70711, 0.13795, -0.69352, 0.70711, 0.12376, -0.6222, 0.77301, 0, -0.63439, 0.77301, 0, -0.63439, 0.77301, 0.12376, -0.6222, 0.77301, 0.10839, -0.54489, 0.83147, 0, -0.55557, 0.83147, 0, -0.55557, 0.83147, 0.10839, -0.54489, 0.83147, 0.09196, -0.46234, 0.88192, 0, -0.4714, 0.88192, 0, -0.4714, 0.88192, 0.09196, -0.46234, 0.88192, 0.07466, -0.37533, 0.92388, 0, -0.38268, 0.92388, 0, -0.38268, 0.92388, 0.07466, -0.37533, 0.92388, 0.05663, -0.28471, 0.95694, 0, -0.29028, 0.95694, 0, -0.29028, 0.95694, 0.05663, -0.28471, 0.95694, 0.03806, -0.19134, 0.98079, 0, -0.19509, 0.98079, 0, -0.19509, 0.98079, 0.03806, -0.19134, 0.98079, 0.01912, -0.09613, 0.99518, 0, -0.09802, 0.99518, 0.01912, -0.09613, 0.99518, 0, 0, 1, 0, -0.09802, 0.99518, 0.03751, -0.09056, 0.99518, 0, 0, 1, 0.01912, -0.09613, 0.99518, 0.03806, -0.19134, 0.98079, 0.07466, -0.18024, 0.98079, 0.03751, -0.09056, 0.99518, 0.01912, -0.09613, 0.99518, 0.05663, -0.28471, 0.95694, 0.11109, -0.26819, 0.95694, 0.07466, -0.18024, 0.98079, 0.03806, -0.19134, 0.98079, 0.07466, -0.37533, 0.92388, 0.14645, -0.35355, 0.92388, 0.11109, -0.26819, 0.95694, 0.05663, -0.28471, 0.95694, 0.09196, -0.46234, 0.88192, 0.1804, -0.43551, 0.88192, 0.14645, -0.35355, 0.92388, 0.07466, -0.37533, 0.92388, 0.10839, -0.54489, 0.83147, 0.21261, -0.51328, 0.83147, 0.1804, -0.43551, 0.88192, 0.09196, -0.46234, 0.88192, 0.12376, -0.6222, 0.77301, 0.24277, -0.5861, 0.77301, 0.21261, -0.51328, 0.83147, 0.10839, -0.54489, 0.83147, 0.13795, -0.69352, 0.70711, 0.2706, -0.65328, 0.70711, 0.24277, -0.5861, 0.77301, 0.12376, -0.6222, 0.77301, 0.15081, -0.75816, 0.63439, 0.29582, -0.71417, 0.63439, 0.2706, -0.65328, 0.70711, 0.13795, -0.69352, 0.70711, 0.16221, -0.81549, 0.55557, 0.31819, -0.76818, 0.55557, 0.29582, -0.71417, 0.63439, 0.15081, -0.75816, 0.63439, 0.17205, -0.86497, 0.4714, 0.3375, -0.81479, 0.4714, 0.31819, -0.76818, 0.55557, 0.16221, -0.81549, 0.55557, 0.18024, -0.90613, 0.38268, 0.35355, -0.85355, 0.38268, 0.3375, -0.81479, 0.4714, 0.17205, -0.86497, 0.4714, 0.18669, -0.93855, 0.29028, 0.36621, -0.8841, 0.29028, 0.35355, -0.85355, 0.38268, 0.18024, -0.90613, 0.38268, 0.19134, -0.96194, 0.19509, 0.37533, -0.90613, 0.19509, 0.36621, -0.8841, 0.29028, 0.18669, -0.93855, 0.29028, 0.19415, -0.97606, 0.09802, 0.38084, -0.91943, 0.09802, 0.37533, -0.90613, 0.19509, 0.19134, -0.96194, 0.19509, 0.19509, -0.98078, -0, 0.38268, -0.92388, -0, 0.38084, -0.91943, 0.09802, 0.19415, -0.97606, 0.09802, 0.19415, -0.97606, -0.09802, 0.38084, -0.91943, -0.09802, 0.38268, -0.92388, -0, 0.19509, -0.98078, -0, 0.19134, -0.96194, -0.19509, 0.37533, -0.90613, -0.19509, 0.38084, -0.91943, -0.09802, 0.19415, -0.97606, -0.09802, 0.18669, -0.93855, -0.29028, 0.36621, -0.8841, -0.29028, 0.37533, -0.90613, -0.19509, 0.19134, -0.96194, -0.19509, 0.18024, -0.90613, -0.38268, 0.35355, -0.85355, -0.38268, 0.36621, -0.8841, -0.29028, 0.18669, -0.93855, -0.29028, 0.17205, -0.86497, -0.4714, 0.3375, -0.81479, -0.4714, 0.35355, -0.85355, -0.38268, 0.18024, -0.90613, -0.38268, 0.16221, -0.81549, -0.55557, 0.31819, -0.76818, -0.55557, 0.3375, -0.81479, -0.4714, 0.17205, -0.86497, -0.4714, 0.15081, -0.75816, -0.63439, 0.29582, -0.71417, -0.63439, 0.31819, -0.76818, -0.55557, 0.16221, -0.81549, -0.55557, 0.13795, -0.69352, -0.70711, 0.2706, -0.65328, -0.70711, 0.29582, -0.71417, -0.63439, 0.15081, -0.75816, -0.63439, 0.12376, -0.6222, -0.77301, 0.24277, -0.5861, -0.77301, 0.2706, -0.65328, -0.70711, 0.13795, -0.69352, -0.70711, 0.10839, -0.54489, -0.83147, 0.21261, -0.51328, -0.83147, 0.24277, -0.5861, -0.77301, 0.12376, -0.6222, -0.77301, 0.09196, -0.46234, -0.88192, 0.1804, -0.43551, -0.88192, 0.21261, -0.51328, -0.83147, 0.10839, -0.54489, -0.83147, 0.07466, -0.37533, -0.92388, 0.14645, -0.35355, -0.92388, 0.1804, -0.43551, -0.88192, 0.09196, -0.46234, -0.88192, 0.05663, -0.28471, -0.95694, 0.11109, -0.26819, -0.95694, 0.14645, -0.35355, -0.92388, 0.07466, -0.37533, -0.92388, 0.03806, -0.19134, -0.98079, 0.07466, -0.18024, -0.98079, 0.11109, -0.26819, -0.95694, 0.05663, -0.28471, -0.95694, 0.01912, -0.09613, -0.99518, 0.03751, -0.09056, -0.99518, 0.07466, -0.18024, -0.98079, 0.03806, -0.19134, -0.98079, -0, -0, -1, 0.03751, -0.09056, -0.99518, 0.01912, -0.09613, -0.99518, -0, -0, -1, 0.05445, -0.0815, -0.99518, 0.03751, -0.09056, -0.99518, 0.03751, -0.09056, -0.99518, 0.05445, -0.0815, -0.99518, 0.10839, -0.16221, -0.98079, 0.07466, -0.18024, -0.98079, 0.07466, -0.18024, -0.98079, 0.10839, -0.16221, -0.98079, 0.16127, -0.24136, -0.95694, 0.11109, -0.26819, -0.95694, 0.11109, -0.26819, -0.95694, 0.16127, -0.24136, -0.95694, 0.21261, -0.31819, -0.92388, 0.14645, -0.35355, -0.92388, 0.14645, -0.35355, -0.92388, 0.21261, -0.31819, -0.92388, 0.26189, -0.39195, -0.88192, 0.1804, -0.43551, -0.88192, 0.1804, -0.43551, -0.88192, 0.26189, -0.39195, -0.88192, 0.30866, -0.46194, -0.83147, 0.21261, -0.51328, -0.83147, 0.21261, -0.51328, -0.83147, 0.30866, -0.46194, -0.83147, 0.35245, -0.52748, -0.77301, 0.24277, -0.5861, -0.77301, 0.24277, -0.5861, -0.77301, 0.35245, -0.52748, -0.77301, 0.39285, -0.58794, -0.70711, 0.2706, -0.65328, -0.70711, 0.2706, -0.65328, -0.70711, 0.39285, -0.58794, -0.70711, 0.42946, -0.64273, -0.63439, 0.29582, -0.71417, -0.63439, 0.29582, -0.71417, -0.63439, 0.42946, -0.64273, -0.63439, 0.46194, -0.69134, -0.55557, 0.31819, -0.76818, -0.55557, 0.31819, -0.76818, -0.55557, 0.46194, -0.69134, -0.55557, 0.48997, -0.73329, -0.4714, 0.3375, -0.81479, -0.4714, 0.3375, -0.81479, -0.4714, 0.48997, -0.73329, -0.4714, 0.51328, -0.76818, -0.38268, 0.35355, -0.85355, -0.38268, 0.35355, -0.85355, -0.38268, 0.51328, -0.76818, -0.38268, 0.53165, -0.79567, -0.29028, 0.36621, -0.8841, -0.29028, 0.36621, -0.8841, -0.29028, 0.53165, -0.79567, -0.29028, 0.54489, -0.81549, -0.19509, 0.37533, -0.90613, -0.19509, 0.37533, -0.90613, -0.19509, 0.54489, -0.81549, -0.19509, 0.55289, -0.82747, -0.09802, 0.38084, -0.91943, -0.09802, 0.38084, -0.91943, -0.09802, 0.55289, -0.82747, -0.09802, 0.55557, -0.83147, -0, 0.38268, -0.92388, -0, 0.38268, -0.92388, -0, 0.55557, -0.83147, -0, 0.55289, -0.82747, 0.09802, 0.38084, -0.91943, 0.09802, 0.38084, -0.91943, 0.09802, 0.55289, -0.82747, 0.09802, 0.54489, -0.81549, 0.19509, 0.37533, -0.90613, 0.19509, 0.37533, -0.90613, 0.19509, 0.54489, -0.81549, 0.19509, 0.53165, -0.79567, 0.29028, 0.36621, -0.8841, 0.29028, 0.36621, -0.8841, 0.29028, 0.53165, -0.79567, 0.29028, 0.51328, -0.76818, 0.38268, 0.35355, -0.85355, 0.38268, 0.35355, -0.85355, 0.38268, 0.51328, -0.76818, 0.38268, 0.48997, -0.73329, 0.4714, 0.3375, -0.81479, 0.4714, 0.3375, -0.81479, 0.4714, 0.48997, -0.73329, 0.4714, 0.46194, -0.69134, 0.55557, 0.31819, -0.76818, 0.55557, 0.31819, -0.76818, 0.55557, 0.46194, -0.69134, 0.55557, 0.42946, -0.64273, 0.63439, 0.29582, -0.71417, 0.63439, 0.29582, -0.71417, 0.63439, 0.42946, -0.64273, 0.63439, 0.39285, -0.58794, 0.70711, 0.2706, -0.65328, 0.70711, 0.2706, -0.65328, 0.70711, 0.39285, -0.58794, 0.70711, 0.35245, -0.52748, 0.77301, 0.24277, -0.5861, 0.77301, 0.24277, -0.5861, 0.77301, 0.35245, -0.52748, 0.77301, 0.30866, -0.46194, 0.83147, 0.21261, -0.51328, 0.83147, 0.21261, -0.51328, 0.83147, 0.30866, -0.46194, 0.83147, 0.26189, -0.39195, 0.88192, 0.1804, -0.43551, 0.88192, 0.1804, -0.43551, 0.88192, 0.26189, -0.39195, 0.88192, 0.21261, -0.31819, 0.92388, 0.14645, -0.35355, 0.92388, 0.14645, -0.35355, 0.92388, 0.21261, -0.31819, 0.92388, 0.16127, -0.24136, 0.95694, 0.11109, -0.26819, 0.95694, 0.11109, -0.26819, 0.95694, 0.16127, -0.24136, 0.95694, 0.10839, -0.16221, 0.98079, 0.07466, -0.18024, 0.98079, 0.07466, -0.18024, 0.98079, 0.10839, -0.16221, 0.98079, 0.05446, -0.0815, 0.99518, 0.03751, -0.09056, 0.99518, 0.05446, -0.0815, 0.99518, 0, 0, 1, 0.03751, -0.09056, 0.99518, 0.06931, -0.06931, 0.99518, 0, 0, 1, 0.05446, -0.0815, 0.99518, 0.10839, -0.16221, 0.98079, 0.13795, -0.13795, 0.98079, 0.06931, -0.06931, 0.99518, 0.05446, -0.0815, 0.99518, 0.16127, -0.24136, 0.95694, 0.20526, -0.20526, 0.95694, 0.13795, -0.13795, 0.98079, 0.10839, -0.16221, 0.98079, 0.21261, -0.31819, 0.92388, 0.2706, -0.2706, 0.92388, 0.20526, -0.20526, 0.95694, 0.16127, -0.24136, 0.95694, 0.26189, -0.39195, 0.88192, 0.33333, -0.33333, 0.88192, 0.2706, -0.2706, 0.92388, 0.21261, -0.31819, 0.92388, 0.30866, -0.46194, 0.83147, 0.39285, -0.39285, 0.83147, 0.33333, -0.33333, 0.88192, 0.26189, -0.39195, 0.88192, 0.35245, -0.52748, 0.77301, 0.44858, -0.44858, 0.77301, 0.39285, -0.39285, 0.83147, 0.30866, -0.46194, 0.83147, 0.39285, -0.58794, 0.70711, 0.5, -0.5, 0.70711, 0.44858, -0.44858, 0.77301, 0.35245, -0.52748, 0.77301, 0.42946, -0.64273, 0.63439, 0.5466, -0.5466, 0.63439, 0.5, -0.5, 0.70711, 0.39285, -0.58794, 0.70711, 0.46194, -0.69134, 0.55557, 0.58794, -0.58794, 0.55557, 0.5466, -0.5466, 0.63439, 0.42946, -0.64273, 0.63439, 0.48997, -0.73329, 0.4714, 0.62361, -0.62361, 0.4714, 0.58794, -0.58794, 0.55557, 0.46194, -0.69134, 0.55557, 0.51328, -0.76818, 0.38268, 0.65328, -0.65328, 0.38268, 0.62361, -0.62361, 0.4714, 0.48997, -0.73329, 0.4714, 0.53165, -0.79567, 0.29028, 0.67666, -0.67666, 0.29028, 0.65328, -0.65328, 0.38268, 0.51328, -0.76818, 0.38268, 0.54489, -0.81549, 0.19509, 0.69352, -0.69352, 0.19509, 0.67666, -0.67666, 0.29028, 0.53165, -0.79567, 0.29028, 0.55289, -0.82747, 0.09802, 0.7037, -0.7037, 0.09802, 0.69352, -0.69352, 0.19509, 0.54489, -0.81549, 0.19509, 0.55557, -0.83147, -0, 0.70711, -0.70711, -0, 0.7037, -0.7037, 0.09802, 0.55289, -0.82747, 0.09802, 0.55289, -0.82747, -0.09802, 0.7037, -0.7037, -0.09802, 0.70711, -0.70711, -0, 0.55557, -0.83147, -0, 0.54489, -0.81549, -0.19509, 0.69352, -0.69352, -0.19509, 0.7037, -0.7037, -0.09802, 0.55289, -0.82747, -0.09802, 0.53165, -0.79567, -0.29028, 0.67666, -0.67666, -0.29028, 0.69352, -0.69352, -0.19509, 0.54489, -0.81549, -0.19509, 0.51328, -0.76818, -0.38268, 0.65328, -0.65328, -0.38268, 0.67666, -0.67666, -0.29028, 0.53165, -0.79567, -0.29028, 0.48997, -0.73329, -0.4714, 0.62361, -0.62361, -0.4714, 0.65328, -0.65328, -0.38268, 0.51328, -0.76818, -0.38268, 0.46194, -0.69134, -0.55557, 0.58794, -0.58794, -0.55557, 0.62361, -0.62361, -0.4714, 0.48997, -0.73329, -0.4714, 0.42946, -0.64273, -0.63439, 0.5466, -0.5466, -0.63439, 0.58794, -0.58794, -0.55557, 0.46194, -0.69134, -0.55557, 0.39285, -0.58794, -0.70711, 0.5, -0.5, -0.70711, 0.5466, -0.5466, -0.63439, 0.42946, -0.64273, -0.63439, 0.35245, -0.52748, -0.77301, 0.44858, -0.44858, -0.77301, 0.5, -0.5, -0.70711, 0.39285, -0.58794, -0.70711, 0.30866, -0.46194, -0.83147, 0.39285, -0.39285, -0.83147, 0.44858, -0.44858, -0.77301, 0.35245, -0.52748, -0.77301, 0.26189, -0.39195, -0.88192, 0.33333, -0.33333, -0.88192, 0.39285, -0.39285, -0.83147, 0.30866, -0.46194, -0.83147, 0.21261, -0.31819, -0.92388, 0.2706, -0.2706, -0.92388, 0.33333, -0.33333, -0.88192, 0.26189, -0.39195, -0.88192, 0.16127, -0.24136, -0.95694, 0.20526, -0.20526, -0.95694, 0.2706, -0.2706, -0.92388, 0.21261, -0.31819, -0.92388, 0.10839, -0.16221, -0.98079, 0.13795, -0.13795, -0.98079, 0.20526, -0.20526, -0.95694, 0.16127, -0.24136, -0.95694, 0.05445, -0.0815, -0.99518, 0.06931, -0.06931, -0.99518, 0.13795, -0.13795, -0.98079, 0.10839, -0.16221, -0.98079, -0, -0, -1, 0.06931, -0.06931, -0.99518, 0.05445, -0.0815, -0.99518, -0, -0, -1, 0.0815, -0.05445, -0.99518, 0.06931, -0.06931, -0.99518, 0.06931, -0.06931, -0.99518, 0.0815, -0.05445, -0.99518, 0.16221, -0.10839, -0.98079, 0.13795, -0.13795, -0.98079, 0.13795, -0.13795, -0.98079, 0.16221, -0.10839, -0.98079, 0.24136, -0.16127, -0.95694, 0.20526, -0.20526, -0.95694, 0.20526, -0.20526, -0.95694, 0.24136, -0.16127, -0.95694, 0.31819, -0.21261, -0.92388, 0.2706, -0.2706, -0.92388, 0.2706, -0.2706, -0.92388, 0.31819, -0.21261, -0.92388, 0.39195, -0.26189, -0.88192, 0.33333, -0.33333, -0.88192, 0.33333, -0.33333, -0.88192, 0.39195, -0.26189, -0.88192, 0.46194, -0.30866, -0.83147, 0.39285, -0.39285, -0.83147, 0.39285, -0.39285, -0.83147, 0.46194, -0.30866, -0.83147, 0.52748, -0.35245, -0.77301, 0.44858, -0.44858, -0.77301, 0.44858, -0.44858, -0.77301, 0.52748, -0.35245, -0.77301, 0.58794, -0.39285, -0.70711, 0.5, -0.5, -0.70711, 0.5, -0.5, -0.70711, 0.58794, -0.39285, -0.70711, 0.64273, -0.42946, -0.63439, 0.5466, -0.5466, -0.63439, 0.5466, -0.5466, -0.63439, 0.64273, -0.42946, -0.63439, 0.69134, -0.46194, -0.55557, 0.58794, -0.58794, -0.55557, 0.58794, -0.58794, -0.55557, 0.69134, -0.46194, -0.55557, 0.73329, -0.48997, -0.4714, 0.62361, -0.62361, -0.4714, 0.62361, -0.62361, -0.4714, 0.73329, -0.48997, -0.4714, 0.76818, -0.51328, -0.38268, 0.65328, -0.65328, -0.38268, 0.65328, -0.65328, -0.38268, 0.76818, -0.51328, -0.38268, 0.79567, -0.53165, -0.29028, 0.67666, -0.67666, -0.29028, 0.67666, -0.67666, -0.29028, 0.79567, -0.53165, -0.29028, 0.81549, -0.54489, -0.19509, 0.69352, -0.69352, -0.19509, 0.69352, -0.69352, -0.19509, 0.81549, -0.54489, -0.19509, 0.82747, -0.55289, -0.09802, 0.7037, -0.7037, -0.09802, 0.7037, -0.7037, -0.09802, 0.82747, -0.55289, -0.09802, 0.83147, -0.55557, -0, 0.70711, -0.70711, -0, 0.70711, -0.70711, -0, 0.83147, -0.55557, -0, 0.82747, -0.55289, 0.09802, 0.7037, -0.7037, 0.09802, 0.7037, -0.7037, 0.09802, 0.82747, -0.55289, 0.09802, 0.81549, -0.54489, 0.19509, 0.69352, -0.69352, 0.19509, 0.69352, -0.69352, 0.19509, 0.81549, -0.54489, 0.19509, 0.79567, -0.53165, 0.29028, 0.67666, -0.67666, 0.29028, 0.67666, -0.67666, 0.29028, 0.79567, -0.53165, 0.29028, 0.76818, -0.51328, 0.38268, 0.65328, -0.65328, 0.38268, 0.65328, -0.65328, 0.38268, 0.76818, -0.51328, 0.38268, 0.73329, -0.48997, 0.4714, 0.62361, -0.62361, 0.4714, 0.62361, -0.62361, 0.4714, 0.73329, -0.48997, 0.4714, 0.69134, -0.46194, 0.55557, 0.58794, -0.58794, 0.55557, 0.58794, -0.58794, 0.55557, 0.69134, -0.46194, 0.55557, 0.64273, -0.42946, 0.63439, 0.5466, -0.5466, 0.63439, 0.5466, -0.5466, 0.63439, 0.64273, -0.42946, 0.63439, 0.58794, -0.39285, 0.70711, 0.5, -0.5, 0.70711, 0.5, -0.5, 0.70711, 0.58794, -0.39285, 0.70711, 0.52748, -0.35245, 0.77301, 0.44858, -0.44858, 0.77301, 0.44858, -0.44858, 0.77301, 0.52748, -0.35245, 0.77301, 0.46194, -0.30866, 0.83147, 0.39285, -0.39285, 0.83147, 0.39285, -0.39285, 0.83147, 0.46194, -0.30866, 0.83147, 0.39195, -0.26189, 0.88192, 0.33333, -0.33333, 0.88192, 0.33333, -0.33333, 0.88192, 0.39195, -0.26189, 0.88192, 0.31819, -0.21261, 0.92388, 0.2706, -0.2706, 0.92388, 0.2706, -0.2706, 0.92388, 0.31819, -0.21261, 0.92388, 0.24136, -0.16127, 0.95694, 0.20526, -0.20526, 0.95694, 0.20526, -0.20526, 0.95694, 0.24136, -0.16127, 0.95694, 0.16221, -0.10839, 0.98079, 0.13795, -0.13795, 0.98079, 0.13795, -0.13795, 0.98079, 0.16221, -0.10839, 0.98079, 0.0815, -0.05446, 0.99518, 0.06931, -0.06931, 0.99518, 0.0815, -0.05446, 0.99518, 0, 0, 1, 0.06931, -0.06931, 0.99518, 0.09056, -0.03751, 0.99518, 0, 0, 1, 0.0815, -0.05446, 0.99518, 0.16221, -0.10839, 0.98079, 0.18024, -0.07466, 0.98079, 0.09056, -0.03751, 0.99518, 0.0815, -0.05446, 0.99518, 0.24136, -0.16127, 0.95694, 0.26819, -0.11109, 0.95694, 0.18024, -0.07466, 0.98079, 0.16221, -0.10839, 0.98079, 0.31819, -0.21261, 0.92388, 0.35355, -0.14645, 0.92388, 0.26819, -0.11109, 0.95694, 0.24136, -0.16127, 0.95694, 0.39195, -0.26189, 0.88192, 0.43551, -0.1804, 0.88192, 0.35355, -0.14645, 0.92388, 0.31819, -0.21261, 0.92388, 0.46194, -0.30866, 0.83147, 0.51328, -0.21261, 0.83147, 0.43551, -0.1804, 0.88192, 0.39195, -0.26189, 0.88192, 0.52748, -0.35245, 0.77301, 0.5861, -0.24277, 0.77301, 0.51328, -0.21261, 0.83147, 0.46194, -0.30866, 0.83147, 0.58794, -0.39285, 0.70711, 0.65328, -0.2706, 0.70711, 0.5861, -0.24277, 0.77301, 0.52748, -0.35245, 0.77301, 0.64273, -0.42946, 0.63439, 0.71417, -0.29582, 0.63439, 0.65328, -0.2706, 0.70711, 0.58794, -0.39285, 0.70711, 0.69134, -0.46194, 0.55557, 0.76818, -0.31819, 0.55557, 0.71417, -0.29582, 0.63439, 0.64273, -0.42946, 0.63439, 0.73329, -0.48997, 0.4714, 0.81479, -0.3375, 0.4714, 0.76818, -0.31819, 0.55557, 0.69134, -0.46194, 0.55557, 0.76818, -0.51328, 0.38268, 0.85355, -0.35355, 0.38268, 0.81479, -0.3375, 0.4714, 0.73329, -0.48997, 0.4714, 0.79567, -0.53165, 0.29028, 0.8841, -0.3662, 0.29028, 0.85355, -0.35355, 0.38268, 0.76818, -0.51328, 0.38268, 0.81549, -0.54489, 0.19509, 0.90613, -0.37533, 0.19509, 0.8841, -0.3662, 0.29028, 0.79567, -0.53165, 0.29028, 0.82747, -0.55289, 0.09802, 0.91943, -0.38084, 0.09802, 0.90613, -0.37533, 0.19509, 0.81549, -0.54489, 0.19509, 0.83147, -0.55557, -0, 0.92388, -0.38268, -0, 0.91943, -0.38084, 0.09802, 0.82747, -0.55289, 0.09802, 0.82747, -0.55289, -0.09802, 0.91943, -0.38084, -0.09802, 0.92388, -0.38268, -0, 0.83147, -0.55557, -0, 0.81549, -0.54489, -0.19509, 0.90613, -0.37533, -0.19509, 0.91943, -0.38084, -0.09802, 0.82747, -0.55289, -0.09802, 0.79567, -0.53165, -0.29028, 0.8841, -0.3662, -0.29028, 0.90613, -0.37533, -0.19509, 0.81549, -0.54489, -0.19509, 0.76818, -0.51328, -0.38268, 0.85355, -0.35355, -0.38268, 0.8841, -0.3662, -0.29028, 0.79567, -0.53165, -0.29028, 0.73329, -0.48997, -0.4714, 0.81479, -0.3375, -0.4714, 0.85355, -0.35355, -0.38268, 0.76818, -0.51328, -0.38268, 0.69134, -0.46194, -0.55557, 0.76818, -0.31819, -0.55557, 0.81479, -0.3375, -0.4714, 0.73329, -0.48997, -0.4714, 0.64273, -0.42946, -0.63439, 0.71417, -0.29582, -0.63439, 0.76818, -0.31819, -0.55557, 0.69134, -0.46194, -0.55557, 0.58794, -0.39285, -0.70711, 0.65328, -0.2706, -0.70711, 0.71417, -0.29582, -0.63439, 0.64273, -0.42946, -0.63439, 0.52748, -0.35245, -0.77301, 0.5861, -0.24277, -0.77301, 0.65328, -0.2706, -0.70711, 0.58794, -0.39285, -0.70711, 0.46194, -0.30866, -0.83147, 0.51328, -0.21261, -0.83147, 0.5861, -0.24277, -0.77301, 0.52748, -0.35245, -0.77301, 0.39195, -0.26189, -0.88192, 0.43551, -0.1804, -0.88192, 0.51328, -0.21261, -0.83147, 0.46194, -0.30866, -0.83147, 0.31819, -0.21261, -0.92388, 0.35355, -0.14645, -0.92388, 0.43551, -0.1804, -0.88192, 0.39195, -0.26189, -0.88192, 0.24136, -0.16127, -0.95694, 0.26819, -0.11109, -0.95694, 0.35355, -0.14645, -0.92388, 0.31819, -0.21261, -0.92388, 0.16221, -0.10839, -0.98079, 0.18024, -0.07466, -0.98079, 0.26819, -0.11109, -0.95694, 0.24136, -0.16127, -0.95694, 0.0815, -0.05445, -0.99518, 0.09056, -0.03751, -0.99518, 0.18024, -0.07466, -0.98079, 0.16221, -0.10839, -0.98079, -0, -0, -1, 0.09056, -0.03751, -0.99518, 0.0815, -0.05445, -0.99518, -0, -0, -1, 0.09613, -0.01912, -0.99518, 0.09056, -0.03751, -0.99518, 0.09056, -0.03751, -0.99518, 0.09613, -0.01912, -0.99518, 0.19134, -0.03806, -0.98079, 0.18024, -0.07466, -0.98079, 0.18024, -0.07466, -0.98079, 0.19134, -0.03806, -0.98079, 0.28471, -0.05663, -0.95694, 0.26819, -0.11109, -0.95694, 0.26819, -0.11109, -0.95694, 0.28471, -0.05663, -0.95694, 0.37533, -0.07466, -0.92388, 0.35355, -0.14645, -0.92388, 0.35355, -0.14645, -0.92388, 0.37533, -0.07466, -0.92388, 0.46234, -0.09196, -0.88192, 0.43551, -0.1804, -0.88192, 0.43551, -0.1804, -0.88192, 0.46234, -0.09196, -0.88192, 0.54489, -0.10839, -0.83147, 0.51328, -0.21261, -0.83147, 0.51328, -0.21261, -0.83147, 0.54489, -0.10839, -0.83147, 0.6222, -0.12376, -0.77301, 0.5861, -0.24277, -0.77301, 0.5861, -0.24277, -0.77301, 0.6222, -0.12376, -0.77301, 0.69352, -0.13795, -0.70711, 0.65328, -0.2706, -0.70711, 0.65328, -0.2706, -0.70711, 0.69352, -0.13795, -0.70711, 0.75816, -0.15081, -0.63439, 0.71417, -0.29582, -0.63439, 0.71417, -0.29582, -0.63439, 0.75816, -0.15081, -0.63439, 0.81549, -0.16221, -0.55557, 0.76818, -0.31819, -0.55557, 0.76818, -0.31819, -0.55557, 0.81549, -0.16221, -0.55557, 0.86497, -0.17205, -0.4714, 0.81479, -0.3375, -0.4714, 0.81479, -0.3375, -0.4714, 0.86497, -0.17205, -0.4714, 0.90613, -0.18024, -0.38268, 0.85355, -0.35355, -0.38268, 0.85355, -0.35355, -0.38268, 0.90613, -0.18024, -0.38268, 0.93855, -0.18669, -0.29028, 0.8841, -0.3662, -0.29028, 0.8841, -0.3662, -0.29028, 0.93855, -0.18669, -0.29028, 0.96194, -0.19134, -0.19509, 0.90613, -0.37533, -0.19509, 0.90613, -0.37533, -0.19509, 0.96194, -0.19134, -0.19509, 0.97606, -0.19415, -0.09802, 0.91943, -0.38084, -0.09802, 0.91943, -0.38084, -0.09802, 0.97606, -0.19415, -0.09802, 0.98078, -0.19509, -0, 0.92388, -0.38268, -0, 0.92388, -0.38268, -0, 0.98078, -0.19509, -0, 0.97606, -0.19415, 0.09802, 0.91943, -0.38084, 0.09802, 0.91943, -0.38084, 0.09802, 0.97606, -0.19415, 0.09802, 0.96194, -0.19134, 0.19509, 0.90613, -0.37533, 0.19509, 0.90613, -0.37533, 0.19509, 0.96194, -0.19134, 0.19509, 0.93855, -0.18669, 0.29028, 0.8841, -0.3662, 0.29028, 0.8841, -0.3662, 0.29028, 0.93855, -0.18669, 0.29028, 0.90613, -0.18024, 0.38268, 0.85355, -0.35355, 0.38268, 0.85355, -0.35355, 0.38268, 0.90613, -0.18024, 0.38268, 0.86497, -0.17205, 0.4714, 0.81479, -0.3375, 0.4714, 0.81479, -0.3375, 0.4714, 0.86497, -0.17205, 0.4714, 0.81549, -0.16221, 0.55557, 0.76818, -0.31819, 0.55557, 0.76818, -0.31819, 0.55557, 0.81549, -0.16221, 0.55557, 0.75816, -0.15081, 0.63439, 0.71417, -0.29582, 0.63439, 0.71417, -0.29582, 0.63439, 0.75816, -0.15081, 0.63439, 0.69352, -0.13795, 0.70711, 0.65328, -0.2706, 0.70711, 0.65328, -0.2706, 0.70711, 0.69352, -0.13795, 0.70711, 0.6222, -0.12376, 0.77301, 0.5861, -0.24277, 0.77301, 0.5861, -0.24277, 0.77301, 0.6222, -0.12376, 0.77301, 0.54489, -0.10839, 0.83147, 0.51328, -0.21261, 0.83147, 0.51328, -0.21261, 0.83147, 0.54489, -0.10839, 0.83147, 0.46234, -0.09196, 0.88192, 0.43551, -0.1804, 0.88192, 0.43551, -0.1804, 0.88192, 0.46234, -0.09196, 0.88192, 0.37533, -0.07466, 0.92388, 0.35355, -0.14645, 0.92388, 0.35355, -0.14645, 0.92388, 0.37533, -0.07466, 0.92388, 0.28471, -0.05663, 0.95694, 0.26819, -0.11109, 0.95694, 0.26819, -0.11109, 0.95694, 0.28471, -0.05663, 0.95694, 0.19134, -0.03806, 0.98079, 0.18024, -0.07466, 0.98079, 0.18024, -0.07466, 0.98079, 0.19134, -0.03806, 0.98079, 0.09613, -0.01912, 0.99518, 0.09056, -0.03751, 0.99518, 0.09613, -0.01912, 0.99518, 0, 0, 1, 0.09056, -0.03751, 0.99518, 0.09802, 0, 0.99518, 0, 0, 1, 0.09613, -0.01912, 0.99518, 0.19134, -0.03806, 0.98079, 0.19509, 0, 0.98079, 0.09802, 0, 0.99518, 0.09613, -0.01912, 0.99518, 0.28471, -0.05663, 0.95694, 0.29028, 0, 0.95694, 0.19509, 0, 0.98079, 0.19134, -0.03806, 0.98079, 0.37533, -0.07466, 0.92388, 0.38268, 0, 0.92388, 0.29028, 0, 0.95694, 0.28471, -0.05663, 0.95694, 0.46234, -0.09196, 0.88192, 0.4714, 0, 0.88192, 0.38268, 0, 0.92388, 0.37533, -0.07466, 0.92388, 0.54489, -0.10839, 0.83147, 0.55557, 0, 0.83147, 0.4714, 0, 0.88192, 0.46234, -0.09196, 0.88192, 0.6222, -0.12376, 0.77301, 0.63439, 0, 0.77301, 0.55557, 0, 0.83147, 0.54489, -0.10839, 0.83147, 0.69352, -0.13795, 0.70711, 0.70711, 0, 0.70711, 0.63439, 0, 0.77301, 0.6222, -0.12376, 0.77301, 0.75816, -0.15081, 0.63439, 0.77301, 0, 0.63439, 0.70711, 0, 0.70711, 0.69352, -0.13795, 0.70711, 0.81549, -0.16221, 0.55557, 0.83147, 0, 0.55557, 0.77301, 0, 0.63439, 0.75816, -0.15081, 0.63439, 0.86497, -0.17205, 0.4714, 0.88192, 0, 0.4714, 0.83147, 0, 0.55557, 0.81549, -0.16221, 0.55557, 0.90613, -0.18024, 0.38268, 0.92388, 0, 0.38268, 0.88192, 0, 0.4714, 0.86497, -0.17205, 0.4714, 0.93855, -0.18669, 0.29028, 0.95694, 0, 0.29028, 0.92388, 0, 0.38268, 0.90613, -0.18024, 0.38268, 0.96194, -0.19134, 0.19509, 0.98078, 0, 0.19509, 0.95694, 0, 0.29028, 0.93855, -0.18669, 0.29028, 0.97606, -0.19415, 0.09802, 0.99518, 0, 0.09802, 0.98078, 0, 0.19509, 0.96194, -0.19134, 0.19509, 0.98078, -0.19509, -0, 1, 0, -0, 0.99518, 0, 0.09802, 0.97606, -0.19415, 0.09802, 0.97606, -0.19415, -0.09802, 0.99518, 0, -0.09802, 1, 0, -0, 0.98078, -0.19509, -0, 0.96194, -0.19134, -0.19509, 0.98078, 0, -0.19509, 0.99518, 0, -0.09802, 0.97606, -0.19415, -0.09802, 0.93855, -0.18669, -0.29028, 0.95694, 0, -0.29028, 0.98078, 0, -0.19509, 0.96194, -0.19134, -0.19509, 0.90613, -0.18024, -0.38268, 0.92388, 0, -0.38268, 0.95694, 0, -0.29028, 0.93855, -0.18669, -0.29028, 0.86497, -0.17205, -0.4714, 0.88192, 0, -0.4714, 0.92388, 0, -0.38268, 0.90613, -0.18024, -0.38268, 0.81549, -0.16221, -0.55557, 0.83147, 0, -0.55557, 0.88192, 0, -0.4714, 0.86497, -0.17205, -0.4714, 0.75816, -0.15081, -0.63439, 0.77301, 0, -0.63439, 0.83147, 0, -0.55557, 0.81549, -0.16221, -0.55557, 0.69352, -0.13795, -0.70711, 0.70711, 0, -0.70711, 0.77301, 0, -0.63439, 0.75816, -0.15081, -0.63439, 0.6222, -0.12376, -0.77301, 0.63439, 0, -0.77301, 0.70711, 0, -0.70711, 0.69352, -0.13795, -0.70711, 0.54489, -0.10839, -0.83147, 0.55557, 0, -0.83147, 0.63439, 0, -0.77301, 0.6222, -0.12376, -0.77301, 0.46234, -0.09196, -0.88192, 0.4714, 0, -0.88192, 0.55557, 0, -0.83147, 0.54489, -0.10839, -0.83147, 0.37533, -0.07466, -0.92388, 0.38268, 0, -0.92388, 0.4714, 0, -0.88192, 0.46234, -0.09196, -0.88192, 0.28471, -0.05663, -0.95694, 0.29028, 0, -0.95694, 0.38268, 0, -0.92388, 0.37533, -0.07466, -0.92388, 0.19134, -0.03806, -0.98079, 0.19509, 0, -0.98079, 0.29028, 0, -0.95694, 0.28471, -0.05663, -0.95694, 0.09613, -0.01912, -0.99518, 0.09802, 0, -0.99518, 0.19509, 0, -0.98079, 0.19134, -0.03806, -0.98079, -0, -0, -1, 0.09802, 0, -0.99518, 0.09613, -0.01912, -0.99518 ],
	                                'itemSize': 3,
	                                'type': 'ARRAY_BUFFER'
	                            }
	                        },
	                        'name': 'Sphere',
	                        'primitives': [ {
	                            'indices': {
	                                'elements': [ 0, 1, 2, 123, 124, 125, 126, 127, 128, 249, 250, 251, 252, 253, 254, 375, 376, 377, 378, 379, 380, 501, 502, 503, 504, 505, 506, 627, 628, 629, 630, 631, 632, 753, 754, 755, 756, 757, 758, 879, 880, 881, 882, 883, 884, 1005, 1006, 1007, 1008, 1009, 1010, 1131, 1132, 1133, 1134, 1135, 1136, 1257, 1258, 1259, 1260, 1261, 1262, 1383, 1384, 1385, 1386, 1387, 1388, 1509, 1510, 1511, 1512, 1513, 1514, 1635, 1636, 1637, 1638, 1639, 1640, 1761, 1762, 1763, 1764, 1765, 1766, 1887, 1888, 1889, 1890, 1891, 1892, 2013, 2014, 2015, 2016, 2017, 2018, 2139, 2140, 2141, 2142, 2143, 2144, 2265, 2266, 2267, 2268, 2269, 2270, 2391, 2392, 2393, 2394, 2395, 2396, 2517, 2518, 2519, 2520, 2521, 2522, 2643, 2644, 2645, 2646, 2647, 2648, 2769, 2770, 2771, 2772, 2773, 2774, 2895, 2896, 2897, 2898, 2899, 2900, 3021, 3022, 3023, 3024, 3025, 3026, 3147, 3148, 3149, 3150, 3151, 3152, 3273, 3274, 3275, 3276, 3277, 3278, 3399, 3400, 3401, 3402, 3403, 3404, 3525, 3526, 3527, 3528, 3529, 3530, 3651, 3652, 3653, 3654, 3655, 3656, 3777, 3778, 3779, 3780, 3781, 3782, 3903, 3904, 3905, 3906, 3907, 3908, 4029, 4030, 4031 ],
	                                'itemSize': 1,
	                                'type': 'ELEMENT_ARRAY_BUFFER'
	                            },
	                            'mode': 'TRIANGLES'
	                        }, {
	                            'indices': {
	                                'elements': [ 3, 4, 6, 4, 5, 6, 7, 8, 10, 8, 9, 10, 11, 12, 14, 12, 13, 14, 15, 16, 18, 16, 17, 18, 19, 20, 22, 20, 21, 22, 23, 24, 26, 24, 25, 26, 27, 28, 30, 28, 29, 30, 31, 32, 34, 32, 33, 34, 35, 36, 38, 36, 37, 38, 39, 40, 42, 40, 41, 42, 43, 44, 46, 44, 45, 46, 47, 48, 50, 48, 49, 50, 51, 52, 54, 52, 53, 54, 55, 56, 58, 56, 57, 58, 59, 60, 62, 60, 61, 62, 63, 64, 66, 64, 65, 66, 67, 68, 70, 68, 69, 70, 71, 72, 74, 72, 73, 74, 75, 76, 78, 76, 77, 78, 79, 80, 82, 80, 81, 82, 83, 84, 86, 84, 85, 86, 87, 88, 90, 88, 89, 90, 91, 92, 94, 92, 93, 94, 95, 96, 98, 96, 97, 98, 99, 100, 102, 100, 101, 102, 103, 104, 106, 104, 105, 106, 107, 108, 110, 108, 109, 110, 111, 112, 114, 112, 113, 114, 115, 116, 118, 116, 117, 118, 119, 120, 122, 120, 121, 122, 129, 130, 132, 130, 131, 132, 133, 134, 136, 134, 135, 136, 137, 138, 140, 138, 139, 140, 141, 142, 144, 142, 143, 144, 145, 146, 148, 146, 147, 148, 149, 150, 152, 150, 151, 152, 153, 154, 156, 154, 155, 156, 157, 158, 160, 158, 159, 160, 161, 162, 164, 162, 163, 164, 165, 166, 168, 166, 167, 168, 169, 170, 172, 170, 171, 172, 173, 174, 176, 174, 175, 176, 177, 178, 180, 178, 179, 180, 181, 182, 184, 182, 183, 184, 185, 186, 188, 186, 187, 188, 189, 190, 192, 190, 191, 192, 193, 194, 196, 194, 195, 196, 197, 198, 200, 198, 199, 200, 201, 202, 204, 202, 203, 204, 205, 206, 208, 206, 207, 208, 209, 210, 212, 210, 211, 212, 213, 214, 216, 214, 215, 216, 217, 218, 220, 218, 219, 220, 221, 222, 224, 222, 223, 224, 225, 226, 228, 226, 227, 228, 229, 230, 232, 230, 231, 232, 233, 234, 236, 234, 235, 236, 237, 238, 240, 238, 239, 240, 241, 242, 244, 242, 243, 244, 245, 246, 248, 246, 247, 248, 255, 256, 258, 256, 257, 258, 259, 260, 262, 260, 261, 262, 263, 264, 266, 264, 265, 266, 267, 268, 270, 268, 269, 270, 271, 272, 274, 272, 273, 274, 275, 276, 278, 276, 277, 278, 279, 280, 282, 280, 281, 282, 283, 284, 286, 284, 285, 286, 287, 288, 290, 288, 289, 290, 291, 292, 294, 292, 293, 294, 295, 296, 298, 296, 297, 298, 299, 300, 302, 300, 301, 302, 303, 304, 306, 304, 305, 306, 307, 308, 310, 308, 309, 310, 311, 312, 314, 312, 313, 314, 315, 316, 318, 316, 317, 318, 319, 320, 322, 320, 321, 322, 323, 324, 326, 324, 325, 326, 327, 328, 330, 328, 329, 330, 331, 332, 334, 332, 333, 334, 335, 336, 338, 336, 337, 338, 339, 340, 342, 340, 341, 342, 343, 344, 346, 344, 345, 346, 347, 348, 350, 348, 349, 350, 351, 352, 354, 352, 353, 354, 355, 356, 358, 356, 357, 358, 359, 360, 362, 360, 361, 362, 363, 364, 366, 364, 365, 366, 367, 368, 370, 368, 369, 370, 371, 372, 374, 372, 373, 374, 381, 382, 384, 382, 383, 384, 385, 386, 388, 386, 387, 388, 389, 390, 392, 390, 391, 392, 393, 394, 396, 394, 395, 396, 397, 398, 400, 398, 399, 400, 401, 402, 404, 402, 403, 404, 405, 406, 408, 406, 407, 408, 409, 410, 412, 410, 411, 412, 413, 414, 416, 414, 415, 416, 417, 418, 420, 418, 419, 420, 421, 422, 424, 422, 423, 424, 425, 426, 428, 426, 427, 428, 429, 430, 432, 430, 431, 432, 433, 434, 436, 434, 435, 436, 437, 438, 440, 438, 439, 440, 441, 442, 444, 442, 443, 444, 445, 446, 448, 446, 447, 448, 449, 450, 452, 450, 451, 452, 453, 454, 456, 454, 455, 456, 457, 458, 460, 458, 459, 460, 461, 462, 464, 462, 463, 464, 465, 466, 468, 466, 467, 468, 469, 470, 472, 470, 471, 472, 473, 474, 476, 474, 475, 476, 477, 478, 480, 478, 479, 480, 481, 482, 484, 482, 483, 484, 485, 486, 488, 486, 487, 488, 489, 490, 492, 490, 491, 492, 493, 494, 496, 494, 495, 496, 497, 498, 500, 498, 499, 500, 507, 508, 510, 508, 509, 510, 511, 512, 514, 512, 513, 514, 515, 516, 518, 516, 517, 518, 519, 520, 522, 520, 521, 522, 523, 524, 526, 524, 525, 526, 527, 528, 530, 528, 529, 530, 531, 532, 534, 532, 533, 534, 535, 536, 538, 536, 537, 538, 539, 540, 542, 540, 541, 542, 543, 544, 546, 544, 545, 546, 547, 548, 550, 548, 549, 550, 551, 552, 554, 552, 553, 554, 555, 556, 558, 556, 557, 558, 559, 560, 562, 560, 561, 562, 563, 564, 566, 564, 565, 566, 567, 568, 570, 568, 569, 570, 571, 572, 574, 572, 573, 574, 575, 576, 578, 576, 577, 578, 579, 580, 582, 580, 581, 582, 583, 584, 586, 584, 585, 586, 587, 588, 590, 588, 589, 590, 591, 592, 594, 592, 593, 594, 595, 596, 598, 596, 597, 598, 599, 600, 602, 600, 601, 602, 603, 604, 606, 604, 605, 606, 607, 608, 610, 608, 609, 610, 611, 612, 614, 612, 613, 614, 615, 616, 618, 616, 617, 618, 619, 620, 622, 620, 621, 622, 623, 624, 626, 624, 625, 626, 633, 634, 636, 634, 635, 636, 637, 638, 640, 638, 639, 640, 641, 642, 644, 642, 643, 644, 645, 646, 648, 646, 647, 648, 649, 650, 652, 650, 651, 652, 653, 654, 656, 654, 655, 656, 657, 658, 660, 658, 659, 660, 661, 662, 664, 662, 663, 664, 665, 666, 668, 666, 667, 668, 669, 670, 672, 670, 671, 672, 673, 674, 676, 674, 675, 676, 677, 678, 680, 678, 679, 680, 681, 682, 684, 682, 683, 684, 685, 686, 688, 686, 687, 688, 689, 690, 692, 690, 691, 692, 693, 694, 696, 694, 695, 696, 697, 698, 700, 698, 699, 700, 701, 702, 704, 702, 703, 704, 705, 706, 708, 706, 707, 708, 709, 710, 712, 710, 711, 712, 713, 714, 716, 714, 715, 716, 717, 718, 720, 718, 719, 720, 721, 722, 724, 722, 723, 724, 725, 726, 728, 726, 727, 728, 729, 730, 732, 730, 731, 732, 733, 734, 736, 734, 735, 736, 737, 738, 740, 738, 739, 740, 741, 742, 744, 742, 743, 744, 745, 746, 748, 746, 747, 748, 749, 750, 752, 750, 751, 752, 759, 760, 762, 760, 761, 762, 763, 764, 766, 764, 765, 766, 767, 768, 770, 768, 769, 770, 771, 772, 774, 772, 773, 774, 775, 776, 778, 776, 777, 778, 779, 780, 782, 780, 781, 782, 783, 784, 786, 784, 785, 786, 787, 788, 790, 788, 789, 790, 791, 792, 794, 792, 793, 794, 795, 796, 798, 796, 797, 798, 799, 800, 802, 800, 801, 802, 803, 804, 806, 804, 805, 806, 807, 808, 810, 808, 809, 810, 811, 812, 814, 812, 813, 814, 815, 816, 818, 816, 817, 818, 819, 820, 822, 820, 821, 822, 823, 824, 826, 824, 825, 826, 827, 828, 830, 828, 829, 830, 831, 832, 834, 832, 833, 834, 835, 836, 838, 836, 837, 838, 839, 840, 842, 840, 841, 842, 843, 844, 846, 844, 845, 846, 847, 848, 850, 848, 849, 850, 851, 852, 854, 852, 853, 854, 855, 856, 858, 856, 857, 858, 859, 860, 862, 860, 861, 862, 863, 864, 866, 864, 865, 866, 867, 868, 870, 868, 869, 870, 871, 872, 874, 872, 873, 874, 875, 876, 878, 876, 877, 878, 885, 886, 888, 886, 887, 888, 889, 890, 892, 890, 891, 892, 893, 894, 896, 894, 895, 896, 897, 898, 900, 898, 899, 900, 901, 902, 904, 902, 903, 904, 905, 906, 908, 906, 907, 908, 909, 910, 912, 910, 911, 912, 913, 914, 916, 914, 915, 916, 917, 918, 920, 918, 919, 920, 921, 922, 924, 922, 923, 924, 925, 926, 928, 926, 927, 928, 929, 930, 932, 930, 931, 932, 933, 934, 936, 934, 935, 936, 937, 938, 940, 938, 939, 940, 941, 942, 944, 942, 943, 944, 945, 946, 948, 946, 947, 948, 949, 950, 952, 950, 951, 952, 953, 954, 956, 954, 955, 956, 957, 958, 960, 958, 959, 960, 961, 962, 964, 962, 963, 964, 965, 966, 968, 966, 967, 968, 969, 970, 972, 970, 971, 972, 973, 974, 976, 974, 975, 976, 977, 978, 980, 978, 979, 980, 981, 982, 984, 982, 983, 984, 985, 986, 988, 986, 987, 988, 989, 990, 992, 990, 991, 992, 993, 994, 996, 994, 995, 996, 997, 998, 1000, 998, 999, 1000, 1001, 1002, 1004, 1002, 1003, 1004, 1011, 1012, 1014, 1012, 1013, 1014, 1015, 1016, 1018, 1016, 1017, 1018, 1019, 1020, 1022, 1020, 1021, 1022, 1023, 1024, 1026, 1024, 1025, 1026, 1027, 1028, 1030, 1028, 1029, 1030, 1031, 1032, 1034, 1032, 1033, 1034, 1035, 1036, 1038, 1036, 1037, 1038, 1039, 1040, 1042, 1040, 1041, 1042, 1043, 1044, 1046, 1044, 1045, 1046, 1047, 1048, 1050, 1048, 1049, 1050, 1051, 1052, 1054, 1052, 1053, 1054, 1055, 1056, 1058, 1056, 1057, 1058, 1059, 1060, 1062, 1060, 1061, 1062, 1063, 1064, 1066, 1064, 1065, 1066, 1067, 1068, 1070, 1068, 1069, 1070, 1071, 1072, 1074, 1072, 1073, 1074, 1075, 1076, 1078, 1076, 1077, 1078, 1079, 1080, 1082, 1080, 1081, 1082, 1083, 1084, 1086, 1084, 1085, 1086, 1087, 1088, 1090, 1088, 1089, 1090, 1091, 1092, 1094, 1092, 1093, 1094, 1095, 1096, 1098, 1096, 1097, 1098, 1099, 1100, 1102, 1100, 1101, 1102, 1103, 1104, 1106, 1104, 1105, 1106, 1107, 1108, 1110, 1108, 1109, 1110, 1111, 1112, 1114, 1112, 1113, 1114, 1115, 1116, 1118, 1116, 1117, 1118, 1119, 1120, 1122, 1120, 1121, 1122, 1123, 1124, 1126, 1124, 1125, 1126, 1127, 1128, 1130, 1128, 1129, 1130, 1137, 1138, 1140, 1138, 1139, 1140, 1141, 1142, 1144, 1142, 1143, 1144, 1145, 1146, 1148, 1146, 1147, 1148, 1149, 1150, 1152, 1150, 1151, 1152, 1153, 1154, 1156, 1154, 1155, 1156, 1157, 1158, 1160, 1158, 1159, 1160, 1161, 1162, 1164, 1162, 1163, 1164, 1165, 1166, 1168, 1166, 1167, 1168, 1169, 1170, 1172, 1170, 1171, 1172, 1173, 1174, 1176, 1174, 1175, 1176, 1177, 1178, 1180, 1178, 1179, 1180, 1181, 1182, 1184, 1182, 1183, 1184, 1185, 1186, 1188, 1186, 1187, 1188, 1189, 1190, 1192, 1190, 1191, 1192, 1193, 1194, 1196, 1194, 1195, 1196, 1197, 1198, 1200, 1198, 1199, 1200, 1201, 1202, 1204, 1202, 1203, 1204, 1205, 1206, 1208, 1206, 1207, 1208, 1209, 1210, 1212, 1210, 1211, 1212, 1213, 1214, 1216, 1214, 1215, 1216, 1217, 1218, 1220, 1218, 1219, 1220, 1221, 1222, 1224, 1222, 1223, 1224, 1225, 1226, 1228, 1226, 1227, 1228, 1229, 1230, 1232, 1230, 1231, 1232, 1233, 1234, 1236, 1234, 1235, 1236, 1237, 1238, 1240, 1238, 1239, 1240, 1241, 1242, 1244, 1242, 1243, 1244, 1245, 1246, 1248, 1246, 1247, 1248, 1249, 1250, 1252, 1250, 1251, 1252, 1253, 1254, 1256, 1254, 1255, 1256, 1263, 1264, 1266, 1264, 1265, 1266, 1267, 1268, 1270, 1268, 1269, 1270, 1271, 1272, 1274, 1272, 1273, 1274, 1275, 1276, 1278, 1276, 1277, 1278, 1279, 1280, 1282, 1280, 1281, 1282, 1283, 1284, 1286, 1284, 1285, 1286, 1287, 1288, 1290, 1288, 1289, 1290, 1291, 1292, 1294, 1292, 1293, 1294, 1295, 1296, 1298, 1296, 1297, 1298, 1299, 1300, 1302, 1300, 1301, 1302, 1303, 1304, 1306, 1304, 1305, 1306, 1307, 1308, 1310, 1308, 1309, 1310, 1311, 1312, 1314, 1312, 1313, 1314, 1315, 1316, 1318, 1316, 1317, 1318, 1319, 1320, 1322, 1320, 1321, 1322, 1323, 1324, 1326, 1324, 1325, 1326, 1327, 1328, 1330, 1328, 1329, 1330, 1331, 1332, 1334, 1332, 1333, 1334, 1335, 1336, 1338, 1336, 1337, 1338, 1339, 1340, 1342, 1340, 1341, 1342, 1343, 1344, 1346, 1344, 1345, 1346, 1347, 1348, 1350, 1348, 1349, 1350, 1351, 1352, 1354, 1352, 1353, 1354, 1355, 1356, 1358, 1356, 1357, 1358, 1359, 1360, 1362, 1360, 1361, 1362, 1363, 1364, 1366, 1364, 1365, 1366, 1367, 1368, 1370, 1368, 1369, 1370, 1371, 1372, 1374, 1372, 1373, 1374, 1375, 1376, 1378, 1376, 1377, 1378, 1379, 1380, 1382, 1380, 1381, 1382, 1389, 1390, 1392, 1390, 1391, 1392, 1393, 1394, 1396, 1394, 1395, 1396, 1397, 1398, 1400, 1398, 1399, 1400, 1401, 1402, 1404, 1402, 1403, 1404, 1405, 1406, 1408, 1406, 1407, 1408, 1409, 1410, 1412, 1410, 1411, 1412, 1413, 1414, 1416, 1414, 1415, 1416, 1417, 1418, 1420, 1418, 1419, 1420, 1421, 1422, 1424, 1422, 1423, 1424, 1425, 1426, 1428, 1426, 1427, 1428, 1429, 1430, 1432, 1430, 1431, 1432, 1433, 1434, 1436, 1434, 1435, 1436, 1437, 1438, 1440, 1438, 1439, 1440, 1441, 1442, 1444, 1442, 1443, 1444, 1445, 1446, 1448, 1446, 1447, 1448, 1449, 1450, 1452, 1450, 1451, 1452, 1453, 1454, 1456, 1454, 1455, 1456, 1457, 1458, 1460, 1458, 1459, 1460, 1461, 1462, 1464, 1462, 1463, 1464, 1465, 1466, 1468, 1466, 1467, 1468, 1469, 1470, 1472, 1470, 1471, 1472, 1473, 1474, 1476, 1474, 1475, 1476, 1477, 1478, 1480, 1478, 1479, 1480, 1481, 1482, 1484, 1482, 1483, 1484, 1485, 1486, 1488, 1486, 1487, 1488, 1489, 1490, 1492, 1490, 1491, 1492, 1493, 1494, 1496, 1494, 1495, 1496, 1497, 1498, 1500, 1498, 1499, 1500, 1501, 1502, 1504, 1502, 1503, 1504, 1505, 1506, 1508, 1506, 1507, 1508, 1515, 1516, 1518, 1516, 1517, 1518, 1519, 1520, 1522, 1520, 1521, 1522, 1523, 1524, 1526, 1524, 1525, 1526, 1527, 1528, 1530, 1528, 1529, 1530, 1531, 1532, 1534, 1532, 1533, 1534, 1535, 1536, 1538, 1536, 1537, 1538, 1539, 1540, 1542, 1540, 1541, 1542, 1543, 1544, 1546, 1544, 1545, 1546, 1547, 1548, 1550, 1548, 1549, 1550, 1551, 1552, 1554, 1552, 1553, 1554, 1555, 1556, 1558, 1556, 1557, 1558, 1559, 1560, 1562, 1560, 1561, 1562, 1563, 1564, 1566, 1564, 1565, 1566, 1567, 1568, 1570, 1568, 1569, 1570, 1571, 1572, 1574, 1572, 1573, 1574, 1575, 1576, 1578, 1576, 1577, 1578, 1579, 1580, 1582, 1580, 1581, 1582, 1583, 1584, 1586, 1584, 1585, 1586, 1587, 1588, 1590, 1588, 1589, 1590, 1591, 1592, 1594, 1592, 1593, 1594, 1595, 1596, 1598, 1596, 1597, 1598, 1599, 1600, 1602, 1600, 1601, 1602, 1603, 1604, 1606, 1604, 1605, 1606, 1607, 1608, 1610, 1608, 1609, 1610, 1611, 1612, 1614, 1612, 1613, 1614, 1615, 1616, 1618, 1616, 1617, 1618, 1619, 1620, 1622, 1620, 1621, 1622, 1623, 1624, 1626, 1624, 1625, 1626, 1627, 1628, 1630, 1628, 1629, 1630, 1631, 1632, 1634, 1632, 1633, 1634, 1641, 1642, 1644, 1642, 1643, 1644, 1645, 1646, 1648, 1646, 1647, 1648, 1649, 1650, 1652, 1650, 1651, 1652, 1653, 1654, 1656, 1654, 1655, 1656, 1657, 1658, 1660, 1658, 1659, 1660, 1661, 1662, 1664, 1662, 1663, 1664, 1665, 1666, 1668, 1666, 1667, 1668, 1669, 1670, 1672, 1670, 1671, 1672, 1673, 1674, 1676, 1674, 1675, 1676, 1677, 1678, 1680, 1678, 1679, 1680, 1681, 1682, 1684, 1682, 1683, 1684, 1685, 1686, 1688, 1686, 1687, 1688, 1689, 1690, 1692, 1690, 1691, 1692, 1693, 1694, 1696, 1694, 1695, 1696, 1697, 1698, 1700, 1698, 1699, 1700, 1701, 1702, 1704, 1702, 1703, 1704, 1705, 1706, 1708, 1706, 1707, 1708, 1709, 1710, 1712, 1710, 1711, 1712, 1713, 1714, 1716, 1714, 1715, 1716, 1717, 1718, 1720, 1718, 1719, 1720, 1721, 1722, 1724, 1722, 1723, 1724, 1725, 1726, 1728, 1726, 1727, 1728, 1729, 1730, 1732, 1730, 1731, 1732, 1733, 1734, 1736, 1734, 1735, 1736, 1737, 1738, 1740, 1738, 1739, 1740, 1741, 1742, 1744, 1742, 1743, 1744, 1745, 1746, 1748, 1746, 1747, 1748, 1749, 1750, 1752, 1750, 1751, 1752, 1753, 1754, 1756, 1754, 1755, 1756, 1757, 1758, 1760, 1758, 1759, 1760, 1767, 1768, 1770, 1768, 1769, 1770, 1771, 1772, 1774, 1772, 1773, 1774, 1775, 1776, 1778, 1776, 1777, 1778, 1779, 1780, 1782, 1780, 1781, 1782, 1783, 1784, 1786, 1784, 1785, 1786, 1787, 1788, 1790, 1788, 1789, 1790, 1791, 1792, 1794, 1792, 1793, 1794, 1795, 1796, 1798, 1796, 1797, 1798, 1799, 1800, 1802, 1800, 1801, 1802, 1803, 1804, 1806, 1804, 1805, 1806, 1807, 1808, 1810, 1808, 1809, 1810, 1811, 1812, 1814, 1812, 1813, 1814, 1815, 1816, 1818, 1816, 1817, 1818, 1819, 1820, 1822, 1820, 1821, 1822, 1823, 1824, 1826, 1824, 1825, 1826, 1827, 1828, 1830, 1828, 1829, 1830, 1831, 1832, 1834, 1832, 1833, 1834, 1835, 1836, 1838, 1836, 1837, 1838, 1839, 1840, 1842, 1840, 1841, 1842, 1843, 1844, 1846, 1844, 1845, 1846, 1847, 1848, 1850, 1848, 1849, 1850, 1851, 1852, 1854, 1852, 1853, 1854, 1855, 1856, 1858, 1856, 1857, 1858, 1859, 1860, 1862, 1860, 1861, 1862, 1863, 1864, 1866, 1864, 1865, 1866, 1867, 1868, 1870, 1868, 1869, 1870, 1871, 1872, 1874, 1872, 1873, 1874, 1875, 1876, 1878, 1876, 1877, 1878, 1879, 1880, 1882, 1880, 1881, 1882, 1883, 1884, 1886, 1884, 1885, 1886, 1893, 1894, 1896, 1894, 1895, 1896, 1897, 1898, 1900, 1898, 1899, 1900, 1901, 1902, 1904, 1902, 1903, 1904, 1905, 1906, 1908, 1906, 1907, 1908, 1909, 1910, 1912, 1910, 1911, 1912, 1913, 1914, 1916, 1914, 1915, 1916, 1917, 1918, 1920, 1918, 1919, 1920, 1921, 1922, 1924, 1922, 1923, 1924, 1925, 1926, 1928, 1926, 1927, 1928, 1929, 1930, 1932, 1930, 1931, 1932, 1933, 1934, 1936, 1934, 1935, 1936, 1937, 1938, 1940, 1938, 1939, 1940, 1941, 1942, 1944, 1942, 1943, 1944, 1945, 1946, 1948, 1946, 1947, 1948, 1949, 1950, 1952, 1950, 1951, 1952, 1953, 1954, 1956, 1954, 1955, 1956, 1957, 1958, 1960, 1958, 1959, 1960, 1961, 1962, 1964, 1962, 1963, 1964, 1965, 1966, 1968, 1966, 1967, 1968, 1969, 1970, 1972, 1970, 1971, 1972, 1973, 1974, 1976, 1974, 1975, 1976, 1977, 1978, 1980, 1978, 1979, 1980, 1981, 1982, 1984, 1982, 1983, 1984, 1985, 1986, 1988, 1986, 1987, 1988, 1989, 1990, 1992, 1990, 1991, 1992, 1993, 1994, 1996, 1994, 1995, 1996, 1997, 1998, 2000, 1998, 1999, 2000, 2001, 2002, 2004, 2002, 2003, 2004, 2005, 2006, 2008, 2006, 2007, 2008, 2009, 2010, 2012, 2010, 2011, 2012, 2019, 2020, 2022, 2020, 2021, 2022, 2023, 2024, 2026, 2024, 2025, 2026, 2027, 2028, 2030, 2028, 2029, 2030, 2031, 2032, 2034, 2032, 2033, 2034, 2035, 2036, 2038, 2036, 2037, 2038, 2039, 2040, 2042, 2040, 2041, 2042, 2043, 2044, 2046, 2044, 2045, 2046, 2047, 2048, 2050, 2048, 2049, 2050, 2051, 2052, 2054, 2052, 2053, 2054, 2055, 2056, 2058, 2056, 2057, 2058, 2059, 2060, 2062, 2060, 2061, 2062, 2063, 2064, 2066, 2064, 2065, 2066, 2067, 2068, 2070, 2068, 2069, 2070, 2071, 2072, 2074, 2072, 2073, 2074, 2075, 2076, 2078, 2076, 2077, 2078, 2079, 2080, 2082, 2080, 2081, 2082, 2083, 2084, 2086, 2084, 2085, 2086, 2087, 2088, 2090, 2088, 2089, 2090, 2091, 2092, 2094, 2092, 2093, 2094, 2095, 2096, 2098, 2096, 2097, 2098, 2099, 2100, 2102, 2100, 2101, 2102, 2103, 2104, 2106, 2104, 2105, 2106, 2107, 2108, 2110, 2108, 2109, 2110, 2111, 2112, 2114, 2112, 2113, 2114, 2115, 2116, 2118, 2116, 2117, 2118, 2119, 2120, 2122, 2120, 2121, 2122, 2123, 2124, 2126, 2124, 2125, 2126, 2127, 2128, 2130, 2128, 2129, 2130, 2131, 2132, 2134, 2132, 2133, 2134, 2135, 2136, 2138, 2136, 2137, 2138, 2145, 2146, 2148, 2146, 2147, 2148, 2149, 2150, 2152, 2150, 2151, 2152, 2153, 2154, 2156, 2154, 2155, 2156, 2157, 2158, 2160, 2158, 2159, 2160, 2161, 2162, 2164, 2162, 2163, 2164, 2165, 2166, 2168, 2166, 2167, 2168, 2169, 2170, 2172, 2170, 2171, 2172, 2173, 2174, 2176, 2174, 2175, 2176, 2177, 2178, 2180, 2178, 2179, 2180, 2181, 2182, 2184, 2182, 2183, 2184, 2185, 2186, 2188, 2186, 2187, 2188, 2189, 2190, 2192, 2190, 2191, 2192, 2193, 2194, 2196, 2194, 2195, 2196, 2197, 2198, 2200, 2198, 2199, 2200, 2201, 2202, 2204, 2202, 2203, 2204, 2205, 2206, 2208, 2206, 2207, 2208, 2209, 2210, 2212, 2210, 2211, 2212, 2213, 2214, 2216, 2214, 2215, 2216, 2217, 2218, 2220, 2218, 2219, 2220, 2221, 2222, 2224, 2222, 2223, 2224, 2225, 2226, 2228, 2226, 2227, 2228, 2229, 2230, 2232, 2230, 2231, 2232, 2233, 2234, 2236, 2234, 2235, 2236, 2237, 2238, 2240, 2238, 2239, 2240, 2241, 2242, 2244, 2242, 2243, 2244, 2245, 2246, 2248, 2246, 2247, 2248, 2249, 2250, 2252, 2250, 2251, 2252, 2253, 2254, 2256, 2254, 2255, 2256, 2257, 2258, 2260, 2258, 2259, 2260, 2261, 2262, 2264, 2262, 2263, 2264, 2271, 2272, 2274, 2272, 2273, 2274, 2275, 2276, 2278, 2276, 2277, 2278, 2279, 2280, 2282, 2280, 2281, 2282, 2283, 2284, 2286, 2284, 2285, 2286, 2287, 2288, 2290, 2288, 2289, 2290, 2291, 2292, 2294, 2292, 2293, 2294, 2295, 2296, 2298, 2296, 2297, 2298, 2299, 2300, 2302, 2300, 2301, 2302, 2303, 2304, 2306, 2304, 2305, 2306, 2307, 2308, 2310, 2308, 2309, 2310, 2311, 2312, 2314, 2312, 2313, 2314, 2315, 2316, 2318, 2316, 2317, 2318, 2319, 2320, 2322, 2320, 2321, 2322, 2323, 2324, 2326, 2324, 2325, 2326, 2327, 2328, 2330, 2328, 2329, 2330, 2331, 2332, 2334, 2332, 2333, 2334, 2335, 2336, 2338, 2336, 2337, 2338, 2339, 2340, 2342, 2340, 2341, 2342, 2343, 2344, 2346, 2344, 2345, 2346, 2347, 2348, 2350, 2348, 2349, 2350, 2351, 2352, 2354, 2352, 2353, 2354, 2355, 2356, 2358, 2356, 2357, 2358, 2359, 2360, 2362, 2360, 2361, 2362, 2363, 2364, 2366, 2364, 2365, 2366, 2367, 2368, 2370, 2368, 2369, 2370, 2371, 2372, 2374, 2372, 2373, 2374, 2375, 2376, 2378, 2376, 2377, 2378, 2379, 2380, 2382, 2380, 2381, 2382, 2383, 2384, 2386, 2384, 2385, 2386, 2387, 2388, 2390, 2388, 2389, 2390, 2397, 2398, 2400, 2398, 2399, 2400, 2401, 2402, 2404, 2402, 2403, 2404, 2405, 2406, 2408, 2406, 2407, 2408, 2409, 2410, 2412, 2410, 2411, 2412, 2413, 2414, 2416, 2414, 2415, 2416, 2417, 2418, 2420, 2418, 2419, 2420, 2421, 2422, 2424, 2422, 2423, 2424, 2425, 2426, 2428, 2426, 2427, 2428, 2429, 2430, 2432, 2430, 2431, 2432, 2433, 2434, 2436, 2434, 2435, 2436, 2437, 2438, 2440, 2438, 2439, 2440, 2441, 2442, 2444, 2442, 2443, 2444, 2445, 2446, 2448, 2446, 2447, 2448, 2449, 2450, 2452, 2450, 2451, 2452, 2453, 2454, 2456, 2454, 2455, 2456, 2457, 2458, 2460, 2458, 2459, 2460, 2461, 2462, 2464, 2462, 2463, 2464, 2465, 2466, 2468, 2466, 2467, 2468, 2469, 2470, 2472, 2470, 2471, 2472, 2473, 2474, 2476, 2474, 2475, 2476, 2477, 2478, 2480, 2478, 2479, 2480, 2481, 2482, 2484, 2482, 2483, 2484, 2485, 2486, 2488, 2486, 2487, 2488, 2489, 2490, 2492, 2490, 2491, 2492, 2493, 2494, 2496, 2494, 2495, 2496, 2497, 2498, 2500, 2498, 2499, 2500, 2501, 2502, 2504, 2502, 2503, 2504, 2505, 2506, 2508, 2506, 2507, 2508, 2509, 2510, 2512, 2510, 2511, 2512, 2513, 2514, 2516, 2514, 2515, 2516, 2523, 2524, 2526, 2524, 2525, 2526, 2527, 2528, 2530, 2528, 2529, 2530, 2531, 2532, 2534, 2532, 2533, 2534, 2535, 2536, 2538, 2536, 2537, 2538, 2539, 2540, 2542, 2540, 2541, 2542, 2543, 2544, 2546, 2544, 2545, 2546, 2547, 2548, 2550, 2548, 2549, 2550, 2551, 2552, 2554, 2552, 2553, 2554, 2555, 2556, 2558, 2556, 2557, 2558, 2559, 2560, 2562, 2560, 2561, 2562, 2563, 2564, 2566, 2564, 2565, 2566, 2567, 2568, 2570, 2568, 2569, 2570, 2571, 2572, 2574, 2572, 2573, 2574, 2575, 2576, 2578, 2576, 2577, 2578, 2579, 2580, 2582, 2580, 2581, 2582, 2583, 2584, 2586, 2584, 2585, 2586, 2587, 2588, 2590, 2588, 2589, 2590, 2591, 2592, 2594, 2592, 2593, 2594, 2595, 2596, 2598, 2596, 2597, 2598, 2599, 2600, 2602, 2600, 2601, 2602, 2603, 2604, 2606, 2604, 2605, 2606, 2607, 2608, 2610, 2608, 2609, 2610, 2611, 2612, 2614, 2612, 2613, 2614, 2615, 2616, 2618, 2616, 2617, 2618, 2619, 2620, 2622, 2620, 2621, 2622, 2623, 2624, 2626, 2624, 2625, 2626, 2627, 2628, 2630, 2628, 2629, 2630, 2631, 2632, 2634, 2632, 2633, 2634, 2635, 2636, 2638, 2636, 2637, 2638, 2639, 2640, 2642, 2640, 2641, 2642, 2649, 2650, 2652, 2650, 2651, 2652, 2653, 2654, 2656, 2654, 2655, 2656, 2657, 2658, 2660, 2658, 2659, 2660, 2661, 2662, 2664, 2662, 2663, 2664, 2665, 2666, 2668, 2666, 2667, 2668, 2669, 2670, 2672, 2670, 2671, 2672, 2673, 2674, 2676, 2674, 2675, 2676, 2677, 2678, 2680, 2678, 2679, 2680, 2681, 2682, 2684, 2682, 2683, 2684, 2685, 2686, 2688, 2686, 2687, 2688, 2689, 2690, 2692, 2690, 2691, 2692, 2693, 2694, 2696, 2694, 2695, 2696, 2697, 2698, 2700, 2698, 2699, 2700, 2701, 2702, 2704, 2702, 2703, 2704, 2705, 2706, 2708, 2706, 2707, 2708, 2709, 2710, 2712, 2710, 2711, 2712, 2713, 2714, 2716, 2714, 2715, 2716, 2717, 2718, 2720, 2718, 2719, 2720, 2721, 2722, 2724, 2722, 2723, 2724, 2725, 2726, 2728, 2726, 2727, 2728, 2729, 2730, 2732, 2730, 2731, 2732, 2733, 2734, 2736, 2734, 2735, 2736, 2737, 2738, 2740, 2738, 2739, 2740, 2741, 2742, 2744, 2742, 2743, 2744, 2745, 2746, 2748, 2746, 2747, 2748, 2749, 2750, 2752, 2750, 2751, 2752, 2753, 2754, 2756, 2754, 2755, 2756, 2757, 2758, 2760, 2758, 2759, 2760, 2761, 2762, 2764, 2762, 2763, 2764, 2765, 2766, 2768, 2766, 2767, 2768, 2775, 2776, 2778, 2776, 2777, 2778, 2779, 2780, 2782, 2780, 2781, 2782, 2783, 2784, 2786, 2784, 2785, 2786, 2787, 2788, 2790, 2788, 2789, 2790, 2791, 2792, 2794, 2792, 2793, 2794, 2795, 2796, 2798, 2796, 2797, 2798, 2799, 2800, 2802, 2800, 2801, 2802, 2803, 2804, 2806, 2804, 2805, 2806, 2807, 2808, 2810, 2808, 2809, 2810, 2811, 2812, 2814, 2812, 2813, 2814, 2815, 2816, 2818, 2816, 2817, 2818, 2819, 2820, 2822, 2820, 2821, 2822, 2823, 2824, 2826, 2824, 2825, 2826, 2827, 2828, 2830, 2828, 2829, 2830, 2831, 2832, 2834, 2832, 2833, 2834, 2835, 2836, 2838, 2836, 2837, 2838, 2839, 2840, 2842, 2840, 2841, 2842, 2843, 2844, 2846, 2844, 2845, 2846, 2847, 2848, 2850, 2848, 2849, 2850, 2851, 2852, 2854, 2852, 2853, 2854, 2855, 2856, 2858, 2856, 2857, 2858, 2859, 2860, 2862, 2860, 2861, 2862, 2863, 2864, 2866, 2864, 2865, 2866, 2867, 2868, 2870, 2868, 2869, 2870, 2871, 2872, 2874, 2872, 2873, 2874, 2875, 2876, 2878, 2876, 2877, 2878, 2879, 2880, 2882, 2880, 2881, 2882, 2883, 2884, 2886, 2884, 2885, 2886, 2887, 2888, 2890, 2888, 2889, 2890, 2891, 2892, 2894, 2892, 2893, 2894, 2901, 2902, 2904, 2902, 2903, 2904, 2905, 2906, 2908, 2906, 2907, 2908, 2909, 2910, 2912, 2910, 2911, 2912, 2913, 2914, 2916, 2914, 2915, 2916, 2917, 2918, 2920, 2918, 2919, 2920, 2921, 2922, 2924, 2922, 2923, 2924, 2925, 2926, 2928, 2926, 2927, 2928, 2929, 2930, 2932, 2930, 2931, 2932, 2933, 2934, 2936, 2934, 2935, 2936, 2937, 2938, 2940, 2938, 2939, 2940, 2941, 2942, 2944, 2942, 2943, 2944, 2945, 2946, 2948, 2946, 2947, 2948, 2949, 2950, 2952, 2950, 2951, 2952, 2953, 2954, 2956, 2954, 2955, 2956, 2957, 2958, 2960, 2958, 2959, 2960, 2961, 2962, 2964, 2962, 2963, 2964, 2965, 2966, 2968, 2966, 2967, 2968, 2969, 2970, 2972, 2970, 2971, 2972, 2973, 2974, 2976, 2974, 2975, 2976, 2977, 2978, 2980, 2978, 2979, 2980, 2981, 2982, 2984, 2982, 2983, 2984, 2985, 2986, 2988, 2986, 2987, 2988, 2989, 2990, 2992, 2990, 2991, 2992, 2993, 2994, 2996, 2994, 2995, 2996, 2997, 2998, 3000, 2998, 2999, 3000, 3001, 3002, 3004, 3002, 3003, 3004, 3005, 3006, 3008, 3006, 3007, 3008, 3009, 3010, 3012, 3010, 3011, 3012, 3013, 3014, 3016, 3014, 3015, 3016, 3017, 3018, 3020, 3018, 3019, 3020, 3027, 3028, 3030, 3028, 3029, 3030, 3031, 3032, 3034, 3032, 3033, 3034, 3035, 3036, 3038, 3036, 3037, 3038, 3039, 3040, 3042, 3040, 3041, 3042, 3043, 3044, 3046, 3044, 3045, 3046, 3047, 3048, 3050, 3048, 3049, 3050, 3051, 3052, 3054, 3052, 3053, 3054, 3055, 3056, 3058, 3056, 3057, 3058, 3059, 3060, 3062, 3060, 3061, 3062, 3063, 3064, 3066, 3064, 3065, 3066, 3067, 3068, 3070, 3068, 3069, 3070, 3071, 3072, 3074, 3072, 3073, 3074, 3075, 3076, 3078, 3076, 3077, 3078, 3079, 3080, 3082, 3080, 3081, 3082, 3083, 3084, 3086, 3084, 3085, 3086, 3087, 3088, 3090, 3088, 3089, 3090, 3091, 3092, 3094, 3092, 3093, 3094, 3095, 3096, 3098, 3096, 3097, 3098, 3099, 3100, 3102, 3100, 3101, 3102, 3103, 3104, 3106, 3104, 3105, 3106, 3107, 3108, 3110, 3108, 3109, 3110, 3111, 3112, 3114, 3112, 3113, 3114, 3115, 3116, 3118, 3116, 3117, 3118, 3119, 3120, 3122, 3120, 3121, 3122, 3123, 3124, 3126, 3124, 3125, 3126, 3127, 3128, 3130, 3128, 3129, 3130, 3131, 3132, 3134, 3132, 3133, 3134, 3135, 3136, 3138, 3136, 3137, 3138, 3139, 3140, 3142, 3140, 3141, 3142, 3143, 3144, 3146, 3144, 3145, 3146, 3153, 3154, 3156, 3154, 3155, 3156, 3157, 3158, 3160, 3158, 3159, 3160, 3161, 3162, 3164, 3162, 3163, 3164, 3165, 3166, 3168, 3166, 3167, 3168, 3169, 3170, 3172, 3170, 3171, 3172, 3173, 3174, 3176, 3174, 3175, 3176, 3177, 3178, 3180, 3178, 3179, 3180, 3181, 3182, 3184, 3182, 3183, 3184, 3185, 3186, 3188, 3186, 3187, 3188, 3189, 3190, 3192, 3190, 3191, 3192, 3193, 3194, 3196, 3194, 3195, 3196, 3197, 3198, 3200, 3198, 3199, 3200, 3201, 3202, 3204, 3202, 3203, 3204, 3205, 3206, 3208, 3206, 3207, 3208, 3209, 3210, 3212, 3210, 3211, 3212, 3213, 3214, 3216, 3214, 3215, 3216, 3217, 3218, 3220, 3218, 3219, 3220, 3221, 3222, 3224, 3222, 3223, 3224, 3225, 3226, 3228, 3226, 3227, 3228, 3229, 3230, 3232, 3230, 3231, 3232, 3233, 3234, 3236, 3234, 3235, 3236, 3237, 3238, 3240, 3238, 3239, 3240, 3241, 3242, 3244, 3242, 3243, 3244, 3245, 3246, 3248, 3246, 3247, 3248, 3249, 3250, 3252, 3250, 3251, 3252, 3253, 3254, 3256, 3254, 3255, 3256, 3257, 3258, 3260, 3258, 3259, 3260, 3261, 3262, 3264, 3262, 3263, 3264, 3265, 3266, 3268, 3266, 3267, 3268, 3269, 3270, 3272, 3270, 3271, 3272, 3279, 3280, 3282, 3280, 3281, 3282, 3283, 3284, 3286, 3284, 3285, 3286, 3287, 3288, 3290, 3288, 3289, 3290, 3291, 3292, 3294, 3292, 3293, 3294, 3295, 3296, 3298, 3296, 3297, 3298, 3299, 3300, 3302, 3300, 3301, 3302, 3303, 3304, 3306, 3304, 3305, 3306, 3307, 3308, 3310, 3308, 3309, 3310, 3311, 3312, 3314, 3312, 3313, 3314, 3315, 3316, 3318, 3316, 3317, 3318, 3319, 3320, 3322, 3320, 3321, 3322, 3323, 3324, 3326, 3324, 3325, 3326, 3327, 3328, 3330, 3328, 3329, 3330, 3331, 3332, 3334, 3332, 3333, 3334, 3335, 3336, 3338, 3336, 3337, 3338, 3339, 3340, 3342, 3340, 3341, 3342, 3343, 3344, 3346, 3344, 3345, 3346, 3347, 3348, 3350, 3348, 3349, 3350, 3351, 3352, 3354, 3352, 3353, 3354, 3355, 3356, 3358, 3356, 3357, 3358, 3359, 3360, 3362, 3360, 3361, 3362, 3363, 3364, 3366, 3364, 3365, 3366, 3367, 3368, 3370, 3368, 3369, 3370, 3371, 3372, 3374, 3372, 3373, 3374, 3375, 3376, 3378, 3376, 3377, 3378, 3379, 3380, 3382, 3380, 3381, 3382, 3383, 3384, 3386, 3384, 3385, 3386, 3387, 3388, 3390, 3388, 3389, 3390, 3391, 3392, 3394, 3392, 3393, 3394, 3395, 3396, 3398, 3396, 3397, 3398, 3405, 3406, 3408, 3406, 3407, 3408, 3409, 3410, 3412, 3410, 3411, 3412, 3413, 3414, 3416, 3414, 3415, 3416, 3417, 3418, 3420, 3418, 3419, 3420, 3421, 3422, 3424, 3422, 3423, 3424, 3425, 3426, 3428, 3426, 3427, 3428, 3429, 3430, 3432, 3430, 3431, 3432, 3433, 3434, 3436, 3434, 3435, 3436, 3437, 3438, 3440, 3438, 3439, 3440, 3441, 3442, 3444, 3442, 3443, 3444, 3445, 3446, 3448, 3446, 3447, 3448, 3449, 3450, 3452, 3450, 3451, 3452, 3453, 3454, 3456, 3454, 3455, 3456, 3457, 3458, 3460, 3458, 3459, 3460, 3461, 3462, 3464, 3462, 3463, 3464, 3465, 3466, 3468, 3466, 3467, 3468, 3469, 3470, 3472, 3470, 3471, 3472, 3473, 3474, 3476, 3474, 3475, 3476, 3477, 3478, 3480, 3478, 3479, 3480, 3481, 3482, 3484, 3482, 3483, 3484, 3485, 3486, 3488, 3486, 3487, 3488, 3489, 3490, 3492, 3490, 3491, 3492, 3493, 3494, 3496, 3494, 3495, 3496, 3497, 3498, 3500, 3498, 3499, 3500, 3501, 3502, 3504, 3502, 3503, 3504, 3505, 3506, 3508, 3506, 3507, 3508, 3509, 3510, 3512, 3510, 3511, 3512, 3513, 3514, 3516, 3514, 3515, 3516, 3517, 3518, 3520, 3518, 3519, 3520, 3521, 3522, 3524, 3522, 3523, 3524, 3531, 3532, 3534, 3532, 3533, 3534, 3535, 3536, 3538, 3536, 3537, 3538, 3539, 3540, 3542, 3540, 3541, 3542, 3543, 3544, 3546, 3544, 3545, 3546, 3547, 3548, 3550, 3548, 3549, 3550, 3551, 3552, 3554, 3552, 3553, 3554, 3555, 3556, 3558, 3556, 3557, 3558, 3559, 3560, 3562, 3560, 3561, 3562, 3563, 3564, 3566, 3564, 3565, 3566, 3567, 3568, 3570, 3568, 3569, 3570, 3571, 3572, 3574, 3572, 3573, 3574, 3575, 3576, 3578, 3576, 3577, 3578, 3579, 3580, 3582, 3580, 3581, 3582, 3583, 3584, 3586, 3584, 3585, 3586, 3587, 3588, 3590, 3588, 3589, 3590, 3591, 3592, 3594, 3592, 3593, 3594, 3595, 3596, 3598, 3596, 3597, 3598, 3599, 3600, 3602, 3600, 3601, 3602, 3603, 3604, 3606, 3604, 3605, 3606, 3607, 3608, 3610, 3608, 3609, 3610, 3611, 3612, 3614, 3612, 3613, 3614, 3615, 3616, 3618, 3616, 3617, 3618, 3619, 3620, 3622, 3620, 3621, 3622, 3623, 3624, 3626, 3624, 3625, 3626, 3627, 3628, 3630, 3628, 3629, 3630, 3631, 3632, 3634, 3632, 3633, 3634, 3635, 3636, 3638, 3636, 3637, 3638, 3639, 3640, 3642, 3640, 3641, 3642, 3643, 3644, 3646, 3644, 3645, 3646, 3647, 3648, 3650, 3648, 3649, 3650, 3657, 3658, 3660, 3658, 3659, 3660, 3661, 3662, 3664, 3662, 3663, 3664, 3665, 3666, 3668, 3666, 3667, 3668, 3669, 3670, 3672, 3670, 3671, 3672, 3673, 3674, 3676, 3674, 3675, 3676, 3677, 3678, 3680, 3678, 3679, 3680, 3681, 3682, 3684, 3682, 3683, 3684, 3685, 3686, 3688, 3686, 3687, 3688, 3689, 3690, 3692, 3690, 3691, 3692, 3693, 3694, 3696, 3694, 3695, 3696, 3697, 3698, 3700, 3698, 3699, 3700, 3701, 3702, 3704, 3702, 3703, 3704, 3705, 3706, 3708, 3706, 3707, 3708, 3709, 3710, 3712, 3710, 3711, 3712, 3713, 3714, 3716, 3714, 3715, 3716, 3717, 3718, 3720, 3718, 3719, 3720, 3721, 3722, 3724, 3722, 3723, 3724, 3725, 3726, 3728, 3726, 3727, 3728, 3729, 3730, 3732, 3730, 3731, 3732, 3733, 3734, 3736, 3734, 3735, 3736, 3737, 3738, 3740, 3738, 3739, 3740, 3741, 3742, 3744, 3742, 3743, 3744, 3745, 3746, 3748, 3746, 3747, 3748, 3749, 3750, 3752, 3750, 3751, 3752, 3753, 3754, 3756, 3754, 3755, 3756, 3757, 3758, 3760, 3758, 3759, 3760, 3761, 3762, 3764, 3762, 3763, 3764, 3765, 3766, 3768, 3766, 3767, 3768, 3769, 3770, 3772, 3770, 3771, 3772, 3773, 3774, 3776, 3774, 3775, 3776, 3783, 3784, 3786, 3784, 3785, 3786, 3787, 3788, 3790, 3788, 3789, 3790, 3791, 3792, 3794, 3792, 3793, 3794, 3795, 3796, 3798, 3796, 3797, 3798, 3799, 3800, 3802, 3800, 3801, 3802, 3803, 3804, 3806, 3804, 3805, 3806, 3807, 3808, 3810, 3808, 3809, 3810, 3811, 3812, 3814, 3812, 3813, 3814, 3815, 3816, 3818, 3816, 3817, 3818, 3819, 3820, 3822, 3820, 3821, 3822, 3823, 3824, 3826, 3824, 3825, 3826, 3827, 3828, 3830, 3828, 3829, 3830, 3831, 3832, 3834, 3832, 3833, 3834, 3835, 3836, 3838, 3836, 3837, 3838, 3839, 3840, 3842, 3840, 3841, 3842, 3843, 3844, 3846, 3844, 3845, 3846, 3847, 3848, 3850, 3848, 3849, 3850, 3851, 3852, 3854, 3852, 3853, 3854, 3855, 3856, 3858, 3856, 3857, 3858, 3859, 3860, 3862, 3860, 3861, 3862, 3863, 3864, 3866, 3864, 3865, 3866, 3867, 3868, 3870, 3868, 3869, 3870, 3871, 3872, 3874, 3872, 3873, 3874, 3875, 3876, 3878, 3876, 3877, 3878, 3879, 3880, 3882, 3880, 3881, 3882, 3883, 3884, 3886, 3884, 3885, 3886, 3887, 3888, 3890, 3888, 3889, 3890, 3891, 3892, 3894, 3892, 3893, 3894, 3895, 3896, 3898, 3896, 3897, 3898, 3899, 3900, 3902, 3900, 3901, 3902, 3909, 3910, 3912, 3910, 3911, 3912, 3913, 3914, 3916, 3914, 3915, 3916, 3917, 3918, 3920, 3918, 3919, 3920, 3921, 3922, 3924, 3922, 3923, 3924, 3925, 3926, 3928, 3926, 3927, 3928, 3929, 3930, 3932, 3930, 3931, 3932, 3933, 3934, 3936, 3934, 3935, 3936, 3937, 3938, 3940, 3938, 3939, 3940, 3941, 3942, 3944, 3942, 3943, 3944, 3945, 3946, 3948, 3946, 3947, 3948, 3949, 3950, 3952, 3950, 3951, 3952, 3953, 3954, 3956, 3954, 3955, 3956, 3957, 3958, 3960, 3958, 3959, 3960, 3961, 3962, 3964, 3962, 3963, 3964, 3965, 3966, 3968, 3966, 3967, 3968, 3969, 3970, 3972, 3970, 3971, 3972, 3973, 3974, 3976, 3974, 3975, 3976, 3977, 3978, 3980, 3978, 3979, 3980, 3981, 3982, 3984, 3982, 3983, 3984, 3985, 3986, 3988, 3986, 3987, 3988, 3989, 3990, 3992, 3990, 3991, 3992, 3993, 3994, 3996, 3994, 3995, 3996, 3997, 3998, 4000, 3998, 3999, 4000, 4001, 4002, 4004, 4002, 4003, 4004, 4005, 4006, 4008, 4006, 4007, 4008, 4009, 4010, 4012, 4010, 4011, 4012, 4013, 4014, 4016, 4014, 4015, 4016, 4017, 4018, 4020, 4018, 4019, 4020, 4021, 4022, 4024, 4022, 4023, 4024, 4025, 4026, 4028, 4026, 4027, 4028 ],
	                                'itemSize': 1,
	                                'type': 'ELEMENT_ARRAY_BUFFER'
	                            },
	                            'mode': 'TRIANGLES'
	                        } ],
	                        'stateset': {
	                            'material': {
	                                'ambient': [ 0.38505, 0.16011, 0.16011, 1 ],
	                                'diffuse': [ 0.61608, 0.25618, 0.25618, 1 ],
	                                'emission': [ 0, 0, 0, 1 ],
	                                'name': 'Material.001',
	                                'shininess': 12.5,
	                                'specular': [ 0.5, 0.5, 0.5, 1 ]
	                            },
	                            'textures': [ {
	                                'file': 'background.png',
	                                'mag_filter': 'LINEAR',
	                                'min_filter': 'LINEAR_MIPMAP_LINEAR'
	                            } ]
	                        }
	                    } ],
	                    'name': 'GeodeSphere'
	                } ],
	                'matrix': [ 55.0, 0, 0, 0, 0, 55.0, 0, 0, 0, 0, 55.0, 0, 0, 0, 0, 1 ],
	                'name': 'Sphere'
	            }, {
	                'children': [ {
	                    'name': 'Lamp'
	                } ],
	                'matrix': [ -0.29086, 0.95517, -0.05519, 0, -0.7711, -0.19988, 0.60452, 0, 0.56639, 0.21839, 0.79467, 0, 4.07625, 1.00545, 5.90386, 1 ],
	                'name': 'Lamp'
	            } ],
	            'name': 'Root'
	        } ]
	    };
	};
	
	module.exports = getScene;


/***/ }),
/* 282 */
/***/ (function(module, exports) {

	'use strict';
	
	var getBoxScene = function () {
	    return {
	        'children': [ {
	            'children': [ {
	                'children': [ {
	                    'attributes': {
	                        'Normal': {
	                            'elements': [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        },
	                        'Vertex': {
	                            'elements': [ -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        }
	                    },
	                    'name': '',
	                    'primitives': [ {
	                        'indices': {
	                            'elements': [ 0, 1, 2, 2, 3, 0 ],
	                            'itemSize': 1,
	                            'type': 'ELEMENT_ARRAY_BUFFER'
	                        },
	                        'mode': 'TRIANGLES'
	                    } ],
	                    'stateset': {
	                        'material': {
	                            'ambient': [ 0, 0, 1, 1 ],
	                            'diffuse': [ 0, 0, 1, 1 ],
	                            'emission': [ 0, 0, 0, 1 ],
	                            'name': 'Plane',
	                            'shininess': 64,
	                            'specular': [ 0, 0, 0, 0 ]
	                        }
	                    }
	                } ],
	                'name': 'Plane'
	            }, {
	                'children': [ {
	                    'attributes': {
	                        'Normal': {
	                            'elements': [ 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        },
	                        'Vertex': {
	                            'elements': [ -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        }
	                    },
	                    'name': '',
	                    'primitives': [ {
	                        'indices': {
	                            'elements': [ 0, 1, 2, 2, 3, 0 ],
	                            'itemSize': 1,
	                            'type': 'ELEMENT_ARRAY_BUFFER'
	                        },
	                        'mode': 'TRIANGLES'
	                    } ],
	                    'stateset': {
	                        'material': {
	                            'ambient': [ 0, 0, 1, 1 ],
	                            'diffuse': [ 0, 0, 1, 1 ],
	                            'emission': [ 0, 0, 0, 1 ],
	                            'name': 'Plane',
	                            'shininess': 64,
	                            'specular': [ 0, 0, 0, 0 ]
	                        }
	                    }
	                } ],
	                'name': 'Plane_001'
	            }, {
	                'children': [ {
	                    'attributes': {
	                        'Normal': {
	                            'elements': [ 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        },
	                        'Vertex': {
	                            'elements': [ -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        }
	                    },
	                    'name': '',
	                    'primitives': [ {
	                        'indices': {
	                            'elements': [ 0, 1, 2, 2, 3, 0 ],
	                            'itemSize': 1,
	                            'type': 'ELEMENT_ARRAY_BUFFER'
	                        },
	                        'mode': 'TRIANGLES'
	                    } ],
	                    'stateset': {
	                        'material': {
	                            'ambient': [ 0, 1, 0, 1 ],
	                            'diffuse': [ 0, 1, 0, 1 ],
	                            'emission': [ 0, 0, 0, 1 ],
	                            'name': 'Plane_002',
	                            'shininess': 64,
	                            'specular': [ 0, 0, 0, 0 ]
	                        }
	                    }
	                } ],
	                'name': 'Plane_002'
	            }, {
	                'children': [ {
	                    'attributes': {
	                        'Normal': {
	                            'elements': [ 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        },
	                        'Vertex': {
	                            'elements': [ -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        }
	                    },
	                    'name': '',
	                    'primitives': [ {
	                        'indices': {
	                            'elements': [ 0, 1, 2, 2, 3, 0 ],
	                            'itemSize': 1,
	                            'type': 'ELEMENT_ARRAY_BUFFER'
	                        },
	                        'mode': 'TRIANGLES'
	                    } ],
	                    'stateset': {
	                        'material': {
	                            'ambient': [ 0, 1, 0, 1 ],
	                            'diffuse': [ 0, 1, 0, 1 ],
	                            'emission': [ 0, 0, 0, 1 ],
	                            'name': 'Plane_002',
	                            'shininess': 64,
	                            'specular': [ 0, 0, 0, 0 ]
	                        }
	                    }
	                } ],
	                'name': 'Plane_003'
	            }, {
	                'children': [ {
	                    'attributes': {
	                        'Normal': {
	                            'elements': [ 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        },
	                        'Vertex': {
	                            'elements': [ 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        }
	                    },
	                    'name': '',
	                    'primitives': [ {
	                        'indices': {
	                            'elements': [ 0, 1, 2, 2, 3, 0 ],
	                            'itemSize': 1,
	                            'type': 'ELEMENT_ARRAY_BUFFER'
	                        },
	                        'mode': 'TRIANGLES'
	                    } ],
	                    'stateset': {
	                        'material': {
	                            'ambient': [ 1, 0, 0, 1 ],
	                            'diffuse': [ 1, 0, 0, 1 ],
	                            'emission': [ 0, 0, 0, 1 ],
	                            'name': 'Plane_004',
	                            'shininess': 64,
	                            'specular': [ 0, 0, 0, 0 ]
	                        }
	                    }
	                } ],
	                'name': 'Plane_004'
	            }, {
	                'children': [ {
	                    'attributes': {
	                        'Normal': {
	                            'elements': [ -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        },
	                        'Vertex': {
	                            'elements': [ -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1 ],
	                            'itemSize': 3,
	                            'type': 'ARRAY_BUFFER'
	                        }
	                    },
	                    'name': '',
	                    'primitives': [ {
	                        'indices': {
	                            'elements': [ 0, 1, 2, 2, 3, 0 ],
	                            'itemSize': 1,
	                            'type': 'ELEMENT_ARRAY_BUFFER'
	                        },
	                        'mode': 'TRIANGLES'
	                    } ],
	                    'stateset': {
	                        'material': {
	                            'ambient': [ 1, 0, 0, 1 ],
	                            'diffuse': [ 1, 0, 0, 1 ],
	                            'emission': [ 0, 0, 0, 1 ],
	                            'name': 'Plane_004',
	                            'shininess': 64,
	                            'specular': [ 0, 0, 0, 0 ]
	                        }
	                    }
	                } ],
	                'name': 'Plane_005'
	            } ],
	            'name': 'box.osg'
	        } ]
	    };
	};
	
	module.exports = getBoxScene;


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var assert = __webpack_require__( 243 ).assert;
	
	module.exports = function ( timed, perfTarget, msg ) {
	
	    var logMsg = msg;
	    if ( logMsg === undefined ) {
	        logMsg = 'perf' + ( perfTarget ? ' of ' + perfTarget : '' ) + ' is: ' + ( timed ).toFixed() + ' ms';
	    }
	
	    assert.isOk( true, logMsg );
	
	};


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var Light = __webpack_require__( 97 );
	var LightSource = __webpack_require__( 64 );
	var Matrix = __webpack_require__( 23 );
	var MatrixTransform = __webpack_require__( 44 );
	var Node = __webpack_require__( 12 );
	var Shape = __webpack_require__( 102 );
	var ShadowedScene = __webpack_require__( 236 );
	var ShadowSettings = __webpack_require__( 235 );
	var ShadowMap = __webpack_require__( 231 );
	
	
	var addScene = function ( rootNode, count, shadows, culling ) {
	
	    var groundSubNode;
	    var groundSize = 75 / count;
	
	    var root = new Node();
	    var ground = Shape.createTexturedQuadGeometry( 0, 0, 0, groundSize, 0, 0, 0, groundSize, 0 );
	    for ( var wG = 0; wG < count; wG++ ) {
	
	        for ( var wH = 0; wH < count; wH++ ) {
	
	            var groundSubNodeTrans = new MatrixTransform();
	            groundSubNodeTrans.setMatrix(
	                Matrix.makeTranslate( wG * groundSize - 100, wH * groundSize - 100, -5.0, groundSubNodeTrans.getMatrix() ) );
	            // only node are culled in CullVisitor frustum culling
	            groundSubNode = new Node();
	            groundSubNode.setCullingActive( culling );
	            groundSubNode.setName( 'groundSubNode_' + wG + '_' + wH );
	            groundSubNodeTrans.addChild( ground );
	            groundSubNodeTrans.setCullingActive( culling );
	            groundSubNode.addChild( groundSubNodeTrans );
	            root.addChild( groundSubNode );
	
	        }
	    }
	    root.setCullingActive( culling );
	
	    if ( shadows ) {
	
	        var lightNew = new Light( 0 );
	        lightNew._enabled = true;
	        // light source is a node handling the light
	        var lightSourcenew = new LightSource();
	        lightSourcenew.setLight( lightNew );
	        var lightNodeModelNodeParent = new MatrixTransform();
	        lightNodeModelNodeParent.addChild( lightSourcenew );
	        rootNode.getOrCreateStateSet().setAttributeAndModes( lightNew );
	        rootNode.addChild( lightNodeModelNodeParent );
	        // setting light, each above its cube
	        lightNodeModelNodeParent.setMatrix( Matrix.makeTranslate( -10, -10, 10, Matrix.create() ) );
	        var shadowedScene = new ShadowedScene();
	        shadowedScene.addChild( root );
	        var shadowSettings = new ShadowSettings();
	        shadowSettings.setLight( lightNew );
	        var shadowMap = new ShadowMap( shadowSettings );
	        shadowedScene.addShadowTechnique( shadowMap );
	        shadowMap.setShadowSettings( shadowSettings );
	        rootNode.addChild( shadowedScene );
	
	    } else {
	        rootNode.addChild( root );
	    }
	};
	
	module.exports = {
	    addScene: addScene
	};


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Shape = __webpack_require__( 102 );
	var Timer = __webpack_require__( 9 );
	var reportStats = __webpack_require__( 283 );
	
	module.exports = function () {
	
	    test( 'ComputeBound', function () {
	
	        // 250 * 250 * 6 = 375k vertices (draw arrays...)
	        var geom = Shape.createTexturedSphere( 1.0, 250, 250 );
	        var timed = Timer.instance().tick();
	
	        console.profile();
	        console.time( 'time' );
	
	        var nCount = 5;
	        for ( var n = 0; n < nCount; n++ ) {
	            geom.dirtyBound();
	            geom.getBound();
	        }
	
	        console.timeEnd( 'time' );
	        console.profileEnd();
	
	        timed = Timer.instance().tick() - timed;
	
	        reportStats( timed, 'ComputeBound' );
	
	    } );
	
	};


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	var mockup = __webpack_require__( 242 );
	var Matrix = __webpack_require__( 23 );
	var Vec3 = __webpack_require__( 15 );
	var Node = __webpack_require__( 12 );
	var NodeVisitor = __webpack_require__( 22 );
	var Timer = __webpack_require__( 9 );
	var reportStats = __webpack_require__( 283 );
	var mockupBench = __webpack_require__( 284 );
	var KdTreeBuilder = __webpack_require__( 96 );
	var Camera = __webpack_require__( 56 );
	var Viewport = __webpack_require__( 107 );
	var View = __webpack_require__( 205 );
	var ReaderParser = __webpack_require__( 38 );
	
	module.exports = function () {
	
	    test( 'NodeVisitor Heavy Static Scene', function () {
	
	        var root = new Node();
	        mockupBench.addScene( root, 25, false, false );
	
	        var timed = Timer.instance().tick();
	
	        var visitor = new NodeVisitor();
	
	        console.profile();
	        console.time( 'time' );
	
	        var nCount = 20;
	        for ( var n = 0; n < nCount; n++ ) {
	            visitor.apply( root );
	        }
	
	        console.timeEnd( 'time' );
	        console.profileEnd();
	
	        timed = Timer.instance().tick() - timed;
	
	        reportStats( timed, 'Visitor Visiting' );
	
	    } );
	
	    test( 'IntersectVisitor Heavy Static Scene', function () {
	        this.timeout( 20000 );
	
	        var view = new View();
	        view.getCamera().setViewport( new Viewport() );
	        view.getCamera().setViewMatrix( Matrix.makeLookAt(
	            Vec3.createAndSet( 0, 0, -10 ),
	            Vec3.createAndSet( 0, 0, 0 ),
	            Vec3.createAndSet( 0, 1, 0 ),
	            Matrix.create() ) );
	        view.getCamera().setProjectionMatrix( Matrix.makePerspective( 60, 800 / 600, 0.1, 100.0, Matrix.create() ) );
	
	        // TODO it uses the old sync parseSceneGraphDeprecated
	        var root = ReaderParser.parseSceneGraph( mockup.getScene() );
	        view.setSceneData( root );
	
	        mockupBench.addScene( root, 25, false, false );
	
	        var treeBuilder = new KdTreeBuilder( {
	            _numVerticesProcessed: 0,
	            _targetNumTrianglesPerLeaf: 50,
	            _maxNumLevels: 20
	        } );
	        treeBuilder.apply( root );
	
	
	        var camera = new Camera();
	        camera.setViewport( new Viewport() );
	        camera.setViewMatrix( Matrix.makeLookAt(
	            Vec3.createAndSet( 0, 0, -10 ),
	            Vec3.createAndSet( 0, 0, 0 ),
	            Vec3.createAndSet( 0, 1, 0 ), Matrix.create() ) );
	        camera.setProjectionMatrix( Matrix.makePerspective( 60, 800 / 600, 0.1, 100.0, Matrix.create() ) );
	
	        var result;
	        var accum = 0;
	        var nCount = 100;
	        var x = new Array( nCount );
	        var y = new Array( nCount );
	        var n;
	        for ( n = 0; n < nCount; n++ ) {
	            x[ n ] = Math.random() * 800;
	            y[ n ] = Math.random() * 600;
	        }
	
	
	        for ( n = 0; n < nCount; n++ ) {
	
	            result = view.computeIntersections( x[ n ], y[ n ] );
	            accum += result.length;
	
	        }
	
	        var timed = Timer.instance().tick();
	        console.profile();
	        console.time( 'time' );
	
	        for ( n = 0; n < nCount; n++ ) {
	
	            result = view.computeIntersections( x[ n ], y[ n ] );
	            accum += result.length;
	
	        }
	
	        console.timeEnd( 'time' );
	        console.profileEnd();
	        timed = Timer.instance().tick() - timed;
	
	        module.accum = accum; // keep the variable on a scope to avoid JIT otimimization and remove code
	        reportStats( timed, 'IntersectVisitor Visiting' );
	    } );
	
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(287)(module)))

/***/ }),
/* 287 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ })
/******/ ])
});
;
//# sourceMappingURL=benchmarks.js.map